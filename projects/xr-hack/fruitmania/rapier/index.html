<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">


    <title>WebXR Emitter Application</title>

    <link rel="icon" href="./static/images/yolo-icon-256x256.png">

    <style>
        body { margin: 0; }
        canvas { display: block; }
        #guiOverlayInput {
            position: absolute;
            width: min-content;
            display: none;
            top: 8px;
            left: 8px;
            z-index: 1001;
        }
        #guiHolderWrap {
            border: 1px solid #ffffff2b;
            max-height: 80vh;
            /* Adjust this value as needed */
            overflow-y: auto;
            border-radius: 0.5rem;
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
        }
        #guiOverlayBar {
            color: black;
            font-size: 0.5rem;
            cursor: pointer;
            padding: 0.25rem;
            background-color: none;
            width: -webkit-fill-available;
            text-align: center;
            border-radius: 0.2rem;
        }
        #guiOverlayBar:hover {
            color: initial;
            background: linear-gradient(145deg, #f5f5f5, #e0e0e0, #9e9e9e, #757575, #616161, #424242, #212121);
        }
        #guiCloudsOverlayInput {
            position: absolute;
            width: min-content;
            display: none;
            top: 50px;
            right: 50px;
        }
        #guiCloudsOverlayBar {
            color: black;
            font-size: 0.5rem;
            cursor: pointer;
            padding: 0.25rem;
            background-color: none;
            width: -webkit-fill-available;
            text-align: center;
            border-radius: 0.2rem;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom: 1px solid black;
        }
        #guiCloudsOverlayBar:hover {
            background-color: rgba(255, 255, 255, 0.95);
            color: initial;
        }        
        /* Control Pad */
        .custom-vr-button {
            background: #0000003b;
            border: 1px solid rgba(255, 255, 255, 0);
            border-radius: 50%;
            display: block;
            width: 53px;
            height: 53px;
            position: fixed;
            bottom: 53px;
            left: 20px;
            padding: 0.25rem;
            margin: 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .display-block {
            display: block !important;
        }
        .custom-vr-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .custom-vr-button:active {
            background-color: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.7);
            transform: scale(0.95);
        }

        .corner-ribbon {
            width: 250px;
            background: #00000010;
            color: #FFFFFF20;
            text-align: center;
            line-height: 50px;
            transform: rotate(-45deg) scale(0.75);
            position: fixed;
            bottom: 25px;
            right: -76px;
            font-family: 'Lato Thin', Arial, sans-serif;
            font-size: 14px;
            z-index: 1000;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(3px);
            user-select: none;
        }

        .corner-ribbon a {
            display: flex;
            align-items: center;
            color: #FFFFFF90;
            text-decoration: none;
            width: 100%;
            height: 100%;
            line-height: inherit;
            justify-content: center;
            user-select: none;
        }

        .corner-ribbon a:hover {
            color: #FFFFFF;
        }

        .corner-ribbon svg {
            fill: #FFFFFF90;
            width: 20px;
            height: 20px;
            margin-right: 8px;
        }



    </style>

    <script>
        // document.addEventListener("DOMContentLoaded", function() {
        //     try {
        //         var script = document.createElement('script');
        //         script.defer = true;
        //         script.src = "https://analytics.mielniczuk.com/script.js";
        //         script.setAttribute('data-website-id', '33076180-1c51-4617-b67b-b91b5e1f8cf8');
        //         document.head.appendChild(script);
        //     } catch (error) {
        //         console.error('Analytics script failed to load', error);
        //     }
        // });
    </script>


</head>




<body>


    <div class="corner-ribbon">
        <a href="https://github.com/Immersive-Collective" target="_blank">
            <svg height="32" width="32" viewBox="0 0 16 16" aria-hidden="true">
                <path fill="#FFFFFF99" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.002 8.002 0 0 0 16 8c0-4.42-3.58-8-8-8z" />
            </svg>
            Immersive Collective
        </a>
    </div>    

<div id="guiOverlayInput">
    <div id="guiOverlayBar"></div>
    <div class="guiSettings">
        <div id="guiHolderWrap">
            <div id="guiHolder"></div>
        </div>
    </div>
</div>

<script type="importmap">
    {
    "imports": {
        "three": "./node_modules/three/build/three.module.js",
        "lil-gui": "./node_modules/lil-gui/dist/lil-gui.esm.min.js",
        "three/addons/": "./node_modules/three/examples/jsm/",
        "rapier": "./node_modules/@dimforge/rapier3d-compat/rapier.es.js",
        "zesty": "./static/libs/zesty/zesty-threejs-sdk.js"        
        }
    }
</script>


<script type="module">


/* 

    Imports
    ----------------------------------------------- 

    */    


import * as THREE from 'three';

import { XRButton } from 'three/addons/webxr/XRButton.js';

import { VRButton } from 'three/addons/webxr/VRButton.js';

import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';  

import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

import { TransformControls } from 'three/addons/controls/TransformControls.js';

import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { GUI } from 'lil-gui';    
import RAPIER from 'rapier';

// Not working
import * as Zesty from 'zesty';



/* 

    Container
    ----------------------------------------------- 

    */


const container = document.createElement('div');
document.body.appendChild(container);


/* 

    ThreeJS Variables
    ----------------------------------------------- 

    */

let scene, camera, renderer
const guiInstances = new Map();





/* 

    Emitter - Geometries Config
    ----------------------------------------------- 

    */

const geometryConfig = {
    BoxGeometry: {
        defaultParams: { sx: 1, sy: 1, sz: 1 },
        params: [
            { name: 'sx', min: 0.01, max: 3 },
            { name: 'sy', min: 0.01, max: 3 },
            { name: 'sz', min: 0.01, max: 3 }
        ],
        create: params => new THREE.BoxGeometry(params.sx, params.sy, params.sz)
    },
    SphereGeometry: {
        defaultParams: { radius: 1, widthSegments: 32, heightSegments: 16 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'widthSegments', min: 3, max: 64, step: 1 },
            { name: 'heightSegments', min: 2, max: 32, step: 1 }
        ],
        create: params => new THREE.SphereGeometry(params.radius, params.widthSegments, params.heightSegments)
    },
    CapsuleGeometry: {
        defaultParams: { radius: 1, length: 1, capSegments: 4, radialSegments: 8 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'length', min: 0.01, max: 3 },
            { name: 'capSegments', min: 1, max: 10, step: 1 },
            { name: 'radialSegments', min: 3, max: 32, step: 1 }
        ],
        create: params => new THREE.CapsuleGeometry(params.radius, params.length, params.capSegments, params.radialSegments)
    },
    CircleGeometry: {
        defaultParams: { radius: 1, segments: 32, thetaStart: 0, thetaLength: Math.PI * 2 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'segments', min: 3, max: 64, step: 1 },
            { name: 'thetaStart', min: 0, max: Math.PI * 2 },
            { name: 'thetaLength', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.CircleGeometry(params.radius, params.segments, params.thetaStart, params.thetaLength)
    },
    ConeGeometry: {
        defaultParams: { radius: 1, height: 1, radialSegments: 32, heightSegments: 1, openEnded: false, thetaStart: 0, thetaLength: Math.PI * 2 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'height', min: 0.01, max: 3 },
            { name: 'radialSegments', min: 3, max: 64, step: 1 },
            { name: 'heightSegments', min: 1, max: 32, step: 1 },
            { name: 'openEnded', min: 0, max: 1 },
            { name: 'thetaStart', min: 0, max: Math.PI * 2 },
            { name: 'thetaLength', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.ConeGeometry(params.radius, params.height, params.radialSegments, params.heightSegments, params.openEnded, params.thetaStart, params.thetaLength)
    },
    CylinderGeometry: {
        defaultParams: { radiusTop: 1, radiusBottom: 1, height: 1, radialSegments: 32, heightSegments: 1, openEnded: false, thetaStart: 0, thetaLength: Math.PI * 2 },
        params: [
            { name: 'radiusTop', min: 0.01, max: 3 },
            { name: 'radiusBottom', min: 0.01, max: 3 },
            { name: 'height', min: 0.01, max: 3 },
            { name: 'radialSegments', min: 3, max: 64, step: 1 },
            { name: 'heightSegments', min: 1, max: 32, step: 1 },
            { name: 'openEnded', min: 0, max: 1 },
            { name: 'thetaStart', min: 0, max: Math.PI * 2 },
            { name: 'thetaLength', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.CylinderGeometry(params.radiusTop, params.radiusBottom, params.height, params.radialSegments, params.heightSegments, params.openEnded, params.thetaStart, params.thetaLength)
    },
    DodecahedronGeometry: {
        defaultParams: { radius: 1, detail: 0 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'detail', min: 0, max: 5, step: 1 }
        ],
        create: params => new THREE.DodecahedronGeometry(params.radius, params.detail)
    },
    IcosahedronGeometry: {
        defaultParams: { radius: 1, detail: 0 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'detail', min: 0, max: 5, step: 1 }
        ],
        create: params => new THREE.IcosahedronGeometry(params.radius, params.detail)
    },
    OctahedronGeometry: {
        defaultParams: { radius: 1, detail: 0 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'detail', min: 0, max: 5, step: 1 }
        ],
        create: params => new THREE.OctahedronGeometry(params.radius, params.detail)
    },
    PlaneGeometry: {
        defaultParams: { width: 1, height: 1, widthSegments: 1, heightSegments: 1 },
        params: [
            { name: 'width', min: 0.01, max: 3 },
            { name: 'height', min: 0.01, max: 3 },
            { name: 'widthSegments', min: 1, max: 32, step: 1 },
            { name: 'heightSegments', min: 1, max: 32, step: 1 }
        ],
        create: params => new THREE.PlaneGeometry(params.width, params.height, params.widthSegments, params.heightSegments)
    },
    RingGeometry: {
        defaultParams: { innerRadius: 0.5, outerRadius: 1, thetaSegments: 32, phiSegments: 1, thetaStart: 0, thetaLength: Math.PI * 2 },
        params: [
            { name: 'innerRadius', min: 0.01, max: 3 },
            { name: 'outerRadius', min: 0.01, max: 3 },
            { name: 'thetaSegments', min: 3, max: 64, step: 1 },
            { name: 'phiSegments', min: 1, max: 32, step: 1 },
            { name: 'thetaStart', min: 0, max: Math.PI * 2 },
            { name: 'thetaLength', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.RingGeometry(params.innerRadius, params.outerRadius, params.thetaSegments, params.phiSegments, params.thetaStart, params.thetaLength)
    },
    TetrahedronGeometry: {
        defaultParams: { radius: 1, detail: 0 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'detail', min: 0, max: 5, step: 1 }
        ],
        create: params => new THREE.TetrahedronGeometry(params.radius, params.detail)
    },
    TorusGeometry: {
        defaultParams: { radius: 1, tube: 0.4, radialSegments: 12, tubularSegments: 48, arc: Math.PI * 2 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'tube', min: 0.01, max: 1 },
            { name: 'radialSegments', min: 3, max: 64, step: 1 },
            { name: 'tubularSegments', min: 3, max: 128, step: 1 },
            { name: 'arc', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.TorusGeometry(params.radius, params.tube, params.radialSegments, params.tubularSegments, params.arc)
    },
    TorusKnotGeometry: {
        defaultParams: { radius: 1, tube: 0.4, tubularSegments: 64, radialSegments: 8, p: 2, q: 3 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'tube', min: 0.01, max: 1 },
            { name: 'tubularSegments', min: 3, max: 128, step: 1 },
            { name: 'radialSegments', min: 3, max: 64, step: 1 },
            { name: 'p', min: 1, max: 20, step: 1 },
            { name: 'q', min: 1, max: 20, step: 1 }
        ],
        create: params => new THREE.TorusKnotGeometry(params.radius, params.tube, params.tubularSegments, params.radialSegments, params.p, params.q)
    }
};



/* 

    Emitter
    ----------------------------------------------- 

    */




const storedEmitters = [];
const emittersMap = new Map();

function cubeEmitter({ x = 0, y = 3, z = 0, id, delay = 0, count = 0, speedFactor = 1, direction = { x: 0, y: -1, z: 0 }, density = 1, ...params } = {}, interTime = 2000) {
    let position = { x, y, z };
    let geometryParams = params;
    let currentGeometry = geometryParams.geometryType;
    let intervalId = null;
    let producedCubes = [];
    let isActive = false;
    let remainingCount = count;

    function start() {
        if (isActive) return;
        isActive = true;
        setTimeout(() => {
            intervalId = setInterval(() => {
                if (remainingCount > 0) remainingCount--;
                if (remainingCount === 0 && count !== 0) {
                    pause();
                    return;
                }
                const color = new THREE.Color(Math.random(), Math.random(), Math.random());
                const random = geometryParams.randomSizes;
                const sizeVector = random
                    ? new THREE.Vector3(
                        Math.random() * geometryParams.sx,
                        Math.random() * geometryParams.sy,
                        Math.random() * geometryParams.sz
                    )
                    : new THREE.Vector3(geometryParams.sx, geometryParams.sy, geometryParams.sz);
                const cubePosition = new THREE.Vector3(position.x, position.y, position.z);
                const cube = addSingleObject(currentGeometry, { ...geometryParams, sx: sizeVector.x, sy: sizeVector.y, sz: sizeVector.z }, cubePosition, color, random, speedFactor, direction, density);
                producedCubes.push(cube);
            }, interTime);
        }, delay);
    }

    function pause() {
        if (intervalId) {
            clearInterval(intervalId);
            intervalId = null;
            isActive = false;
        }
    }

    function reset() {
        pause();
        producedCubes.forEach(({ mesh, rigidBody, collider }) => {
            if (mesh) {
                scene.remove(mesh);
                const meshIndex = window.threeCubes.indexOf(mesh);
                if (meshIndex > -1) {
                    window.threeCubes.splice(meshIndex, 1);
                }
            }
            if (myRapierWorld && rigidBody) {
                myRapierWorld.removeCollider(collider, true);
                myRapierWorld.removeRigidBody(rigidBody, true);
                const rigidBodyIndex = window.rigidBodies.indexOf(rigidBody);
                if (rigidBodyIndex > -1) {
                    window.rigidBodies.splice(rigidBodyIndex, 1);
                }
            }
        });
        producedCubes = [];
        remainingCount = count;
    }

    function restart() {
        pause();
        remainingCount = count;
        start();
    }

    function setPosition(newPosition) {
        position = newPosition;
    }

    function setGeometryParams(newParams) {
        geometryParams = { ...geometryParams, ...newParams };
    }

    function setGeometryType(type) {
        currentGeometry = type;
    }

    function setIntervalTime(newIntervalTime) {
        interTime = newIntervalTime;
        if (isActive) {
            pause();
            start();
        }
    }

    function setRandomSizes(value) {
        geometryParams.randomSizes = value;
    }

    function setCount(newCount) {
        count = Math.floor(newCount); // Ensure count is always an integer
        remainingCount = count;
    }

    function setDelay(newDelay) {
        delay = newDelay;
    }

    function setDirection(newDirection) {
        direction = newDirection;
    }

    function setDensity(newDensity) {
        density = newDensity;
    }

    function setSpeedFactor(newSpeedFactor) {
        speedFactor = newSpeedFactor;
    }

    function getParams() {
        return {
            id,
            x: position.x,
            y: position.y,
            z: position.z,
            ...geometryParams,
            interval: interTime,
            delay,
            count,
            directionX: direction.x,
            directionY: direction.y,
            directionZ: direction.z,
            speedFactor,
            density
        };
    }

    function addSingleObject(type, params, position, color, random, speedFactor, direction, density) {
        const geometry = geometryConfig[type].create(params);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.2, roughness: 0.8, wireframe: false });
        const bodyMesh = new THREE.Mesh(geometry, bodyMaterial);
        bodyMesh.position.copy(position);
        bodyMesh.castShadow = true;
        bodyMesh.receiveShadow = true;
        bodyMesh.type = "cb";
        scene.add(bodyMesh);

        // Calculate the quaternion for the direction
        const directionVector = new THREE.Vector3(direction.x, direction.y, direction.z).normalize();
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), directionVector);
        
        let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
            .setTranslation(position.x, position.y, position.z)
            .setRotation({ w: quaternion.w, x: quaternion.x, y: quaternion.y, z: quaternion.z })
            .setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
        
        let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);
        let colliderDesc;

        if (type === 'BoxGeometry') {
            colliderDesc = RAPIER.ColliderDesc.cuboid(params.sx / 2, params.sy / 2, params.sz / 2).setDensity(density);
        } else if (['SphereGeometry', 'DodecahedronGeometry', 'IcosahedronGeometry', 'OctahedronGeometry', 'TetrahedronGeometry'].includes(type)) {
            const radius = params.radius;
            colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
        } else if (type === 'CapsuleGeometry') {
            const radius = params.radius;
            colliderDesc = RAPIER.ColliderDesc.capsule(radius, params.length / 2).setDensity(density);
        } else if (type === 'CylinderGeometry') {
            colliderDesc = RAPIER.ColliderDesc.cylinder(params.height / 2, params.radiusTop).setDensity(density);
        } else if (type === 'ConeGeometry') {
            colliderDesc = RAPIER.ColliderDesc.cone(params.height / 2, params.radius).setDensity(density);
        } else {
            colliderDesc = RAPIER.ColliderDesc.cuboid(params.sx / 2, params.sy / 2, params.sz / 2).setDensity(density);
        }

        let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);
        rigidBody.type = "cb";
        window.rigidBodies.push(rigidBody);
        window.threeCubes.push(bodyMesh);

        playFX("shoot0", 10);

        return { mesh: bodyMesh, rigidBody: rigidBody, collider: collider };
    }


    const emitterInstance = {
        id,
        start,
        pause,
        reset,
        restart,
        setPosition,
        setGeometryParams,
        setGeometryType,
        setIntervalTime,
        setRandomSizes,
        setCount,
        setDelay,
        setDirection,
        setDensity,
        setSpeedFactor,
        getParams
    };

    if (id) {
        emittersMap.set(id, emitterInstance);
    }

    return emitterInstance;
}

window.cubeEmitter = cubeEmitter;

function initEmittersEdit(guiKey, loadedEmitters = []) {
    const container = document.getElementById("guiHolder");
    const gui = new GUI({ width: 350, container: container });
    guiInstances.set(guiKey, gui);

    const emitters = [];

    function addEmitter() {
        const emitterParams = {
            id: generateUniqueId(),
            x: 0,
            y: 0,
            z: 0,
            ...geometryConfig.BoxGeometry.defaultParams, // default geometry
            geometryType: 'BoxGeometry',
            interval: 500,
            randomSizes: false,
            delay: 0,
            count: 0,
            directionX: 0,
            directionY: -1,
            directionZ: 0,
            speedFactor: 1,
            density: 1
        };

        const folder = gui.addFolder('Add Emitter');
        folder.add(emitterParams, 'geometryType', Object.keys(geometryConfig)).name('Geometry Type').onChange((newGeometryType) => {
            Object.assign(emitterParams, geometryConfig[newGeometryType].defaultParams);
            emitterParams.geometryType = newGeometryType;
        });
        folder.add({ create: () => createEmitter(emitterParams) }, 'create').name('Create Emitter');
        folder.open();
    }

    function createEmitter(params) {
        const emitterId = generateUniqueId();
        params.id = emitterId;

        const index = emitters.length;
        const emitter = cubeEmitter({ ...params }, params.interval, params.delay, params.count);
        emitter.setIntervalTime(params.interval);
        emitter.setDelay(params.delay);
        emitter.setCount(params.count);
        emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
        emitter.setDensity(params.density);
        emitter.setSpeedFactor(params.speedFactor);

        emitters.push({ emitter, params: { ...params } }); // Ensure a deep copy of params
        storedEmitters.push({ ...params }); // Store parameters

        const folder = gui.addFolder(`Emitter ${params.id}`);
        folder.add({ geometryType: params.geometryType }, 'geometryType').name('Geometry Type').listen();
        folder.add(params, 'x', -200, 200).name('X').onChange(() => {
            emitter.setPosition({ x: params.x, y: params.y, z: params.z });
            updatePreviewMeshPosition(emitter.previewMesh, params);
            updatePreviewLine(emitter.previewLine, params);
        });
        folder.add(params, 'y', -30, 200).name('Y').onChange(() => {
            emitter.setPosition({ x: params.x, y: params.y, z: params.z });
            updatePreviewMeshPosition(emitter.previewMesh, params);
            updatePreviewLine(emitter.previewLine, params);
        });
        folder.add(params, 'z', -200, 200).name('Z').onChange(() => {
            emitter.setPosition({ x: params.x, y: params.y, z: params.z });
            updatePreviewMeshPosition(emitter.previewMesh, params);
            updatePreviewLine(emitter.previewLine, params);
        });

        folder.add(params, 'randomSizes').name('Random Sizes').onChange(() => emitter.setRandomSizes(params.randomSizes));
        folder.add(params, 'interval', 1, 5000).name('Interval (ms)').onChange(() => emitter.setIntervalTime(params.interval));
        folder.add(params, 'delay', 0, 25000).name('Delay (ms)').onChange(() => emitter.setDelay(params.delay));
        
        folder.add(params, 'count', 0, 10000).step(1).name('Count').onChange(() => emitter.setCount(params.count));
        folder.add(params, 'directionX', -1, 1).name('Direction X').onChange(() => {
            emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
            updatePreviewLine(emitter.previewLine, params);
            updatePreviewMeshRotation(emitter.previewMesh, params);
        });
        folder.add(params, 'directionY', -1, 1).name('Direction Y').onChange(() => {
            emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
            updatePreviewLine(emitter.previewLine, params);
            updatePreviewMeshRotation(emitter.previewMesh, params);
        });
        folder.add(params, 'directionZ', -1, 1).name('Direction Z').onChange(() => {
            emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
            updatePreviewLine(emitter.previewLine, params);
            updatePreviewMeshRotation(emitter.previewMesh, params);
        });
        folder.add(params, 'speedFactor', 0.1, 150).name('Speed Factor').onChange(() => {
            emitter.setSpeedFactor(params.speedFactor);
            updatePreviewLine(emitter.previewLine, params);
        });
        folder.add(params, 'density', 0.1, 10).name('Density').onChange(() => emitter.setDensity(params.density));

        addGeometrySpecificParams(folder, params, emitter);

        folder.add({ start: () => startEmitter(index) }, 'start').name('Start');
        folder.add({ pause: () => pauseEmitter(index) }, 'pause').name('Pause');
        folder.add({ reset: () => resetEmitter(index, emitter.previewMesh, emitter.previewLine) }, 'reset').name('Reset');
        folder.add({ restart: () => restartEmitter(index) }, 'restart').name('Restart');
        folder.add({ exportEmitter: () => exportEmitter(emitterId) }, 'exportEmitter').name('Export Emitter');
        folder.add({ removeEmitter: () => removeEmitter(index, folder) }, 'removeEmitter').name('Remove Emitter');
        folder.open();

        emitter.previewMesh = createStaticPreview(params);
        emitter.previewLine = createPreviewLine(params);
    }

    function startAllEmitters() {
        emitters.forEach(({ emitter }) => emitter.start());
    }

    function stopAllEmitters() {
        emitters.forEach(({ emitter }) => emitter.pause());
    }

    function removeEmitter(index, folder) {
        if (emitters[index]) {
            try {
                const emitter = emitters[index].emitter;
                if (emitter) {
                    emitter.reset();
                    if (emitter.previewMesh) {
                        scene.remove(emitter.previewMesh);
                    }
                    if (emitter.previewLine) {
                        scene.remove(emitter.previewLine);
                    }
                }
                if (folder) {
                    folder.close();
                    folder.domElement.remove();
                    const folderName = `Emitter ${emitters[index].params.id}`;
                    if (gui.folders[folderName]) {
                        delete gui.folders[folderName];
                    }
                }
                emitters.splice(index, 1);
                storedEmitters.splice(index, 1);
            } catch (e) {
                console.error(`Error removing emitter at index ${index}:`, e);
            }
        }
    }

    function removeAllEmitters() {
        emitters.slice().forEach((emitterData, index) => {
            try {
                const emitter = emitterData.emitter;
                if (emitter) {
                    emitter.reset();
                    if (emitter.previewMesh) {
                        scene.remove(emitter.previewMesh);
                    }
                    if (emitter.previewLine) {
                        scene.remove(emitter.previewLine);
                    }
                }
                const folderName = `Emitter ${emitterData.params.id}`;
                const folder = gui.folders && gui.folders[folderName];
                if (folder) {
                    folder.close();
                    folder.domElement.remove();
                    delete gui.folders[folderName];
                }
            } catch (e) {
                console.error(`Error removing emitter at index ${index}:`, e);
            }
        });

        emitters.length = 0; // Clear the emitters array
        storedEmitters.length = 0; // Clear the storedEmitters array
        emittersMap.clear(); // Clear the emittersMap

        // really dirty hack - but this is the only way so far to remove GUI folders and recreate GUI - it is actually impossible to see what is going on here
        toggleEmittersEditGUI()
        toggleEmittersEditGUI()

    }

    function exportEmitter(emitterId) {
        const emitterObj = emitters.find(e => e.emitter.id === emitterId);
        if (emitterObj) {
            const params = emitterObj.emitter.getParams();
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(params));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", `emitter_${params.id}.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }
    }

    function exportAllEmitters() {
        const updatedStoredEmitters = emitters.map(({ emitter }) => emitter.getParams());
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(updatedStoredEmitters));
        const now = new Date().toISOString().replace(/[:.]/g, '-');
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", `emitters_${now}.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    }

    function importEmitters() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = event => {
                const importedParams = JSON.parse(event.target.result);
                importedParams.forEach(params => createEmitter(params));
            };
            reader.readAsText(file);
        };
        input.click();
    }

    function addGeometrySpecificParams(folder, params, emitter) {
        const geometryType = params.geometryType;
        const config = geometryConfig[geometryType];

        config.params.forEach(param => {
            const controller = folder.add(params, param.name, param.min, param.max).name(param.name.charAt(0).toUpperCase() + param.name.slice(1));
            if (param.step) {
                controller.step(param.step); // Ensure integer parameters use integer steps
            }
            controller.onChange(() => {
                const newParams = { [param.name]: params[param.name] };
                emitter.setGeometryParams(newParams);
                updatePreviewMeshGeometry(emitter.previewMesh, params);
            });
        });
    }

    function createStaticPreview(params) {
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00]; // Red, Green, Blue, Yellow
        const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
        const geometry = createGeometry(params.geometryType, params);
        const edges = new THREE.EdgesGeometry(geometry);
        const material = new THREE.LineBasicMaterial({ color: color });
        const previewMesh = new THREE.LineSegments(edges, material);
        previewMesh.position.set(params.x, params.y, params.z);

        // Set the initial rotation based on direction
        updatePreviewMeshRotation(previewMesh, params);

        scene.add(previewMesh);
        return previewMesh;
    }

    function createGeometry(type, params) {
        const config = geometryConfig[type];
        return config.create(params);
    }

    function updatePreviewMeshGeometry(previewMesh, params) {
        const newGeometry = createGeometry(params.geometryType, params);
        const edges = new THREE.EdgesGeometry(newGeometry);
        previewMesh.geometry.dispose();
        previewMesh.geometry = edges;
    }

    function updatePreviewMeshPosition(previewMesh, params) {
        previewMesh.position.set(params.x, params.y, params.z);
        updatePreviewMeshRotation(previewMesh, params);
    }

function updatePreviewMeshRotation(previewMesh, params) {
    const direction = new THREE.Vector3(params.directionX, params.directionY, params.directionZ).normalize();
    const quaternion = new THREE.Quaternion();
    quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), direction);
    previewMesh.quaternion.copy(quaternion);
}

    function updatePreviewLine(line, params) {
        const points = [
            new THREE.Vector3(params.x, params.y, params.z),
            new THREE.Vector3(params.x + params.directionX * params.speedFactor, params.y + params.directionY * params.speedFactor, params.z + params.directionZ * params.speedFactor)
        ];
        line.geometry.setFromPoints(points);
    }


    function createPreviewLine(params) {
        const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
        const points = [
            new THREE.Vector3(params.x, params.y, params.z),
            new THREE.Vector3(params.x + params.directionX * params.speedFactor, params.y + params.directionY * params.speedFactor, params.z + params.directionZ * params.speedFactor)
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);
        return line;
    }


    function startEmitter(index) {
        if (emitters[index]) {
            emitters[index].emitter.start();
        }
    }

    function pauseEmitter(index) {
        if (emitters[index]) {
            emitters[index].emitter.pause();
        }
    }

    function resetEmitter(index, previewMesh, previewLine) {
        if (emitters[index]) {
            emitters[index].emitter.reset();
            updatePreviewMeshPosition(previewMesh, emitters[index].params);
            updatePreviewLine(previewLine, emitters[index].params);
        }
    }

    function restartEmitter(index) {
        if (emitters[index]) {
            emitters[index].emitter.restart();
        }
    }

    function importEmitter() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = event => {
                const importedParams = JSON.parse(event.target.result);
                createEmitter(importedParams);
            };
            reader.readAsText(file);
        };
        input.click();
    }

    gui.add({ importEmitters: importEmitters }, 'importEmitters').name('Load Emitters');
    gui.add({ exportAllEmitters: exportAllEmitters }, 'exportAllEmitters').name('Export All Emitters');
    gui.add({ importEmitter: importEmitter }, 'importEmitter').name('Import Emitter');
    gui.add({ startAllEmitters }, 'startAllEmitters').name('Start All Emitters');
    gui.add({ stopAllEmitters }, 'stopAllEmitters').name('Stop All Emitters');
    gui.add({ removeAllEmitters }, 'removeAllEmitters').name('Remove All Emitters');

    addEmitter();
    loadedEmitters.forEach(params => createEmitter(params)); // Load emitters from JSON data if provided
    makePanelDraggable(document.getElementById("guiOverlayInput"), document.getElementById("guiOverlayBar"));
}

window.initEmittersEdit = initEmittersEdit;

function generateUniqueId() {
    return 'emitter-' + Math.random().toString(36).substr(2, 9);
}

function toggleEmittersEditGUI() {
    if (guiInstances.has('emittersEditGUI')) {
        guiInstances.get('emittersEditGUI').destroy();
        guiInstances.delete('emittersEditGUI');
    } else {
        initEmittersEdit('emittersEditGUI', storedEmitters);
    }
}

window.toggleEmittersEditGUI = toggleEmittersEditGUI;

/* Emitters Managers */

function listEmitterIds() {
    return Array.from(emittersMap.keys());
}

window.listEmitterIds = listEmitterIds;

function triggerEmittersArrayById(ids, action) {
    ids.forEach(id => {
        triggerEmitterById(id, action);
    });
}

window.triggerEmittersArrayById = triggerEmittersArrayById;

function startAllEmitters() {
    emittersMap.forEach(emitter => emitter.start());
}

window.startAllEmitters = startAllEmitters;

function stopAllEmitters() {
    emittersMap.forEach(emitter => emitter.pause());
}

window.stopAllEmitters = stopAllEmitters;

function removeAllEmitters() {
    emittersMap.forEach((emitter, id) => {
        emitter.reset();
        if (emitter.previewMesh) {
            scene.remove(emitter.previewMesh);
        }
        if (emitter.previewLine) {
            scene.remove(emitter.previewLine);
        }
        if (typeof gui !== 'undefined') {
            const folderName = `Emitter ${id}`;
            const folder = gui.folders.find(f => f.title === folderName);
            if (folder) {
                folder.destroy();
            }
        }
    });
    emittersMap.clear(); // Clear the emittersMap
    storedEmitters.length = 0; // Clear the storedEmitters array
}

window.removeAllEmitters = removeAllEmitters;

function triggerEmitterById(id, action) {
    const emitter = emittersMap.get(id);
    if (!emitter) {
        console.error(`Emitter with ID ${id} not found.`);
        return;
    }
    switch(action) {
        case 'start':
            emitter.start();
            break;
        case 'pause':
            emitter.pause();
            break;
        case 'reset':
            emitter.reset();
            updatePreviewMeshPosition(emitter.previewMesh, emitter.getParams());
            updatePreviewLine(emitter.previewLine, emitter.getParams());
            break;
        case 'restart':
            emitter.restart();
            break;
        default:
            console.error(`Invalid action: ${action}`);
    }
}

window.triggerEmitterById = triggerEmitterById;

function removeEmitterById(id) {
    const emitter = emittersMap.get(id);
    if (!emitter) {
        console.error(`Emitter with ID ${id} not found.`);
        return;
    }
    emitter.reset();
    if (emitter.previewMesh) {
        scene.remove(emitter.previewMesh);
    }
    if (emitter.previewLine) {
        scene.remove(emitter.previewLine);
    }

    emittersMap.delete(id);
    storedEmitters.splice(storedEmitters.findIndex(e => e.id === id), 1);

    if (guiInstances.has('emittersEditGUI')) {
        const gui = guiInstances.get('emittersEditGUI');
        const folderName = `Emitter ${id}`;
        const folder = gui.folders.find(f => f.title === folderName);
        if (folder) {
            folder.destroy();
        }
    }
}

window.removeEmitterById = removeEmitterById;

function loadEmittersFromJSON(url) {
    fetch(url)
        .then(response => response.json())
        .then(data => initEmittersEdit('emittersEditGUI', data))
        .catch(error => console.error('Error loading emitters:', error));
}

window.loadEmittersFromJSON = loadEmittersFromJSON;

function createEmitter(params, start=false) {
    const emitterId = params.id || generateUniqueId();
    params.id = emitterId;

    const emitter = cubeEmitter(params);
    emitter.setIntervalTime(params.interval);
    emitter.setDelay(params.delay);
    emitter.setCount(params.count);
    emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
    emitter.setDensity(params.density);
    emitter.setSpeedFactor(params.speedFactor);

    storedEmitters.push({ ...params });

    // start if you want on load 
    if(start) {
        emitter.start()
    }
    //emitter.start();
}

function loadEmitters(url) {
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (Array.isArray(data)) {
                data.forEach(emitterData => {
                    if (typeof emitterData === 'object' && emitterData !== null) {
                        createEmitter(emitterData); // Assumes each item in the array is a single emitter object
                    } else {
                        console.error('Invalid emitter data format');
                    }
                });
            } else {
                console.error('Invalid emitters data format');
            }
        })
        .catch(error => console.error('Error loading emitters:', error));
}

window.loadEmitters = loadEmitters;



function loadSingleEmitter(url) {
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (typeof data === 'object' && data !== null) {
                createEmitter(data); // Assumes the JSON is a single object
            } else {
                console.error('Invalid emitter data format');
            }
        })
        .catch(error => console.error('Error loading emitter:', error));
}

window.loadSingleEmitter = loadSingleEmitter;



function runEmitterValues(emitterId, newPosition, newDirection) {

    const emitter = emittersMap.get(emitterId);
    
    if (!emitter) {
        console.error(`Emitter with ID ${emitterId} not found.`);
        return;
    }

    if (newPosition) {
        emitter.setPosition(newPosition);
    }

    if (newDirection) {
        emitter.setDirection(newDirection);

        // this can not work if there is no GUI and preview geometries:
        // Update the preview rotation based on the new direction
        // updatePreviewMeshRotation(emitter.previewMesh, { 
        //     directionX: newDirection.x, 
        //     directionY: newDirection.y, 
        //     directionZ: newDirection.z 
        // });
        // updatePreviewLine(emitter.previewLine, { 
        //     x: newPosition.x, 
        //     y: newPosition.y, 
        //     z: newPosition.z, 
        //     directionX: newDirection.x, 
        //     directionY: newDirection.y, 
        //     directionZ: newDirection.z, 
        //     speedFactor: emitter.getParams().speedFactor 
        // });
    }

    emitter.restart();
}

window.runEmitterValues = runEmitterValues;




function runEmitterDev(emitterId, positionDeviation = { x: 0, y: 0, z: 0 }, directionDeviation = { x: 0, y: 0, z: 0 }, speedFactorDeviation = 0, densityDeviation = 0) {
    const emitter = emittersMap.get(emitterId);
    if (!emitter) {
        console.error(`Emitter with ID ${emitterId} not found.`);
        return;
    }

    // Check and store original values if they don't exist
    if (!emitter.originalValues) {
        const currentParams = emitter.getParams();
        emitter.originalValues = {
            position: { x: currentParams.x, y: currentParams.y, z: currentParams.z },
            direction: { x: currentParams.directionX, y: currentParams.directionY, z: currentParams.directionZ },
            speedFactor: currentParams.speedFactor,
            density: currentParams.density
        };
    }

    const original = emitter.originalValues;

    function applyDeviation(value, deviation) {
        return value + (Math.random() * deviation - Math.random() * deviation);
    }

    const newPosition = {
        x: applyDeviation(original.position.x, positionDeviation.x),
        y: applyDeviation(original.position.y, positionDeviation.y),
        z: applyDeviation(original.position.z, positionDeviation.z)
    };

    const newDirection = {
        x: applyDeviation(original.direction.x, directionDeviation.x),
        y: applyDeviation(original.direction.y, directionDeviation.y),
        z: applyDeviation(original.direction.z, directionDeviation.z)
    };

    const newSpeedFactor = applyDeviation(original.speedFactor, speedFactorDeviation);
    const newDensity = applyDeviation(original.density, densityDeviation);

    emitter.setPosition(newPosition);
    emitter.setDirection(newDirection);
    emitter.setSpeedFactor(newSpeedFactor);
    emitter.setDensity(newDensity);

    // this can not work if there is no GUI and preview geometries:
    // Update the preview rotation based on the new direction
    // updatePreviewMeshRotation(emitter.previewMesh, newDirection);
    // updatePreviewLine(emitter.previewLine, { 
    //     x: newPosition.x, 
    //     y: newPosition.y, 
    //     z: newPosition.z, 
    //     directionX: newDirection.x, 
    //     directionY: newDirection.y, 
    //     directionZ: newDirection.z, 
    //     speedFactor: newSpeedFactor 
    // });

    emitter.restart();
}

window.runEmitterDev = runEmitterDev;




// loadEmittersFromJSONString(controllersEmittersJSON)
function loadEmittersFromJSONString(jsonString) {
    try {
        const data = JSON.parse(jsonString);
        if (Array.isArray(data)) {
            data.forEach(emitterData => {
                if (typeof emitterData === 'object' && emitterData !== null) {
                    createEmitter(emitterData); // Assumes each item in the array is a single emitter object
                } else {
                    console.error('Invalid emitter data format');
                }
            });
        } else {
            console.error('Invalid emitters data format');
        }
    } catch (error) {
        console.error('Error parsing emitters JSON:', error);
    }
}

window.loadEmittersFromJSONString = loadEmittersFromJSONString;



let controllersEmittersJSON = `[{
    "id": "controller1",
    "x": 0,
    "y": 0,
    "z": 0,
    "sx": 0.1,
    "sy": 0.3,
    "sz": 0.1,
    "geometryType": "BoxGeometry",
    "interval": 50,
    "randomSizes": false,
    "directionX": 0,
    "directionY": 1,
    "directionZ": 0,
    "delay": 0,
    "count": 4,
    "speedFactor": 100,
    "density": 10
},
{
    "id": "controller2",
    "x": 0,
    "y": 0,
    "z": 0,
    "sx": 0.1,
    "sy": 0.3,
    "sz": 0.1,
    "geometryType": "BoxGeometry",
    "interval": 50,
    "randomSizes": false,
    "directionX": 0,
    "directionY": -1,
    "directionZ": 0,
    "delay": 0,
    "count": 4,
    "speedFactor": 100,
    "density": 10
}]`;


function initControllersEmitters() {

    loadEmittersFromJSONString(controllersEmittersJSON)

}


/* 

    Game Timer GUI with Event Handlers
    ----------------------------------------------- 

    */

function gameTimerEdit(guiKey) {
    const container = document.getElementById("guiHolder");

    const gui = new GUI({ width: 350, container: container });
    guiInstances.set(guiKey, gui);

    const timerParams = {
        totalTime: 0,
        remainingTime: 0,
        isActive: false,
        intervalId: null,
        status: 'Stopped',
        formattedTime: '00:00:00'
    };

    const timerEvents = {
        onTimerStart: () => console.log('Timer started'),
        onTimerEnd: () => console.log('Timer ended'),
        onTimerPaused: () => console.log('Timer paused')
    };

    function formatTime(seconds) {
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
    }

    function updateTimeDisplay() {
        timerParams.remainingTime = Math.max(0, timerParams.remainingTime);
        timerParams.formattedTime = formatTime(timerParams.remainingTime);
        statusController.updateDisplay();
        timeController.updateDisplay();
    }

    function startTimer() {
        if (timerParams.isActive) return;
        timerParams.isActive = true;
        timerParams.status = 'Running';
        timerEvents.onTimerStart(); // Trigger onTimerStart event
        timerParams.intervalId = setInterval(() => {
            timerParams.remainingTime -= 1;
            updateTimeDisplay();
            if (timerParams.remainingTime <= 0) {
                pauseTimer();
                timerEvents.onTimerEnd(); // Trigger onTimerEnd event
            }
        }, 1000);
        statusController.updateDisplay();
    }

    function pauseTimer() {
        if (timerParams.intervalId) {
            clearInterval(timerParams.intervalId);
            timerParams.intervalId = null;
            timerParams.isActive = false;
            timerParams.status = 'Paused';
            timerEvents.onTimerPaused(); // Trigger onTimerPaused event
            statusController.updateDisplay();
        }
    }

    function resetTimer() {
        pauseTimer();
        timerParams.remainingTime = timerParams.totalTime;
        timerParams.status = 'Stopped';
        updateTimeDisplay();
        statusController.updateDisplay();
    }

    const folder = gui.addFolder('Game Timer');
    folder.add(timerParams, 'totalTime', 0, 1000).name('Total Time (sec)').onChange(value => {
        timerParams.totalTime = Math.floor(value);
        resetTimer();
    });

    folder.add({ start: startTimer }, 'start').name('Start');
    folder.add({ pause: pauseTimer }, 'pause').name('Pause');
    folder.add({ reset: resetTimer }, 'reset').name('Reset');

    const statusController = folder.add(timerParams, 'status').name('Status').listen();
    const timeController = folder.add(timerParams, 'formattedTime').name('Time Left').listen();

    folder.add({ close: () => toggleGameTimerGUI() }, 'close').name('CLOSE');
    folder.open();

    // Adding event handlers to GUI
    const eventFolder = gui.addFolder('Event Handlers');
    eventFolder.add(timerEvents, 'onTimerStart').name('On Timer Start');
    eventFolder.add(timerEvents, 'onTimerEnd').name('On Timer End');
    eventFolder.add(timerEvents, 'onTimerPaused').name('On Timer Paused');
    eventFolder.open();

    resetTimer();
}

function toggleGameTimerGUI() {
    if (guiInstances.has('gameTimerGUI')) {
        guiInstances.get('gameTimerGUI').destroy();
        guiInstances.delete('gameTimerGUI');
    } else {
        gameTimerEdit('gameTimerGUI');
    }
}

window.toggleGameTimerGUI = toggleGameTimerGUI;









/* 

    World / Ground
    ----------------------------------------------- 

    */



let groundHeight = 0;
let gravity = { x: 0.0, y: -2, z: 0.0 };
let eventQueue

window.myRapierWorld

window.rigidBodies = window.rigidBodies || [];
window.threeCubes = window.threeCubes || [];

let obstacles = [];
let groundObjects = [];

//let ground = "static/models/grounds/simple-ground-3.glb";
//let ground = "static/models/grounds/hide-n-seek-plat-1.glb";
let ground = "static/models/grounds/szachownica2.glb";



/* 

    Init Rapier
    ----------------------------------------------- 

    */




function updateRapier() {

    if (window.myRapierWorld && window.rigidBodies) {
        //window.myRapierWorld.step();
        window.myRapierWorld.step(window.eventQueue);
        //console.log(window.rigidBodies)

        for(let i = 0; i < window.rigidBodies.length; i++) {
            if(window.rigidBodies[i].bodyType() == 0) {
                let position = window.rigidBodies[i].translation();
                window.threeCubes[i].position.set(position.x, position.y, position.z);
                // Add this part to update the rotation
                let rotation = window.rigidBodies[i].rotation(); // Assuming the rotation method returns a quaternion
                window.threeCubes[i].quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
            }
        }

        logRapierEvents()
        //updateRigidBodies();
        //updateDummyAvatar();
    }
}


function logRapierEvents() {
    window.eventQueue.drainCollisionEvents((handle1, handle2, started) => {
        const object1Data = window.handleToObjectMap.get(handle1);
        const object2Data = window.handleToObjectMap.get(handle2);

        if (object1Data && object2Data) {
            const name1 = object1Data.name || 'Unnamed Object 1';
            const name2 = object2Data.name || 'Unnamed Object 2';

            // Use getWorldPosition to get the actual world position of the objects
            const worldPosition1 = new THREE.Vector3();
            const worldPosition2 = new THREE.Vector3();
            object1Data.object.getWorldPosition(worldPosition1);
            object2Data.object.getWorldPosition(worldPosition2);

            // console.log(`Collision ${started ? 'started' : 'ended'} between ${name1} and ${name2}`);
            //console.log(`Position of ${name1}: x=${worldPosition1.x}, y=${worldPosition1.y}, z=${worldPosition1.z}`);
            //console.log(`Position of ${name2}: x=${worldPosition2.x}, y=${worldPosition2.y}, z=${worldPosition2.z}`);

            if (started) {


                //makeExplosion(worldPosition2);
                


                //console.log(`Hit ${name1}: ${worldPosition1.x}, ${worldPosition1.y}, ${worldPosition1.z}`);
                //console.log(`Target ${name2}: ${worldPosition2.x}, ${worldPosition2.y}, ${worldPosition2.z}`);
                console.log(`Hit | ${name2} => ${name1} | :${Math.floor(worldPosition2.x)}, ${Math.floor(worldPosition2.y)}, ${Math.floor(worldPosition2.z)}`);


                // hit sound
                // fxPip({
                //     frequency: 200 - Math.random()*100,
                //     volume: 1,
                //     duration: 100,
                //     type: 'square',
                //     fadeInPercent: 0,
                //     fadeOutPercent: 90,
                //     filterType: 'bandpass',
                //     filterFrequency: 1000,
                //     filterQ: 10
                // }); 

                // Play positional sound


                // SoundManager.playPositionalSound('blip', worldPosition2, {
                //     initialFrequency: 50 - Math.random() * 10,
                //     volume: 1,
                //     duration: 0.05,
                //     type: 'square',
                //     fadeInPercent: 0,
                //     fadeOutPercent: 90,
                //     filterType: 'bandpass',
                //     filterFrequency: 50,
                //     filterQ: 10
                // });



            }
        } else {
            //console.log("Could not find object data for one or both handles.");
        }
    });
}


let world 

window.myRapierWorld
window.rigidBodies = window.rigidBodies || [];
window.threeCubes = window.threeCubes || [];


async function initRapier() {
    
    console.log("initRapier, gravity", gravity);

    await RAPIER.init();

    world = new RAPIER.World(gravity);

    eventQueue = new RAPIER.EventQueue(true);


    loadStaticGroundModel(ground);

}


window.objectRigidBodyMap = new Map();


function needsColliderUpdate(threeObject) {
    // Implement logic to determine if the collider needs to be updated
    // This could be based on comparing the current scale with the original scale
}

function updateColliderForScale(threeObject, rigidBody) {
    // Remove the old collider from the rigid body
    // ...

    // Create a new collider with the updated scale
    // This will typically involve creating a new shape (e.g., TriMesh) with the scaled geometry
    // and then attaching it to the rigid body
    // ...
}


function updateRigidBodies() {

    window.objectRigidBodyMap.forEach((rigidBody, threeObject) => {
        // Get world position and quaternion
        const worldPosition = new THREE.Vector3();
        const worldQuaternion = new THREE.Quaternion();

        threeObject.getWorldPosition(worldPosition);
        threeObject.getWorldQuaternion(worldQuaternion);

        // Update position and rotation in Rapier
        rigidBody.setTranslation(worldPosition, true);
        rigidBody.setRotation({ w: worldQuaternion.w, x: worldQuaternion.x, y: worldQuaternion.y, z: worldQuaternion.z });


        if (needsColliderUpdate(threeObject)) {
            // Remove old collider and create a new one with updated scale
            updateColliderForScale(threeObject, rigidBody);
        }        

        //console.log("updateRigidBodies", worldPosition, worldQuaternion);
    });

}



/* 

    Loaders
    ----------------------------------------------- 

    */


const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('./static/libs/draco/');
const loader = new GLTFLoader();
loader.setDRACOLoader(dracoLoader);


function loadStaticGroundModel(ground) {


    loader.load(ground, gltf => {

        let mesh = gltf.scene
        mesh.name = "PAD"
        mesh.ignore = true;

        scene.add(mesh);

        mesh.rotation.y = 0;
        groundObjects.push(mesh)

        gltf.scene.traverse(item => {
            if (item.isMesh) {
            // if (item.isMesh && Array.isArray(item.material)) {
            //     item.material.forEach(mat => {
            //         console.log(mat.name)
            //         if (mat.name === "Material.002") {
            //             waterMaterial = mat; // Store the reference
            //         }
            //     });
            // }
            // if (Array.isArray(item.material)) {
            //     item.material.forEach((mat, index) => {
            //         console.log(`Material ${index} on mesh ${item.name}:`, mat.name);
            //             if (mat.name === "Material.001") {
            //                 console.log("material")
            //                 waterMaterial = mat; // Store the reference
            //             }
            //     });
            // } else {
            //     // Single material
            //     // console.log("Single material on mesh", item.name, ":", item.material.name);
            //             if (item.material.name === "Material.003") {
            //                 //console.log("material")
            //                 waterMaterial = item.material; // Store the reference
            //                 window.waterMaterial = waterMaterial;
            //             }                    
            // }
                //console.log("isMesh:", item.name)
                const geometry = item.geometry;
                item.castShadow = true;     // allows the node to cast shadows
                item.receiveShadow = true;                 
                // swap material for refractions
                // item.material = new THREE.MeshPhongMaterial({ 
                //     transparent: true,  opacity: 0.1, 
                //     color: 0xFFFFFF
                //     //color: 0xFFFFFF, envMap: envMap1, refractionRatio: 0.98, reflectivity: 0.98
                // });
                //item.material = shaderMaterial;
                
                //console.log(geometry)
                
                const vertices = geometry.attributes.position.array;
                const indices = geometry.index.array;
                const trimesh = new RAPIER.TriMesh(vertices, indices);
                //console.log('TriMesh created successfully', trimesh);
                //console.log('Vertices length:', vertices.length);
                //console.log('Indices length:', indices.length);
                let groundColliderDesc = RAPIER.ColliderDesc.trimesh(trimesh)
                    .setDensity(100)
                    .setTranslation(0, groundHeight, 0)
                    .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
                // this part is a kind of hack...
                groundColliderDesc.shape.indices = indices;
                groundColliderDesc.shape.vertices = vertices;
                let groundCollider = world.createCollider(groundColliderDesc);
                window.groundColliderHandle = groundCollider.handle;

                window.myRapierWorld = world;
                
                window.eventQueue = eventQueue;
                item.material.wireframe = false;
                
                // this enabled that ground is a subject to teleportation
                teleportTargets.push(item);
            }

            //setTimeout(connectWebSocket, 1000);


        })


    })

}










/* 

    Init Controlllers
    ----------------------------------------------- 

    */



/* Light settings */

const modelsCastShadow = true;
const lightShadowMapSizeF = 10;

const tronLegacyColors = {
    
    deepBlack: 0x0a0a0a,
    greyMetallic: 0x6f6f6f,
    darkGrey: 0x1c1c1c,
    
    brightBlue: 0x00d9ff,
    brightOrange: 0xff3700,
    pureWhite: 0xffffff,

    almostBlack: 0x1a1a1a,
    digitalBlue: 0x0057ff,
};



/* Teleportation - Controllers */





/* 

    Controllers 


    */



async function checkVRHeadsetAvailability() {
    if (navigator.xr) {
        try {
            // Check if 'immersive-vr' mode is supported
            const isSupported = await navigator.xr.isSessionSupported('immersive-vr');
            return isSupported;
        } catch (error) {
            console.log("Error checking VR headset availability:", error);
            return false;
        }
    } else {
        return false;
    }
}

let renderPostprocessing = false;
window.renderPostprocessing = renderPostprocessing;



async function setupCustomVRButton() {

    const vrAvailable = await checkVRHeadsetAvailability();
    
    if (vrAvailable) {
        const customVrButton = document.createElement('button');
        customVrButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <style>
                @keyframes blink {
                  0%, 100% { opacity: 1; }
                  50% { opacity: 0.5; }
                }
                .blink {
                  animation: blink 4s linear infinite;
                }
              </style>
        <g fill="rgba(255,255,255,0.75)" fill-rule="evenodd" clip-rule="evenodd"><path class="blink" d="M10 7.5c0-.3.2-.5.5-.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1-.5-.5z" fill="#99FF00"/><path class="blink" d="M3 7c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v4a2 2 0 0 1-1 1.8c-1 3.8-4.1 6.7-8 6.7-3.9 0-7-2.9-8-6.7A2 2 0 0 1 3 11zm2-1h14c.6 0 1 .4 1 1v4c0 .6-.4 1-1 1h-3.3a1 1 0 0 1-.3 0l-2.5-.8a3 3 0 0 0-1.8 0l-2.5.8H5a1 1 0 0 1-1-1V7c0-.6.4-1 1-1zm.2 7c1 3.3 3.6 5.5 6.8 5.5 3.2 0 5.8-2.2 6.8-5.5h-3.1a2 2 0 0 1-.6 0l-2.5-.8a2 2 0 0 0-1.2 0l-2.5.7a2 2 0 0 1-.6.1z" fill="#99FF00"/><path class="blink" d="M10 14.5c.3 0 .5.2.5.5l.3.3 1.2.2 1.2-.2.3-.2V15a.5.5 0 0 1 1 0c0 .6-.4 1-.9 1.2-.4.2-1 .3-1.6.3s-1.2-.1-1.6-.3c-.5-.3-.9-.6-.9-1.2 0-.3.2-.5.5-.5z" fill="#99FF00"/></g></svg>
        `; // Or use an <img> tag for a custom icon
        customVrButton.classList.add('custom-vr-button');
        customVrButton.id = "customVrButton";

        // Custom styling

        customVrButton.addEventListener('click', () => {

            renderPostprocessing = false;
            // Logic to start VR session
            renderer.xr.enabled = true;

            const sessionInit = {
                optionalFeatures: ['local-floor', 'bounded-floor'],
                requiredFeatures: ['hand-tracking']
            };

            // const sessionInit = {
            //         optionalFeatures: [ 'depth-sensing', 'local-floor' ],
            //         depthSensing: { 'usagePreference': [ 'gpu-optimized' ], dataFormatPreference: [] 
            //     }}

            // const sessionInit = { optionalFeatures: ['local-floor', 'bounded-floor'] };

            navigator.xr.requestSession('immersive-vr', sessionInit).then((session) => {
                renderer.xr.setSession(session);
            });


            startGame();


        });

        document.body.appendChild(customVrButton);

        document.querySelector('.custom-vr-button').classList.add('display-block')

    }
}


// setupCustomVRButton()



    //----
    // Updated part: Add sessionInit parameter with hand-tracking
    // See - https://github.com/immersive-web/webxr/issues/1358#issuecomment-1941838121
    // moved to   customVrButton  
    // const sessionInit = {
    //     optionalFeatures: [],
    //     requiredFeatures: ['hand-tracking']
    // };

    // document.body.appendChild(VRButton.createButton(renderer, sessionInit));



let raycaster = new THREE.Raycaster();

const teleportTargets = [];

let hand1, hand2;
let controller1, controller2;
let controllerGrip1, controllerGrip2;

let controllers = [];
let dummyMatrix;

const handModels = {
    left: null,
    right: null,
};
let handModelFactory;
let conS = [];

let teleportMode = false;
let teleportRing;
let cameraContainer
let activeController



/*  ---------------------------------------------------  */


let controller1QuaternionDisplay, controller2QuaternionDisplay;

function setupControllerDisplays() {

    function createQuaternionDisplay(controller) {
        const canvas = document.createElement('canvas');
        canvas.width = 100;  // Adjusted width for single column
        canvas.height = 100;
        const context = canvas.getContext('2d');
        context.fillStyle = 'orange';
        context.font = '18px monofonto';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), material);
        plane.position.set(0, 0, 0.15); // Adjust position as needed

        controller.add(plane);
        
        return { canvas, texture, plane };
    }

    controller1QuaternionDisplay = createQuaternionDisplay(controller1);
    controller2QuaternionDisplay = createQuaternionDisplay(controller2);
}

function refreshControllerInfo() {
    const lineSpace = 18; // Adjust this value to change the space between lines

    function formatValue(value) {
        return (value >= 0 ? ' ' : '') + value.toFixed(2); // Add space if positive
    }

    function updateDisplay(controller, display, mode) {
        const quaternion = controller.getWorldQuaternion(new THREE.Quaternion());
        const lines = [
            `M: ${mode.substr(0,6)}`,
            `x:${formatValue(quaternion.x)}`,
            `y:${formatValue(quaternion.y)}`,
            `z:${formatValue(quaternion.z)}`,
            `w:${formatValue(quaternion.w)}`
        ];
        const context = display.canvas.getContext('2d');
        context.clearRect(0, 0, display.canvas.width, display.canvas.height);
        context.fillStyle = 'blue'; // Color for the mode text
        context.fillText(lines[0], display.canvas.width / 2, 15); // Display the mode

        lines.slice(1).forEach((value, index) => {
            context.fillStyle = value.includes('-') ? 'green' : 'orange'; // Orange for positive, green for negative
            context.fillText(value, display.canvas.width / 2, 15 + ((index + 1) * lineSpace));
        });

        display.texture.needsUpdate = true;
    }

    updateDisplay(controller1, controller1QuaternionDisplay, currentMode);
    updateDisplay(controller2, controller2QuaternionDisplay, currentMode);


    updateEmitterFromController(controller1);
    updateEmitterFromController(controller2);


}


/*  ---------------------------------------------------  */

/* Web Sockets - placeholders */


function broadcastXRUser() {

}











/*  ---------------------------------------------------  */

function generateRayTexture() {
    const canvas = document.createElement("canvas");
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext("2d");

    // Create a gradient that starts fading to transparent immediately
    const gradient = ctx.createLinearGradient(0, 0, 0, 64);
    gradient.addColorStop(0, "rgba(255, 0, 0, 1)"); // Fully opaque at the start
    gradient.addColorStop(0.1, "rgba(255, 0, 0, 0)"); // Start fading out almost immediately

    // The rest of the gradient is transparent
    gradient.addColorStop(1, "rgba(255, 0, 0, 0)"); // Fully transparent towards the end

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);

    return canvas;
}

function generatePointerTexture() {
    const canvas = document.createElement("canvas");
    canvas.width = 64;
    canvas.height = 64;

    const ctx = canvas.getContext("2d");

    ctx.beginPath();
    ctx.arc(32, 32, 29, 0, 2 * Math.PI);
    ctx.lineWidth = 5;
    ctx.stroke();
    ctx.fillStyle = "white";
    ctx.fill();

    return canvas;
}


function getCameraPosition() {
    const cameraPosition = new THREE.Vector3();
    renderer.xr.getCamera(camera).getWorldPosition(cameraPosition);
    return cameraPosition;
}



function addBallTrajectory() {

    console.log(" - addBallTrajectory")

    // Remove existing line if any

    if (window.ballTrajectory) {
        scene.remove(window.ballTrajectory);
    }

    let cameraPosition = getCameraPosition();
    let leftHand = renderer.xr.getController(0); // 0 is usually the left hand
    let leftHandPosition = new THREE.Vector3();
    leftHand.getWorldPosition(leftHandPosition);

    // Create the line to visualize this vector
    const lineGeometry = new THREE.BufferGeometry().setFromPoints([leftHandPosition, cameraPosition]);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const line = new THREE.Line(lineGeometry, lineMaterial);

    window.ballTrajectory = line;

    // Add line to the scene
    scene.add(window.ballTrajectory);

}



function initControllers() {

    console.log(" -------- initControllers")




    addBallTrajectory();

    const rayTexture = new THREE.CanvasTexture(generateRayTexture());
    rayTexture.needsUpdate = true;

    const material = new THREE.MeshBasicMaterial({
        map: rayTexture,
        transparent: true,
        side: THREE.DoubleSide,
        alphaTest: 0.05,
    });

    const geometry = new THREE.BoxGeometry(0.005, 0.005, 20);
    geometry.translate(0, 0, -10.01);

    const uvAttribute = geometry.getAttribute("uv");
    for (let i = 0; i < uvAttribute.count; i++) {
        uvAttribute.setXY(i, i % 2, Math.floor(i / 4) % 2);
    }

    const linesHelper = new THREE.Mesh(geometry, material);
    linesHelper.rotation.z = 5 * (Math.PI / 4);
    linesHelper.ignore = true;

    const spriteMaterial = new THREE.SpriteMaterial({
        map: new THREE.CanvasTexture(generatePointerTexture()),
        sizeAttenuation: false,
        depthTest: false,
    });

    const pointer = new THREE.Sprite(spriteMaterial);
    pointer.scale.set(0.015, 0.015, 1);
    pointer.renderOrder = Infinity;    

    controller1 = renderer.xr.getController(0);
    controller1.name = "controller1";
    scene.add(controller1);

    controller2 = renderer.xr.getController(1);
    controller2.name = "controller2";
    scene.add(controller2);

    const controllerModelFactory = new XRControllerModelFactory();
    handModelFactory = new XRHandModelFactory();

    console.log(" - - - - - - - - -handModelFactory:", handModelFactory);

    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(
        controllerModelFactory.createControllerModel(controllerGrip1),
    );
    scene.add(controllerGrip1);

    hand1 = renderer.xr.getHand(0);
    hand1.name = "hand1";
    hand1.userData.currentHandModel = 0;
    scene.add(hand1);

    console.log(" - - - - - - - - -hand1", hand1);

    handModels.left = [handModelFactory.createHandModel(hand1, "mesh")];
    const model1 = handModels.left[0];
    model1.visible = true;

    hand1.add(model1);

    hand1.addEventListener("pinchend", function () {
        console.log("hand1 pinched");
        handlePinch(hand1);

    });

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(
        controllerModelFactory.createControllerModel(controllerGrip2),
    );
    scene.add(controllerGrip2);

    hand2 = renderer.xr.getHand(1);
    hand2.name = "hand2";    
    hand2.userData.currentHandModel = 2;
    scene.add(hand2);

    handModels.right = [handModelFactory.createHandModel(hand2, "mesh")];
    const model2 = handModels.right[0];
    model2.visible = true;
    hand2.add(model2);

    hand2.addEventListener("pinchend", function () {
        console.log("hand2 pinched");
        handlePinch(hand2);
    });

    window.hand1 = hand1;
    window.hand2 = hand2;

    /* rings */

    // Define the geometry and material for the wearable torus
    const torusGeometry = new THREE.TorusGeometry(0.06, 0.005, 16, 100); // Adjust the size as needed
    const torusMaterial = new THREE.MeshBasicMaterial({ color: tronLegacyColors.brightBlue }); // Green color for visibility

    controller1.addEventListener("connected", function (e) {
        
        console.log("Controller 1 connected!", e.data);
        
        if (e.data.gamepad !== null) {
            if (conS.filter((obj) => obj.id === 0).length === 0) {
                conS.push({
                    id: 0,
                    data: e.data,
                });
            }
        }
    });

    controller2.addEventListener("connected", function (event) {
        
        console.log("Controller 2 connected!", event.data);
        if (event.data.gamepad !== null) {
            if (conS.filter((obj) => obj.id === 1).length === 0) {
                conS.push({
                    id: 1,
                    data: event.data,
                });
            }
        }
    });

    controllers.push(controller1);
    controllers.push(controller2);

    controllers.forEach((controller) => {

        const simpleRayGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -10),
        ]);
        
        const simpleRay = new THREE.Line(
            simpleRayGeometry,
            new THREE.LineBasicMaterial({ color: 0xffffff, visible: true }),
        ); // Invisible for visual purposes
        
        controller.simpleRay = simpleRay; // Attach the simpleRay to the controller
        controller.add(simpleRay); // Add the simpleRay to the controller object
        simpleRay.ignore = true;
    });

    controllers.forEach((controller) => {
        const ray = linesHelper.clone();
        ray.ignore = true;
        const point = pointer.clone();
        point.ignore = true;
        controller.add(ray, point);
        controller.ray = ray;
        controller.point = point;
    });

    const discRadius = 0.25;
    const discMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.25,
    });
    const discGeometry = new THREE.CircleGeometry(discRadius, 32);

    controllers.forEach((controller) => {
        const disc = new THREE.Mesh(discGeometry, discMaterial);
        disc.visible = false; // Initially invisible
        disc.ignore = true;
        controller.disc = disc; // Store the disc as a property of the controller
        scene.add(disc);

        // Create and add the ring
        const ring = new THREE.Mesh(torusGeometry, torusMaterial);
        controller.ring = ring;
        ring.ignore = true;
        ring.position.set(0, 0, 0.15); // Adjust position relative to the controller
        ring.rotation.set(0, 0, 0); // Adjust rotation if needed
        controller.add(ring); // Attach the ring directly to the controller
    });

    dummyMatrix = new THREE.Matrix4();
    raycaster = new THREE.Raycaster();

    const teleportRingGeometry = new THREE.RingGeometry(0.23, 0.25, 64);
    const teleportRingMaterial = new THREE.MeshBasicMaterial({ color: tronLegacyColors.brightBlue, side: THREE.DoubleSide });
    teleportRing = new THREE.Mesh(teleportRingGeometry, teleportRingMaterial);
    teleportRing.rotation.x = -Math.PI / 2; // Rotate to lay flat on the ground
    teleportRing.visible = false; // Initially invisible
    teleportRing.ignore = true;

    scene.add(teleportRing);

    cameraContainer = new THREE.Object3D();
    scene.add(cameraContainer);
    
    cameraContainer.add(camera);

    /* parent controllers to the container */
    cameraContainer.add(controller1);
    cameraContainer.add(controller2);  

    cameraContainer.add(hand1);
    cameraContainer.add(hand2);

    cameraContainer.add(model1);
    cameraContainer.add(model2);

    cameraContainer.add(controllerGrip1);
    cameraContainer.add(controllerGrip2);

    function onControllerSelectStart(controller) {
        if (currentMode !== 'teleportation') return;

        const tempMatrix = new THREE.Matrix4();
        tempMatrix.identity().extractRotation(controller.matrixWorld);

        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

        const intersects = raycaster.intersectObjects(teleportTargets, false);

        if (intersects.length > 0) {
            teleportMode = true;
            activeController = controller;
            teleportRing.visible = true;
            teleportRing.position.copy(intersects[0].point);
            teleportRing.position.y += 0.03; // Adjust if necessary
        }
    }

    function performTeleportation() {

        console.log("performTeleportation",currentMode,teleportMode)

        if (currentMode === 'teleportation' && teleportMode) {
            const teleportDestination = new THREE.Vector3();
            teleportRing.getWorldPosition(teleportDestination);

            cameraContainer.position.copy(teleportDestination);

            teleportMode = false;
            teleportRing.visible = false;
            activeController = null;
        }
    }



    listEmitterIds();

    const emitterId1 = "controller1"; // Assuming you have at least two emitters
    const emitterId2 = "controller2";

    controller1.userData.emitterId = emitterId1;
    controller2.userData.emitterId = emitterId2;


    controller1.addEventListener('selectstart', function () {
        if (currentMode === 'teleportation') {
            onControllerSelectStart(controller1);
        } else if (currentMode === 'weapon') {
            shootBallFromController(controller1);
            broadcastXRUser();
        }
        handlePinch(controller1);
    });

    controller1.addEventListener('selectend', function () {
        if (currentMode === 'teleportation' && teleportMode) {
            performTeleportation();
        }
    });

    controller2.addEventListener('selectstart', function () {
        if (currentMode === 'teleportation') {
            onControllerSelectStart(controller2);
        } else if (currentMode === 'weapon') {
            shootBallFromController(controller2);
            broadcastXRUser();
        }
        handlePinch(controller2);
    });

    controller2.addEventListener('selectend', function () {
        if (currentMode === 'teleportation' && teleportMode) {
            performTeleportation();
        }
    });

    setupControllerDisplays();
}


function updateRaycasting() {
    controllers.forEach((controller) => {
        const simpleRay = controller.simpleRay;
        raycaster.ray.origin.setFromMatrixPosition(simpleRay.matrixWorld);
        const rayDirection = new THREE.Vector3(0, 0, -1).applyMatrix4(simpleRay.matrixWorld);
        rayDirection.sub(raycaster.ray.origin).normalize();
        raycaster.ray.direction.copy(rayDirection);

        const intersects = raycaster.intersectObjects(teleportTargets, false);
        const intersectsWithGUI = intersects.some(intersect => intersect.object.isGUI);
        
        if (intersectsWithGUI) {
            if (currentMode !== 'gui') {
                previousMode = currentMode;
                currentMode = 'gui';
                teleportMode = false;
            }
            return; // Skip further processing to avoid teleportation while interacting with GUI
        }

        if (currentMode === 'gui') {
            currentMode = previousMode;
            teleportMode = false;
        }

        if (currentMode !== 'gui') {
            if (intersects.length > 0) {
                const closestIntersection = intersects[0];
                processIntersection(closestIntersection, controller);
            } else {
                controller.disc.visible = false;
                controller.point.visible = false;
            }
        }
    });
}



function handlePinch(controller) {

    // const intersections = raycaster.intersectObjects(scene.children, true);
    console.log("handlePinch, control", controller);

    // intersections.forEach(intersection => {
    //     if (intersection.object) {
    //         //console.log("👆 Intersected Object:", intersection.object.name);
    //         traverseAndLog(intersection.object);
    //     }
    // });

}



function traverseAndLog(object, level = 0) {
    const indent = ' '.repeat(level * 2); // Create an indent based on the level
    let output = `${indent}${object.type} - ${object.name}`;

    if (object.userData && Object.keys(object.userData).length > 0) {
        output += ` | userData: ${JSON.stringify(object.userData)}`;
    }

    if (object.data && Object.keys(object.data).length > 0) {
        output += ` | data: ${JSON.stringify(object.data)}`;
    }

    console.log(output);

    if (object.parent) {
        console.log(`${indent}  Parent: ${object.parent.type} - ${object.parent.name}`);
    }

    object.children.forEach(child => {
        traverseAndLog(child, level + 1);
    });
}






function processIntersection(intersection, controller) {
    const intersectPoint = intersection.point;
    const intersectNormal = intersection.face.normal;

    const disc = controller.disc;
    const offsetDistance = 0.01;
    const offsetPoint = intersectPoint.clone().add(intersectNormal.multiplyScalar(offsetDistance));
    disc.position.copy(offsetPoint);
    disc.lookAt(offsetPoint.x + intersectNormal.x, offsetPoint.y + intersectNormal.y, offsetPoint.z + intersectNormal.z);
    disc.visible = true;

    teleportRing.position.copy(intersectPoint);
    teleportRing.position.y += 0.03;

    controller.worldToLocal(intersectPoint);
    controller.point.position.copy(intersectPoint);
    controller.point.visible = true;

    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    const maxScale = 0.05;
    let scale = maxScale / distance;
    controller.point.scale.set(scale, scale, 1);

    if (intersection.object.userData.file_type == "note") {
        intersection.object.material.color.set(0x00ff00); // Change color for testing
        console.log("Info spot detected:", intersection.object);
    }
}

/* Teleportation / Weapon */



let currentMode = 'teleportation'; // Initial mode
const collisionThreshold = 0.05; // Threshold for ring collision, adjust as needed

let isColliding = false;
let collisionCooldown = false;
const cooldownTime = 100; // Cooldown time in milliseconds (1 second)


function startCooldown() {
    collisionCooldown = true;
    setTimeout(() => {
        collisionCooldown = false;
    }, cooldownTime);
}

function updateRingColors() {
    const newColor = (currentMode === 'teleportation') ? tronLegacyColors.brightBlue : tronLegacyColors.brightOrange; 
    controller1.ring.material.color.set(new THREE.Color(newColor));
    controller2.ring.material.color.set(new THREE.Color(newColor));

    // Toggle visibility of helper lines and points based on the current mode
    const helpersVisible = currentMode === 'weapon';
    controllers.forEach(controller => {
        controller.ray.visible = helpersVisible;
        controller.point.visible = helpersVisible;
    });
}


function getLastCharAsDigit(str) {
    if (str.length === 0) {
        return null; // or an appropriate default value
    }
    const lastChar = str.charAt(str.length - 1);
    const digit = parseInt(lastChar, 10);
    if (isNaN(digit)) {
        return null; // or handle non-digit characters as needed
    }
    return digit;
}


function switchMode() {
    
    currentMode = (currentMode === 'teleportation') ? 'weapon' : 'teleportation';

    updateRingColors();
    //console.log("Switched to mode:", currentMode);

    // Ring changing Sound
    fxPip({
        frequency: 140,
        volume: 0.5,
        duration: 1000,
        fadeInPercent: 2, // 20% of the total duration for fade-in
        fadeOutPercent: 70 // 30% of the total duration for fade-out
    });

}



function checkRingCollision() {

    if (!renderer.xr.isPresenting) {
        // console.log(" - - - no - - - ");
        return;
    }

    refreshControllerInfo();    

    function isControllerPointingUpwards(controller, thresholdAngle) {
        const worldUp = new THREE.Vector3(0, 1, 0);
        const controllerDirection = new THREE.Vector3(0, 0, -1); // Forward direction in controller's local space
        controllerDirection.applyQuaternion(controller.getWorldQuaternion(new THREE.Quaternion()));

        const angleToUp = controllerDirection.angleTo(worldUp) * (180 / Math.PI);
        return angleToUp <= thresholdAngle;
    }

    const thresholdAngle = 30; // Angle threshold in degrees to determine if pointing upwards

    controller1.ring.visible = isControllerPointingUpwards(controller1, thresholdAngle);
    controller2.ring.visible = isControllerPointingUpwards(controller2, thresholdAngle);


    // Check if both controller rings are defined and visible
    if (controller1 && controller1.ring && controller2 && controller2.ring &&
        controller1.ring.visible && controller2.ring.visible) {
        
        // Get world positions of the rings
        const ring1WorldPosition = new THREE.Vector3();
        const ring2WorldPosition = new THREE.Vector3();
        controller1.ring.getWorldPosition(ring1WorldPosition);
        controller2.ring.getWorldPosition(ring2WorldPosition);

        // Check for ring collision using world positions
        const distance = ring1WorldPosition.distanceTo(ring2WorldPosition);

        if (distance < collisionThreshold && !isColliding && !collisionCooldown) {
            isColliding = true;
            switchMode();
            startCooldown(); // Start the cooldown period
        } else if (distance >= collisionThreshold && isColliding) {
            isColliding = false; // Rings are no longer colliding
        }
    }

}







/* 


    Shooting balls 
    -------------------------------------


    */


function shootBallFromXRBroadcast(data) {

    //createAndShootBall(startPosition, targetPosition, radius, color, density, speedFactor) {

    let color = tronLegacyColors.brightOrange;
    let radius = 0.15 + Math.random() * 0.01;
    let density = 5;
    let speedFactor = 22;    

    const startPosition = data.startPosition;
    const targetPosition = data.targetPosition

    // Calculate direction from start to target position
    let direction = new THREE.Vector3().subVectors(targetPosition, startPosition).normalize();

    // Create the rigid body description and set its properties
    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(startPosition.x, startPosition.y, startPosition.z)
        .setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);

    // Create the sphere geometry and material
    const sphereGeometry = new THREE.SphereGeometry(radius);
    const sphereMaterial = new THREE.MeshStandardMaterial({ color: color });
    const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphereMesh.position.copy(startPosition);

    scene.add(sphereMesh);

    // Create the collider
    let colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
    myRapierWorld.createCollider(colliderDesc, rigidBody);

    // Store the rigid body and mesh for future reference
    window.rigidBodies.push(rigidBody);
    window.threeCubes.push(sphereMesh);

}



function shootBallFromBroadcast(data) {


    const cameraPosition = new THREE.Vector3(data.cameraPosition.x, data.cameraPosition.y, data.cameraPosition.z);
    const cameraDirection = new THREE.Vector3(data.cameraDirection.x, data.cameraDirection.y, data.cameraDirection.z);

    const offsetDistance = 0.25; // Adjust as needed to clear the avatar
    const startPosition = new THREE.Vector3().copy(cameraPosition).addScaledVector(cameraDirection, offsetDistance);

    let color = tronLegacyColors.brightOrange;
    let radius = 0.15 + Math.random() * 0.01;
    let density = 5;
    let speedFactor = 22;

    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(startPosition.x, startPosition.y, startPosition.z)
        .setLinvel(cameraDirection.x * speedFactor, cameraDirection.y * speedFactor, cameraDirection.z * speedFactor);

    // let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
    //                       .setTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z)
    //                       .setLinvel(cameraDirection.x * speedFactor, cameraDirection.y * speedFactor, cameraDirection.z * speedFactor);

    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);

    // Create the visual representation of the ball
    const sphereGeometry = new THREE.SphereGeometry(radius, 16, 12);
    const myBallMaterial = new THREE.MeshStandardMaterial({ color: color });
    const sphereMesh = new THREE.Mesh(sphereGeometry, myBallMaterial);
    
    scene.add(sphereMesh);

    // Create the collider
    let colliderDesc = RAPIER.ColliderDesc.ball(radius*1.05).setDensity(density);
    let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);

    // Update global arrays
    window.colliderHandles.push(collider.handle);
    window.rigidBodies.push(rigidBody);
    window.threeCubes.push(sphereMesh); // Consider renaming this array for clarity

}



// Sphere Core
const cacheSphereGeometry = new THREE.SphereGeometry(0.2,16,12);




function addBallFromCamera(radius, color, offsetY = 0.2, density = 1, speedFactor = 25) {


    const cameraPosition = camera.position;
    const cameraDirection = new THREE.Vector3();

    camera.getWorldDirection(cameraDirection);
    cameraDirection.y += offsetY;
    cameraDirection.normalize();


    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                          .setTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z)
                          .setLinvel(cameraDirection.x * speedFactor, cameraDirection.y * speedFactor, cameraDirection.z * speedFactor);
    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);

    //let texture = texturesCache[Math.floor(Math.random() * texturesCache.length)].texture;

      // Sphere Core
      // const sphereGeometry = new THREE.SphereGeometry(radius,16,12);

    const sphereGeometry = cacheSphereGeometry;  


      // const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
      
      const myBallMaterial = new THREE.MeshStandardMaterial({ color: color });
        // ------

      const sphereMesh = new THREE.Mesh(sphereGeometry, myBallMaterial);

      sphereMesh.name = "b-fc"

      scene.add(sphereMesh);

      // Create the collider
      let colliderDesc = RAPIER.ColliderDesc.ball(radius*1.05).setDensity(density)
      let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);
      // Save the collider handle
      window.colliderHandles = window.colliderHandles || [];
      window.colliderHandles.push(collider.handle); 
      // Push the rigid body and the Three.js sphere to the global arrays:


        // Store the mapping from collider handle to the THREE.js object
        window.handleToObjectMap = window.handleToObjectMap || new Map();
        window.handleToObjectMap.set(collider.handle, {
            object: sphereMesh,
            name: sphereMesh.name
        });

      window.rigidBodies.push(rigidBody);
      window.threeCubes.push(sphereMesh);  // Consider renaming this array for clarity

      // ws
      // ---------------

    //console.log(" - --> broadcastObjectChange", model_uuid, value, propName, valueToSend)


    // const message = {
    //     type: "broadcastBallFromCamera",
    //     world_uuid: place.uuid,
    //     world_name: place.name,
    //     client_uuid: client_uuid,
    //     cameraPosition: { x: cameraPosition.x, y: cameraPosition.y, z: cameraPosition.z },
    //     cameraDirection: { x: cameraDirection.x, y: cameraDirection.y, z: cameraDirection.z }
    // };

    // if (ws && ws.readyState === WebSocket.OPEN) {
    //     ws.send(JSON.stringify(message));
    // } else {
    //     console.warn('WebSocket is not open. Cannot request the model.');
    // }


    fxPip({
        frequency: Math.random()*100+400,
        volume: 1,
        duration: 50,
        type: 'sine',
        fadeInPercent: 0,
        fadeOutPercent: 90,
        filterType: 'bandpass',
        filterFrequency: 100,
        filterQ: 10
    });    


}

window.addBallFromCamera = addBallFromCamera;



function shootBall() {

    console.log("shootBall - Spacebar released!");

    let ballSize = 0.2 + Math.random() * 0.005;
    let density = 1;
    let speedFactor = 100;

    addBallFromCamera(ballSize, 0xFF3322, 0.1, density, speedFactor)


    console.log("shootBall",ballSize,density,speedFactor);
    
    //addBallFromShotLineEnd(ballSize, colorsSet[Math.floor(Math.random()*colorsSet.length)], 0.1, 1)
    //au.playAudioFromFile(au.findSounds(audioData, "kick2")[0])


    //game.balls +=1;

}

window.shootBall = shootBall;


document.addEventListener('keyup', (event) => {
    
    if (event.keyCode === 32) {
        shootBall();
    }

});


function updateEmitterValues(emitterId, newPosition, newDirection) {
    const emitter = emittersMap.get(emitterId);
    if (!emitter) {
        console.error(`Emitter with ID ${emitterId} not found.`);
        return;
    }

    if (newPosition) {
        emitter.setPosition(newPosition);
    }

    if (newDirection) {
        emitter.setDirection(newDirection);
    }
}

window.updateEmitterValues = updateEmitterValues;



function updateEmitterFromController(controller) {

    const emitterId = controller.userData.emitterId;
    if (!emitterId) return;

    // Get the world position of the controller
    const controllerWorldPosition = new THREE.Vector3();
    controller.getWorldPosition(controllerWorldPosition);

    // Get the world position of the point sprite
    const pointSpriteWorldPosition = new THREE.Vector3();
    controller.point.getWorldPosition(pointSpriteWorldPosition);

    // Calculate the direction from the controller to the point sprite
    const direction = new THREE.Vector3().subVectors(pointSpriteWorldPosition, controllerWorldPosition).normalize();

    // Update the emitter's position and direction
    updateEmitterValues(emitterId, 
        { x: controllerWorldPosition.x, y: controllerWorldPosition.y, z: controllerWorldPosition.z }, 
        { x: direction.x, y: direction.y, z: direction.z }
    );
}


function shootBallFromController(controller) {

    console.log("shootBallFromController - name:", controller.name);

    const emitterId = controller.userData.emitterId;
    if (!emitterId) return;

    console.log("shootBallFromController - emitterId:", emitterId);


    // Get the world position of the controller
    const controllerWorldPosition = new THREE.Vector3();
    controller.getWorldPosition(controllerWorldPosition);

    // Get the world position of the point sprite
    const pointSpriteWorldPosition = new THREE.Vector3();
    controller.point.getWorldPosition(pointSpriteWorldPosition);

    // Calculate the direction from the controller to the point sprite
    const direction = new THREE.Vector3().subVectors(pointSpriteWorldPosition, controllerWorldPosition).normalize();

    // Run the emitter with the calculated position and direction
    runEmitterValues(emitterId, 
        { x: controllerWorldPosition.x, y: controllerWorldPosition.y, z: controllerWorldPosition.z }, 
        { x: direction.x, y: direction.y, z: direction.z }
    );

    

}

window.shootBallFromController = shootBallFromController;


// function shootBallFromController(controller) {

//     console.log("shootBallFromController:", controller);

//     // The size, density, and speed factor for the ball
//     let ballSize = 0.12 + Math.random() * 0.01;
//     let density = 5;
//     let speedFactor = 30;

//     // Get the world position of the controller
//     const controllerWorldPosition = new THREE.Vector3();
//     controller.getWorldPosition(controllerWorldPosition);

//     // Get the world position of the point sprite
//     const pointSpriteWorldPosition = new THREE.Vector3();
//     controller.point.getWorldPosition(pointSpriteWorldPosition);

//     // Create and shoot the ball towards the point sprite
//     createAndShootBall(controllerWorldPosition, pointSpriteWorldPosition, ballSize, tronLegacyColors.brightBlue, density, speedFactor);

//     //game.balls +=1;

// }


function createAndShootBall(startPosition, targetPosition, radius, color, density, speedFactor) {

    let direction = new THREE.Vector3().subVectors(targetPosition, startPosition).normalize();

    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(startPosition.x, startPosition.y, startPosition.z);

    console.log("Parent object:", cameraContainer.parent);

    if (cameraContainer.parent) {
        let parentRigidBody = cameraContainer.parent.rigidBody;
        if (parentRigidBody) {
            let parentVelocity = parentRigidBody.linvel();
            console.log("Parent velocity:", parentVelocity);

            rigidBodyDesc.setLinvel(
                direction.x * speedFactor + parentVelocity.x,
                direction.y * speedFactor + parentVelocity.y,
                direction.z * speedFactor + parentVelocity.z
            );
        } else {
            console.log("Parent object has no rigidBody.");
            rigidBodyDesc.setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
        }
    } else {
        rigidBodyDesc.setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
    }

    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);

    const sphereGeometry = new THREE.SphereGeometry(radius);
    const sphereMaterial = new THREE.MeshStandardMaterial({ color: color });
    const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphereMesh.position.copy(startPosition);

    sphereMesh.name = "ball-xr";

    scene.add(sphereMesh);

    let colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
    let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);

    window.handleToObjectMap = window.handleToObjectMap || new Map();
    window.handleToObjectMap.set(collider.handle, {
        object: sphereMesh,
        name: sphereMesh.name
    });

    window.rigidBodies.push(rigidBody);
    window.threeCubes.push(sphereMesh);

    // const message = {
    //     type: "broadcastBallFromXRCamera",
    //     world_uuid: place.uuid,
    //     world_name: place.name,
    //     client_uuid: client_uuid,
    //     startPosition: startPosition,
    //     targetPosition: targetPosition
    // };

    // if (ws.readyState === WebSocket.OPEN) {
    //     ws.send(JSON.stringify(message));
    // } else {
    //     console.log('WebSocket is not open. Cannot request the model.');
    // }


    playFX("shoot1", 10);


}





/* 

            Audio 
    --------------------------------------------------------------
*/

function exportSoundOptions(soundParams) {
    const soundOptions = {
        initialFrequency: soundParams.initialFrequency,
        volume: soundParams.volume,
        duration: soundParams.duration,
        type: soundParams.type,
        fadeInPercent: soundParams.fadeInPercent,
        fadeOutPercent: soundParams.fadeOutPercent,
        filterType: soundParams.filterType,
        filterFrequency: soundParams.filterFrequency,
        filterQ: soundParams.filterQ,
        loop: soundParams.loop,
        interval: soundParams.interval
    };
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(soundOptions));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "soundOptions.json");
    document.body.appendChild(downloadAnchorNode); // required for firefox
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

function importSoundOptions() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';

    input.onchange = event => {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const importedOptions = JSON.parse(content);
            applyImportedSoundOptions(importedOptions);
        };
        reader.readAsText(file);
    };

    input.click();
}


function applyImportedSoundOptions(importedOptions) {
    if (guiInstances.has('soundEditGUI')) {
        const gui = guiInstances.get('soundEditGUI');
        if (gui && Array.isArray(gui.controllers)) { // Updated check for gui.controllers
            Object.keys(importedOptions).forEach(key => {
                if (soundParams.hasOwnProperty(key)) {
                    soundParams[key] = importedOptions[key];
                }
            });
            gui.controllers.forEach(controller => { // Updated to use gui.controllers
                if (importedOptions.hasOwnProperty(controller.property)) {
                    controller.setValue(importedOptions[controller.property]);
                }
            });
        } else {
            console.error('GUI controllers are not defined or not an array');
        }
    } else {
        console.error('Sound Edit GUI instance not found');
    }
}



let soundParams;

function initSoundEdit(guiKey) {

    const container = document.getElementById("guiHolder");

    const gui = new GUI({ width: 350, container: container });
    guiInstances.set(guiKey, gui);

    let loopIntervalId = null;

    soundParams = {
        initialFrequency: 440,
        volume: 0.5,
        duration: 1,
        type: 'sine',
        fadeInPercent: 0,
        fadeOutPercent: 0,
        filterType: 'none',
        filterFrequency: 1000,
        filterQ: 1,
        loop: false,
        interval: 1,
        play: function () {
            const soundOptions = {
                initialFrequency: soundParams.initialFrequency,
                volume: soundParams.volume,
                duration: soundParams.duration,
                type: soundParams.type,
                fadeInPercent: soundParams.fadeInPercent,
                fadeOutPercent: soundParams.fadeOutPercent,
                filterType: soundParams.filterType === 'none' ? null : soundParams.filterType,
                filterFrequency: soundParams.filterFrequency,
                filterQ: soundParams.filterQ
            };
            const position = new THREE.Vector3(0, 0, 0);
            SoundManager.playPositionalSound('blip', position, soundOptions);
        },
        toggleLoop: function() {
            if (soundParams.loop) {
                if (loopIntervalId) {
                    clearInterval(loopIntervalId);
                }
                loopIntervalId = setInterval(() => {
                    soundParams.play();
                }, soundParams.interval * 1000);
            } else {
                clearInterval(loopIntervalId);
                loopIntervalId = null;
            }
        },
        export: function() {
            exportSoundOptions(soundParams);
        },
        import: function() {
            importSoundOptions();
        }
    };

    gui.add(soundParams, 'initialFrequency', 20, 2000).name('Initial Frequency');
    gui.add(soundParams, 'volume', 0, 1).name('Volume');
    gui.add(soundParams, 'duration', 0.1, 5).name('Duration');
    gui.add(soundParams, 'type', ['sine', 'square', 'sawtooth', 'triangle']).name('Wave Type');
    gui.add(soundParams, 'fadeInPercent', 0, 100).name('Fade In (%)');
    gui.add(soundParams, 'fadeOutPercent', 0, 100).name('Fade Out (%)');
    gui.add(soundParams, 'filterType', ['none', 'lowpass', 'highpass', 'bandpass']).name('Filter Type');
    gui.add(soundParams, 'filterFrequency', 20, 20000).name('Filter Frequency');
    gui.add(soundParams, 'filterQ', 0.1, 20).name('Filter Q');
    gui.add(soundParams, 'play').name('Play Sound');
    gui.add(soundParams, 'loop').name('Loop').onChange(soundParams.toggleLoop);
    gui.add(soundParams, 'interval', 0.1, 5).name('Loop Interval (s)').onChange(() => {
        if (soundParams.loop) {
            soundParams.toggleLoop();
        }
    });
    gui.add(soundParams, 'export').name('Export Sound Options');
    gui.add(soundParams, 'import').name('Import Sound Options');

    gui.add({ close: () => toggleSoundEditGUI() }, 'close').name('CLOSE');

    makePanelDraggable(document.getElementById("guiOverlayInput"), document.getElementById("guiOverlayBar"));
}

function toggleSoundEditGUI() {
    if (guiInstances.has('soundEditGUI')) {
        guiInstances.get('soundEditGUI').destroy();
        guiInstances.delete('soundEditGUI');
        ana.track(`toggleSoundEditGUI: off`);
    } else {
        initSoundEdit('soundEditGUI');
    }
}

window.toggleSoundEditGUI = toggleSoundEditGUI;




/*

    Sound Manager

        */



const SoundManager = (function() {
    const listener = new THREE.AudioListener();
    const audioLoader = new THREE.AudioLoader();

    const sounds = {
        blip: function(options) {
            const sound = new THREE.PositionalAudio(listener);
            const audioCtx = listener.context;
            const oscillator = audioCtx.createOscillator();
            oscillator.type = options.type || 'sine';
            oscillator.frequency.setValueAtTime(options.initialFrequency || 440, audioCtx.currentTime);

            const gainNode = audioCtx.createGain();
            const volume = options.volume || 0.5;
            const duration = (options.duration || 1) * 1000; // Total duration in milliseconds
            const fadeInDuration = Math.min(duration * (options.fadeInPercent || 0) / 100, duration);
            const fadeOutDuration = Math.min(duration * (options.fadeOutPercent || 0) / 100, duration - fadeInDuration);

            // Start with 0 volume for fade-in
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime); 
            gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + fadeInDuration / 1000); // Fade-in

            if (options.filterType) {
                const filter = audioCtx.createBiquadFilter();
                filter.type = options.filterType;
                filter.frequency.setValueAtTime(options.filterFrequency || 1000, audioCtx.currentTime);
                filter.Q.value = options.filterQ || 1;
                oscillator.connect(filter);
                filter.connect(gainNode);
            } else {
                oscillator.connect(gainNode);
            }

            gainNode.connect(audioCtx.destination);
            sound.setNodeSource(gainNode);

            this.configureSound(sound, options);

            oscillator.start();

            if (fadeOutDuration > 0) {
                const fadeOutStartTime = (duration - fadeOutDuration) / 1000;
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + fadeOutStartTime);
            }

            setTimeout(() => {
                oscillator.stop();
                sound.disconnect();
            }, duration); 

            return sound;
        },

        // Other sound functions...

        configureSound: function(sound, options) {
            sound.setVolume(options.volume || 0.5);
            sound.setRefDistance(options.refDistance || 1);
            sound.setRolloffFactor(options.rolloffFactor || 1);
            sound.setDistanceModel(options.distanceModel || 'linear');
            sound.setMaxDistance(options.maxDistance || 1000);
            if (options.object3D) {
                options.object3D.add(sound);
            }
        },

        playPositionalSound: function(soundType, position, options = {}) {
            const sound = this.playSound(soundType, options);
            if (sound) {
                sound.position.copy(position);
                if (sound.context) {
                    sound.context.listener.setPosition(position.x, position.y, position.z);
                }
                sound.play();
            }
        },

        playSound: function(name, options) {
            if (sounds[name]) {
                return sounds[name].call(this, options);
            } else {
                console.error('Sound not found:', name);
            }
        },

        applySoundToObject: function(object3D, soundType, options = {}) {
            options.object3D = object3D;
            this.playSound(soundType, options);
        },

        playUISound: function(options) {
            const sound = new THREE.Audio(listener);

            audioLoader.load(options.soundFile, function(buffer) {
                sound.setBuffer(buffer);
                sound.setLoop(options.loop || false);
                sound.setVolume(options.volume || 0.5);
                sound.play();
            });

            return sound;
        },

        playGeneratedSound: function(options) {
            const audioCtx = listener.context;
            const oscillator = audioCtx.createOscillator();
            oscillator.type = options.type || 'sine';
            oscillator.frequency.setValueAtTime(options.frequency || 440, audioCtx.currentTime); // Frequency in Hz

            const gainNode = audioCtx.createGain();
            const volume = options.volume || 0.5;

            const duration = options.duration || 1000; // Total duration in milliseconds
            const fadeInDuration = Math.min(duration * (options.fadeInPercent || 0) / 100, duration);
            const fadeOutDuration = Math.min(duration * (options.fadeOutPercent || 0) / 100, duration - fadeInDuration);

            gainNode.gain.setValueAtTime(0, audioCtx.currentTime); // Start with 0 volume for fade-in
            gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + fadeInDuration / 1000); // Fade-in

            if (options.filterType) {
                const filter = audioCtx.createBiquadFilter();
                filter.type = options.filterType;
                filter.frequency.setValueAtTime(options.filterFrequency || 1000, audioCtx.currentTime);
                filter.Q.value = options.filterQ || 1;
                oscillator.connect(filter);
                filter.connect(gainNode);
            } else {
                oscillator.connect(gainNode);
            }

            gainNode.connect(audioCtx.destination);

            oscillator.start();

            if (fadeOutDuration > 0) {
                const fadeOutStartTime = (duration - fadeOutDuration) / 1000;
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + fadeOutStartTime);
            }

            setTimeout(() => {
                oscillator.stop();
            }, duration); // Duration in milliseconds

            return oscillator;
        }
    };

    return {
        listener: listener,

        playSound: function(name, options) {
            if (sounds[name]) {
                return sounds[name].call(this, options);
            } else {
                console.error('Sound not found:', name);
            }
        },

        applySoundToObject: function(object3D, soundType, options = {}) {
            options.object3D = object3D;
            this.playSound(soundType, options);
        },

        playUISound: function(options) {
            return sounds.playUISound(options);
        },

        playGeneratedSound: function(options) {
            return sounds.playGeneratedSound(options);
        },

        playPositionalSound: function(soundType, position, options = {}) {
            return sounds.playPositionalSound(soundType, position, options);
        }
    };
})();





function fxPip({
    frequency = 100,
    volume = 0.25,
    duration = 1000,
    type = 'sine',
    fadeInPercent = 0,
    fadeOutPercent = 0,
    filterType = null,
    filterFrequency = 1000
} = {}) {
    SoundManager.playGeneratedSound({
        type: type,
        frequency: frequency,
        volume: volume,
        duration: duration,
        fadeInPercent: fadeInPercent,
        fadeOutPercent: fadeOutPercent,
        filterType: filterType,
        filterFrequency: filterFrequency
    });
}

window.fxPip = fxPip;



const soundPresets = {

    "shoot0": {
        "initialFrequency": 20,
        "volume": 0.5,
        "duration": 0.1029,
        "type": "triangle",
        "fadeInPercent": 3.1,
        "fadeOutPercent": 35.3,
        "filterType": "lowpass",
        "filterFrequency": 779.22,
        "filterQ": 15.3429,
        "loop": true,
        "interval": 0.1029
    },

    "shoot1": {
        "initialFrequency": 20,
        "volume": 0.259,
        "duration": 0.1323,
        "type": "square",
        "fadeInPercent": 0.1,
        "fadeOutPercent": 20.1,
        "filterType": "highpass",
        "filterFrequency": 739.26,
        "filterQ": 13.5718,
        "loop": true,
        "interval": 0.392
    },

    "message-in": {
        "initialFrequency": 615.78,
        "volume": 0.389,
        "duration": 0.3038,
        "type": "square",
        "fadeInPercent": 18.3,
        "fadeOutPercent": 28.3,
        "filterType": "bandpass",
        "filterFrequency": 3556.44,
        "filterQ": 1.5124,
        "loop": false,
        "interval": 0.3038
    },

    "message-out": {
        "initialFrequency": 415.78,
        "volume": 0.389,
        "duration": 0.3038,
        "type": "square",
        "fadeInPercent": 34.3,
        "fadeOutPercent": 8.3,
        "filterType": "bandpass",
        "filterFrequency": 3556.44,
        "filterQ": 1.5124,
        "loop": false,
        "interval": 0.3038
    },

    "plain": {
        "initialFrequency": 440,
        "volume": 0.5,
        "duration": 0.1911,
        "type": "sine",
        "fadeInPercent": 1.3,
        "fadeOutPercent": 16,
        "filterType": "none",
        "filterFrequency": 1000,
        "filterQ": 1,
        "loop": false,
        "interval": 1
    }

};

function playFX(presetName, seed = 0) {
    const preset = soundPresets[presetName];
    if (preset) {

        const randomFactor = Math.random()*seed - Math.random()*seed;
        // Use the seed to modify frequency and other parameters if needed
        //const randomFactor = seed !== 0 ? (Math.sin(seed) * 0.5 + 0.5) : 1; // Generate a deterministic random factor based on the seed

        fxPip({
            frequency: preset.initialFrequency + randomFactor,
            volume: preset.volume,
            duration: preset.duration * 1000, // Convert to milliseconds if needed
            type: preset.type,
            fadeInPercent: preset.fadeInPercent,
            fadeOutPercent: preset.fadeOutPercent,
            filterType: preset.filterType,
            filterFrequency: preset.filterFrequency // Apply randomness
        });
    } else {
        console.error(`Preset "${presetName}" not found.`);
    }
}


window.playFX = playFX;







/* 

    Restore Camera
    ----------------------------------------------- 

    */

let controlsUpdateAllow = true;
let cameraAnimated = false;
let cameraPositions = [];


function controlsUpdate() {
    if(controlsUpdateAllow) {
        controls.update()
    }
}
window.controlsUpdateAllow = controlsUpdateAllow;


function restoreCameraPosition() {
     let camData;
    if (localStorage.getItem("cameraPositions")) {
            let data = JSON.parse(localStorage.getItem("cameraPositions"));
            console.log("restoreCameraPosition",data)
            camData = data[data.length - 1];
            camera.position.copy(new THREE.Vector3().copy(camData.camera.position));
            camera.rotation.set(camData.camera.rotation.x, camData.camera.rotation.y, camData.camera.rotation.z);
            if (controls) {
                controls.target.copy(new THREE.Vector3().copy(camData.controls.target));
            }
            console.log("-- 2. Setting camera from localStorage data:", camData);
    }
    controlsUpdate();
}


function saveCameraPosition() {

    if (cameraAnimated) return;
    console.log("saveCameraPosition");

    const cameraData = {
        position: camera.position.clone(),
        rotation: camera.rotation.clone(),
    };
    const controlsData = { target: controls.target.clone() };

    console.log("controlsData:", controlsData);

    // Store data in localStorage
    localStorage.setItem("cameraData", JSON.stringify(cameraData));
    localStorage.setItem("controlsData", JSON.stringify(controlsData));
    cameraPositions.push({ camera: cameraData, controls: controlsData });
    localStorage.setItem("cameraPositions", JSON.stringify(cameraPositions));

}



/* 

    Zesty
    ----------------------------------------------- 

    */


function addBanners() {

    const zestyBanner = new ZestyBanner("e1876a74-b9f2-4768-93a2-db7da6a3ab79", "medium-rectangle", 3, null, true);
    scene.add(zestyBanner);


    // const zestyBanner = new ZestyBanner("0", "billboard", 3, null, true);
    // scene.add(zestyBanner);

}

window.addBanners = addBanners;





/* 

    Init Scene
    ----------------------------------------------- 

    */



function addLight() {



    // Lights
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5);
    scene.add(light);


}






function setupControls() {


    // ORBIT CONTROLS

    let isOrbitControlActive = false
    let lastInteractionTime = Date.now();
    const orbitControlDeactivationDelay = 300; 

    const controls = new OrbitControls(camera, container);

    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    controls.minPolarAngle = 0;
    //controls.autoRotate = false;

    //controls.maxPolarAngle = Math.PI / 2.1; // This is already the default, means camera can't go more than 90 degrees.
    controls.minDistance = 0.25; // The closest the camera can get to the target
    controls.maxDistance = 1274210; // The farthest the camera can be from the target

        // ---
        controls.maxPolarAngle = Math.PI / 1.99; // This is already the default, means camera can't go more than 90 degrees.        
        
        // controls.minDistance = 0.5; // The closest the camera can get to the target
        // controls.maxDistance = 150; // The farthest the camera can be from the target

    function debounce(func, wait) {
        let timeout;
        return function (...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), wait);
        };
    }

    const debouncedSave = debounce(saveCameraPosition, 300); // 300ms delay

    controls.addEventListener("end", () => {
        setTimeout(() => {
            
        }, orbitControlDeactivationDelay);
        isOrbitControlActive = false;

        debouncedSave();
    });

    controls.addEventListener("change", () => {

        //controls.needsUpdate = true;

        //updateControls();  // Call updateControls on each change
        
        debouncedSave();   // Debounced call to save the camera position

        // Other updates...
        // updateDummyAvatar();
        updateRigidBodies();
    });

    window.controls = controls;


    // XR Button - if yo uwant to test mixed reality
    // document.body.appendChild( XRButton.createButton( renderer, {
    //     'optionalFeatures': [ 'depth-sensing' ],
    //     'depthSensing': { 'usagePreference': [ 'gpu-optimized' ], 'dataFormatPreference': [] }
    // } ) ); 


}



function initScene() {


    scene = new THREE.Scene();
    // solid background color
    // you can add background from addEnvMap() 
    
    scene.background = new THREE.Color( 0x505050 );

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    
    //renderer.setClearColor(0x000000, 0); // Transparent background

    container.appendChild(renderer.domElement);      


    addLight();

    setupControls();

    setupCustomVRButton(); 


}



/*


    Duster
    ------------------------------------------------

    */


// const dustCount = 256 * 2;
// const dustSpeedY = 0.02;
// const dustSpeedX = 0.01;
// const dustSpeedZ = 0.03;
// const dustSizeFac = 4;
// const dustTopFloor = 10;
// const dustFloor = -10;
// const dustArea = 20;
// let dusts = [];

// function createGeometry(size) {
//   const geometries = [
//     new THREE.BoxGeometry(size.x, size.y, size.z),
//     new THREE.CircleGeometry(size.x, 6),
//     new THREE.ConeGeometry(size.x, size.y * 2, 6),
//     new THREE.TetrahedronGeometry(size.x),
//     new THREE.RingGeometry(size.x / 2, size.x, 6)
//   ];
//   return geometries[Math.floor(Math.random() * geometries.length)];
// }

// function initDuster() {
//   for (let i = 0; i < dustCount; i++) {
//     let randomSize = { x: Math.random() * 0.025 * dustSizeFac, y: Math.random() * 0.025 * dustSizeFac, z: Math.random() * 0.01 * dustSizeFac };
//     const geometry = createGeometry(randomSize);
//     const material = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
//     const dust = new THREE.InstancedMesh(geometry, material, 1024);
//     dust.position.set((Math.random() - 0.5) * dustArea, (Math.random() - 0.5) * (dustTopFloor - dustFloor) + dustFloor, (Math.random() - 0.5) * dustArea);
//     dust.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
//     scene.add(dust);
//     dusts.push(dust);
//   }
// }

// window.initDuster = initDuster;

// let dusterActive = false;

// function toggleDuster() {
//   dusterActive = !dusterActive;
//   if (dusterActive) {
//     initDuster();
//   } else {
//     removeDuster();
//   }
// }

// function removeDuster() {
//   dusts.forEach(dust => scene.remove(dust));
//   dusts = [];
// }

// function updateDuster() {
//   dusts.forEach(dust => {
//     dust.position.y += dustSpeedY;
//     dust.position.x += dustSpeedX;
//     dust.position.z += dustSpeedZ;
//     dust.rotation.x += 0.01;
//     dust.rotation.y += 0.001;
//     if (dust.position.y > dustTopFloor) {
//       dust.position.set((Math.random() - 0.5) * dustArea, dustFloor, (Math.random() - 0.5) * dustArea);
//     }
//   });
// }


// const dustParams = {
//     dustCount: 256 * 2,
//     dustSpeedY: 0.02,
//     dustSpeedX: 0.01,
//     dustSpeedZ: 0.03,
//     dustSizeFac: 4,
//     dustTopFloor: 10,
//     dustFloor: -10,
//     dustArea: 20
// };
// let dusts = [];

// function createGeometry(size) {
//   const geometries = [
//     new THREE.BoxGeometry(size.x, size.y, size.z),
//     new THREE.CircleGeometry(size.x, 6),
//     new THREE.ConeGeometry(size.x, size.y * 2, 6),
//     new THREE.TetrahedronGeometry(size.x),
//     new THREE.RingGeometry(size.x / 2, size.x, 6)
//   ];
//   return geometries[Math.floor(Math.random() * geometries.length)];
// }

// function initDuster() {
//   for (let i = 0; i < dustParams.dustCount; i++) {
//     let randomSize = { x: Math.random() * 0.025 * dustParams.dustSizeFac, y: Math.random() * 0.025 * dustParams.dustSizeFac, z: Math.random() * 0.01 * dustParams.dustSizeFac };
//     const geometry = createGeometry(randomSize);
//     const material = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
//     const dust = new THREE.InstancedMesh(geometry, material, 1024);
//     dust.position.set((Math.random() - 0.5) * dustParams.dustArea, (Math.random() - 0.5) * (dustParams.dustTopFloor - dustParams.dustFloor) + dustParams.dustFloor, (Math.random() - 0.5) * dustParams.dustArea);
//     dust.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
//     scene.add(dust);
//     dusts.push(dust);
//   }
// }

// function exportDustOptions(dustParams) {
//     const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dustParams));
//     const downloadAnchorNode = document.createElement('a');
//     downloadAnchorNode.setAttribute("href", dataStr);
//     downloadAnchorNode.setAttribute("download", "dustOptions.json");
//     document.body.appendChild(downloadAnchorNode);
//     downloadAnchorNode.click();
//     downloadAnchorNode.remove();
// }

// function importDustOptions() {
//     const input = document.createElement('input');
//     input.type = 'file';
//     input.accept = '.json';

//     input.onchange = event => {
//         const file = event.target.files[0];
//         const reader = new FileReader();
//         reader.onload = function(e) {
//             const content = e.target.result;
//             const importedOptions = JSON.parse(content);
//             applyImportedDustOptions(importedOptions);
//         };
//         reader.readAsText(file);
//     };

//     input.click();
// }

// function applyImportedDustOptions(importedOptions) {
//     Object.keys(importedOptions).forEach(key => {
//         if (dustParams.hasOwnProperty(key)) {
//             dustParams[key] = importedOptions[key];
//         }
//     });
//     gui.controllers.forEach(controller => {
//         if (importedOptions.hasOwnProperty(controller.property)) {
//             controller.setValue(importedOptions[controller.property]);
//         }
//     });
// }

// function initDustEdit(guiKey) {
//     const container = document.getElementById("guiHolder");
//     const gui = new GUI({ width: 350, container: container });
//     guiInstances.set(guiKey, gui);

//     gui.add(dustParams, 'dustCount', 256, 512).name('Dust Count');
//     gui.add(dustParams, 'dustSpeedY', 0.01, 0.1).name('Dust Speed Y');
//     gui.add(dustParams, 'dustSpeedX', 0.01, 0.1).name('Dust Speed X');
//     gui.add(dustParams, 'dustSpeedZ', 0.01, 0.1).name('Dust Speed Z');
//     gui.add(dustParams, 'dustSizeFac', 1, 10).name('Dust Size Factor');
//     gui.add(dustParams, 'dustTopFloor', 1, 10).name('Dust Top Floor');
//     gui.add(dustParams, 'dustFloor', -10, 0).name('Dust Floor');
//     gui.add(dustParams, 'dustArea', 10, 100).name('Dust Area');
//     gui.add({ createDuster: () => initDuster() }, 'createDuster').name('Create Duster');
//     gui.add({ export: () => exportDustOptions(dustParams) }, 'export').name('Export Dust Options');
//     gui.add({ import: () => importDustOptions() }, 'import').name('Import Dust Options');
//     gui.add({ close: () => toggleDustEditGUI() }, 'close').name('CLOSE');

//     makePanelDraggable(document.getElementById("guiOverlayInput"), document.getElementById("guiOverlayBar"));
// }

// function toggleDustEditGUI() {
//     if (guiInstances.has('dustEditGUI')) {
//         guiInstances.get('dustEditGUI').destroy();
//         guiInstances.delete('dustEditGUI');
//     } else {
//         initDustEdit('dustEditGUI');
//     }
// }

// window.toggleDustEditGUI = toggleDustEditGUI;

// let dusterActive = false;

// function toggleDuster() {
//     dusterActive = !dusterActive;
//     if (dusterActive) {
//         initDuster();
//     } else {
//         removeDuster();
//     }
// }

// function removeDuster() {
//     dusts.forEach(dust => scene.remove(dust));
//     dusts = [];
// }

// function updateDuster() {
//     dusts.forEach(dust => {
//         dust.position.y += dustParams.dustSpeedY;
//         dust.position.x += dustParams.dustSpeedX;
//         dust.position.z += dustParams.dustSpeedZ;
//         dust.rotation.x += 0.01;
//         dust.rotation.y += 0.001;
//         if (dust.position.y > dustParams.dustTopFloor) {
//             dust.position.set((Math.random() - 0.5) * dustParams.dustArea, dustParams.dustFloor, (Math.random() - 0.5) * dustParams.dustArea);
//         }
//     });
// }




/* 

    Dusters - GUI
    ----------------------------------------------- 

    */



const dustersMap = new Map();
const storedDusters = [];
const dustParams = {
    dustCount: 256 * 2,
    dustSpeedY: 0.02,
    dustSpeedX: 0.01,
    dustSpeedZ: 0.03,
    dustSizeFac: 4,
    dustTopFloor: 10,
    dustFloor: -10,
    dustArea: 20
};

function createGeometry(size) {
    const geometries = [
        new THREE.BoxGeometry(size.x, size.y, size.z),
        new THREE.CircleGeometry(size.x, 6),
        new THREE.ConeGeometry(size.x, size.y * 2, 6),
        new THREE.TetrahedronGeometry(size.x),
        new THREE.RingGeometry(size.x / 2, size.x, 6)
    ];
    return geometries[Math.floor(Math.random() * geometries.length)];
}

function initDuster(id, params, addToScene = true) {
    const duster = {
        id,
        params,
        dusts: [],
        isActive: false,
        init() {
            for (let i = 0; i < this.params.dustCount; i++) {
                let randomSize = { x: Math.random() * 0.025 * this.params.dustSizeFac, y: Math.random() * 0.025 * this.params.dustSizeFac, z: Math.random() * 0.01 * this.params.dustSizeFac };
                const geometry = createGeometry(randomSize);
                const material = new THREE.MeshBasicMaterial({ color: 0x000000, side: THREE.DoubleSide });
                const dust = new THREE.InstancedMesh(geometry, material, 1024);
                dust.position.set((Math.random() - 0.5) * this.params.dustArea, (Math.random() - 0.5) * (this.params.dustTopFloor - this.params.dustFloor) + this.params.dustFloor, (Math.random() - 0.5) * this.params.dustArea);
                dust.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI);
                if (addToScene) {
                    scene.add(dust);
                }
                this.dusts.push(dust);
            }
        },
        update() {
            if (!this.isActive) return;
            this.dusts.forEach(dust => {
                dust.position.y += this.params.dustSpeedY;
                dust.position.x += this.params.dustSpeedX;
                dust.position.z += this.params.dustSpeedZ;
                dust.rotation.x += 0.01;
                dust.rotation.y += 0.001;
                if (dust.position.y > this.params.dustTopFloor) {
                    dust.position.set((Math.random() - 0.5) * this.params.dustArea, this.params.dustFloor, (Math.random() - 0.5) * this.params.dustArea);
                }
            });
        },
        remove() {
            this.dusts.forEach(dust => scene.remove(dust));
            this.dusts = [];
        },
        start() {
            this.isActive = true;
        },
        pause() {
            this.isActive = false;
        },
        restart() {
            this.remove();
            this.init();
            this.start();
        }
    };
    duster.init();
    dustersMap.set(id, duster);
    return duster;
}

function exportDustOptions(dustParams) {
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(dustParams));
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", "dustOptions.json");
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

function importDustOptions(duster) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';

    input.onchange = event => {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function(e) {
            const content = e.target.result;
            const importedOptions = JSON.parse(content);
            duster.params = importedOptions;
            duster.remove();
            duster.init();
        };
        reader.readAsText(file);
    };

    input.click();
}

function createDusterFromImport(importedOptions) {
    const dusterId = `duster-${Math.random().toString(36).substr(2, 9)}`;
    const duster = initDuster(dusterId, importedOptions, true);
    storedDusters.push({ id: dusterId, params: importedOptions });
    const gui = guiInstances.get('dustEditGUI');
    if (gui) {
        createDusterFolder(gui, dusterId, duster);
    }
}

function createDusterFolder(gui, dusterId, duster) {
    const folder = gui.addFolder(`Duster ${dusterId}`);
    folder.add(duster.params, 'dustCount', 1, 512).name('Dust Count').onChange(value => { duster.params.dustCount = value; duster.remove(); duster.init(); });
    folder.add(duster.params, 'dustSpeedY', 0.001, 0.5).name('Dust Speed Y').onChange(value => duster.params.dustSpeedY = value);
    folder.add(duster.params, 'dustSpeedX', 0.001, 0.5).name('Dust Speed X').onChange(value => duster.params.dustSpeedX = value);
    folder.add(duster.params, 'dustSpeedZ', 0.001, 0.5).name('Dust Speed Z').onChange(value => duster.params.dustSpeedZ = value);
    folder.add(duster.params, 'dustSizeFac', 0.1, 60).name('Dust Size Factor').onChange(value => { duster.params.dustSizeFac = value; duster.remove(); duster.init(); });
    folder.add(duster.params, 'dustTopFloor', 1, 30).name('Dust Top Floor').onChange(value => duster.params.dustTopFloor = value);
    folder.add(duster.params, 'dustFloor', -30, 0).name('Dust Floor').onChange(value => duster.params.dustFloor = value);
    folder.add(duster.params, 'dustArea', 1, 100).name('Dust Area').onChange(value => duster.params.dustArea = value);
    folder.add({ start: () => duster.start() }, 'start').name('Start');
    folder.add({ pause: () => duster.pause() }, 'pause').name('Pause');
    folder.add({ restart: () => duster.restart() }, 'restart').name('Restart');
    folder.add({ exportOptions: () => exportDustOptions(duster.params) }, 'exportOptions').name('Export Duster Options');
    folder.add({ importOptions: () => importDustOptions(duster) }, 'importOptions').name('Import Duster Options');
    folder.add({ removeDuster: () => { duster.remove(); dustersMap.delete(dusterId); storedDusters.splice(storedDusters.findIndex(d => d.id === dusterId), 1); folder.destroy(); } }, 'removeDuster').name('Remove Duster');
}

function initDustEdit(guiKey) {
    const container = document.getElementById("guiHolder");
    const gui = new GUI({ width: 350, container: container });
    guiInstances.set(guiKey, gui);

    gui.add({ createDuster: () => createDuster() }, 'createDuster').name('Create Duster');
    gui.add({ exportDusters }, 'exportDusters').name('Export All Dusters');
    gui.add({ importDusters }, 'importDusters').name('Import All Dusters');
    gui.add({ startAllDusters }, 'startAllDusters').name('Start All Dusters');
    gui.add({ stopAllDusters }, 'stopAllDusters').name('Stop All Dusters');
    gui.add({ removeAllDusters }, 'removeAllDusters').name('Remove All Dusters');
    gui.add({ close: () => toggleDustEditGUI() }, 'close').name('CLOSE');

    storedDusters.forEach(dusterData => {
        const duster = dustersMap.get(dusterData.id) || initDuster(dusterData.id, dusterData.params, true);
        createDusterFolder(gui, dusterData.id, duster);
    });

    makePanelDraggable(document.getElementById("guiOverlayInput"), document.getElementById("guiOverlayBar"));
}

function toggleDustEditGUI() {
    if (guiInstances.has('dustEditGUI')) {
        guiInstances.get('dustEditGUI').destroy();
        guiInstances.delete('dustEditGUI');
    } else {
        initDustEdit('dustEditGUI');
    }
}

function createDuster() {
    const gui = guiInstances.get('dustEditGUI');
    if (!gui) {
        console.error('GUI instance not found');
        return;
    }
    const dusterId = `duster-${Math.random().toString(36).substr(2, 9)}`;
    const duster = initDuster(dusterId, { ...dustParams });
    storedDusters.push({ id: dusterId, params: { ...dustParams } });
    createDusterFolder(gui, dusterId, duster);
}

function updateDusters() {
    dustersMap.forEach(duster => duster.update());
}

function exportDusters() {
    const updatedStoredDusters = Array.from(dustersMap.values()).map(duster => ({
        id: duster.id,
        params: duster.params
    }));
    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(updatedStoredDusters));
    const now = new Date().toISOString().replace(/[:.]/g, '-');
    const downloadAnchorNode = document.createElement('a');
    downloadAnchorNode.setAttribute("href", dataStr);
    downloadAnchorNode.setAttribute("download", `dusters_${now}.json`);
    document.body.appendChild(downloadAnchorNode);
    downloadAnchorNode.click();
    downloadAnchorNode.remove();
}

function importDusters() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = e => {
        const file = e.target.files[0];
        const reader = new FileReader();
        reader.onload = event => {
            const importedDusters = JSON.parse(event.target.result);
            importedDusters.forEach(params => {
                const duster = initDuster(params.id, params.params, true);
                storedDusters.push({ id: params.id, params: params.params });
            });
            const gui = guiInstances.get('dustEditGUI');
            if (gui) {
                gui.destroy();
                initDustEdit('dustEditGUI');
            }
        };
        reader.readAsText(file);
    };
    input.click();
}

function triggerDustersArrayById(ids, action) {
    ids.forEach(id => {
        triggerDusterById(id, action);
    });
}

function triggerDusterById(id, action) {
    const duster = dustersMap.get(id);
    if (!duster) return;
    switch(action) {
        case 'start': duster.start(); break;
        case 'pause': duster.pause(); break;
        case 'restart': duster.restart(); break;
        case 'remove': {
            duster.remove();
            dustersMap.delete(id);
            storedDusters.splice(storedDusters.findIndex(d => d.id === id), 1);
            if (guiInstances.has('dustEditGUI')) {
                const gui = guiInstances.get('dustEditGUI');
                const folder = gui.folders.find(f => f._title === `Duster ${id}`);
                if (folder) {
                    folder.destroy();
                }
            }
            break;
        }
    }
}

function startAllDusters() {
    dustersMap.forEach(duster => duster.start());
}

function stopAllDusters() {
    dustersMap.forEach(duster => duster.pause());
}

function removeAllDusters() {
    dustersMap.forEach((duster, id) => {
        duster.remove();
        dustersMap.delete(id);
    });
    storedDusters.length = 0;
    if (guiInstances.has('dustEditGUI')) {
        const gui = guiInstances.get('dustEditGUI');
        gui.foldersRecursive().forEach(folder => folder.destroy());
    }
}

function loadDusters(url) {
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (Array.isArray(data)) {
                data.forEach(dusterData => {
                    if (typeof dusterData === 'object' && dusterData !== null) {
                        initDuster(dusterData.id, dusterData.params, true);
                        storedDusters.push(dusterData);
                    } else {
                        console.error('Invalid duster data format');
                    }
                });
            } else {
                console.error('Invalid dusters data format');
            }
        })
        .catch(error => console.error('Error loading dusters:', error));
}

function loadSingleDuster(url) {
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (typeof data === 'object' && data !== null) {
                initDuster(data.id, data.params, true);
                storedDusters.push(data);
            } else {
                console.error('Invalid duster data format');
            }
        })
        .catch(error => console.error('Error loading duster:', error));
}

function loadDustersFromJSONString(jsonString) {
    try {
        const data = JSON.parse(jsonString);
        if (Array.isArray(data)) {
            data.forEach(dusterData => {
                if (typeof dusterData === 'object' && dusterData !== null) {
                    initDuster(dusterData.id, dusterData.params, true);
                    storedDusters.push(dusterData);
                } else {
                    console.error('Invalid duster data format');
                }
            });
        } else {
            console.error('Invalid dusters data format');
        }
    } catch (error) {
        console.error('Error parsing dusters JSON:', error);
    }
}

function listDusterIds() {
    return Array.from(dustersMap.keys());
}

window.listDusterIds = listDusterIds;
window.toggleDustEditGUI = toggleDustEditGUI;
window.initDustEdit = initDustEdit;
window.exportDusters = exportDusters;
window.importDusters = importDusters;
window.triggerDustersArrayById = triggerDustersArrayById;
window.triggerDusterById = triggerDusterById;
window.startAllDusters = startAllDusters;
window.stopAllDusters = stopAllDusters;
window.removeAllDusters = removeAllDusters;
window.loadDusters = loadDusters;
window.loadSingleDuster = loadSingleDuster;
window.loadDustersFromJSONString = loadDustersFromJSONString;












/* 

    Helpers
    ----------------------------------------------- 

    */


function addHelpers() {

    let visible = true;

    const helperLayer = new THREE.Layers();
    helperLayer.set(1); // Set to layer 1, different from the default layer 0

    // GridHelper
    const size = 500;
    const divisions = 20;
    const gridHelper = new THREE.GridHelper(size, divisions, 0x333333, 0xFFFFFF00);
    gridHelper.name = "gridHelper"
    gridHelper.layers.enable(1); // Assign to layer 1
    gridHelper.ignore = true
    gridHelper.position.set(0,-0.01,0)
    gridHelper.visible = visible;
    
    scene.add(gridHelper);

    // Create an AxesHelper
    const axesHelper = new THREE.AxesHelper(100); // 5 is the size of the axes
    axesHelper.ignore = true;
    axesHelper.name = "axesHelper";
    axesHelper.visible = visible;

    scene.add(axesHelper);

}



/*

    Add Background Gradient


    */


let placeJSON = `

{"name":"Lights","uuid":"dfc69d72-e71a-4077-8c04-1d3f21fe3ba8","created":"2024-02-21T20:22:59.627238","ts":"1708546979627","updated":"2024-03-20T13:27:51.273229","updated_ts":"1710941271273","owner":"9f009ae9-2b80-42a8-aaa6-df4647aeea3c","type":"public","visible":"true","data":{"description":"Lights","entrance":{"cameraData":{"position":{"x":2.374200000000002,"y":1.7888610000000011,"z":-11.091581},"rotation":{"isEuler":true,"_x":-1.8924195448902037,"_y":1.1524113932477926,"_z":1.920456752422363,"_order":"XYZ"}},"controlsData":{"target":{"x":0.089834,"y":0.82523,"z":-10.770507}}},"gravity":{"x":0,"y":-1,"z":0},"ground":"d6c0531c-33ff-4130-85c5-9826d5072461","metadata":"","sky":{"colors":[{"hex":"ff0000","position":0},{"hex":"000000","position":1}]},"splash":"/","environment":{"hdr":"","i":1,"b":0,"state":"OFF"},"lights":[{"type":"AmbientLight","color":"#ff7c7c","intensity":0.847,"name":"AmbientLight-1708548295776","castShadow":false},{"type":"DirectionalLight","color":"#5afff8","intensity":2.09,"name":"DirectionalLight-1708552002581","castShadow":false,"position":{"x":5,"y":5,"z":5},"targetPosition":{"x":0,"y":0,"z":0}},{"type":"HemisphereLight","color":"#eefffa","intensity":5,"name":"HemisphereLight-1708552068357","castShadow":false,"skyColor":"#eefffa","groundColor":"#000001","position":{"x":0,"y":1,"z":0}},{"type":"PointLight","color":"#f7ff00","intensity":1,"name":"PointLight-1708552139090","castShadow":false,"position":{"x":0,"y":2,"z":0},"power":12.566370614359172},{"type":"SpotLight","color":"#ffffff","intensity":1500,"name":"SpotLight-1708552213870","castShadow":false,"position":{"x":0,"y":-1.1,"z":0},"targetPosition":{"x":0,"y":0,"z":0},"angle":1.0471975511965976,"penumbra":0,"decay":2,"distance":0,"power":4712.38898038469}],"fog":{"color":"#ffffff","near":4.752,"far":100},"avatar":"/static/models/avatars/XX2.glb"}}`;

let place = JSON.parse(placeJSON)







let worldColors, worldGradientMaterial;

function addGradientBackground() {
    console.log("addGradientBackground");
    let sphereGeometry = new THREE.SphereGeometry(500, 120, 80);
    sphereGeometry.scale(-1, 1, 1);
    const vertexShader = `
        varying vec3 vPosition;
        void main() {
            vPosition = position;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    worldColors = [
        { color: new THREE.Color(0xffffff), position: 0.0 },
        { color: new THREE.Color(0x86d100), position: 0.4 },
        { color: new THREE.Color(0x334455), position: 0.5 },
        { color: new THREE.Color(0xff0000), position: 0.9 },
        { color: new THREE.Color(0xffffff), position: 1.0 }
    ];

    const gradientColors = worldColors.map(wc => wc.color);
    const gradientPositions = worldColors.map(wc => wc.position);

    const fragmentShader = `
        precision highp float;
        uniform float rainbowTime;
        uniform vec3 gradientColors[${worldColors.length}];
        uniform float gradientPositions[${worldColors.length}];
        varying vec3 vPosition;

        vec4 permute(vec4 x) {
            return mod(((x * 34.0) + 1.0) * x, 289.0);
        }

        vec3 fade(vec3 t) {
            return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
        }

        float noise(vec3 P) {
            vec3 Pi = mod(floor(P), 289.0);
            vec3 Pf = fract(P);
            vec4 ix = vec4(Pi.x, Pi.x + 1.0, Pi.x, Pi.x + 1.0);
            vec4 iy = vec4(Pi.y, Pi.y, Pi.y + 1.0, Pi.y + 1.0);
            vec4 iz0 = vec4(Pi.z);
            vec4 iz1 = vec4(Pi.z + 1.0);

            vec4 ixy = permute(permute(ix) + iy);
            vec4 ixy0 = permute(ixy + iz0);
            vec4 ixy1 = permute(ixy + iz1);

            vec4 gx0 = ixy0 / 7.0;
            vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
            gx0 = fract(gx0);
            vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
            vec4 sz0 = step(gz0, vec4(0.0));
            gx0 -= sz0 * (step(0.0, gx0) - 0.5);
            gy0 -= sz0 * (step(0.0, gy0) - 0.5);

            vec4 gx1 = ixy1 / 7.0;
            vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
            gx1 = fract(gx1);
            vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
            vec4 sz1 = step(gz1, vec4(0.0));
            gx1 -= sz1 * (step(0.0, gx1) - 0.5);
            gy1 -= sz1 * (step(0.0, gy1) - 0.5);

            vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);
            vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);
            vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);
            vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);
            vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);
            vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);
            vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);
            vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);

            vec4 norm0 = inversesqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
            g000 *= norm0.x;
            g010 *= norm0.y;
            g100 *= norm0.z;
            g110 *= norm0.w;
            vec4 norm1 = inversesqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
            g001 *= norm1.x;
            g011 *= norm1.y;
            g101 *= norm1.z;
            g111 *= norm1.w;

            float n000 = dot(g000, Pf);
            float n100 = dot(g100, Pf + vec3(-1.0, 0.0, 0.0));
            float n010 = dot(g010, Pf + vec3(0.0, -1.0, 0.0));
            float n110 = dot(g110, Pf + vec3(-1.0, -1.0, 0.0));
            float n001 = dot(g001, Pf + vec3(0.0, 0.0, -1.0));
            float n101 = dot(g101, Pf + vec3(-1.0, 0.0, -1.0));
            float n011 = dot(g011, Pf + vec3(0.0, -1.0, -1.0));
            float n111 = dot(g111, Pf + vec3(-1.0, -1.0, -1.0));

            vec3 fade_xyz = fade(Pf);
            vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
            vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
            float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
            return 2.2 * n_xyz;
        }

        vec3 getGradientColor(float position) {
            position = 1.0 - position;
            for (int i = 0; i < ${worldColors.length - 1}; i++) {
                if (position < gradientPositions[i + 1]) {
                    float mixFactor = (position - gradientPositions[i]) / (gradientPositions[i + 1] - gradientPositions[i]);
                    return mix(gradientColors[i], gradientColors[i + 1], mixFactor);
                }
            }
            return gradientColors[${worldColors.length - 1}];
        }

        void main() {
            float t = rainbowTime;
            vec3 P = normalize(vPosition);
            float theta = atan(P.z, P.x);
            float phi = acos(P.y);

            // multiplication
            vec2 sphericalUV = vec2(theta / (0.1 * 3.14159265), phi / 3.14159265);

            float position = mod(sphericalUV.y + t * 0.9, 1.0);
            vec3 gradientColor = getGradientColor(position);
            vec3 noisePos = vec3(sphericalUV * 0.1, t); // Reduced scaling noise coordinates
            float noiseValue = noise(noisePos);
            vec3 color = mix(gradientColor, vec3(noiseValue), 0.3); // Reduced blend factor
            gl_FragColor = vec4(color, 1.0);
        }
    `;



    worldGradientMaterial = new THREE.ShaderMaterial({
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
        uniforms: {
            rainbowTime: { value: 0 },
            gradientColors: { value: gradientColors },
            gradientPositions: { value: gradientPositions }
        }
    });

    let sphere = new THREE.Mesh(sphereGeometry, worldGradientMaterial);
    sphere.name = "GradientBackgroundSphere";
    scene.add(sphere);

    if (place.data.sky.rotation) {
        sphere.rotation.set(place.data.sky.rotation.x, place.data.sky.rotation.y, place.data.sky.rotation.z);
    } else {
        sphere.rotation.x = Math.PI / 2;
    }

    sphere.ignore = true;
}

function updateGradientBackground(deltaTime) {
    if (worldGradientMaterial) {
        worldGradientMaterial.uniforms.rainbowTime.value += deltaTime * 0.05;
    }
}

window.addGradientBackground = addGradientBackground;
window.updateGradientBackground = updateGradientBackground;





// let worldColors, worldGradientMaterial;

// function addGradientBackground() {
//     console.log("addGradientBackground");
//     let sphereGeometry = new THREE.SphereGeometry(500, 120, 80);
//     sphereGeometry.scale(-1, 1, 1);
//     const vertexShader = `
//         varying vec3 vPosition;
//         void main() {
//             vPosition = position;
//             gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
//         }
//     `;

//     worldColors = [
//         { color: new THREE.Color(0x00007f), position: 0.0 },
//         { color: new THREE.Color(0x86d1fa), position: 0.4 },
//         { color: new THREE.Color(0xfffffe), position: 0.5 },
//         { color: new THREE.Color(0x7f7f7f), position: 0.9 },
//         { color: new THREE.Color(0x3f3f3f), position: 1.0 }
//     ];

//     const gradientColors = worldColors.map(wc => wc.color);
//     const gradientPositions = worldColors.map(wc => wc.position);

//     const fragmentShader = `
//         precision highp float;
//         uniform float rainbowTime;
//         uniform vec3 gradientColors[${worldColors.length}];
//         uniform float gradientPositions[${worldColors.length}];
//         varying vec3 vPosition;

//         vec4 permute(vec4 x) {
//             return mod(((x * 34.0) + 1.0) * x, 289.0);
//         }
//         vec4 taylorInvSqrt(vec4 r) {
//             return 1.79284291400159 - 0.85373472095314 * r;
//         }
//         vec3 fade(vec3 t) {
//             return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);
//         }

//         float noise(vec3 P) {
//             vec3 Pi0 = floor(P);
//             vec3 Pi1 = Pi0 + vec3(1.0);
//             Pi0 = mod(Pi0, 289.0);
//             Pi1 = mod(Pi1, 289.0);
//             vec3 Pf0 = fract(P);
//             vec3 Pf1 = Pf0 - vec3(1.0);
//             vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);
//             vec4 iy = vec4(Pi0.y, Pi0.y, Pi1.y, Pi1.y);
//             vec4 iz0 = vec4(Pi0.z);
//             vec4 iz1 = vec4(Pi1.z);

//             vec4 ixy = permute(permute(ix) + iy);
//             vec4 ixy0 = permute(ixy + iz0);
//             vec4 ixy1 = permute(ixy + iz1);

//             vec4 gx0 = ixy0 / 7.0;
//             vec4 gy0 = fract(floor(gx0) / 7.0) - 0.5;
//             gx0 = fract(gx0);
//             vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);
//             vec4 sz0 = step(gz0, vec4(0.0));
//             gx0 -= sz0 * (step(0.0, gx0) - 0.5);
//             gy0 -= sz0 * (step(0.0, gy0) - 0.5);

//             vec4 gx1 = ixy1 / 7.0;
//             vec4 gy1 = fract(floor(gx1) / 7.0) - 0.5;
//             gx1 = fract(gx1);
//             vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);
//             vec4 sz1 = step(gz1, vec4(0.0));
//             gx1 -= sz1 * (step(0.0, gx1) - 0.5);
//             gy1 -= sz1 * (step(0.0, gy1) - 0.5);

//             vec3 g000 = vec3(gx0.x, gy0.x, gz0.x);
//             vec3 g100 = vec3(gx0.y, gy0.y, gz0.y);
//             vec3 g010 = vec3(gx0.z, gy0.z, gz0.z);
//             vec3 g110 = vec3(gx0.w, gy0.w, gz0.w);
//             vec3 g001 = vec3(gx1.x, gy1.x, gz1.x);
//             vec3 g101 = vec3(gx1.y, gy1.y, gz1.y);
//             vec3 g011 = vec3(gx1.z, gy1.z, gz1.z);
//             vec3 g111 = vec3(gx1.w, gy1.w, gz1.w);

//             vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));
//             g000 *= norm0.x;
//             g010 *= norm0.y;
//             g100 *= norm0.z;
//             g110 *= norm0.w;
//             vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));
//             g001 *= norm1.x;
//             g011 *= norm1.y;
//             g101 *= norm1.z;
//             g111 *= norm1.w;

//             float n000 = dot(g000, Pf0);
//             float n100 = dot(g100, vec3(Pf1.x, Pf0.y, Pf0.z));
//             float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));
//             float n110 = dot(g110, vec3(Pf1.x, Pf1.y, Pf0.z));
//             float n001 = dot(g001, vec3(Pf0.x, Pf0.y, Pf1.z));
//             float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));
//             float n011 = dot(g011, vec3(Pf0.x, Pf1.y, Pf1.z));
//             float n111 = dot(g111, Pf1);

//             vec3 fade_xyz = fade(Pf0);
//             vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);
//             vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);
//             float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);
//             return 2.2 * n_xyz;
//         }

//         vec3 getGradientColor(float position) {
//             position = 1.0 - position;
//             for (int i = 0; i < ${worldColors.length - 1}; i++) {
//                 if (position < gradientPositions[i + 1]) {
//                     float mixFactor = (position - gradientPositions[i]) / (gradientPositions[i + 1] - gradientPositions[i]);
//                     return mix(gradientColors[i], gradientColors[i + 1], mixFactor);
//                 }
//             }
//             return gradientColors[${worldColors.length - 1}];
//         }

//         void main() {
//             float t = rainbowTime;
//             vec3 P = normalize(vPosition);
//             float theta = atan(P.z, P.x);
//             float phi = acos(P.y);
//             vec2 sphericalUV = vec2(theta / (2.0 * 3.14159265), phi / 3.14159265);

//             float position = mod(sphericalUV.y + t * 0.1, 1.0);
//             vec3 gradientColor = getGradientColor(position);
//             vec3 noisePos = vec3(sphericalUV * 10.0, t); // Scaling noise coordinates
//             float noiseValue = noise(noisePos);
//             vec3 color = mix(gradientColor, vec3(noiseValue), 0.5); // Adjusted blend factor
//             gl_FragColor = vec4(color, 1.0);
//         }
//     `;

//     worldGradientMaterial = new THREE.ShaderMaterial({
//         vertexShader: vertexShader,
//         fragmentShader: fragmentShader,
//         uniforms: {
//             rainbowTime: { value: 0 },
//             gradientColors: { value: gradientColors },
//             gradientPositions: { value: gradientPositions }
//         }
//     });

//     let sphere = new THREE.Mesh(sphereGeometry, worldGradientMaterial);
//     sphere.name = "GradientBackgroundSphere";
//     scene.add(sphere);

//     // if (place.data.sky.rotation) {
//     //     sphere.rotation.set(place.data.sky.rotation.x, place.data.sky.rotation.y, place.data.sky.rotation.z);
//     // } else {
//     //     sphere.rotation.x = Math.PI / 2;
//     // }

//     sphere.ignore = true;
// }

// function updateGradientBackground(deltaTime) {
//     if (worldGradientMaterial) {
//         worldGradientMaterial.uniforms.rainbowTime.value += deltaTime * 0.1;
//     }
// }

// window.addGradientBackground = addGradientBackground;
// window.updateGradientBackground = updateGradientBackground;




// let worldColors, worldGradientMaterial;

// function addGradientBackground() {

//     console.log("addGradientBackground");
//     let sphereGeometry = new THREE.SphereGeometry(500, 120, 80);
    
//     sphereGeometry.scale(-1, 1, 1);
//     const vertexShader = `
//         varying vec2 vUvRainbow;
//         void main() {
//             vUvRainbow = uv;
//             gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
//         }
//     `;

//     worldColors = [
//         { color: new THREE.Color(0x00007f), position: 0.0 },
//         { color: new THREE.Color(0x86d1fa), position: 0.4 },
//         { color: new THREE.Color(0xfffffe), position: 0.5 },
//         { color: new THREE.Color(0x7f7f7f), position: 0.9 },
//         { color: new THREE.Color(0x3f3f3f), position: 1.0 }
//     ];

//     const gradientColors = worldColors.map(wc => wc.color);
//     const gradientPositions = worldColors.map(wc => wc.position);

//     const fragmentShader = `
//         precision highp float;
//         uniform float rainbowTime;
//         uniform vec3 gradientColors[${worldColors.length}];
//         uniform float gradientPositions[${worldColors.length}];
//         varying vec2 vUvRainbow;

//         vec3 getGradientColor(float position) {
//             position = 1.0 - position;
//             for (int i = 0; i < ${worldColors.length - 1}; i++) {
//                 if (position < gradientPositions[i + 1]) {
//                     float mixFactor = (position - gradientPositions[i]) / (gradientPositions[i + 1] - gradientPositions[i]);
//                     return mix(gradientColors[i], gradientColors[i + 1], mixFactor);
//                 }
//             }
//             return gradientColors[${worldColors.length - 1}];
//         }

//         void main() {
//             float t = rainbowTime;
//             vec2 FC = vUvRainbow * 2.0 - 1.0;
//             float position = mod(FC.y + t * 0.1, 1.0);
//             vec3 color = getGradientColor(position);
//             gl_FragColor = vec4(color, 1.0);
//         }
//     `;

//     worldGradientMaterial = new THREE.ShaderMaterial({
//         vertexShader: vertexShader,
//         fragmentShader: fragmentShader,
//         uniforms: {
//             rainbowTime: { value: 0 },
//             gradientColors: { value: gradientColors },
//             gradientPositions: { value: gradientPositions }
//         }
//     });

//     let sphere = new THREE.Mesh(sphereGeometry, worldGradientMaterial);
//     sphere.name = "GradientBackgroundSphere";
//     scene.add(sphere);

//     if (place.data.sky.rotation) {
//         sphere.rotation.set(place.data.sky.rotation.x, place.data.sky.rotation.y, place.data.sky.rotation.z);
//     } else {
//         sphere.rotation.x = Math.PI / 2;
//     }

//     sphere.ignore = true;
// }

// function updateGradientBackground(deltaTime) {
//     if (worldGradientMaterial) {
//         worldGradientMaterial.uniforms.rainbowTime.value += deltaTime * 0.1;
//     }
// }

// window.addGradientBackground = addGradientBackground;
// window.updateGradientBackground = updateGradientBackground;













/* 

    Env Map - nice 360 seamless backgrounds
    ----------------------------------------------- 

    */

let envMaterial;
let pmremGenerator, envMap
let backgroundBlurriness = 0;
let backgroundIntensity = 1.1


function addEnvMap() {


    let filePath = './static/models/environments/ai3.webp';
    //let filePath = './static/models/environments/hdr/beach.hdr';

    const fileExtension = filePath.split('.').pop().toLowerCase();

    let loader;

    // Choose the loader based on the file extension
    if (fileExtension === 'hdr') {
        loader = new RGBELoader();
    } else {
        loader = new THREE.TextureLoader();
    }

    loader.load(filePath, function(texture) {

            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;


        // Special handling for HDR textures
        if (fileExtension === 'hdr') {


            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
        } else {
            // For non-HDR images, use a CubeTexture if needed
            const renderTarget = new THREE.WebGLCubeRenderTarget(texture.image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            texture = renderTarget.texture;
            scene.background = texture;
        }

        // Apply to materials as envMap
        envMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.7,
            roughness: 0.3,
            envMap: texture
        });

        // Example: Add a sphere to the scene
        const sphereGeometry = new THREE.SphereGeometry(40, 120, 80);
        const sphere = new THREE.Mesh(sphereGeometry, envMaterial);
        //scene.add(sphere);

        scene.backgroundBlurriness = backgroundBlurriness;
        scene.backgroundIntensity = backgroundIntensity;


        // ENV
        // - ON -
        pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        envMap = pmremGenerator.fromEquirectangular(texture).texture;
        scene.environment = envMap;

        texture.dispose(); // Optional: Dispose the original texture to free memory
        pmremGenerator.dispose(); // Dispose PMREMGenerator when done

    });

}

window.addEnvMap = addEnvMap;




function changeEnvMap(filePath) {
    let renderer = renderer;

    // Determine the file extension
    const fileExtension = filePath.split('.').pop().toLowerCase();

    let loader;

    // Choose the loader based on the file extension
    if (fileExtension === 'hdr') {
        loader = new RGBELoader();
    } else {
        loader = new THREE.TextureLoader();
    }

    loader.load(filePath, function(texture) {
        // Special handling for HDR textures
        if (fileExtension === 'hdr') {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
        } else {
            // For non-HDR images, use a CubeTexture if needed
            const renderTarget = new THREE.WebGLCubeRenderTarget(texture.image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            scene.background = renderTarget.texture;
        }
    });
}

window.changeEnvMap = changeEnvMap;





/*


    Start Game
    ------------------


    */


function startGame() {


    //loadEmitters("data/emitters.json")


    // loadSingleEmitter("data/emitter_machine1.json")
    // loadSingleEmitter("data/emitter_machine2.json")

    // setTimeout(()=> { startAllEmitters()}, 2000);

    //loadEmitters("data/emitters.json");


    // setInterval(()=> { 

    //     let randomInterval = 1000 + Math.random()*2000;
    //     setTimeout(()=> { 

    //         let randomID = Math.floor(Math.random()*3);

    //         console.log("triggerEmitterById", randomID);
    //         triggerEmitterById(listEmitterIds()[randomID],'restart')


    //     }, randomInterval);


    // }, 10000)

        triggerEmittersArrayById(['emitter-a9abxr5fo', 'emitter-5qt68g97t', 'emitter-sxgj49uz4', 'emitter-d', 'emitter-bv5kdlp8r'],"restart");



        startAllEmitters()

        startAllDusters()



    
}

window.startGame = startGame;



/* 

    Init
    ----------------------------------------------- 

    */



function init() {


    initScene();

    initRapier();

    restoreCameraPosition();    

    //addHelpers();


    //addEnvMap();
    
    addGradientBackground()

    animate();

    //loadEmitters("data/emitters.json")

    initControllersEmitters()

    initControllers();

    //toggleEmittersEditGUI()

    //startGame();

    // Zesty ad test
    //addBanners();


    // loadSingleEmitter("data/selected/emitter_a.json")
    // loadSingleEmitter("data/selected/emitter_b.json")
    // loadSingleEmitter("data/selected/emitter_c.json")
    

    loadEmitters("data/emitters/all.json");

    loadDusters("data/dusters/all.json");


    //initDuster()




}



/* 

    Animate
    ----------------------------------------------- 

    */


function animate() {

    renderer.setAnimationLoop(render);


}



/* 

    Render Loop
    ----------------------------------------------- 

    */


let clock = new THREE.Clock()


function render() {

    let delta = clock.getDelta();


    // if (myRapierWorld) {
    //     myRapierWorld.step();
    // }


    //console.log("render")

    controlsUpdate()

    updateRapier();

    updateRaycasting();

    checkRingCollision();

    updateGradientBackground(delta)

    updateDusters()


    renderer.render(scene, camera);
}






function onSelectStart(event) {
    const controller = event.target;
    const intersections = getIntersections(controller);
    if (intersections.length > 0) {
        const intersection = intersections[0];
        controller.userData.selected = intersection.object;
    }
}

function onSelectEnd(event) {
    const controller = event.target;
    if (controller.userData.selected !== undefined) {
        const object = controller.userData.selected;
        object.material.emissive.b = 0;
        controller.userData.selected = undefined;
    }
}

function getIntersections(controller) {
    const tempMatrix = new THREE.Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);

    const raycaster = new THREE.Raycaster();
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    return raycaster.intersectObjects(scene.children, false);
}



/* 

    GUIs draggable window
    ----------------------------------------------- 

    */

function makePanelDraggable(element, dragHandle) {
    
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    dragHandle.onmousedown = dragMouseDown;

    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        // Get the mouse cursor position at startup:
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        // Call a function whenever the cursor moves:
        document.onmousemove = elementDrag;
        element.style.zIndex += 1;
    }
    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        // Calculate the new cursor position:
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        // Set the element's new position:
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
    }
    function closeDragElement() {
        // Stop moving when mouse button is released:
        document.onmouseup = null;
        document.onmousemove = null;
    }
    // display it
    element.style.display = "block";
}
window.makePanelDraggable = makePanelDraggable;



/* 

    Window Resize Update
    ----------------------------------------------- 

    */

let resizeTimeout;

function onWindowResize() {

    clearTimeout(resizeTimeout);

    resizeTimeout = setTimeout(() => {

        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);

     }, 200); 

}


/* 

    DOM Loaded - execute init()
    ----------------------------------------------- 

    */


document.addEventListener("DOMContentLoaded", function() {

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', onWindowResize);

    init();

});



</script>




</body>

</html>