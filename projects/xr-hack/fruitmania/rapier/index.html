<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">


    <title>WebXR Emitter Application</title>

    <link rel="icon" href="./static/images/yolo-icon-256x256.png">

    <style>
        body { margin: 0; }
        canvas { display: block; }
        #guiOverlayInput {
            position: absolute;
            width: min-content;
            display: none;
            top: 8px;
            left: 8px;
            z-index: 1001;
        }
        #guiHolderWrap {
            border: 1px solid #ffffff2b;
            max-height: 90vh;
            /* Adjust this value as needed */
            overflow-y: auto;
            border-radius: 0.5rem;
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
        }
        #guiOverlayBar {
            color: black;
            font-size: 0.5rem;
            cursor: pointer;
            padding: 0.25rem;
            background-color: none;
            width: -webkit-fill-available;
            text-align: center;
            border-radius: 0.2rem;
        }
        #guiOverlayBar:hover {
            color: initial;
            background: linear-gradient(145deg, #f5f5f5, #e0e0e0, #9e9e9e, #757575, #616161, #424242, #212121);
        }
        #guiCloudsOverlayInput {
            position: absolute;
            width: min-content;
            display: none;
            top: 50px;
            right: 50px;
        }
        #guiCloudsOverlayBar {
            color: black;
            font-size: 0.5rem;
            cursor: pointer;
            padding: 0.25rem;
            background-color: none;
            width: -webkit-fill-available;
            text-align: center;
            border-radius: 0.2rem;
            border-bottom-left-radius: 0;
            border-bottom-right-radius: 0;
            border-bottom: 1px solid black;
        }
        #guiCloudsOverlayBar:hover {
            background-color: rgba(255, 255, 255, 0.95);
            color: initial;
        }        
        /* Control Pad */
        .custom-vr-button {
            background: #0000003b;
            border: 1px solid rgba(255, 255, 255, 0);
            border-radius: 50%;
            display: block;
            width: 53px;
            height: 53px;
            position: fixed;
            bottom: 53px;
            left: 20px;
            padding: 0.25rem;
            margin: 0;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .display-block {
            display: block !important;
        }
        .custom-vr-button:hover {
            background-color: rgba(255, 255, 255, 0.2);
            transform: scale(1.1);
        }
        .custom-vr-button:active {
            background-color: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.7);
            transform: scale(0.95);
        }

        .corner-ribbon {
            width: 250px;
            background: #00000010;
            color: #FFFFFF20;
            text-align: center;
            line-height: 50px;
            transform: rotate(-45deg) scale(0.75);
            position: fixed;
            bottom: 25px;
            right: -76px;
            font-family: 'Lato Thin', Arial, sans-serif;
            font-size: 14px;
            z-index: 1000;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.3);
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(3px);
            user-select: none;
        }

        .corner-ribbon a {
            display: flex;
            align-items: center;
            color: #FFFFFF90;
            text-decoration: none;
            width: 100%;
            height: 100%;
            line-height: inherit;
            justify-content: center;
            user-select: none;
        }

        .corner-ribbon a:hover {
            color: #FFFFFF;
        }

        .corner-ribbon svg {
            fill: #FFFFFF90;
            width: 20px;
            height: 20px;
            margin-right: 8px;
        }



    </style>

    <script>
        document.addEventListener("DOMContentLoaded", function() {
            try {
                var script = document.createElement('script');
                script.defer = true;
                script.src = "https://analytics.mielniczuk.com/script.js";
                script.setAttribute('data-website-id', '33076180-1c51-4617-b67b-b91b5e1f8cf8');
                document.head.appendChild(script);
            } catch (error) {
                console.error('Analytics script failed to load', error);
            }
        });
    </script>


</head>




<body>


    <div class="corner-ribbon">
        <a href="https://github.com/Immersive-Collective" target="_blank">
            <svg height="32" width="32" viewBox="0 0 16 16" aria-hidden="true">
                <path fill="#FFFFFF99" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.002 8.002 0 0 0 16 8c0-4.42-3.58-8-8-8z" />
            </svg>
            Immersive Collective
        </a>
    </div>    

<div id="guiOverlayInput">
    <div id="guiOverlayBar"></div>
    <div class="guiSettings">
        <div id="guiHolderWrap">
            <div id="guiHolder"></div>
        </div>
    </div>
</div>

<script type="importmap">
    {
    "imports": {
        "three": "./node_modules/three/build/three.module.js",
        "lil-gui": "./node_modules/lil-gui/dist/lil-gui.esm.min.js",
        "three/addons/": "./node_modules/three/examples/jsm/",
        "rapier": "./node_modules/@dimforge/rapier3d-compat/rapier.es.js"
        }
    }
</script>


<script type="module">


/* 

    Imports
    ----------------------------------------------- 

    */    


import * as THREE from 'three';

import { XRButton } from 'three/addons/webxr/XRButton.js';

import { VRButton } from 'three/addons/webxr/VRButton.js';

import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';  

import { XRHandModelFactory } from 'three/addons/webxr/XRHandModelFactory.js';

import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

import { TransformControls } from 'three/addons/controls/TransformControls.js';

import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
import { GUI } from 'lil-gui';    
import RAPIER from 'rapier';



/* 

    Container
    ----------------------------------------------- 

    */


const container = document.createElement('div');
document.body.appendChild(container);


/* 

    ThreeJS Variables
    ----------------------------------------------- 

    */

let scene, camera, renderer


const guiInstances = new Map();




/* 

    Emitter - Geometries Config
    ----------------------------------------------- 

    */

const geometryConfig = {
    BoxGeometry: {
        defaultParams: { sx: 1, sy: 1, sz: 1 },
        params: [
            { name: 'sx', min: 0.01, max: 3 },
            { name: 'sy', min: 0.01, max: 3 },
            { name: 'sz', min: 0.01, max: 3 }
        ],
        create: params => new THREE.BoxGeometry(params.sx, params.sy, params.sz)
    },
    SphereGeometry: {
        defaultParams: { radius: 1, widthSegments: 32, heightSegments: 16 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'widthSegments', min: 3, max: 64, step: 1 },
            { name: 'heightSegments', min: 2, max: 32, step: 1 }
        ],
        create: params => new THREE.SphereGeometry(params.radius, params.widthSegments, params.heightSegments)
    },
    CapsuleGeometry: {
        defaultParams: { radius: 1, length: 1, capSegments: 4, radialSegments: 8 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'length', min: 0.01, max: 3 },
            { name: 'capSegments', min: 1, max: 10, step: 1 },
            { name: 'radialSegments', min: 3, max: 32, step: 1 }
        ],
        create: params => new THREE.CapsuleGeometry(params.radius, params.length, params.capSegments, params.radialSegments)
    },
    CircleGeometry: {
        defaultParams: { radius: 1, segments: 32, thetaStart: 0, thetaLength: Math.PI * 2 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'segments', min: 3, max: 64, step: 1 },
            { name: 'thetaStart', min: 0, max: Math.PI * 2 },
            { name: 'thetaLength', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.CircleGeometry(params.radius, params.segments, params.thetaStart, params.thetaLength)
    },
    ConeGeometry: {
        defaultParams: { radius: 1, height: 1, radialSegments: 32, heightSegments: 1, openEnded: false, thetaStart: 0, thetaLength: Math.PI * 2 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'height', min: 0.01, max: 3 },
            { name: 'radialSegments', min: 3, max: 64, step: 1 },
            { name: 'heightSegments', min: 1, max: 32, step: 1 },
            { name: 'openEnded', min: 0, max: 1 },
            { name: 'thetaStart', min: 0, max: Math.PI * 2 },
            { name: 'thetaLength', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.ConeGeometry(params.radius, params.height, params.radialSegments, params.heightSegments, params.openEnded, params.thetaStart, params.thetaLength)
    },
    CylinderGeometry: {
        defaultParams: { radiusTop: 1, radiusBottom: 1, height: 1, radialSegments: 32, heightSegments: 1, openEnded: false, thetaStart: 0, thetaLength: Math.PI * 2 },
        params: [
            { name: 'radiusTop', min: 0.01, max: 3 },
            { name: 'radiusBottom', min: 0.01, max: 3 },
            { name: 'height', min: 0.01, max: 3 },
            { name: 'radialSegments', min: 3, max: 64, step: 1 },
            { name: 'heightSegments', min: 1, max: 32, step: 1 },
            { name: 'openEnded', min: 0, max: 1 },
            { name: 'thetaStart', min: 0, max: Math.PI * 2 },
            { name: 'thetaLength', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.CylinderGeometry(params.radiusTop, params.radiusBottom, params.height, params.radialSegments, params.heightSegments, params.openEnded, params.thetaStart, params.thetaLength)
    },
    DodecahedronGeometry: {
        defaultParams: { radius: 1, detail: 0 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'detail', min: 0, max: 5, step: 1 }
        ],
        create: params => new THREE.DodecahedronGeometry(params.radius, params.detail)
    },
    IcosahedronGeometry: {
        defaultParams: { radius: 1, detail: 0 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'detail', min: 0, max: 5, step: 1 }
        ],
        create: params => new THREE.IcosahedronGeometry(params.radius, params.detail)
    },
    OctahedronGeometry: {
        defaultParams: { radius: 1, detail: 0 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'detail', min: 0, max: 5, step: 1 }
        ],
        create: params => new THREE.OctahedronGeometry(params.radius, params.detail)
    },
    PlaneGeometry: {
        defaultParams: { width: 1, height: 1, widthSegments: 1, heightSegments: 1 },
        params: [
            { name: 'width', min: 0.01, max: 3 },
            { name: 'height', min: 0.01, max: 3 },
            { name: 'widthSegments', min: 1, max: 32, step: 1 },
            { name: 'heightSegments', min: 1, max: 32, step: 1 }
        ],
        create: params => new THREE.PlaneGeometry(params.width, params.height, params.widthSegments, params.heightSegments)
    },
    RingGeometry: {
        defaultParams: { innerRadius: 0.5, outerRadius: 1, thetaSegments: 32, phiSegments: 1, thetaStart: 0, thetaLength: Math.PI * 2 },
        params: [
            { name: 'innerRadius', min: 0.01, max: 3 },
            { name: 'outerRadius', min: 0.01, max: 3 },
            { name: 'thetaSegments', min: 3, max: 64, step: 1 },
            { name: 'phiSegments', min: 1, max: 32, step: 1 },
            { name: 'thetaStart', min: 0, max: Math.PI * 2 },
            { name: 'thetaLength', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.RingGeometry(params.innerRadius, params.outerRadius, params.thetaSegments, params.phiSegments, params.thetaStart, params.thetaLength)
    },
    TetrahedronGeometry: {
        defaultParams: { radius: 1, detail: 0 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'detail', min: 0, max: 5, step: 1 }
        ],
        create: params => new THREE.TetrahedronGeometry(params.radius, params.detail)
    },
    TorusGeometry: {
        defaultParams: { radius: 1, tube: 0.4, radialSegments: 12, tubularSegments: 48, arc: Math.PI * 2 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'tube', min: 0.01, max: 1 },
            { name: 'radialSegments', min: 3, max: 64, step: 1 },
            { name: 'tubularSegments', min: 3, max: 128, step: 1 },
            { name: 'arc', min: 0, max: Math.PI * 2 }
        ],
        create: params => new THREE.TorusGeometry(params.radius, params.tube, params.radialSegments, params.tubularSegments, params.arc)
    },
    TorusKnotGeometry: {
        defaultParams: { radius: 1, tube: 0.4, tubularSegments: 64, radialSegments: 8, p: 2, q: 3 },
        params: [
            { name: 'radius', min: 0.01, max: 3 },
            { name: 'tube', min: 0.01, max: 1 },
            { name: 'tubularSegments', min: 3, max: 128, step: 1 },
            { name: 'radialSegments', min: 3, max: 64, step: 1 },
            { name: 'p', min: 1, max: 20, step: 1 },
            { name: 'q', min: 1, max: 20, step: 1 }
        ],
        create: params => new THREE.TorusKnotGeometry(params.radius, params.tube, params.tubularSegments, params.radialSegments, params.p, params.q)
    }
};




const storedEmitters = [];
const emittersMap = new Map();

function cubeEmitter({ x = 0, y = 3, z = 0, id, delay = 0, count = 0, speedFactor = 1, direction = { x: 0, y: -1, z: 0 }, density = 1, ...params } = {}, interTime = 2000) {
    let position = { x, y, z };
    let geometryParams = params;
    let currentGeometry = geometryParams.geometryType;
    let intervalId = null;
    let producedCubes = [];
    let isActive = false;
    let remainingCount = count;

    function start() {
        if (isActive) return;
        isActive = true;
        setTimeout(() => {
            intervalId = setInterval(() => {
                if (remainingCount > 0) remainingCount--;
                if (remainingCount === 0 && count !== 0) {
                    pause();
                    return;
                }
                const color = new THREE.Color(Math.random(), Math.random(), Math.random());
                const random = geometryParams.randomSizes;
                const sizeVector = random
                    ? new THREE.Vector3(
                        Math.random() * geometryParams.sx,
                        Math.random() * geometryParams.sy,
                        Math.random() * geometryParams.sz
                    )
                    : new THREE.Vector3(geometryParams.sx, geometryParams.sy, geometryParams.sz);
                const cubePosition = new THREE.Vector3(position.x, position.y, position.z);
                const cube = addSingleObject(currentGeometry, { ...geometryParams, sx: sizeVector.x, sy: sizeVector.y, sz: sizeVector.z }, cubePosition, color, random, speedFactor, direction, density);
                producedCubes.push(cube);
            }, interTime);
        }, delay);
    }

    function pause() {
        if (intervalId) {
            clearInterval(intervalId);
            intervalId = null;
            isActive = false;
        }
    }

    function reset() {
        pause();
        producedCubes.forEach(({ mesh, rigidBody, collider }) => {
            if (mesh) {
                scene.remove(mesh);
                const meshIndex = window.threeCubes.indexOf(mesh);
                if (meshIndex > -1) {
                    window.threeCubes.splice(meshIndex, 1);
                }
            }
            if (myRapierWorld && rigidBody) {
                myRapierWorld.removeCollider(collider, true);
                myRapierWorld.removeRigidBody(rigidBody, true);
                const rigidBodyIndex = window.rigidBodies.indexOf(rigidBody);
                if (rigidBodyIndex > -1) {
                    window.rigidBodies.splice(rigidBodyIndex, 1);
                }
            }
        });
        producedCubes = [];
        remainingCount = count;
    }

    function restart() {
        pause();
        remainingCount = count;
        start();
    }

    function setPosition(newPosition) {
        position = newPosition;
    }

    function setGeometryParams(newParams) {
        geometryParams = { ...geometryParams, ...newParams };
    }

    function setGeometryType(type) {
        currentGeometry = type;
    }

    function setIntervalTime(newIntervalTime) {
        interTime = newIntervalTime;
        if (isActive) {
            pause();
            start();
        }
    }

    function setRandomSizes(value) {
        geometryParams.randomSizes = value;
    }

    function setCount(newCount) {
        count = Math.floor(newCount); // Ensure count is always an integer
        remainingCount = count;
    }

    function setDelay(newDelay) {
        delay = newDelay;
    }

    function setDirection(newDirection) {
        direction = newDirection;
    }

    function setDensity(newDensity) {
        density = newDensity;
    }

    function setSpeedFactor(newSpeedFactor) {
        speedFactor = newSpeedFactor;
    }

    function getParams() {
        return {
            id,
            x: position.x,
            y: position.y,
            z: position.z,
            ...geometryParams,
            interval: interTime,
            delay,
            count,
            directionX: direction.x,
            directionY: direction.y,
            directionZ: direction.z,
            speedFactor,
            density
        };
    }

    function addSingleObject(type, params, position, color, random, speedFactor, direction, density) {
        const geometry = geometryConfig[type].create(params);
        const bodyMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.2, roughness: 0.8, wireframe: false });
        const bodyMesh = new THREE.Mesh(geometry, bodyMaterial);
        bodyMesh.position.copy(position);
        bodyMesh.castShadow = true;
        bodyMesh.receiveShadow = true;
        bodyMesh.type = "cb";
        scene.add(bodyMesh);

        let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(position.x, position.y, position.z).setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
        let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);
        let colliderDesc;

        if (type === 'BoxGeometry') {
            colliderDesc = RAPIER.ColliderDesc.cuboid(params.sx / 2, params.sy / 2, params.sz / 2).setDensity(density);
        } else if (['SphereGeometry', 'DodecahedronGeometry', 'IcosahedronGeometry', 'OctahedronGeometry', 'TetrahedronGeometry'].includes(type)) {
            const radius = params.radius;
            colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
        } else if (type === 'CapsuleGeometry') {
            const radius = params.radius;
            colliderDesc = RAPIER.ColliderDesc.capsule(radius, params.length / 2).setDensity(density);
        } else if (type === 'CylinderGeometry') {
            colliderDesc = RAPIER.ColliderDesc.cylinder(params.height / 2, params.radiusTop).setDensity(density);
        } else if (type === 'ConeGeometry') {
            colliderDesc = RAPIER.ColliderDesc.cone(params.height / 2, params.radius).setDensity(density);
        } else {
            colliderDesc = RAPIER.ColliderDesc.cuboid(params.sx / 2, params.sy / 2, params.sz / 2).setDensity(density);
        }

        let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);
        rigidBody.type = "cb";
        window.rigidBodies.push(rigidBody);
        window.threeCubes.push(bodyMesh);

        return { mesh: bodyMesh, rigidBody: rigidBody, collider: collider };
    }

    const emitterInstance = {
        id,
        start,
        pause,
        reset,
        restart,
        setPosition,
        setGeometryParams,
        setGeometryType,
        setIntervalTime,
        setRandomSizes,
        setCount,
        setDelay,
        setDirection,
        setDensity,
        setSpeedFactor,
        getParams
    };

    if (id) {
        emittersMap.set(id, emitterInstance);
    }

    return emitterInstance;
}

window.cubeEmitter = cubeEmitter;

function initEmittersEdit(guiKey, loadedEmitters = []) {
    const container = document.getElementById("guiHolder");
    const gui = new GUI({ width: 350, container: container });
    guiInstances.set(guiKey, gui);

    const emitters = [];

    function addEmitter() {
        const emitterParams = {
            id: generateUniqueId(),
            x: 0,
            y: 0,
            z: 0,
            ...geometryConfig.BoxGeometry.defaultParams, // default geometry
            geometryType: 'BoxGeometry',
            interval: 500,
            randomSizes: false,
            delay: 0,
            count: 0,
            directionX: 0,
            directionY: -1,
            directionZ: 0,
            speedFactor: 1,
            density: 1
        };

        const folder = gui.addFolder('Add Emitter');
        folder.add(emitterParams, 'geometryType', Object.keys(geometryConfig)).name('Geometry Type').onChange((newGeometryType) => {
            Object.assign(emitterParams, geometryConfig[newGeometryType].defaultParams);
            emitterParams.geometryType = newGeometryType;
        });
        folder.add({ create: () => createEmitter(emitterParams) }, 'create').name('Create Emitter');
        folder.open();
    }

    function createEmitter(params) {
        const emitterId = generateUniqueId();
        params.id = emitterId;

        const index = emitters.length;
        const emitter = cubeEmitter({ ...params }, params.interval, params.delay, params.count);
        emitter.setIntervalTime(params.interval);
        emitter.setDelay(params.delay);
        emitter.setCount(params.count);
        emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
        emitter.setDensity(params.density);
        emitter.setSpeedFactor(params.speedFactor);

        emitters.push({ emitter, params: { ...params } }); // Ensure a deep copy of params
        storedEmitters.push({ ...params }); // Store parameters

        const folder = gui.addFolder(`Emitter ${params.id}`);
        folder.add({ geometryType: params.geometryType }, 'geometryType').name('Geometry Type').listen();
        folder.add(params, 'x', -200, 200).name('X').onChange(() => {
            emitter.setPosition({ x: params.x, y: params.y, z: params.z });
            updatePreviewMeshPosition(emitter.previewMesh, params);
            updatePreviewLine(emitter.previewLine, params);
        });
        folder.add(params, 'y', -30, 200).name('Y').onChange(() => {
            emitter.setPosition({ x: params.x, y: params.y, z: params.z });
            updatePreviewMeshPosition(emitter.previewMesh, params);
            updatePreviewLine(emitter.previewLine, params);
        });
        folder.add(params, 'z', -200, 200).name('Z').onChange(() => {
            emitter.setPosition({ x: params.x, y: params.y, z: params.z });
            updatePreviewMeshPosition(emitter.previewMesh, params);
            updatePreviewLine(emitter.previewLine, params);
        });

        folder.add(params, 'randomSizes').name('Random Sizes').onChange(() => emitter.setRandomSizes(params.randomSizes));
        folder.add(params, 'interval', 1, 5000).name('Interval (ms)').onChange(() => emitter.setIntervalTime(params.interval));
        folder.add(params, 'delay', 0, 25000).name('Delay (ms)').onChange(() => emitter.setDelay(params.delay));
        
        folder.add(params, 'count', 0, 10000).step(1).name('Count').onChange(() => emitter.setCount(params.count));
        folder.add(params, 'directionX', -1, 1).name('Direction X').onChange(() => {
            emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
            updatePreviewLine(emitter.previewLine, params);
            updatePreviewMeshRotation(emitter.previewMesh, params);
        });
        folder.add(params, 'directionY', -1, 1).name('Direction Y').onChange(() => {
            emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
            updatePreviewLine(emitter.previewLine, params);
            updatePreviewMeshRotation(emitter.previewMesh, params);
        });
        folder.add(params, 'directionZ', -1, 1).name('Direction Z').onChange(() => {
            emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
            updatePreviewLine(emitter.previewLine, params);
            updatePreviewMeshRotation(emitter.previewMesh, params);
        });
        folder.add(params, 'speedFactor', 0.1, 10).name('Speed Factor').onChange(() => {
            emitter.setSpeedFactor(params.speedFactor);
            updatePreviewLine(emitter.previewLine, params);
        });
        folder.add(params, 'density', 0.1, 10).name('Density').onChange(() => emitter.setDensity(params.density));

        addGeometrySpecificParams(folder, params, emitter);

        folder.add({ start: () => startEmitter(index) }, 'start').name('Start');
        folder.add({ pause: () => pauseEmitter(index) }, 'pause').name('Pause');
        folder.add({ reset: () => resetEmitter(index, emitter.previewMesh, emitter.previewLine) }, 'reset').name('Reset');
        folder.add({ restart: () => restartEmitter(index) }, 'restart').name('Restart');
        folder.add({ exportEmitter: () => exportEmitter(emitterId) }, 'exportEmitter').name('Export Emitter');
        folder.add({ removeEmitter: () => removeEmitter(index, folder) }, 'removeEmitter').name('Remove Emitter');
        folder.open();

        emitter.previewMesh = createStaticPreview(params);
        emitter.previewLine = createPreviewLine(params);

        listEmitterIds();

    }

    function startAllEmitters() {
        emitters.forEach(({ emitter }) => emitter.start());
    }

    function stopAllEmitters() {
        emitters.forEach(({ emitter }) => emitter.pause());
    }

    function removeEmitter(index, folder) {
        if (emitters[index]) {
            try {
                const emitter = emitters[index].emitter;
                if (emitter) {
                    emitter.reset();
                    if (emitter.previewMesh) {
                        scene.remove(emitter.previewMesh);
                    }
                    if (emitter.previewLine) {
                        scene.remove(emitter.previewLine);
                    }
                }
                if (folder) {
                    folder.close();
                    folder.domElement.remove();
                    const folderName = `Emitter ${emitters[index].params.id}`;
                    if (gui.folders[folderName]) {
                        delete gui.folders[folderName];
                    }
                }
                emitters.splice(index, 1);
                storedEmitters.splice(index, 1);
            } catch (e) {
                console.error(`Error removing emitter at index ${index}:`, e);
            }
        }
    }

    function removeAllEmitters() {
        emitters.slice().forEach((emitterData, index) => {
            try {
                const emitter = emitterData.emitter;
                if (emitter) {
                    emitter.reset();
                    if (emitter.previewMesh) {
                        scene.remove(emitter.previewMesh);
                    }
                    if (emitter.previewLine) {
                        scene.remove(emitter.previewLine);
                    }
                }
                const folderName = `Emitter ${emitterData.params.id}`;
                const folder = gui.folders && gui.folders[folderName];
                if (folder) {
                    folder.close();
                    folder.domElement.remove();
                    delete gui.folders[folderName];
                }
            } catch (e) {
                console.error(`Error removing emitter at index ${index}:`, e);
            }
        });

        emitters.length = 0; // Clear the emitters array
        storedEmitters.length = 0; // Clear the storedEmitters array
        emittersMap.clear(); // Clear the emittersMap

        // really dirty hack - but this is the only way so far to remove GUI folders and recreate GUI - it is actually impossible to see what is going on here
        toggleEmittersEditGUI()
        toggleEmittersEditGUI()

    }

    function exportEmitter(emitterId) {
        const emitterObj = emitters.find(e => e.emitter.id === emitterId);
        if (emitterObj) {
            const params = emitterObj.emitter.getParams();
            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(params));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", `emitter_${params.id}.json`);
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }
    }

    function exportAllEmitters() {
        const updatedStoredEmitters = emitters.map(({ emitter }) => emitter.getParams());
        const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(updatedStoredEmitters));
        const now = new Date().toISOString().replace(/[:.]/g, '-');
        const downloadAnchorNode = document.createElement('a');
        downloadAnchorNode.setAttribute("href", dataStr);
        downloadAnchorNode.setAttribute("download", `emitters_${now}.json`);
        document.body.appendChild(downloadAnchorNode);
        downloadAnchorNode.click();
        downloadAnchorNode.remove();
    }

    function importEmitters() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = event => {
                const importedParams = JSON.parse(event.target.result);
                importedParams.forEach(params => createEmitter(params));
            };
            reader.readAsText(file);
        };
        input.click();
    }

    function addGeometrySpecificParams(folder, params, emitter) {
        const geometryType = params.geometryType;
        const config = geometryConfig[geometryType];

        config.params.forEach(param => {
            const controller = folder.add(params, param.name, param.min, param.max).name(param.name.charAt(0).toUpperCase() + param.name.slice(1));
            if (param.step) {
                controller.step(param.step); // Ensure integer parameters use integer steps
            }
            controller.onChange(() => {
                const newParams = { [param.name]: params[param.name] };
                emitter.setGeometryParams(newParams);
                updatePreviewMeshGeometry(emitter.previewMesh, params);
            });
        });
    }

    function createStaticPreview(params) {
        const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00]; // Red, Green, Blue, Yellow
        const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
        const geometry = createGeometry(params.geometryType, params);
        const edges = new THREE.EdgesGeometry(geometry);
        const material = new THREE.LineBasicMaterial({ color: color });
        const previewMesh = new THREE.LineSegments(edges, material);
        previewMesh.position.set(params.x, params.y, params.z);
        scene.add(previewMesh);
        return previewMesh;
    }

    function createGeometry(type, params) {
        const config = geometryConfig[type];
        return config.create(params);
    }

    function updatePreviewMeshGeometry(previewMesh, params) {
        const newGeometry = createGeometry(params.geometryType, params);
        const edges = new THREE.EdgesGeometry(newGeometry);
        previewMesh.geometry.dispose();
        previewMesh.geometry = edges;
    }

    function updatePreviewMeshPosition(previewMesh, params) {
        previewMesh.position.set(params.x, params.y, params.z);
        updatePreviewMeshRotation(previewMesh, params);
    }

    function updatePreviewMeshRotation(previewMesh, params) {
        const direction = new THREE.Vector3(params.directionX, params.directionY, params.directionZ).normalize();
        const quaternion = new THREE.Quaternion();
        quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), direction);
        previewMesh.quaternion.copy(quaternion);
    }

    function updatePreviewLine(line, params) {
        const points = [
            new THREE.Vector3(params.x, params.y, params.z),
            new THREE.Vector3(params.x + params.directionX * params.speedFactor, params.y + params.directionY * params.speedFactor, params.z + params.directionZ * params.speedFactor)
        ];
        line.geometry.setFromPoints(points);
    }


    function createPreviewLine(params) {
        const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
        const points = [
            new THREE.Vector3(params.x, params.y, params.z),
            new THREE.Vector3(params.x + params.directionX * params.speedFactor, params.y + params.directionY * params.speedFactor, params.z + params.directionZ * params.speedFactor)
        ];
        const geometry = new THREE.BufferGeometry().setFromPoints(points);
        const line = new THREE.Line(geometry, material);
        scene.add(line);
        return line;
    }


    function startEmitter(index) {
        if (emitters[index]) {
            emitters[index].emitter.start();
        }
    }

    function pauseEmitter(index) {
        if (emitters[index]) {
            emitters[index].emitter.pause();
        }
    }

    function resetEmitter(index, previewMesh, previewLine) {
        if (emitters[index]) {
            emitters[index].emitter.reset();
            updatePreviewMeshPosition(previewMesh, emitters[index].emitter.getParams());
            updatePreviewLine(previewLine, emitters[index].emitter.getParams());
        }
    }

    function restartEmitter(index) {
        if (emitters[index]) {
            emitters[index].emitter.restart();
        }
    }

    function importEmitter() {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.json';
        input.onchange = e => {
            const file = e.target.files[0];
            const reader = new FileReader();
            reader.onload = event => {
                const importedParams = JSON.parse(event.target.result);
                createEmitter(importedParams);
            };
            reader.readAsText(file);
        };
        input.click();
    }

    gui.add({ importEmitters: importEmitters }, 'importEmitters').name('Load Emitters');
    gui.add({ exportAllEmitters: exportAllEmitters }, 'exportAllEmitters').name('Export All Emitters');
    gui.add({ importEmitter: importEmitter }, 'importEmitter').name('Import Emitter');
    gui.add({ startAllEmitters }, 'startAllEmitters').name('Start All Emitters');
    gui.add({ stopAllEmitters }, 'stopAllEmitters').name('Stop All Emitters');
    gui.add({ removeAllEmitters }, 'removeAllEmitters').name('Remove All Emitters');

    addEmitter();
    loadedEmitters.forEach(params => createEmitter(params)); // Load emitters from JSON data if provided
    makePanelDraggable(document.getElementById("guiOverlayInput"), document.getElementById("guiOverlayBar"));
}

window.initEmittersEdit = initEmittersEdit;

function generateUniqueId() {
    return 'emitter-' + Math.random().toString(36).substr(2, 9);
}

function toggleEmittersEditGUI() {
    if (guiInstances.has('emittersEditGUI')) {
        guiInstances.get('emittersEditGUI').destroy();
        guiInstances.delete('emittersEditGUI');
    } else {
        initEmittersEdit('emittersEditGUI', storedEmitters);
    }
}

window.toggleEmittersEditGUI = toggleEmittersEditGUI;

/* Emitters Managers */

function listEmitterIds() {
    return Array.from(emittersMap.keys());
}

window.listEmitterIds = listEmitterIds;

function triggerEmittersArrayById(ids, action) {
    ids.forEach(id => {
        triggerEmitterById(id, action);
    });
}

window.triggerEmittersArrayById = triggerEmittersArrayById;

function startAllEmitters() {
    emittersMap.forEach(emitter => emitter.start());
}

window.startAllEmitters = startAllEmitters;

function stopAllEmitters() {
    emittersMap.forEach(emitter => emitter.pause());
}

window.stopAllEmitters = stopAllEmitters;

function removeAllEmitters() {
    emittersMap.forEach((emitter, id) => {
        emitter.reset();
        if (emitter.previewMesh) {
            scene.remove(emitter.previewMesh);
        }
        if (emitter.previewLine) {
            scene.remove(emitter.previewLine);
        }
        if (typeof gui !== 'undefined') {
            const folderName = `Emitter ${id}`;
            const folder = gui.folders.find(f => f.title === folderName);
            if (folder) {
                folder.destroy();
            }
        }
    });
    emittersMap.clear(); // Clear the emittersMap
    storedEmitters.length = 0; // Clear the storedEmitters array
}

window.removeAllEmitters = removeAllEmitters;

function triggerEmitterById(id, action) {
    const emitter = emittersMap.get(id);
    if (!emitter) {
        console.error(`Emitter with ID ${id} not found.`);
        return;
    }
    switch(action) {
        case 'start':
            emitter.start();
            break;
        case 'pause':
            emitter.pause();
            break;
        case 'reset':
            emitter.reset();
            updatePreviewMeshPosition(emitter.previewMesh, emitter.getParams());
            updatePreviewLine(emitter.previewLine, emitter.getParams());
            break;
        case 'restart':
            emitter.restart();
            break;
        default:
            console.error(`Invalid action: ${action}`);
    }
}

window.triggerEmitterById = triggerEmitterById;

function removeEmitterById(id) {
    const emitter = emittersMap.get(id);
    if (!emitter) {
        console.error(`Emitter with ID ${id} not found.`);
        return;
    }
    emitter.reset();
    if (emitter.previewMesh) {
        scene.remove(emitter.previewMesh);
    }
    if (emitter.previewLine) {
        scene.remove(emitter.previewLine);
    }

    emittersMap.delete(id);
    storedEmitters.splice(storedEmitters.findIndex(e => e.id === id), 1);

    if (guiInstances.has('emittersEditGUI')) {
        const gui = guiInstances.get('emittersEditGUI');
        const folderName = `Emitter ${id}`;
        const folder = gui.folders.find(f => f.title === folderName);
        if (folder) {
            folder.destroy();
        }
    }
}

window.removeEmitterById = removeEmitterById;

function loadEmittersFromJSON(url) {
    fetch(url)
        .then(response => response.json())
        .then(data => initEmittersEdit('emittersEditGUI', data))
        .catch(error => console.error('Error loading emitters:', error));
}

window.loadEmittersFromJSON = loadEmittersFromJSON;

function createEmitter(params) {
    const emitterId = params.id || generateUniqueId();
    params.id = emitterId;

    const emitter = cubeEmitter(params);
    emitter.setIntervalTime(params.interval);
    emitter.setDelay(params.delay);
    emitter.setCount(params.count);
    emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
    emitter.setDensity(params.density);
    emitter.setSpeedFactor(params.speedFactor);

    storedEmitters.push({ ...params });

    // start if you want on load 
    //emitter.start();
}

function loadEmitters(url) {
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (Array.isArray(data)) {
                data.forEach(emitterData => {
                    if (typeof emitterData === 'object' && emitterData !== null) {
                        createEmitter(emitterData); // Assumes each item in the array is a single emitter object
                    } else {
                        console.error('Invalid emitter data format');
                    }
                });
            } else {
                console.error('Invalid emitters data format');
            }
        })
        .catch(error => console.error('Error loading emitters:', error));
}

window.loadEmitters = loadEmitters;



function loadSingleEmitter(url) {
    fetch(url)
        .then(response => response.json())
        .then(data => {
            if (typeof data === 'object' && data !== null) {
                createEmitter(data); // Assumes the JSON is a single object
            } else {
                console.error('Invalid emitter data format');
            }
        })
        .catch(error => console.error('Error loading emitter:', error));
}

window.loadSingleEmitter = loadSingleEmitter;




// const storedEmitters = [];
// const emittersMap = new Map();

// function cubeEmitter({ x = 0, y = 3, z = 0, id, delay = 0, count = 0, speedFactor = 1, direction = { x: 0, y: -1, z: 0 }, density = 1, ...params } = {}, interTime = 2000) {
//     let position = { x, y, z };
//     let geometryParams = params;
//     let currentGeometry = geometryParams.geometryType;
//     let intervalId = null;
//     let producedCubes = [];
//     let isActive = false;
//     let remainingCount = count;

//     function start() {
//         if (isActive) return;
//         isActive = true;
//         setTimeout(() => {
//             intervalId = setInterval(() => {
//                 if (remainingCount > 0) remainingCount--;
//                 if (remainingCount === 0 && count !== 0) {
//                     pause();
//                     return;
//                 }
//                 const color = new THREE.Color(Math.random(), Math.random(), Math.random());
//                 const random = geometryParams.randomSizes;
//                 const sizeVector = random
//                     ? new THREE.Vector3(
//                         Math.random() * geometryParams.sx,
//                         Math.random() * geometryParams.sy,
//                         Math.random() * geometryParams.sz
//                     )
//                     : new THREE.Vector3(geometryParams.sx, geometryParams.sy, geometryParams.sz);
//                 const cubePosition = new THREE.Vector3(position.x, position.y, position.z);
//                 const cube = addSingleObject(currentGeometry, { ...geometryParams, sx: sizeVector.x, sy: sizeVector.y, sz: sizeVector.z }, cubePosition, color, random, speedFactor, direction, density);
//                 producedCubes.push(cube);
//             }, interTime);
//         }, delay);
//     }

//     function pause() {
//         if (intervalId) {
//             clearInterval(intervalId);
//             intervalId = null;
//             isActive = false;
//         }
//     }

//     function reset() {
//         pause();
//         producedCubes.forEach(({ mesh, rigidBody, collider }) => {
//             if (mesh) {
//                 scene.remove(mesh);
//                 const meshIndex = window.threeCubes.indexOf(mesh);
//                 if (meshIndex > -1) {
//                     window.threeCubes.splice(meshIndex, 1);
//                 }
//             }
//             if (myRapierWorld && rigidBody) {
//                 myRapierWorld.removeCollider(collider, true);
//                 myRapierWorld.removeRigidBody(rigidBody, true);
//                 const rigidBodyIndex = window.rigidBodies.indexOf(rigidBody);
//                 if (rigidBodyIndex > -1) {
//                     window.rigidBodies.splice(rigidBodyIndex, 1);
//                 }
//             }
//         });
//         producedCubes = [];
//         remainingCount = count;
//     }

//     function restart() {
//         pause();
//         remainingCount = count;
//         start();
//     }

//     function setPosition(newPosition) {
//         position = newPosition;
//     }

//     function setGeometryParams(newParams) {
//         geometryParams = { ...geometryParams, ...newParams };
//     }

//     function setGeometryType(type) {
//         currentGeometry = type;
//     }

//     function setIntervalTime(newIntervalTime) {
//         interTime = newIntervalTime;
//         if (isActive) {
//             pause();
//             start();
//         }
//     }

//     function setRandomSizes(value) {
//         geometryParams.randomSizes = value;
//     }

//     function setCount(newCount) {
//         count = Math.floor(newCount); // Ensure count is always an integer
//         remainingCount = count;
//     }

//     function setDelay(newDelay) {
//         delay = newDelay;
//     }

//     function setDirection(newDirection) {
//         direction = newDirection;
//     }

//     function setDensity(newDensity) {
//         density = newDensity;
//     }

//     function setSpeedFactor(newSpeedFactor) {
//         speedFactor = newSpeedFactor;
//     }

//     function getParams() {
//         return {
//             id,
//             x: position.x,
//             y: position.y,
//             z: position.z,
//             ...geometryParams,
//             interval: interTime,
//             delay,
//             count,
//             directionX: direction.x,
//             directionY: direction.y,
//             directionZ: direction.z,
//             speedFactor,
//             density
//         };
//     }

//     function addSingleObject(type, params, position, color, random, speedFactor, direction, density) {
//         const geometry = geometryConfig[type].create(params);
//         const bodyMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.2, roughness: 0.8, wireframe: false });
//         const bodyMesh = new THREE.Mesh(geometry, bodyMaterial);
//         bodyMesh.position.copy(position);
//         bodyMesh.castShadow = true;
//         bodyMesh.receiveShadow = true;
//         bodyMesh.type = "cb";
//         scene.add(bodyMesh);

//         let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(position.x, position.y, position.z).setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
//         let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);
//         let colliderDesc;

//         if (type === 'BoxGeometry') {
//             colliderDesc = RAPIER.ColliderDesc.cuboid(params.sx / 2, params.sy / 2, params.sz / 2).setDensity(density);
//         } else if (['SphereGeometry', 'DodecahedronGeometry', 'IcosahedronGeometry', 'OctahedronGeometry', 'TetrahedronGeometry'].includes(type)) {
//             const radius = params.radius;
//             colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
//         } else if (type === 'CapsuleGeometry') {
//             const radius = params.radius;
//             colliderDesc = RAPIER.ColliderDesc.capsule(radius, params.length / 2).setDensity(density);
//         } else if (type === 'CylinderGeometry') {
//             colliderDesc = RAPIER.ColliderDesc.cylinder(params.height / 2, params.radiusTop).setDensity(density);
//         } else if (type === 'ConeGeometry') {
//             colliderDesc = RAPIER.ColliderDesc.cone(params.height / 2, params.radius).setDensity(density);
//         } else {
//             colliderDesc = RAPIER.ColliderDesc.cuboid(params.sx / 2, params.sy / 2, params.sz / 2).setDensity(density);
//         }

//         let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);
//         rigidBody.type = "cb";
//         window.rigidBodies.push(rigidBody);
//         window.threeCubes.push(bodyMesh);

//         return { mesh: bodyMesh, rigidBody: rigidBody, collider: collider };
//     }

//     const emitterInstance = {
//         id,
//         start,
//         pause,
//         reset,
//         restart,
//         setPosition,
//         setGeometryParams,
//         setGeometryType,
//         setIntervalTime,
//         setRandomSizes,
//         setCount,
//         setDelay,
//         setDirection,
//         setDensity,
//         setSpeedFactor,
//         getParams
//     };

//     if (id) {
//         emittersMap.set(id, emitterInstance);
//     }

//     return emitterInstance;
// }

// window.cubeEmitter = cubeEmitter;

// function initEmittersEdit(guiKey, loadedEmitters = []) {
//     const container = document.getElementById("guiHolder");
//     const gui = new GUI({ width: 350, container: container });
//     guiInstances.set(guiKey, gui);

//     const emitters = [];

//     function addEmitter() {
//         const emitterParams = {
//             id: generateUniqueId(),
//             x: 0,
//             y: 0,
//             z: 0,
//             ...geometryConfig.BoxGeometry.defaultParams, // default geometry
//             geometryType: 'BoxGeometry',
//             interval: 500,
//             randomSizes: false,
//             delay: 0,
//             count: 0,
//             directionX: 0,
//             directionY: -1,
//             directionZ: 0,
//             speedFactor: 1,
//             density: 1
//         };

//         const folder = gui.addFolder('Add Emitter');
//         folder.add(emitterParams, 'geometryType', Object.keys(geometryConfig)).name('Geometry Type').onChange((newGeometryType) => {
//             Object.assign(emitterParams, geometryConfig[newGeometryType].defaultParams);
//             emitterParams.geometryType = newGeometryType;
//         });
//         folder.add({ create: () => createEmitter(emitterParams) }, 'create').name('Create Emitter');
//         folder.open();
//     }

//     function createEmitter(params) {
//         const emitterId = generateUniqueId();
//         params.id = emitterId;

//         const index = emitters.length;
//         const emitter = cubeEmitter({ ...params }, params.interval, params.delay, params.count);
//         emitter.setIntervalTime(params.interval);
//         emitter.setDelay(params.delay);
//         emitter.setCount(params.count);
//         emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//         emitter.setDensity(params.density);
//         emitter.setSpeedFactor(params.speedFactor);

//         emitters.push({ emitter, params: { ...params } }); // Ensure a deep copy of params
//         storedEmitters.push({ ...params }); // Store parameters

//         const folder = gui.addFolder(`Emitter ${params.id}`);
//         folder.add({ geometryType: params.geometryType }, 'geometryType').name('Geometry Type').listen();
//         folder.add(params, 'x', -200, 200).name('X').onChange(() => {
//             emitter.setPosition({ x: params.x, y: params.y, z: params.z });
//             updatePreviewMeshPosition(emitter.previewMesh, params);
//             updatePreviewLine(emitter.previewLine, params);
//         });
//         folder.add(params, 'y', -30, 200).name('Y').onChange(() => {
//             emitter.setPosition({ x: params.x, y: params.y, z: params.z });
//             updatePreviewMeshPosition(emitter.previewMesh, params);
//             updatePreviewLine(emitter.previewLine, params);
//         });
//         folder.add(params, 'z', -200, 200).name('Z').onChange(() => {
//             emitter.setPosition({ x: params.x, y: params.y, z: params.z });
//             updatePreviewMeshPosition(emitter.previewMesh, params);
//             updatePreviewLine(emitter.previewLine, params);
//         });

//         folder.add(params, 'randomSizes').name('Random Sizes').onChange(() => emitter.setRandomSizes(params.randomSizes));
//         folder.add(params, 'interval', 1, 5000).name('Interval (ms)').onChange(() => emitter.setIntervalTime(params.interval));
//         folder.add(params, 'delay', 0, 25000).name('Delay (ms)').onChange(() => emitter.setDelay(params.delay));
        
//         folder.add(params, 'count', 0, 10000).step(1).name('Count').onChange(() => emitter.setCount(params.count));
//         folder.add(params, 'directionX', -1, 1).name('Direction X').onChange(() => {
//             emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//             updatePreviewLine(emitter.previewLine, params);
//             updatePreviewMeshRotation(emitter.previewMesh, params);
//         });
//         folder.add(params, 'directionY', -1, 1).name('Direction Y').onChange(() => {
//             emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//             updatePreviewLine(emitter.previewLine, params);
//             updatePreviewMeshRotation(emitter.previewMesh, params);
//         });
//         folder.add(params, 'directionZ', -1, 1).name('Direction Z').onChange(() => {
//             emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//             updatePreviewLine(emitter.previewLine, params);
//             updatePreviewMeshRotation(emitter.previewMesh, params);
//         });
//         folder.add(params, 'speedFactor', 0.1, 10).name('Speed Factor').onChange(() => {
//             emitter.setSpeedFactor(params.speedFactor);
//             updatePreviewLine(emitter.previewLine, params);
//         });
//         folder.add(params, 'density', 0.1, 10).name('Density').onChange(() => emitter.setDensity(params.density));

//         addGeometrySpecificParams(folder, params, emitter);

//         folder.add({ start: () => startEmitter(index) }, 'start').name('Start');
//         folder.add({ pause: () => pauseEmitter(index) }, 'pause').name('Pause');
//         folder.add({ reset: () => resetEmitter(index, emitter.previewMesh, emitter.previewLine) }, 'reset').name('Reset');
//         folder.add({ restart: () => restartEmitter(index) }, 'restart').name('Restart');
//         folder.add({ exportEmitter: () => exportEmitter(emitterId) }, 'exportEmitter').name('Export Emitter');
//         folder.add({ removeEmitter: () => removeEmitter(index, folder) }, 'removeEmitter').name('Remove Emitter');
//         folder.open();

//         emitter.previewMesh = createStaticPreview(params);
//         emitter.previewLine = createPreviewLine(params);
//         updatePreviewMeshRotation(emitter.previewMesh, params); // Set initial rotation
//     }

//     function startAllEmitters() {
//         emitters.forEach(({ emitter }) => emitter.start());
//     }

//     function stopAllEmitters() {
//         emitters.forEach(({ emitter }) => emitter.pause());
//     }

//     function removeEmitter(index, folder) {
//         if (emitters[index]) {
//             try {
//                 const emitter = emitters[index].emitter;
//                 if (emitter) {
//                     emitter.reset();
//                     if (emitter.previewMesh) {
//                         scene.remove(emitter.previewMesh);
//                     }
//                     if (emitter.previewLine) {
//                         scene.remove(emitter.previewLine);
//                     }
//                 }
//                 if (folder) {
//                     folder.close();
//                     folder.domElement.remove();
//                     const folderName = `Emitter ${emitters[index].params.id}`;
//                     if (gui.folders[folderName]) {
//                         delete gui.folders[folderName];
//                     }
//                 }
//                 emitters.splice(index, 1);
//                 storedEmitters.splice(index, 1);
//             } catch (e) {
//                 console.error(`Error removing emitter at index ${index}:`, e);
//             }
//         }
//     }

//     function removeAllEmitters() {
//         emitters.slice().forEach((emitterData, index) => {
//             try {
//                 const emitter = emitterData.emitter;
//                 if (emitter) {
//                     emitter.reset();
//                     if (emitter.previewMesh) {
//                         scene.remove(emitter.previewMesh);
//                     }
//                     if (emitter.previewLine) {
//                         scene.remove(emitter.previewLine);
//                     }
//                 }
//                 const folderName = `Emitter ${emitterData.params.id}`;
//                 const folder = gui.folders && gui.folders[folderName];
//                 if (folder) {
//                     folder.close();
//                     folder.domElement.remove();
//                     delete gui.folders[folderName];
//                 }
//             } catch (e) {
//                 console.error(`Error removing emitter at index ${index}:`, e);
//             }
//         });

//         emitters.length = 0; // Clear the emitters array
//         storedEmitters.length = 0; // Clear the storedEmitters array
//         emittersMap.clear(); // Clear the emittersMap

//         // really dirty hack - but this is the only way so far to remove GUI folders and recreate GUI - it is actually impossible to see what is going on here
//         toggleEmittersEditGUI()
//         toggleEmittersEditGUI()

//     }

//     function exportEmitter(emitterId) {
//         const emitterObj = emitters.find(e => e.emitter.id === emitterId);
//         if (emitterObj) {
//             const params = emitterObj.emitter.getParams();
//             const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(params));
//             const downloadAnchorNode = document.createElement('a');
//             downloadAnchorNode.setAttribute("href", dataStr);
//             downloadAnchorNode.setAttribute("download", `emitter_${params.id}.json`);
//             document.body.appendChild(downloadAnchorNode);
//             downloadAnchorNode.click();
//             downloadAnchorNode.remove();
//         }
//     }

//     function exportAllEmitters() {
//         const updatedStoredEmitters = emitters.map(({ emitter }) => emitter.getParams());
//         const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(updatedStoredEmitters));
//         const now = new Date().toISOString().replace(/[:.]/g, '-');
//         const downloadAnchorNode = document.createElement('a');
//         downloadAnchorNode.setAttribute("href", dataStr);
//         downloadAnchorNode.setAttribute("download", `emitters_${now}.json`);
//         document.body.appendChild(downloadAnchorNode);
//         downloadAnchorNode.click();
//         downloadAnchorNode.remove();
//     }

//     function importEmitters() {
//         const input = document.createElement('input');
//         input.type = 'file';
//         input.accept = '.json';
//         input.onchange = e => {
//             const file = e.target.files[0];
//             const reader = new FileReader();
//             reader.onload = event => {
//                 const importedParams = JSON.parse(event.target.result);
//                 importedParams.forEach(params => createEmitter(params));
//             };
//             reader.readAsText(file);
//         };
//         input.click();
//     }

//     function addGeometrySpecificParams(folder, params, emitter) {
//         const geometryType = params.geometryType;
//         const config = geometryConfig[geometryType];

//         config.params.forEach(param => {
//             const controller = folder.add(params, param.name, param.min, param.max).name(param.name.charAt(0).toUpperCase() + param.name.slice(1));
//             if (param.step) {
//                 controller.step(param.step); // Ensure integer parameters use integer steps
//             }
//             controller.onChange(() => {
//                 const newParams = { [param.name]: params[param.name] };
//                 emitter.setGeometryParams(newParams);
//                 updatePreviewMeshGeometry(emitter.previewMesh, params);
//             });
//         });
//     }

//     function createStaticPreview(params) {
//         const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00]; // Red, Green, Blue, Yellow
//         const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
//         const geometry = createGeometry(params.geometryType, params);
//         const edges = new THREE.EdgesGeometry(geometry);
//         const material = new THREE.LineBasicMaterial({ color: color });
//         const previewMesh = new THREE.LineSegments(edges, material);
//         previewMesh.position.set(params.x, params.y, params.z);
//         scene.add(previewMesh);
//         return previewMesh;
//     }

//     function createGeometry(type, params) {
//         const config = geometryConfig[type];
//         return config.create(params);
//     }

//     function updatePreviewMeshGeometry(previewMesh, params) {
//         const newGeometry = createGeometry(params.geometryType, params);
//         const edges = new THREE.EdgesGeometry(newGeometry);
//         previewMesh.geometry.dispose();
//         previewMesh.geometry = edges;
//     }

//     function updatePreviewMeshPosition(previewMesh, params) {
//         previewMesh.position.set(params.x, params.y, params.z);
//         updatePreviewMeshRotation(previewMesh, params);
//     }

//     function updatePreviewMeshRotation(previewMesh, params) {
//         const direction = new THREE.Vector3(params.directionX, params.directionY, params.directionZ).normalize();
//         const quaternion = new THREE.Quaternion();
//         quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), direction);
//         previewMesh.quaternion.copy(quaternion);
//     }

//     function updatePreviewLine(line, params) {
//         const points = [
//             new THREE.Vector3(params.x, params.y, params.z),
//             new THREE.Vector3(params.x + params.directionX * params.speedFactor, params.y + params.directionY * params.speedFactor, params.z + params.directionZ * params.speedFactor)
//         ];
//         line.geometry.setFromPoints(points);
//     }

//     function createPreviewLine(params) {
//         const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
//         const points = [
//             new THREE.Vector3(params.x, params.y, params.z),
//             new THREE.Vector3(params.x + params.directionX * params.speedFactor, params.y + params.directionY * params.speedFactor, params.z + params.directionZ * params.speedFactor)
//         ];
//         const geometry = new THREE.BufferGeometry().setFromPoints(points);
//         const line = new THREE.Line(geometry, material);
//         scene.add(line);
//         return line;
//     }

//     function startEmitter(index) {
//         if (emitters[index]) {
//             emitters[index].emitter.start();
//         }
//     }

//     function pauseEmitter(index) {
//         if (emitters[index]) {
//             emitters[index].emitter.pause();
//         }
//     }

//     function resetEmitter(index, previewMesh, previewLine) {
//         if (emitters[index]) {
//             emitters[index].emitter.reset();
//             updatePreviewMeshPosition(previewMesh, emitters[index].params);
//             updatePreviewLine(previewLine, emitters[index].params);
//         }
//     }

//     function restartEmitter(index) {
//         if (emitters[index]) {
//             emitters[index].emitter.restart();
//         }
//     }

//     function importEmitter() {
//         const input = document.createElement('input');
//         input.type = 'file';
//         input.accept = '.json';
//         input.onchange = e => {
//             const file = e.target.files[0];
//             const reader = new FileReader();
//             reader.onload = event => {
//                 const importedParams = JSON.parse(event.target.result);
//                 createEmitter(importedParams);
//             };
//             reader.readAsText(file);
//         };
//         input.click();
//     }

//     gui.add({ importEmitters: importEmitters }, 'importEmitters').name('Load Emitters');
//     gui.add({ exportAllEmitters: exportAllEmitters }, 'exportAllEmitters').name('Export All Emitters');
//     gui.add({ importEmitter: importEmitter }, 'importEmitter').name('Import Emitter');
//     gui.add({ startAllEmitters }, 'startAllEmitters').name('Start All Emitters');
//     gui.add({ stopAllEmitters }, 'stopAllEmitters').name('Stop All Emitters');
//     gui.add({ removeAllEmitters }, 'removeAllEmitters').name('Remove All Emitters');

//     addEmitter();
//     loadedEmitters.forEach(params => createEmitter(params)); // Load emitters from JSON data if provided
//     makePanelDraggable(document.getElementById("guiOverlayInput"), document.getElementById("guiOverlayBar"));
// }

// window.initEmittersEdit = initEmittersEdit;

// function generateUniqueId() {
//     return 'emitter-' + Math.random().toString(36).substr(2, 9);
// }

// function toggleEmittersEditGUI() {
//     if (guiInstances.has('emittersEditGUI')) {
//         guiInstances.get('emittersEditGUI').destroy();
//         guiInstances.delete('emittersEditGUI');
//     } else {
//         initEmittersEdit('emittersEditGUI', storedEmitters);
//     }
// }

// window.toggleEmittersEditGUI = toggleEmittersEditGUI;

// /* Emitters Managers */

// function listEmitterIds() {
//     return Array.from(emittersMap.keys());
// }

// window.listEmitterIds = listEmitterIds;

// function triggerEmittersArrayById(ids, action) {
//     ids.forEach(id => {
//         triggerEmitterById(id, action);
//     });
// }

// window.triggerEmittersArrayById = triggerEmittersArrayById;

// function startAllEmitters() {
//     emittersMap.forEach(emitter => emitter.start());
// }

// window.startAllEmitters = startAllEmitters;

// function stopAllEmitters() {
//     emittersMap.forEach(emitter => emitter.pause());
// }

// window.stopAllEmitters = stopAllEmitters;

// function removeAllEmitters() {
//     emittersMap.forEach((emitter, id) => {
//         emitter.reset();
//         if (emitter.previewMesh) {
//             scene.remove(emitter.previewMesh);
//         }
//         if (emitter.previewLine) {
//             scene.remove(emitter.previewLine);
//         }
//         if (typeof gui !== 'undefined') {
//             const folderName = `Emitter ${id}`;
//             const folder = gui.folders.find(f => f.title === folderName);
//             if (folder) {
//                 folder.destroy();
//             }
//         }
//     });
//     emittersMap.clear(); // Clear the emittersMap
//     storedEmitters.length = 0; // Clear the storedEmitters array
// }

// window.removeAllEmitters = removeAllEmitters;

// function triggerEmitterById(id, action) {
//     const emitter = emittersMap.get(id);
//     if (!emitter) {
//         console.error(`Emitter with ID ${id} not found.`);
//         return;
//     }
//     switch(action) {
//         case 'start':
//             emitter.start();
//             break;
//         case 'pause':
//             emitter.pause();
//             break;
//         case 'reset':
//             emitter.reset();
//             break;
//         case 'restart':
//             emitter.restart();
//             break;
//         default:
//             console.error(`Invalid action: ${action}`);
//     }
// }

// window.triggerEmitterById = triggerEmitterById;

// function removeEmitterById(id) {
//     const emitter = emittersMap.get(id);
//     if (!emitter) {
//         console.error(`Emitter with ID ${id} not found.`);
//         return;
//     }
//     emitter.reset();
//     if (emitter.previewMesh) {
//         scene.remove(emitter.previewMesh);
//     }
//     if (emitter.previewLine) {
//         scene.remove(emitter.previewLine);
//     }

//     emittersMap.delete(id);
//     storedEmitters.splice(storedEmitters.findIndex(e => e.id === id), 1);

//     if (guiInstances.has('emittersEditGUI')) {
//         const gui = guiInstances.get('emittersEditGUI');
//         const folderName = `Emitter ${id}`;
//         const folder = gui.folders.find(f => f.title === folderName);
//         if (folder) {
//             folder.destroy();
//         }
//     }
// }

// window.removeEmitterById = removeEmitterById;

// function loadEmittersFromJSON(url) {
//     fetch(url)
//         .then(response => response.json())
//         .then(data => initEmittersEdit('emittersEditGUI', data))
//         .catch(error => console.error('Error loading emitters:', error));
// }

// window.loadEmittersFromJSON = loadEmittersFromJSON;

// function createEmitter(params) {
//     const emitterId = params.id || generateUniqueId();
//     params.id = emitterId;

//     const emitter = cubeEmitter(params);
//     emitter.setIntervalTime(params.interval);
//     emitter.setDelay(params.delay);
//     emitter.setCount(params.count);
//     emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//     emitter.setDensity(params.density);
//     emitter.setSpeedFactor(params.speedFactor);

//     storedEmitters.push({ ...params });

//     // start if you want on load 
//     //emitter.start();
// }

// function loadSingleEmitter(url) {
//     fetch(url)
//         .then(response => response.json())
//         .then(data => {
//             if (typeof data === 'object' && data !== null) {
//                 createEmitter(data); // Assumes the JSON is a single object
//             } else {
//                 console.error('Invalid emitter data format');
//             }
//         })
//         .catch(error => console.error('Error loading emitter:', error));
// }

// window.loadSingleEmitter = loadSingleEmitter;




// const storedEmitters = [];
// const emittersMap = new Map();

// function cubeEmitter({ x = 0, y = 3, z = 0, id, delay = 0, count = 0, speedFactor = 1, direction = { x: 0, y: -1, z: 0 }, density = 1, ...params } = {}, interTime = 2000) {
//     let position = { x, y, z };
//     let geometryParams = params;
//     let currentGeometry = geometryParams.geometryType;
//     let intervalId = null;
//     let producedCubes = [];
//     let isActive = false;
//     let remainingCount = count;

//     function start() {
//         if (isActive) return;
//         isActive = true;
//         setTimeout(() => {
//             intervalId = setInterval(() => {
//                 if (remainingCount > 0) remainingCount--;
//                 if (remainingCount === 0 && count !== 0) {
//                     pause();
//                     return;
//                 }
//                 const color = new THREE.Color(Math.random(), Math.random(), Math.random());
//                 const random = geometryParams.randomSizes;
//                 const sizeVector = random
//                     ? new THREE.Vector3(
//                         Math.random() * geometryParams.sx,
//                         Math.random() * geometryParams.sy,
//                         Math.random() * geometryParams.sz
//                     )
//                     : new THREE.Vector3(geometryParams.sx, geometryParams.sy, geometryParams.sz);
//                 const cubePosition = new THREE.Vector3(position.x, position.y, position.z);
//                 const cube = addSingleObject(currentGeometry, { ...geometryParams, sx: sizeVector.x, sy: sizeVector.y, sz: sizeVector.z }, cubePosition, color, random, speedFactor, direction, density);
//                 producedCubes.push(cube);
//             }, interTime);
//         }, delay);
//     }

//     function pause() {
//         if (intervalId) {
//             clearInterval(intervalId);
//             intervalId = null;
//             isActive = false;
//         }
//     }

//     function reset() {
//         pause();
//         producedCubes.forEach(({ mesh, rigidBody, collider }) => {
//             if (mesh) {
//                 scene.remove(mesh);
//                 const meshIndex = window.threeCubes.indexOf(mesh);
//                 if (meshIndex > -1) {
//                     window.threeCubes.splice(meshIndex, 1);
//                 }
//             }
//             if (myRapierWorld && rigidBody) {
//                 myRapierWorld.removeCollider(collider, true);
//                 myRapierWorld.removeRigidBody(rigidBody, true);
//                 const rigidBodyIndex = window.rigidBodies.indexOf(rigidBody);
//                 if (rigidBodyIndex > -1) {
//                     window.rigidBodies.splice(rigidBodyIndex, 1);
//                 }
//             }
//         });
//         producedCubes = [];
//         remainingCount = count;
//     }

//     function restart() {
//         pause();
//         remainingCount = count;
//         start();
//     }

//     function setPosition(newPosition) {
//         position = newPosition;
//     }

//     function setGeometryParams(newParams) {
//         geometryParams = { ...geometryParams, ...newParams };
//     }

//     function setGeometryType(type) {
//         currentGeometry = type;
//     }

//     function setIntervalTime(newIntervalTime) {
//         interTime = newIntervalTime;
//         if (isActive) {
//             pause();
//             start();
//         }
//     }

//     function setRandomSizes(value) {
//         geometryParams.randomSizes = value;
//     }

//     function setCount(newCount) {
//         count = Math.floor(newCount); // Ensure count is always an integer
//         remainingCount = count;
//     }

//     function setDelay(newDelay) {
//         delay = newDelay;
//     }

//     function setDirection(newDirection) {
//         direction = newDirection;
//     }

//     function setDensity(newDensity) {
//         density = newDensity;
//     }

//     function setSpeedFactor(newSpeedFactor) {
//         speedFactor = newSpeedFactor;
//     }

//     function getParams() {
//         return {
//             id,
//             x: position.x,
//             y: position.y,
//             z: position.z,
//             ...geometryParams,
//             interval: interTime,
//             delay,
//             count,
//             directionX: direction.x,
//             directionY: direction.y,
//             directionZ: direction.z,
//             speedFactor,
//             density
//         };
//     }

//     function addSingleObject(type, params, position, color, random, speedFactor, direction, density) {
//         const geometry = geometryConfig[type].create(params);
//         const bodyMaterial = new THREE.MeshStandardMaterial({ color: color, metalness: 0.2, roughness: 0.8, wireframe: false });
//         const bodyMesh = new THREE.Mesh(geometry, bodyMaterial);
//         bodyMesh.position.copy(position);
//         bodyMesh.castShadow = true;
//         bodyMesh.receiveShadow = true;
//         bodyMesh.type = "cb";
//         scene.add(bodyMesh);

//         let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(position.x, position.y, position.z).setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
//         let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);
//         let colliderDesc;

//         if (type === 'BoxGeometry') {
//             colliderDesc = RAPIER.ColliderDesc.cuboid(params.sx / 2, params.sy / 2, params.sz / 2).setDensity(density);
//         } else if (['SphereGeometry', 'DodecahedronGeometry', 'IcosahedronGeometry', 'OctahedronGeometry', 'TetrahedronGeometry'].includes(type)) {
//             const radius = params.radius;
//             colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
//         } else if (type === 'CapsuleGeometry') {
//             const radius = params.radius;
//             colliderDesc = RAPIER.ColliderDesc.capsule(radius, params.length / 2).setDensity(density);
//         } else if (type === 'CylinderGeometry') {
//             colliderDesc = RAPIER.ColliderDesc.cylinder(params.height / 2, params.radiusTop).setDensity(density);
//         } else if (type === 'ConeGeometry') {
//             colliderDesc = RAPIER.ColliderDesc.cone(params.height / 2, params.radius).setDensity(density);
//         } else {
//             colliderDesc = RAPIER.ColliderDesc.cuboid(params.sx / 2, params.sy / 2, params.sz / 2).setDensity(density);
//         }

//         let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);
//         rigidBody.type = "cb";
//         window.rigidBodies.push(rigidBody);
//         window.threeCubes.push(bodyMesh);

//         return { mesh: bodyMesh, rigidBody: rigidBody, collider: collider };
//     }

//     const emitterInstance = {
//         id,
//         start,
//         pause,
//         reset,
//         restart,
//         setPosition,
//         setGeometryParams,
//         setGeometryType,
//         setIntervalTime,
//         setRandomSizes,
//         setCount,
//         setDelay,
//         setDirection,
//         setDensity,
//         setSpeedFactor,
//         getParams
//     };

//     if (id) {
//         emittersMap.set(id, emitterInstance);
//     }

//     return emitterInstance;
// }

// window.cubeEmitter = cubeEmitter;

// function initEmittersEdit(guiKey, loadedEmitters = []) {
//     const container = document.getElementById("guiHolder");
//     const gui = new GUI({ width: 350, container: container });
//     guiInstances.set(guiKey, gui);

//     const emitters = [];

//     function addEmitter() {
//         const emitterParams = {
//             id: generateUniqueId(),
//             x: 0,
//             y: 0,
//             z: 0,
//             ...geometryConfig.BoxGeometry.defaultParams, // default geometry
//             geometryType: 'BoxGeometry',
//             interval: 500,
//             randomSizes: false,
//             delay: 0,
//             count: 0,
//             directionX: 0,
//             directionY: -1,
//             directionZ: 0,
//             speedFactor: 1,
//             density: 1
//         };

//         const folder = gui.addFolder('Add Emitter');
//         folder.add(emitterParams, 'geometryType', Object.keys(geometryConfig)).name('Geometry Type').onChange((newGeometryType) => {
//             Object.assign(emitterParams, geometryConfig[newGeometryType].defaultParams);
//             emitterParams.geometryType = newGeometryType;
//         });
//         folder.add({ create: () => createEmitter(emitterParams) }, 'create').name('Create Emitter');
//         folder.open();
//     }

//     function createEmitter(params) {
//         const emitterId = generateUniqueId();
//         params.id = emitterId;

//         const index = emitters.length;
//         const emitter = cubeEmitter({ ...params }, params.interval, params.delay, params.count);
//         emitter.setIntervalTime(params.interval);
//         emitter.setDelay(params.delay);
//         emitter.setCount(params.count);
//         emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//         emitter.setDensity(params.density);
//         emitter.setSpeedFactor(params.speedFactor);

//         emitters.push({ emitter, params: { ...params } }); // Ensure a deep copy of params
//         storedEmitters.push({ ...params }); // Store parameters

//         const folder = gui.addFolder(`Emitter ${params.id}`);
//         folder.add({ geometryType: params.geometryType }, 'geometryType').name('Geometry Type').listen();
//         folder.add(params, 'x', -200, 200).name('X').onChange(() => {
//             emitter.setPosition({ x: params.x, y: params.y, z: params.z });
//             updatePreviewMeshPosition(emitter.previewMesh, params);
//             updatePreviewLine(emitter.previewLine, params);
//         });
//         folder.add(params, 'y', -30, 200).name('Y').onChange(() => {
//             emitter.setPosition({ x: params.x, y: params.y, z: params.z });
//             updatePreviewMeshPosition(emitter.previewMesh, params);
//             updatePreviewLine(emitter.previewLine, params);
//         });
//         folder.add(params, 'z', -200, 200).name('Z').onChange(() => {
//             emitter.setPosition({ x: params.x, y: params.y, z: params.z });
//             updatePreviewMeshPosition(emitter.previewMesh, params);
//             updatePreviewLine(emitter.previewLine, params);
//         });

//         folder.add(params, 'randomSizes').name('Random Sizes').onChange(() => emitter.setRandomSizes(params.randomSizes));
//         folder.add(params, 'interval', 1, 5000).name('Interval (ms)').onChange(() => emitter.setIntervalTime(params.interval));
//         folder.add(params, 'delay', 0, 25000).name('Delay (ms)').onChange(() => emitter.setDelay(params.delay));
        
//         folder.add(params, 'count', 0, 10000).step(1).name('Count').onChange(() => emitter.setCount(params.count));
//         folder.add(params, 'directionX', -1, 1).name('Direction X').onChange(() => {
//             emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//             updatePreviewLine(emitter.previewLine, params);
//             updatePreviewMeshRotation(emitter.previewMesh, params);
//         });
//         folder.add(params, 'directionY', -1, 1).name('Direction Y').onChange(() => {
//             emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//             updatePreviewLine(emitter.previewLine, params);
//             updatePreviewMeshRotation(emitter.previewMesh, params);
//         });
//         folder.add(params, 'directionZ', -1, 1).name('Direction Z').onChange(() => {
//             emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//             updatePreviewLine(emitter.previewLine, params);
//             updatePreviewMeshRotation(emitter.previewMesh, params);
//         });
//         folder.add(params, 'speedFactor', 0.1, 10).name('Speed Factor').onChange(() => {
//             emitter.setSpeedFactor(params.speedFactor);
//             updatePreviewLine(emitter.previewLine, params);
//         });
//         folder.add(params, 'density', 0.1, 10).name('Density').onChange(() => emitter.setDensity(params.density));

//         addGeometrySpecificParams(folder, params, emitter);

//         folder.add({ start: () => startEmitter(index) }, 'start').name('Start');
//         folder.add({ pause: () => pauseEmitter(index) }, 'pause').name('Pause');
//         folder.add({ reset: () => resetEmitter(index, emitter.previewMesh, emitter.previewLine) }, 'reset').name('Reset');
//         folder.add({ restart: () => restartEmitter(index) }, 'restart').name('Restart');
//         folder.add({ exportEmitter: () => exportEmitter(emitterId) }, 'exportEmitter').name('Export Emitter');
//         folder.add({ removeEmitter: () => removeEmitter(index, folder) }, 'removeEmitter').name('Remove Emitter');
//         folder.open();

//         emitter.previewMesh = createStaticPreview(params);
//         emitter.previewLine = createPreviewLine(params);
//     }

//     function startAllEmitters() {
//         emitters.forEach(({ emitter }) => emitter.start());
//     }

//     function stopAllEmitters() {
//         emitters.forEach(({ emitter }) => emitter.pause());
//     }

//     function removeEmitter(index, folder) {
//         if (emitters[index]) {
//             try {
//                 const emitter = emitters[index].emitter;
//                 if (emitter) {
//                     emitter.reset();
//                     if (emitter.previewMesh) {
//                         scene.remove(emitter.previewMesh);
//                     }
//                     if (emitter.previewLine) {
//                         scene.remove(emitter.previewLine);
//                     }
//                 }
//                 if (folder) {
//                     folder.close();
//                     folder.domElement.remove();
//                     const folderName = `Emitter ${emitters[index].params.id}`;
//                     if (gui.folders[folderName]) {
//                         delete gui.folders[folderName];
//                     }
//                 }
//                 emitters.splice(index, 1);
//                 storedEmitters.splice(index, 1);
//             } catch (e) {
//                 console.error(`Error removing emitter at index ${index}:`, e);
//             }
//         }
//     }

//     function removeAllEmitters() {
//         emitters.slice().forEach((emitterData, index) => {
//             try {
//                 const emitter = emitterData.emitter;
//                 if (emitter) {
//                     emitter.reset();
//                     if (emitter.previewMesh) {
//                         scene.remove(emitter.previewMesh);
//                     }
//                     if (emitter.previewLine) {
//                         scene.remove(emitter.previewLine);
//                     }
//                 }
//                 const folderName = `Emitter ${emitterData.params.id}`;
//                 const folder = gui.folders && gui.folders[folderName];
//                 if (folder) {
//                     folder.close();
//                     folder.domElement.remove();
//                     delete gui.folders[folderName];
//                 }
//             } catch (e) {
//                 console.error(`Error removing emitter at index ${index}:`, e);
//             }
//         });

//         emitters.length = 0; // Clear the emitters array
//         storedEmitters.length = 0; // Clear the storedEmitters array
//         emittersMap.clear(); // Clear the emittersMap

//         // really dirty hack - but this is the only way so far to remove GUI folders and recreate GUI - it is actually impossible to see what is going on here
//         toggleEmittersEditGUI()
//         toggleEmittersEditGUI()

//     }

//     function exportEmitter(emitterId) {
//         const emitterObj = emitters.find(e => e.emitter.id === emitterId);
//         if (emitterObj) {
//             const params = emitterObj.emitter.getParams();
//             const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(params));
//             const downloadAnchorNode = document.createElement('a');
//             downloadAnchorNode.setAttribute("href", dataStr);
//             downloadAnchorNode.setAttribute("download", `emitter_${params.id}.json`);
//             document.body.appendChild(downloadAnchorNode);
//             downloadAnchorNode.click();
//             downloadAnchorNode.remove();
//         }
//     }

//     function exportAllEmitters() {
//         const updatedStoredEmitters = emitters.map(({ emitter }) => emitter.getParams());
//         const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(updatedStoredEmitters));
//         const now = new Date().toISOString().replace(/[:.]/g, '-');
//         const downloadAnchorNode = document.createElement('a');
//         downloadAnchorNode.setAttribute("href", dataStr);
//         downloadAnchorNode.setAttribute("download", `emitters_${now}.json`);
//         document.body.appendChild(downloadAnchorNode);
//         downloadAnchorNode.click();
//         downloadAnchorNode.remove();
//     }

//     function importEmitters() {
//         const input = document.createElement('input');
//         input.type = 'file';
//         input.accept = '.json';
//         input.onchange = e => {
//             const file = e.target.files[0];
//             const reader = new FileReader();
//             reader.onload = event => {
//                 const importedParams = JSON.parse(event.target.result);
//                 importedParams.forEach(params => createEmitter(params));
//             };
//             reader.readAsText(file);
//         };
//         input.click();
//     }

//     function addGeometrySpecificParams(folder, params, emitter) {
//         const geometryType = params.geometryType;
//         const config = geometryConfig[geometryType];

//         config.params.forEach(param => {
//             const controller = folder.add(params, param.name, param.min, param.max).name(param.name.charAt(0).toUpperCase() + param.name.slice(1));
//             if (param.step) {
//                 controller.step(param.step); // Ensure integer parameters use integer steps
//             }
//             controller.onChange(() => {
//                 const newParams = { [param.name]: params[param.name] };
//                 emitter.setGeometryParams(newParams);
//                 updatePreviewMeshGeometry(emitter.previewMesh, params);
//             });
//         });
//     }

//     function createStaticPreview(params) {
//         const colors = [0xff0000, 0x00ff00, 0x0000ff, 0xffff00]; // Red, Green, Blue, Yellow
//         const color = new THREE.Color(colors[Math.floor(Math.random() * colors.length)]);
//         const geometry = createGeometry(params.geometryType, params);
//         const edges = new THREE.EdgesGeometry(geometry);
//         const material = new THREE.LineBasicMaterial({ color: color });
//         const previewMesh = new THREE.LineSegments(edges, material);
//         previewMesh.position.set(params.x, params.y, params.z);
//         scene.add(previewMesh);
//         return previewMesh;
//     }

//     function createGeometry(type, params) {
//         const config = geometryConfig[type];
//         return config.create(params);
//     }

//     function updatePreviewMeshGeometry(previewMesh, params) {
//         const newGeometry = createGeometry(params.geometryType, params);
//         const edges = new THREE.EdgesGeometry(newGeometry);
//         previewMesh.geometry.dispose();
//         previewMesh.geometry = edges;
//     }

//     // function updatePreviewMeshPosition(previewMesh, params) {
//     //     previewMesh.position.set(params.x, params.y, params.z);
//     // }

//     function updatePreviewMeshPosition(previewMesh, params) {
//         previewMesh.position.set(params.x, params.y, params.z);
//         updatePreviewMeshRotation(previewMesh, params);
//     }

//     function updatePreviewMeshRotation(previewMesh, params) {
//         const direction = new THREE.Vector3(params.directionX, params.directionY, params.directionZ).normalize();
//         const quaternion = new THREE.Quaternion();
//         quaternion.setFromUnitVectors(new THREE.Vector3(0, -1, 0), direction);
//         previewMesh.quaternion.copy(quaternion);
//     }

//     function updatePreviewLine(line, params) {
//         const points = [
//             new THREE.Vector3(params.x, params.y, params.z),
//             new THREE.Vector3(params.x + params.directionX * params.speedFactor, params.y + params.directionY * params.speedFactor, params.z + params.directionZ * params.speedFactor)
//         ];
//         line.geometry.setFromPoints(points);
//     }


//     function createPreviewLine(params) {
//         const material = new THREE.LineBasicMaterial({ color: 0x0000ff });
//         const points = [
//             new THREE.Vector3(params.x, params.y, params.z),
//             new THREE.Vector3(params.x + params.directionX * params.speedFactor, params.y + params.directionY * params.speedFactor, params.z + params.directionZ * params.speedFactor)
//         ];
//         const geometry = new THREE.BufferGeometry().setFromPoints(points);
//         const line = new THREE.Line(geometry, material);
//         scene.add(line);
//         return line;
//     }


//     function startEmitter(index) {
//         if (emitters[index]) {
//             emitters[index].emitter.start();
//         }
//     }

//     function pauseEmitter(index) {
//         if (emitters[index]) {
//             emitters[index].emitter.pause();
//         }
//     }

//     function resetEmitter(index, previewMesh, previewLine) {
//         if (emitters[index]) {
//             emitters[index].emitter.reset();
//             scene.remove(previewMesh);
//             scene.remove(previewLine);
//             emitters[index].emitter.previewMesh = createStaticPreview(emitters[index].params);
//             emitters[index].emitter.previewLine = createPreviewLine(emitters[index].params);
//         }
//     }

//     function restartEmitter(index) {
//         if (emitters[index]) {
//             emitters[index].emitter.restart();
//         }
//     }

//     function importEmitter() {
//         const input = document.createElement('input');
//         input.type = 'file';
//         input.accept = '.json';
//         input.onchange = e => {
//             const file = e.target.files[0];
//             const reader = new FileReader();
//             reader.onload = event => {
//                 const importedParams = JSON.parse(event.target.result);
//                 createEmitter(importedParams);
//             };
//             reader.readAsText(file);
//         };
//         input.click();
//     }

//     gui.add({ importEmitters: importEmitters }, 'importEmitters').name('Load Emitters');
//     gui.add({ exportAllEmitters: exportAllEmitters }, 'exportAllEmitters').name('Export All Emitters');
//     gui.add({ importEmitter: importEmitter }, 'importEmitter').name('Import Emitter');
//     gui.add({ startAllEmitters }, 'startAllEmitters').name('Start All Emitters');
//     gui.add({ stopAllEmitters }, 'stopAllEmitters').name('Stop All Emitters');
//     gui.add({ removeAllEmitters }, 'removeAllEmitters').name('Remove All Emitters');

//     addEmitter();
//     loadedEmitters.forEach(params => createEmitter(params)); // Load emitters from JSON data if provided
//     makePanelDraggable(document.getElementById("guiOverlayInput"), document.getElementById("guiOverlayBar"));
// }

// window.initEmittersEdit = initEmittersEdit;

// function generateUniqueId() {
//     return 'emitter-' + Math.random().toString(36).substr(2, 9);
// }

// function toggleEmittersEditGUI() {
//     if (guiInstances.has('emittersEditGUI')) {
//         guiInstances.get('emittersEditGUI').destroy();
//         guiInstances.delete('emittersEditGUI');
//     } else {
//         initEmittersEdit('emittersEditGUI', storedEmitters);
//     }
// }

// window.toggleEmittersEditGUI = toggleEmittersEditGUI;

// /* Emitters Managers */

// function listEmitterIds() {
//     return Array.from(emittersMap.keys());
// }

// window.listEmitterIds = listEmitterIds;

// function triggerEmittersArrayById(ids, action) {
//     ids.forEach(id => {
//         triggerEmitterById(id, action);
//     });
// }

// window.triggerEmittersArrayById = triggerEmittersArrayById;

// function startAllEmitters() {
//     emittersMap.forEach(emitter => emitter.start());
// }

// window.startAllEmitters = startAllEmitters;

// function stopAllEmitters() {
//     emittersMap.forEach(emitter => emitter.pause());
// }

// window.stopAllEmitters = stopAllEmitters;

// function removeAllEmitters() {
//     emittersMap.forEach((emitter, id) => {
//         emitter.reset();
//         if (emitter.previewMesh) {
//             scene.remove(emitter.previewMesh);
//         }
//         if (emitter.previewLine) {
//             scene.remove(emitter.previewLine);
//         }
//         if (typeof gui !== 'undefined') {
//             const folderName = `Emitter ${id}`;
//             const folder = gui.folders.find(f => f.title === folderName);
//             if (folder) {
//                 folder.destroy();
//             }
//         }
//     });
//     emittersMap.clear(); // Clear the emittersMap
//     storedEmitters.length = 0; // Clear the storedEmitters array
// }

// window.removeAllEmitters = removeAllEmitters;

// function triggerEmitterById(id, action) {
//     const emitter = emittersMap.get(id);
//     if (!emitter) {
//         console.error(`Emitter with ID ${id} not found.`);
//         return;
//     }
//     switch(action) {
//         case 'start':
//             emitter.start();
//             break;
//         case 'pause':
//             emitter.pause();
//             break;
//         case 'reset':
//             emitter.reset();
//             break;
//         case 'restart':
//             emitter.restart();
//             break;
//         default:
//             console.error(`Invalid action: ${action}`);
//     }
// }

// window.triggerEmitterById = triggerEmitterById;

// function removeEmitterById(id) {
//     const emitter = emittersMap.get(id);
//     if (!emitter) {
//         console.error(`Emitter with ID ${id} not found.`);
//         return;
//     }
//     emitter.reset();
//     if (emitter.previewMesh) {
//         scene.remove(emitter.previewMesh);
//     }
//     if (emitter.previewLine) {
//         scene.remove(emitter.previewLine);
//     }

//     emittersMap.delete(id);
//     storedEmitters.splice(storedEmitters.findIndex(e => e.id === id), 1);

//     if (guiInstances.has('emittersEditGUI')) {
//         const gui = guiInstances.get('emittersEditGUI');
//         const folderName = `Emitter ${id}`;
//         const folder = gui.folders.find(f => f.title === folderName);
//         if (folder) {
//             folder.destroy();
//         }
//     }
// }

// window.removeEmitterById = removeEmitterById;

// function loadEmittersFromJSON(url) {
//     fetch(url)
//         .then(response => response.json())
//         .then(data => initEmittersEdit('emittersEditGUI', data))
//         .catch(error => console.error('Error loading emitters:', error));
// }

// window.loadEmittersFromJSON = loadEmittersFromJSON;

// function createEmitter(params) {
//     const emitterId = params.id || generateUniqueId();
//     params.id = emitterId;

//     const emitter = cubeEmitter(params);
//     emitter.setIntervalTime(params.interval);
//     emitter.setDelay(params.delay);
//     emitter.setCount(params.count);
//     emitter.setDirection({ x: params.directionX, y: params.directionY, z: params.directionZ });
//     emitter.setDensity(params.density);
//     emitter.setSpeedFactor(params.speedFactor);

//     storedEmitters.push({ ...params });

//     // start if you want on load 
//     //emitter.start();
// }

// function loadSingleEmitter(url) {
//     fetch(url)
//         .then(response => response.json())
//         .then(data => {
//             if (typeof data === 'object' && data !== null) {
//                 createEmitter(data); // Assumes the JSON is a single object
//             } else {
//                 console.error('Invalid emitter data format');
//             }
//         })
//         .catch(error => console.error('Error loading emitter:', error));
// }

// window.loadSingleEmitter = loadSingleEmitter;









/* 

    Game Timer GUI with Event Handlers
    ----------------------------------------------- 

    */

function gameTimerEdit(guiKey) {
    const container = document.getElementById("guiHolder");

    const gui = new GUI({ width: 350, container: container });
    guiInstances.set(guiKey, gui);

    const timerParams = {
        totalTime: 0,
        remainingTime: 0,
        isActive: false,
        intervalId: null,
        status: 'Stopped',
        formattedTime: '00:00:00'
    };

    const timerEvents = {
        onTimerStart: () => console.log('Timer started'),
        onTimerEnd: () => console.log('Timer ended'),
        onTimerPaused: () => console.log('Timer paused')
    };

    function formatTime(seconds) {
        const h = Math.floor(seconds / 3600).toString().padStart(2, '0');
        const m = Math.floor((seconds % 3600) / 60).toString().padStart(2, '0');
        const s = (seconds % 60).toString().padStart(2, '0');
        return `${h}:${m}:${s}`;
    }

    function updateTimeDisplay() {
        timerParams.remainingTime = Math.max(0, timerParams.remainingTime);
        timerParams.formattedTime = formatTime(timerParams.remainingTime);
        statusController.updateDisplay();
        timeController.updateDisplay();
    }

    function startTimer() {
        if (timerParams.isActive) return;
        timerParams.isActive = true;
        timerParams.status = 'Running';
        timerEvents.onTimerStart(); // Trigger onTimerStart event
        timerParams.intervalId = setInterval(() => {
            timerParams.remainingTime -= 1;
            updateTimeDisplay();
            if (timerParams.remainingTime <= 0) {
                pauseTimer();
                timerEvents.onTimerEnd(); // Trigger onTimerEnd event
            }
        }, 1000);
        statusController.updateDisplay();
    }

    function pauseTimer() {
        if (timerParams.intervalId) {
            clearInterval(timerParams.intervalId);
            timerParams.intervalId = null;
            timerParams.isActive = false;
            timerParams.status = 'Paused';
            timerEvents.onTimerPaused(); // Trigger onTimerPaused event
            statusController.updateDisplay();
        }
    }

    function resetTimer() {
        pauseTimer();
        timerParams.remainingTime = timerParams.totalTime;
        timerParams.status = 'Stopped';
        updateTimeDisplay();
        statusController.updateDisplay();
    }

    const folder = gui.addFolder('Game Timer');
    folder.add(timerParams, 'totalTime', 0, 1000).name('Total Time (sec)').onChange(value => {
        timerParams.totalTime = Math.floor(value);
        resetTimer();
    });

    folder.add({ start: startTimer }, 'start').name('Start');
    folder.add({ pause: pauseTimer }, 'pause').name('Pause');
    folder.add({ reset: resetTimer }, 'reset').name('Reset');

    const statusController = folder.add(timerParams, 'status').name('Status').listen();
    const timeController = folder.add(timerParams, 'formattedTime').name('Time Left').listen();

    folder.add({ close: () => toggleGameTimerGUI() }, 'close').name('CLOSE');
    folder.open();

    // Adding event handlers to GUI
    const eventFolder = gui.addFolder('Event Handlers');
    eventFolder.add(timerEvents, 'onTimerStart').name('On Timer Start');
    eventFolder.add(timerEvents, 'onTimerEnd').name('On Timer End');
    eventFolder.add(timerEvents, 'onTimerPaused').name('On Timer Paused');
    eventFolder.open();

    resetTimer();
}

function toggleGameTimerGUI() {
    if (guiInstances.has('gameTimerGUI')) {
        guiInstances.get('gameTimerGUI').destroy();
        guiInstances.delete('gameTimerGUI');
    } else {
        gameTimerEdit('gameTimerGUI');
    }
}

window.toggleGameTimerGUI = toggleGameTimerGUI;











/* 

    World / Ground
    ----------------------------------------------- 

    */



let groundHeight = 0;
let gravity = { x: 0.0, y: -2, z: 0.0 };
let eventQueue

window.myRapierWorld

window.rigidBodies = window.rigidBodies || [];
window.threeCubes = window.threeCubes || [];

let obstacles = [];
let groundObjects = [];

//let ground = "static/models/grounds/simple-ground-3.glb";
let ground = "static/models/grounds/glass-glass-double2.glb";



/* 

    Init Rapier
    ----------------------------------------------- 

    */




function updateRapier() {

    if (window.myRapierWorld && window.rigidBodies) {
        //window.myRapierWorld.step();
        window.myRapierWorld.step(window.eventQueue);
        //console.log(window.rigidBodies)

        for(let i = 0; i < window.rigidBodies.length; i++) {
            if(window.rigidBodies[i].bodyType() == 0) {
                let position = window.rigidBodies[i].translation();
                window.threeCubes[i].position.set(position.x, position.y, position.z);
                // Add this part to update the rotation
                let rotation = window.rigidBodies[i].rotation(); // Assuming the rotation method returns a quaternion
                window.threeCubes[i].quaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
            }
        }

        logRapierEvents()
        //updateRigidBodies();
        //updateDummyAvatar();
    }
}


function logRapierEvents() {
    window.eventQueue.drainCollisionEvents((handle1, handle2, started) => {
        const object1Data = window.handleToObjectMap.get(handle1);
        const object2Data = window.handleToObjectMap.get(handle2);

        if (object1Data && object2Data) {
            const name1 = object1Data.name || 'Unnamed Object 1';
            const name2 = object2Data.name || 'Unnamed Object 2';

            // Use getWorldPosition to get the actual world position of the objects
            const worldPosition1 = new THREE.Vector3();
            const worldPosition2 = new THREE.Vector3();
            object1Data.object.getWorldPosition(worldPosition1);
            object2Data.object.getWorldPosition(worldPosition2);

            // console.log(`Collision ${started ? 'started' : 'ended'} between ${name1} and ${name2}`);
            //console.log(`Position of ${name1}: x=${worldPosition1.x}, y=${worldPosition1.y}, z=${worldPosition1.z}`);
            //console.log(`Position of ${name2}: x=${worldPosition2.x}, y=${worldPosition2.y}, z=${worldPosition2.z}`);

            if (started) {


                //makeExplosion(worldPosition2);
                


                //console.log(`Hit ${name1}: ${worldPosition1.x}, ${worldPosition1.y}, ${worldPosition1.z}`);
                //console.log(`Target ${name2}: ${worldPosition2.x}, ${worldPosition2.y}, ${worldPosition2.z}`);
                console.log(`Hit | ${name2} => ${name1} | :${Math.floor(worldPosition2.x)}, ${Math.floor(worldPosition2.y)}, ${Math.floor(worldPosition2.z)}`);


                // hit sound
                // fxPip({
                //     frequency: 200 - Math.random()*100,
                //     volume: 1,
                //     duration: 100,
                //     type: 'square',
                //     fadeInPercent: 0,
                //     fadeOutPercent: 90,
                //     filterType: 'bandpass',
                //     filterFrequency: 1000,
                //     filterQ: 10
                // }); 

                // Play positional sound


                // SoundManager.playPositionalSound('blip', worldPosition2, {
                //     initialFrequency: 50 - Math.random() * 10,
                //     volume: 1,
                //     duration: 0.05,
                //     type: 'square',
                //     fadeInPercent: 0,
                //     fadeOutPercent: 90,
                //     filterType: 'bandpass',
                //     filterFrequency: 50,
                //     filterQ: 10
                // });



            }
        } else {
            //console.log("Could not find object data for one or both handles.");
        }
    });
}


let world 

window.myRapierWorld
window.rigidBodies = window.rigidBodies || [];
window.threeCubes = window.threeCubes || [];


async function initRapier() {
    
    console.log("initRapier, gravity", gravity);

    await RAPIER.init();

    world = new RAPIER.World(gravity);

    eventQueue = new RAPIER.EventQueue(true);


    loadStaticGroundModel(ground);

}


window.objectRigidBodyMap = new Map();


function needsColliderUpdate(threeObject) {
    // Implement logic to determine if the collider needs to be updated
    // This could be based on comparing the current scale with the original scale
}

function updateColliderForScale(threeObject, rigidBody) {
    // Remove the old collider from the rigid body
    // ...

    // Create a new collider with the updated scale
    // This will typically involve creating a new shape (e.g., TriMesh) with the scaled geometry
    // and then attaching it to the rigid body
    // ...
}


function updateRigidBodies() {

    window.objectRigidBodyMap.forEach((rigidBody, threeObject) => {
        // Get world position and quaternion
        const worldPosition = new THREE.Vector3();
        const worldQuaternion = new THREE.Quaternion();

        threeObject.getWorldPosition(worldPosition);
        threeObject.getWorldQuaternion(worldQuaternion);

        // Update position and rotation in Rapier
        rigidBody.setTranslation(worldPosition, true);
        rigidBody.setRotation({ w: worldQuaternion.w, x: worldQuaternion.x, y: worldQuaternion.y, z: worldQuaternion.z });


        if (needsColliderUpdate(threeObject)) {
            // Remove old collider and create a new one with updated scale
            updateColliderForScale(threeObject, rigidBody);
        }        

        //console.log("updateRigidBodies", worldPosition, worldQuaternion);
    });

}



/* 

    Loaders
    ----------------------------------------------- 

    */


const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('./static/libs/draco/');
const loader = new GLTFLoader();
loader.setDRACOLoader(dracoLoader);


function loadStaticGroundModel(ground) {


    loader.load(ground, gltf => {

        let mesh = gltf.scene
        mesh.name = "PAD"
        mesh.ignore = true;

        scene.add(mesh);

        mesh.rotation.y = 0;
        groundObjects.push(mesh)

        gltf.scene.traverse(item => {
            if (item.isMesh) {
            // if (item.isMesh && Array.isArray(item.material)) {
            //     item.material.forEach(mat => {
            //         console.log(mat.name)
            //         if (mat.name === "Material.002") {
            //             waterMaterial = mat; // Store the reference
            //         }
            //     });
            // }
            // if (Array.isArray(item.material)) {
            //     item.material.forEach((mat, index) => {
            //         console.log(`Material ${index} on mesh ${item.name}:`, mat.name);
            //             if (mat.name === "Material.001") {
            //                 console.log("material")
            //                 waterMaterial = mat; // Store the reference
            //             }
            //     });
            // } else {
            //     // Single material
            //     // console.log("Single material on mesh", item.name, ":", item.material.name);
            //             if (item.material.name === "Material.003") {
            //                 //console.log("material")
            //                 waterMaterial = item.material; // Store the reference
            //                 window.waterMaterial = waterMaterial;
            //             }                    
            // }
                //console.log("isMesh:", item.name)
                const geometry = item.geometry;
                item.castShadow = true;     // allows the node to cast shadows
                item.receiveShadow = true;                 
                // swap material for refractions
                // item.material = new THREE.MeshPhongMaterial({ 
                //     transparent: true,  opacity: 0.1, 
                //     color: 0xFFFFFF
                //     //color: 0xFFFFFF, envMap: envMap1, refractionRatio: 0.98, reflectivity: 0.98
                // });
                //item.material = shaderMaterial;
                console.log(geometry)
                const vertices = geometry.attributes.position.array;
                const indices = geometry.index.array;
                const trimesh = new RAPIER.TriMesh(vertices, indices);
                //console.log('TriMesh created successfully', trimesh);
                //console.log('Vertices length:', vertices.length);
                //console.log('Indices length:', indices.length);
                let groundColliderDesc = RAPIER.ColliderDesc.trimesh(trimesh)
                    .setDensity(100)
                    .setTranslation(0, groundHeight, 0)
                    .setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
                // this part is a kind of hack...
                groundColliderDesc.shape.indices = indices;
                groundColliderDesc.shape.vertices = vertices;
                let groundCollider = world.createCollider(groundColliderDesc);
                window.groundColliderHandle = groundCollider.handle;

                window.myRapierWorld = world;
                
                window.eventQueue = eventQueue;
                item.material.wireframe = false;
                
                // this enabled that ground is a subject to teleportation
                teleportTargets.push(item);
            }

            //setTimeout(connectWebSocket, 1000);


        })


    })

}


/* 

    Env Map - nice 360 seamless backgrounds
    ----------------------------------------------- 

    */

let envMaterial;
let pmremGenerator, envMap
let backgroundBlurriness = 0.2;
let backgroundIntensity = 1.1


function addEnvMap() {


    let filePath = './static/models/environments/ai3.webp';
    //let filePath = './static/models/environments/hdr/beach.hdr';

    const fileExtension = filePath.split('.').pop().toLowerCase();

    let loader;

    // Choose the loader based on the file extension
    if (fileExtension === 'hdr') {
        loader = new RGBELoader();
    } else {
        loader = new THREE.TextureLoader();
    }

    loader.load(filePath, function(texture) {

            texture.minFilter = THREE.LinearFilter;
            texture.magFilter = THREE.LinearFilter;


        // Special handling for HDR textures
        if (fileExtension === 'hdr') {


            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
        } else {
            // For non-HDR images, use a CubeTexture if needed
            const renderTarget = new THREE.WebGLCubeRenderTarget(texture.image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            texture = renderTarget.texture;
            scene.background = texture;
        }

        // Apply to materials as envMap
        envMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            metalness: 0.7,
            roughness: 0.3,
            envMap: texture
        });

        // Example: Add a sphere to the scene
        const sphereGeometry = new THREE.SphereGeometry(40, 120, 80);
        const sphere = new THREE.Mesh(sphereGeometry, envMaterial);
        //scene.add(sphere);

        scene.backgroundBlurriness = backgroundBlurriness;
        scene.backgroundIntensity = backgroundIntensity;


        // ENV
        // - ON -
        pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        envMap = pmremGenerator.fromEquirectangular(texture).texture;
        scene.environment = envMap;

        texture.dispose(); // Optional: Dispose the original texture to free memory
        pmremGenerator.dispose(); // Dispose PMREMGenerator when done

    });

}

window.addEnvMap = addEnvMap


function changeEnvMap(filePath) {
    let renderer = renderer;

    // Determine the file extension
    const fileExtension = filePath.split('.').pop().toLowerCase();

    let loader;

    // Choose the loader based on the file extension
    if (fileExtension === 'hdr') {
        loader = new RGBELoader();
    } else {
        loader = new THREE.TextureLoader();
    }

    loader.load(filePath, function(texture) {
        // Special handling for HDR textures
        if (fileExtension === 'hdr') {
            texture.mapping = THREE.EquirectangularReflectionMapping;
            scene.background = texture;
        } else {
            // For non-HDR images, use a CubeTexture if needed
            const renderTarget = new THREE.WebGLCubeRenderTarget(texture.image.height);
            renderTarget.fromEquirectangularTexture(renderer, texture);
            scene.background = renderTarget.texture;
        }
    });
}

window.changeEnvMap = changeEnvMap;









/* 

    Init Controlllers
    ----------------------------------------------- 

    */



/* Light settings */

const modelsCastShadow = true;
const lightShadowMapSizeF = 10;

const tronLegacyColors = {
    
    deepBlack: 0x0a0a0a,
    greyMetallic: 0x6f6f6f,
    darkGrey: 0x1c1c1c,
    
    brightBlue: 0x00d9ff,
    brightOrange: 0xff3700,
    pureWhite: 0xffffff,

    almostBlack: 0x1a1a1a,
    digitalBlue: 0x0057ff,
};



/* Teleportation - Controllers */





/* 

    Controllers 


    */



async function checkVRHeadsetAvailability() {
    if (navigator.xr) {
        try {
            // Check if 'immersive-vr' mode is supported
            const isSupported = await navigator.xr.isSessionSupported('immersive-vr');
            return isSupported;
        } catch (error) {
            console.log("Error checking VR headset availability:", error);
            return false;
        }
    } else {
        return false;
    }
}

let renderPostprocessing = false;
window.renderPostprocessing = renderPostprocessing;



async function setupCustomVRButton() {

    const vrAvailable = await checkVRHeadsetAvailability();
    
    if (vrAvailable) {
        const customVrButton = document.createElement('button');
        customVrButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
              <style>
                @keyframes blink {
                  0%, 100% { opacity: 1; }
                  50% { opacity: 0.5; }
                }
                .blink {
                  animation: blink 4s linear infinite;
                }
              </style>
        <g fill="rgba(255,255,255,0.75)" fill-rule="evenodd" clip-rule="evenodd"><path class="blink" d="M10 7.5c0-.3.2-.5.5-.5h3a.5.5 0 0 1 0 1h-3a.5.5 0 0 1-.5-.5z" fill="#99FF00"/><path class="blink" d="M3 7c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v4a2 2 0 0 1-1 1.8c-1 3.8-4.1 6.7-8 6.7-3.9 0-7-2.9-8-6.7A2 2 0 0 1 3 11zm2-1h14c.6 0 1 .4 1 1v4c0 .6-.4 1-1 1h-3.3a1 1 0 0 1-.3 0l-2.5-.8a3 3 0 0 0-1.8 0l-2.5.8H5a1 1 0 0 1-1-1V7c0-.6.4-1 1-1zm.2 7c1 3.3 3.6 5.5 6.8 5.5 3.2 0 5.8-2.2 6.8-5.5h-3.1a2 2 0 0 1-.6 0l-2.5-.8a2 2 0 0 0-1.2 0l-2.5.7a2 2 0 0 1-.6.1z" fill="#99FF00"/><path class="blink" d="M10 14.5c.3 0 .5.2.5.5l.3.3 1.2.2 1.2-.2.3-.2V15a.5.5 0 0 1 1 0c0 .6-.4 1-.9 1.2-.4.2-1 .3-1.6.3s-1.2-.1-1.6-.3c-.5-.3-.9-.6-.9-1.2 0-.3.2-.5.5-.5z" fill="#99FF00"/></g></svg>
        `; // Or use an <img> tag for a custom icon
        customVrButton.classList.add('custom-vr-button');
        customVrButton.id = "customVrButton";

        // Custom styling

        customVrButton.addEventListener('click', () => {

            renderPostprocessing = false;
            // Logic to start VR session
            renderer.xr.enabled = true;

            const sessionInit = {
                optionalFeatures: ['local-floor', 'bounded-floor'],
                requiredFeatures: ['hand-tracking']
            };

            // const sessionInit = {
            //         optionalFeatures: [ 'depth-sensing', 'local-floor' ],
            //         depthSensing: { 'usagePreference': [ 'gpu-optimized' ], dataFormatPreference: [] 
            //     }}

            // const sessionInit = { optionalFeatures: ['local-floor', 'bounded-floor'] };

            navigator.xr.requestSession('immersive-vr', sessionInit).then((session) => {
                renderer.xr.setSession(session);
            });
        });

        document.body.appendChild(customVrButton);

        document.querySelector('.custom-vr-button').classList.add('display-block')

    }
}


// setupCustomVRButton()



    //----
    // Updated part: Add sessionInit parameter with hand-tracking
    // See - https://github.com/immersive-web/webxr/issues/1358#issuecomment-1941838121
    // moved to   customVrButton  
    // const sessionInit = {
    //     optionalFeatures: [],
    //     requiredFeatures: ['hand-tracking']
    // };

    // document.body.appendChild(VRButton.createButton(renderer, sessionInit));



let raycaster = new THREE.Raycaster();

const teleportTargets = [];

let hand1, hand2;
let controller1, controller2;
let controllerGrip1, controllerGrip2;

let controllers = [];
let dummyMatrix;

const handModels = {
    left: null,
    right: null,
};
let handModelFactory;
let conS = [];

let teleportMode = false;
let teleportRing;
let cameraContainer
let activeController



/*  ---------------------------------------------------  */


let controller1QuaternionDisplay, controller2QuaternionDisplay;

function setupControllerDisplays() {

    function createQuaternionDisplay(controller) {
        const canvas = document.createElement('canvas');
        canvas.width = 100;  // Adjusted width for single column
        canvas.height = 100;
        const context = canvas.getContext('2d');
        context.fillStyle = 'orange';
        context.font = '18px monofonto';
        context.textAlign = 'center';
        context.textBaseline = 'middle';
        const texture = new THREE.CanvasTexture(canvas);
        const material = new THREE.MeshBasicMaterial({ map: texture, transparent: true, side: THREE.DoubleSide });
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(0.1, 0.1), material);
        plane.position.set(0, 0, 0.15); // Adjust position as needed

        controller.add(plane);
        
        return { canvas, texture, plane };
    }

    controller1QuaternionDisplay = createQuaternionDisplay(controller1);
    controller2QuaternionDisplay = createQuaternionDisplay(controller2);
}

function refreshControllerInfo() {
    const lineSpace = 18; // Adjust this value to change the space between lines

    function formatValue(value) {
        return (value >= 0 ? ' ' : '') + value.toFixed(2); // Add space if positive
    }

    function updateDisplay(controller, display, mode) {
        const quaternion = controller.getWorldQuaternion(new THREE.Quaternion());
        const lines = [
            `M: ${mode.substr(0,6)}`,
            `x:${formatValue(quaternion.x)}`,
            `y:${formatValue(quaternion.y)}`,
            `z:${formatValue(quaternion.z)}`,
            `w:${formatValue(quaternion.w)}`
        ];
        const context = display.canvas.getContext('2d');
        context.clearRect(0, 0, display.canvas.width, display.canvas.height);
        context.fillStyle = 'blue'; // Color for the mode text
        context.fillText(lines[0], display.canvas.width / 2, 15); // Display the mode

        lines.slice(1).forEach((value, index) => {
            context.fillStyle = value.includes('-') ? 'green' : 'orange'; // Orange for positive, green for negative
            context.fillText(value, display.canvas.width / 2, 15 + ((index + 1) * lineSpace));
        });

        display.texture.needsUpdate = true;
    }

    updateDisplay(controller1, controller1QuaternionDisplay, currentMode);
    updateDisplay(controller2, controller2QuaternionDisplay, currentMode);
}


/*  ---------------------------------------------------  */

/* Web Sockets - placeholders */


function broadcastXRUser() {

}











/*  ---------------------------------------------------  */

function generateRayTexture() {
    const canvas = document.createElement("canvas");
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext("2d");

    // Create a gradient that starts fading to transparent immediately
    const gradient = ctx.createLinearGradient(0, 0, 0, 64);
    gradient.addColorStop(0, "rgba(255, 0, 0, 1)"); // Fully opaque at the start
    gradient.addColorStop(0.1, "rgba(255, 0, 0, 0)"); // Start fading out almost immediately

    // The rest of the gradient is transparent
    gradient.addColorStop(1, "rgba(255, 0, 0, 0)"); // Fully transparent towards the end

    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);

    return canvas;
}

function generatePointerTexture() {
    const canvas = document.createElement("canvas");
    canvas.width = 64;
    canvas.height = 64;

    const ctx = canvas.getContext("2d");

    ctx.beginPath();
    ctx.arc(32, 32, 29, 0, 2 * Math.PI);
    ctx.lineWidth = 5;
    ctx.stroke();
    ctx.fillStyle = "white";
    ctx.fill();

    return canvas;
}


function getCameraPosition() {
    const cameraPosition = new THREE.Vector3();
    renderer.xr.getCamera(camera).getWorldPosition(cameraPosition);
    return cameraPosition;
}



function addBallTrajectory() {

    console.log(" - addBallTrajectory")

    // Remove existing line if any

    if (window.ballTrajectory) {
        scene.remove(window.ballTrajectory);
    }

    let cameraPosition = getCameraPosition();
    let leftHand = renderer.xr.getController(0); // 0 is usually the left hand
    let leftHandPosition = new THREE.Vector3();
    leftHand.getWorldPosition(leftHandPosition);

    // Create the line to visualize this vector
    const lineGeometry = new THREE.BufferGeometry().setFromPoints([leftHandPosition, cameraPosition]);
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000 });
    const line = new THREE.Line(lineGeometry, lineMaterial);

    window.ballTrajectory = line;

    // Add line to the scene
    scene.add(window.ballTrajectory);

}



function initControllers() {

    console.log(" -------- initControllers")

    addBallTrajectory();

    const rayTexture = new THREE.CanvasTexture(generateRayTexture());
    rayTexture.needsUpdate = true;

    const material = new THREE.MeshBasicMaterial({
        map: rayTexture,
        transparent: true,
        side: THREE.DoubleSide,
        alphaTest: 0.05,
    });

    const geometry = new THREE.BoxGeometry(0.005, 0.005, 20);
    geometry.translate(0, 0, -10.01);

    const uvAttribute = geometry.getAttribute("uv");
    for (let i = 0; i < uvAttribute.count; i++) {
        uvAttribute.setXY(i, i % 2, Math.floor(i / 4) % 2);
    }

    const linesHelper = new THREE.Mesh(geometry, material);
    linesHelper.rotation.z = 5 * (Math.PI / 4);
    linesHelper.ignore = true;

    const spriteMaterial = new THREE.SpriteMaterial({
        map: new THREE.CanvasTexture(generatePointerTexture()),
        sizeAttenuation: false,
        depthTest: false,
    });

    const pointer = new THREE.Sprite(spriteMaterial);
    pointer.scale.set(0.015, 0.015, 1);
    pointer.renderOrder = Infinity;    

    controller1 = renderer.xr.getController(0);
    controller1.name = "controller1";
    scene.add(controller1);

    controller2 = renderer.xr.getController(1);
    controller2.name = "controller2";
    scene.add(controller2);

    const controllerModelFactory = new XRControllerModelFactory();
    handModelFactory = new XRHandModelFactory();

    console.log(" - - - - - - - - -handModelFactory:", handModelFactory);

    controllerGrip1 = renderer.xr.getControllerGrip(0);
    controllerGrip1.add(
        controllerModelFactory.createControllerModel(controllerGrip1),
    );
    scene.add(controllerGrip1);

    hand1 = renderer.xr.getHand(0);
    hand1.name = "hand1";
    hand1.userData.currentHandModel = 0;
    scene.add(hand1);

    console.log(" - - - - - - - - -hand1", hand1);

    handModels.left = [handModelFactory.createHandModel(hand1, "mesh")];
    const model1 = handModels.left[0];
    model1.visible = true;

    hand1.add(model1);

    hand1.addEventListener("pinchend", function () {
        console.log("hand1 pinched");
        handlePinch(hand1);

    });

    controllerGrip2 = renderer.xr.getControllerGrip(1);
    controllerGrip2.add(
        controllerModelFactory.createControllerModel(controllerGrip2),
    );
    scene.add(controllerGrip2);

    hand2 = renderer.xr.getHand(1);
    hand2.name = "hand2";    
    hand2.userData.currentHandModel = 2;
    scene.add(hand2);

    handModels.right = [handModelFactory.createHandModel(hand2, "mesh")];
    const model2 = handModels.right[0];
    model2.visible = true;
    hand2.add(model2);

    hand2.addEventListener("pinchend", function () {
        console.log("hand2 pinched");
        handlePinch(hand2);
    });

    window.hand1 = hand1;
    window.hand2 = hand2;

    /* rings */

    // Define the geometry and material for the wearable torus
    const torusGeometry = new THREE.TorusGeometry(0.06, 0.005, 16, 100); // Adjust the size as needed
    const torusMaterial = new THREE.MeshBasicMaterial({ color: tronLegacyColors.brightBlue }); // Green color for visibility

    controller1.addEventListener("connected", function (e) {
        
        console.log("Controller 1 connected!", e.data);
        
        if (e.data.gamepad !== null) {
            if (conS.filter((obj) => obj.id === 0).length === 0) {
                conS.push({
                    id: 0,
                    data: e.data,
                });
            }
        }
    });

    controller2.addEventListener("connected", function (event) {
        
        console.log("Controller 2 connected!", event.data);
        if (event.data.gamepad !== null) {
            if (conS.filter((obj) => obj.id === 1).length === 0) {
                conS.push({
                    id: 1,
                    data: event.data,
                });
            }
        }
    });

    controllers.push(controller1);
    controllers.push(controller2);

    controllers.forEach((controller) => {

        const simpleRayGeometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 0, 0),
            new THREE.Vector3(0, 0, -10),
        ]);
        
        const simpleRay = new THREE.Line(
            simpleRayGeometry,
            new THREE.LineBasicMaterial({ color: 0xffffff, visible: true }),
        ); // Invisible for visual purposes
        
        controller.simpleRay = simpleRay; // Attach the simpleRay to the controller
        controller.add(simpleRay); // Add the simpleRay to the controller object
        simpleRay.ignore = true;
    });

    controllers.forEach((controller) => {
        const ray = linesHelper.clone();
        ray.ignore = true;
        const point = pointer.clone();
        point.ignore = true;
        controller.add(ray, point);
        controller.ray = ray;
        controller.point = point;
    });

    const discRadius = 0.25;
    const discMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        side: THREE.DoubleSide,
        transparent: true,
        opacity: 0.25,
    });
    const discGeometry = new THREE.CircleGeometry(discRadius, 32);

    controllers.forEach((controller) => {
        const disc = new THREE.Mesh(discGeometry, discMaterial);
        disc.visible = false; // Initially invisible
        disc.ignore = true;
        controller.disc = disc; // Store the disc as a property of the controller
        scene.add(disc);

        // Create and add the ring
        const ring = new THREE.Mesh(torusGeometry, torusMaterial);
        controller.ring = ring;
        ring.ignore = true;
        ring.position.set(0, 0, 0.15); // Adjust position relative to the controller
        ring.rotation.set(0, 0, 0); // Adjust rotation if needed
        controller.add(ring); // Attach the ring directly to the controller
    });

    dummyMatrix = new THREE.Matrix4();
    raycaster = new THREE.Raycaster();

    const teleportRingGeometry = new THREE.RingGeometry(0.23, 0.25, 64);
    const teleportRingMaterial = new THREE.MeshBasicMaterial({ color: tronLegacyColors.brightBlue, side: THREE.DoubleSide });
    teleportRing = new THREE.Mesh(teleportRingGeometry, teleportRingMaterial);
    teleportRing.rotation.x = -Math.PI / 2; // Rotate to lay flat on the ground
    teleportRing.visible = false; // Initially invisible
    teleportRing.ignore = true;

    scene.add(teleportRing);

    cameraContainer = new THREE.Object3D();
    scene.add(cameraContainer);
    
    cameraContainer.add(camera);

    /* parent controllers to the container */
    cameraContainer.add(controller1);
    cameraContainer.add(controller2);  

    cameraContainer.add(hand1);
    cameraContainer.add(hand2);

    cameraContainer.add(model1);
    cameraContainer.add(model2);

    cameraContainer.add(controllerGrip1);
    cameraContainer.add(controllerGrip2);

    function onControllerSelectStart(controller) {
        if (currentMode !== 'teleportation') return;

        const tempMatrix = new THREE.Matrix4();
        tempMatrix.identity().extractRotation(controller.matrixWorld);

        raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

        const intersects = raycaster.intersectObjects(teleportTargets, false);

        if (intersects.length > 0) {
            teleportMode = true;
            activeController = controller;
            teleportRing.visible = true;
            teleportRing.position.copy(intersects[0].point);
            teleportRing.position.y += 0.03; // Adjust if necessary
        }
    }

    function performTeleportation() {

        console.log("performTeleportation",currentMode,teleportMode)

        if (currentMode === 'teleportation' && teleportMode) {
            const teleportDestination = new THREE.Vector3();
            teleportRing.getWorldPosition(teleportDestination);

            cameraContainer.position.copy(teleportDestination);

            teleportMode = false;
            teleportRing.visible = false;
            activeController = null;
        }
    }

    controller1.addEventListener('selectstart', function () {
        if (currentMode === 'teleportation') {
            onControllerSelectStart(controller1);
        } else if (currentMode === 'weapon') {
            shootBallFromController(controller1);
            broadcastXRUser();
        }
        handlePinch(controller1);
    });

    controller1.addEventListener('selectend', function () {
        if (currentMode === 'teleportation' && teleportMode) {
            performTeleportation();
        }
    });

    controller2.addEventListener('selectstart', function () {
        if (currentMode === 'teleportation') {
            onControllerSelectStart(controller2);
        } else if (currentMode === 'weapon') {
            shootBallFromController(controller2);
            broadcastXRUser();
        }
        handlePinch(controller2);
    });

    controller2.addEventListener('selectend', function () {
        if (currentMode === 'teleportation' && teleportMode) {
            performTeleportation();
        }
    });

    setupControllerDisplays();
}


function updateRaycasting() {
    controllers.forEach((controller) => {
        const simpleRay = controller.simpleRay;
        raycaster.ray.origin.setFromMatrixPosition(simpleRay.matrixWorld);
        const rayDirection = new THREE.Vector3(0, 0, -1).applyMatrix4(simpleRay.matrixWorld);
        rayDirection.sub(raycaster.ray.origin).normalize();
        raycaster.ray.direction.copy(rayDirection);

        const intersects = raycaster.intersectObjects(teleportTargets, false);
        const intersectsWithGUI = intersects.some(intersect => intersect.object.isGUI);
        
        if (intersectsWithGUI) {
            if (currentMode !== 'gui') {
                previousMode = currentMode;
                currentMode = 'gui';
                teleportMode = false;
            }
            return; // Skip further processing to avoid teleportation while interacting with GUI
        }

        if (currentMode === 'gui') {
            currentMode = previousMode;
            teleportMode = false;
        }

        if (currentMode !== 'gui') {
            if (intersects.length > 0) {
                const closestIntersection = intersects[0];
                processIntersection(closestIntersection, controller);
            } else {
                controller.disc.visible = false;
                controller.point.visible = false;
            }
        }
    });
}



function handlePinch(controller) {

    // const intersections = raycaster.intersectObjects(scene.children, true);
    console.log("handlePinch, control", controller);

    // intersections.forEach(intersection => {
    //     if (intersection.object) {
    //         //console.log("👆 Intersected Object:", intersection.object.name);
    //         traverseAndLog(intersection.object);
    //     }
    // });

}



function traverseAndLog(object, level = 0) {
    const indent = ' '.repeat(level * 2); // Create an indent based on the level
    let output = `${indent}${object.type} - ${object.name}`;

    if (object.userData && Object.keys(object.userData).length > 0) {
        output += ` | userData: ${JSON.stringify(object.userData)}`;
    }

    if (object.data && Object.keys(object.data).length > 0) {
        output += ` | data: ${JSON.stringify(object.data)}`;
    }

    console.log(output);

    if (object.parent) {
        console.log(`${indent}  Parent: ${object.parent.type} - ${object.parent.name}`);
    }

    object.children.forEach(child => {
        traverseAndLog(child, level + 1);
    });
}






function processIntersection(intersection, controller) {
    const intersectPoint = intersection.point;
    const intersectNormal = intersection.face.normal;

    const disc = controller.disc;
    const offsetDistance = 0.01;
    const offsetPoint = intersectPoint.clone().add(intersectNormal.multiplyScalar(offsetDistance));
    disc.position.copy(offsetPoint);
    disc.lookAt(offsetPoint.x + intersectNormal.x, offsetPoint.y + intersectNormal.y, offsetPoint.z + intersectNormal.z);
    disc.visible = true;

    teleportRing.position.copy(intersectPoint);
    teleportRing.position.y += 0.03;

    controller.worldToLocal(intersectPoint);
    controller.point.position.copy(intersectPoint);
    controller.point.visible = true;

    const distance = raycaster.ray.origin.distanceTo(intersectPoint);
    const maxScale = 0.05;
    let scale = maxScale / distance;
    controller.point.scale.set(scale, scale, 1);

    if (intersection.object.userData.file_type == "note") {
        intersection.object.material.color.set(0x00ff00); // Change color for testing
        console.log("Info spot detected:", intersection.object);
    }
}

/* Teleportation / Weapon */



let currentMode = 'teleportation'; // Initial mode
const collisionThreshold = 0.05; // Threshold for ring collision, adjust as needed

let isColliding = false;
let collisionCooldown = false;
const cooldownTime = 100; // Cooldown time in milliseconds (1 second)


function startCooldown() {
    collisionCooldown = true;
    setTimeout(() => {
        collisionCooldown = false;
    }, cooldownTime);
}

function updateRingColors() {
    const newColor = (currentMode === 'teleportation') ? tronLegacyColors.brightBlue : tronLegacyColors.brightOrange; 
    controller1.ring.material.color.set(new THREE.Color(newColor));
    controller2.ring.material.color.set(new THREE.Color(newColor));

    // Toggle visibility of helper lines and points based on the current mode
    const helpersVisible = currentMode === 'weapon';
    controllers.forEach(controller => {
        controller.ray.visible = helpersVisible;
        controller.point.visible = helpersVisible;
    });
}


function getLastCharAsDigit(str) {
    if (str.length === 0) {
        return null; // or an appropriate default value
    }
    const lastChar = str.charAt(str.length - 1);
    const digit = parseInt(lastChar, 10);
    if (isNaN(digit)) {
        return null; // or handle non-digit characters as needed
    }
    return digit;
}


function switchMode() {
    
    currentMode = (currentMode === 'teleportation') ? 'weapon' : 'teleportation';

    updateRingColors();
    //console.log("Switched to mode:", currentMode);

    // Ring changing Sound
    fxPip({
        frequency: 140,
        volume: 0.5,
        duration: 1000,
        fadeInPercent: 2, // 20% of the total duration for fade-in
        fadeOutPercent: 70 // 30% of the total duration for fade-out
    });

}



function checkRingCollision() {

    if (!renderer.xr.isPresenting) {
        // console.log(" - - - no - - - ");
        return;
    }

    refreshControllerInfo();    

    function isControllerPointingUpwards(controller, thresholdAngle) {
        const worldUp = new THREE.Vector3(0, 1, 0);
        const controllerDirection = new THREE.Vector3(0, 0, -1); // Forward direction in controller's local space
        controllerDirection.applyQuaternion(controller.getWorldQuaternion(new THREE.Quaternion()));

        const angleToUp = controllerDirection.angleTo(worldUp) * (180 / Math.PI);
        return angleToUp <= thresholdAngle;
    }

    const thresholdAngle = 30; // Angle threshold in degrees to determine if pointing upwards

    controller1.ring.visible = isControllerPointingUpwards(controller1, thresholdAngle);
    controller2.ring.visible = isControllerPointingUpwards(controller2, thresholdAngle);


    // Check if both controller rings are defined and visible
    if (controller1 && controller1.ring && controller2 && controller2.ring &&
        controller1.ring.visible && controller2.ring.visible) {
        
        // Get world positions of the rings
        const ring1WorldPosition = new THREE.Vector3();
        const ring2WorldPosition = new THREE.Vector3();
        controller1.ring.getWorldPosition(ring1WorldPosition);
        controller2.ring.getWorldPosition(ring2WorldPosition);

        // Check for ring collision using world positions
        const distance = ring1WorldPosition.distanceTo(ring2WorldPosition);

        if (distance < collisionThreshold && !isColliding && !collisionCooldown) {
            isColliding = true;
            switchMode();
            startCooldown(); // Start the cooldown period
        } else if (distance >= collisionThreshold && isColliding) {
            isColliding = false; // Rings are no longer colliding
        }
    }

}







/* 


    Shooting balls 
    -------------------------------------


    */


function shootBallFromXRBroadcast(data) {

    //createAndShootBall(startPosition, targetPosition, radius, color, density, speedFactor) {

    let color = tronLegacyColors.brightOrange;
    let radius = 0.15 + Math.random() * 0.01;
    let density = 5;
    let speedFactor = 22;    

    const startPosition = data.startPosition;
    const targetPosition = data.targetPosition

    // Calculate direction from start to target position
    let direction = new THREE.Vector3().subVectors(targetPosition, startPosition).normalize();

    // Create the rigid body description and set its properties
    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(startPosition.x, startPosition.y, startPosition.z)
        .setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);

    // Create the sphere geometry and material
    const sphereGeometry = new THREE.SphereGeometry(radius);
    const sphereMaterial = new THREE.MeshStandardMaterial({ color: color });
    const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphereMesh.position.copy(startPosition);

    scene.add(sphereMesh);

    // Create the collider
    let colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
    myRapierWorld.createCollider(colliderDesc, rigidBody);

    // Store the rigid body and mesh for future reference
    window.rigidBodies.push(rigidBody);
    window.threeCubes.push(sphereMesh);

}



function shootBallFromBroadcast(data) {


    const cameraPosition = new THREE.Vector3(data.cameraPosition.x, data.cameraPosition.y, data.cameraPosition.z);
    const cameraDirection = new THREE.Vector3(data.cameraDirection.x, data.cameraDirection.y, data.cameraDirection.z);

    const offsetDistance = 0.25; // Adjust as needed to clear the avatar
    const startPosition = new THREE.Vector3().copy(cameraPosition).addScaledVector(cameraDirection, offsetDistance);

    let color = tronLegacyColors.brightOrange;
    let radius = 0.15 + Math.random() * 0.01;
    let density = 5;
    let speedFactor = 22;

    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
        .setTranslation(startPosition.x, startPosition.y, startPosition.z)
        .setLinvel(cameraDirection.x * speedFactor, cameraDirection.y * speedFactor, cameraDirection.z * speedFactor);

    // let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
    //                       .setTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z)
    //                       .setLinvel(cameraDirection.x * speedFactor, cameraDirection.y * speedFactor, cameraDirection.z * speedFactor);

    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);

    // Create the visual representation of the ball
    const sphereGeometry = new THREE.SphereGeometry(radius, 16, 12);
    const myBallMaterial = new THREE.MeshStandardMaterial({ color: color });
    const sphereMesh = new THREE.Mesh(sphereGeometry, myBallMaterial);
    
    scene.add(sphereMesh);

    // Create the collider
    let colliderDesc = RAPIER.ColliderDesc.ball(radius*1.05).setDensity(density);
    let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);

    // Update global arrays
    window.colliderHandles.push(collider.handle);
    window.rigidBodies.push(rigidBody);
    window.threeCubes.push(sphereMesh); // Consider renaming this array for clarity

}



// Sphere Core
const cacheSphereGeometry = new THREE.SphereGeometry(0.2,16,12);




function addBallFromCamera(radius, color, offsetY = 0.2, density = 1, speedFactor = 25) {


    const cameraPosition = camera.position;
    const cameraDirection = new THREE.Vector3();

    camera.getWorldDirection(cameraDirection);
    cameraDirection.y += offsetY;
    cameraDirection.normalize();


    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                          .setTranslation(cameraPosition.x, cameraPosition.y, cameraPosition.z)
                          .setLinvel(cameraDirection.x * speedFactor, cameraDirection.y * speedFactor, cameraDirection.z * speedFactor);
    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);

    //let texture = texturesCache[Math.floor(Math.random() * texturesCache.length)].texture;

      // Sphere Core
      // const sphereGeometry = new THREE.SphereGeometry(radius,16,12);

    const sphereGeometry = cacheSphereGeometry;  


      // const sphereMaterial = new THREE.MeshBasicMaterial({ color: 0xFF0000 });
      
      const myBallMaterial = new THREE.MeshStandardMaterial({ color: color });
        // ------

      const sphereMesh = new THREE.Mesh(sphereGeometry, myBallMaterial);

      sphereMesh.name = "b-fc"

      scene.add(sphereMesh);

      // Create the collider
      let colliderDesc = RAPIER.ColliderDesc.ball(radius*1.05).setDensity(density)
      let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);
      // Save the collider handle
      window.colliderHandles = window.colliderHandles || [];
      window.colliderHandles.push(collider.handle); 
      // Push the rigid body and the Three.js sphere to the global arrays:


        // Store the mapping from collider handle to the THREE.js object
        window.handleToObjectMap = window.handleToObjectMap || new Map();
        window.handleToObjectMap.set(collider.handle, {
            object: sphereMesh,
            name: sphereMesh.name
        });

      window.rigidBodies.push(rigidBody);
      window.threeCubes.push(sphereMesh);  // Consider renaming this array for clarity

      // ws
      // ---------------

    //console.log(" - --> broadcastObjectChange", model_uuid, value, propName, valueToSend)


    // const message = {
    //     type: "broadcastBallFromCamera",
    //     world_uuid: place.uuid,
    //     world_name: place.name,
    //     client_uuid: client_uuid,
    //     cameraPosition: { x: cameraPosition.x, y: cameraPosition.y, z: cameraPosition.z },
    //     cameraDirection: { x: cameraDirection.x, y: cameraDirection.y, z: cameraDirection.z }
    // };

    // if (ws && ws.readyState === WebSocket.OPEN) {
    //     ws.send(JSON.stringify(message));
    // } else {
    //     console.warn('WebSocket is not open. Cannot request the model.');
    // }


    fxPip({
        frequency: Math.random()*100+400,
        volume: 1,
        duration: 50,
        type: 'sine',
        fadeInPercent: 0,
        fadeOutPercent: 90,
        filterType: 'bandpass',
        filterFrequency: 100,
        filterQ: 10
    });    


}

window.addBallFromCamera = addBallFromCamera;



function shootBall() {

    console.log("shootBall - Spacebar released!");

    let ballSize = 0.2 + Math.random() * 0.005;
    let density = 1;
    let speedFactor = 100;

    addBallFromCamera(ballSize, 0xFF3322, 0.1, density, speedFactor)


    console.log("shootBall",ballSize,density,speedFactor);
    
    //addBallFromShotLineEnd(ballSize, colorsSet[Math.floor(Math.random()*colorsSet.length)], 0.1, 1)
    //au.playAudioFromFile(au.findSounds(audioData, "kick2")[0])


    //game.balls +=1;

}

window.shootBall = shootBall;


document.addEventListener('keyup', (event) => {
    
    if (event.keyCode === 32) {
        shootBall();
    }

});




function shootBallFromController(controller) {

    console.log("shootBallFromController:", controller);

    // The size, density, and speed factor for the ball
    let ballSize = 0.12 + Math.random() * 0.01;
    let density = 5;
    let speedFactor = 30;

    // Get the world position of the controller
    const controllerWorldPosition = new THREE.Vector3();
    controller.getWorldPosition(controllerWorldPosition);

    // Get the world position of the point sprite
    const pointSpriteWorldPosition = new THREE.Vector3();
    controller.point.getWorldPosition(pointSpriteWorldPosition);

    // Create and shoot the ball towards the point sprite
    createAndShootBall(controllerWorldPosition, pointSpriteWorldPosition, ballSize, tronLegacyColors.brightBlue, density, speedFactor);

    //game.balls +=1;

}


function createAndShootBall(startPosition, targetPosition, radius, color, density, speedFactor) {

    let direction = new THREE.Vector3().subVectors(targetPosition, startPosition).normalize();

    let rigidBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(startPosition.x, startPosition.y, startPosition.z);

    console.log("Parent object:", cameraContainer.parent);

    if (cameraContainer.parent) {
        let parentRigidBody = cameraContainer.parent.rigidBody;
        if (parentRigidBody) {
            let parentVelocity = parentRigidBody.linvel();
            console.log("Parent velocity:", parentVelocity);

            rigidBodyDesc.setLinvel(
                direction.x * speedFactor + parentVelocity.x,
                direction.y * speedFactor + parentVelocity.y,
                direction.z * speedFactor + parentVelocity.z
            );
        } else {
            console.log("Parent object has no rigidBody.");
            rigidBodyDesc.setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
        }
    } else {
        rigidBodyDesc.setLinvel(direction.x * speedFactor, direction.y * speedFactor, direction.z * speedFactor);
    }

    let rigidBody = myRapierWorld.createRigidBody(rigidBodyDesc);

    const sphereGeometry = new THREE.SphereGeometry(radius);
    const sphereMaterial = new THREE.MeshStandardMaterial({ color: color });
    const sphereMesh = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphereMesh.position.copy(startPosition);

    sphereMesh.name = "ball-xr";

    scene.add(sphereMesh);

    let colliderDesc = RAPIER.ColliderDesc.ball(radius).setDensity(density);
    let collider = myRapierWorld.createCollider(colliderDesc, rigidBody);

    window.handleToObjectMap = window.handleToObjectMap || new Map();
    window.handleToObjectMap.set(collider.handle, {
        object: sphereMesh,
        name: sphereMesh.name
    });

    window.rigidBodies.push(rigidBody);
    window.threeCubes.push(sphereMesh);

    // const message = {
    //     type: "broadcastBallFromXRCamera",
    //     world_uuid: place.uuid,
    //     world_name: place.name,
    //     client_uuid: client_uuid,
    //     startPosition: startPosition,
    //     targetPosition: targetPosition
    // };

    // if (ws.readyState === WebSocket.OPEN) {
    //     ws.send(JSON.stringify(message));
    // } else {
    //     console.log('WebSocket is not open. Cannot request the model.');
    // }


    playFX("shoot1", 10);


}


/*

    Sound Manager

        */



const SoundManager = (function() {
    const listener = new THREE.AudioListener();
    const audioLoader = new THREE.AudioLoader();

    const sounds = {
        blip: function(options) {
            const sound = new THREE.PositionalAudio(listener);
            const audioCtx = listener.context;
            const oscillator = audioCtx.createOscillator();
            oscillator.type = options.type || 'sine';
            oscillator.frequency.setValueAtTime(options.initialFrequency || 440, audioCtx.currentTime);

            const gainNode = audioCtx.createGain();
            const volume = options.volume || 0.5;
            const duration = (options.duration || 1) * 1000; // Total duration in milliseconds
            const fadeInDuration = Math.min(duration * (options.fadeInPercent || 0) / 100, duration);
            const fadeOutDuration = Math.min(duration * (options.fadeOutPercent || 0) / 100, duration - fadeInDuration);

            // Start with 0 volume for fade-in
            gainNode.gain.setValueAtTime(0, audioCtx.currentTime); 
            gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + fadeInDuration / 1000); // Fade-in

            if (options.filterType) {
                const filter = audioCtx.createBiquadFilter();
                filter.type = options.filterType;
                filter.frequency.setValueAtTime(options.filterFrequency || 1000, audioCtx.currentTime);
                filter.Q.value = options.filterQ || 1;
                oscillator.connect(filter);
                filter.connect(gainNode);
            } else {
                oscillator.connect(gainNode);
            }

            gainNode.connect(audioCtx.destination);
            sound.setNodeSource(gainNode);

            this.configureSound(sound, options);

            oscillator.start();

            if (fadeOutDuration > 0) {
                const fadeOutStartTime = (duration - fadeOutDuration) / 1000;
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + fadeOutStartTime);
            }

            setTimeout(() => {
                oscillator.stop();
                sound.disconnect();
            }, duration); 

            return sound;
        },

        // Other sound functions...

        configureSound: function(sound, options) {
            sound.setVolume(options.volume || 0.5);
            sound.setRefDistance(options.refDistance || 1);
            sound.setRolloffFactor(options.rolloffFactor || 1);
            sound.setDistanceModel(options.distanceModel || 'linear');
            sound.setMaxDistance(options.maxDistance || 1000);
            if (options.object3D) {
                options.object3D.add(sound);
            }
        },

        playPositionalSound: function(soundType, position, options = {}) {
            const sound = this.playSound(soundType, options);
            if (sound) {
                sound.position.copy(position);
                if (sound.context) {
                    sound.context.listener.setPosition(position.x, position.y, position.z);
                }
                sound.play();
            }
        },

        playSound: function(name, options) {
            if (sounds[name]) {
                return sounds[name].call(this, options);
            } else {
                console.error('Sound not found:', name);
            }
        },

        applySoundToObject: function(object3D, soundType, options = {}) {
            options.object3D = object3D;
            this.playSound(soundType, options);
        },

        playUISound: function(options) {
            const sound = new THREE.Audio(listener);

            audioLoader.load(options.soundFile, function(buffer) {
                sound.setBuffer(buffer);
                sound.setLoop(options.loop || false);
                sound.setVolume(options.volume || 0.5);
                sound.play();
            });

            return sound;
        },

        playGeneratedSound: function(options) {
            const audioCtx = listener.context;
            const oscillator = audioCtx.createOscillator();
            oscillator.type = options.type || 'sine';
            oscillator.frequency.setValueAtTime(options.frequency || 440, audioCtx.currentTime); // Frequency in Hz

            const gainNode = audioCtx.createGain();
            const volume = options.volume || 0.5;

            const duration = options.duration || 1000; // Total duration in milliseconds
            const fadeInDuration = Math.min(duration * (options.fadeInPercent || 0) / 100, duration);
            const fadeOutDuration = Math.min(duration * (options.fadeOutPercent || 0) / 100, duration - fadeInDuration);

            gainNode.gain.setValueAtTime(0, audioCtx.currentTime); // Start with 0 volume for fade-in
            gainNode.gain.linearRampToValueAtTime(volume, audioCtx.currentTime + fadeInDuration / 1000); // Fade-in

            if (options.filterType) {
                const filter = audioCtx.createBiquadFilter();
                filter.type = options.filterType;
                filter.frequency.setValueAtTime(options.filterFrequency || 1000, audioCtx.currentTime);
                filter.Q.value = options.filterQ || 1;
                oscillator.connect(filter);
                filter.connect(gainNode);
            } else {
                oscillator.connect(gainNode);
            }

            gainNode.connect(audioCtx.destination);

            oscillator.start();

            if (fadeOutDuration > 0) {
                const fadeOutStartTime = (duration - fadeOutDuration) / 1000;
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + fadeOutStartTime);
            }

            setTimeout(() => {
                oscillator.stop();
            }, duration); // Duration in milliseconds

            return oscillator;
        }
    };

    return {
        listener: listener,

        playSound: function(name, options) {
            if (sounds[name]) {
                return sounds[name].call(this, options);
            } else {
                console.error('Sound not found:', name);
            }
        },

        applySoundToObject: function(object3D, soundType, options = {}) {
            options.object3D = object3D;
            this.playSound(soundType, options);
        },

        playUISound: function(options) {
            return sounds.playUISound(options);
        },

        playGeneratedSound: function(options) {
            return sounds.playGeneratedSound(options);
        },

        playPositionalSound: function(soundType, position, options = {}) {
            return sounds.playPositionalSound(soundType, position, options);
        }
    };
})();





function fxPip({
    frequency = 100,
    volume = 0.25,
    duration = 1000,
    type = 'sine',
    fadeInPercent = 0,
    fadeOutPercent = 0,
    filterType = null,
    filterFrequency = 1000
} = {}) {
    SoundManager.playGeneratedSound({
        type: type,
        frequency: frequency,
        volume: volume,
        duration: duration,
        fadeInPercent: fadeInPercent,
        fadeOutPercent: fadeOutPercent,
        filterType: filterType,
        filterFrequency: filterFrequency
    });
}

window.fxPip = fxPip;



const soundPresets = {
    "shoot1":
        {
            "initialFrequency": 20,
            "volume": 0.259,
            "duration": 0.1323,
            "type": "square",
            "fadeInPercent": 0.1,
            "fadeOutPercent": 20.1,
            "filterType": "highpass",
            "filterFrequency": 739.26,
            "filterQ": 13.5718,
            "loop": true,
            "interval": 0.392
        },
    "message-in": {
        "initialFrequency": 615.78,
        "volume": 0.389,
        "duration": 0.3038,
        "type": "square",
        "fadeInPercent": 18.3,
        "fadeOutPercent": 28.3,
        "filterType": "bandpass",
        "filterFrequency": 3556.44,
        "filterQ": 1.5124,
        "loop": false,
        "interval": 0.3038
    },
    "message-out": {
        "initialFrequency": 415.78,
        "volume": 0.389,
        "duration": 0.3038,
        "type": "square",
        "fadeInPercent": 34.3,
        "fadeOutPercent": 8.3,
        "filterType": "bandpass",
        "filterFrequency": 3556.44,
        "filterQ": 1.5124,
        "loop": false,
        "interval": 0.3038
    },

    "plain": {
        "initialFrequency": 440,
        "volume": 0.5,
        "duration": 0.1911,
        "type": "sine",
        "fadeInPercent": 1.3,
        "fadeOutPercent": 16,
        "filterType": "none",
        "filterFrequency": 1000,
        "filterQ": 1,
        "loop": false,
        "interval": 1
        }
};

function playFX(presetName, seed = 0) {
    const preset = soundPresets[presetName];
    if (preset) {

        const randomFactor = Math.random()*seed - Math.random()*seed;
        // Use the seed to modify frequency and other parameters if needed
        //const randomFactor = seed !== 0 ? (Math.sin(seed) * 0.5 + 0.5) : 1; // Generate a deterministic random factor based on the seed

        fxPip({
            frequency: preset.initialFrequency + randomFactor,
            volume: preset.volume,
            duration: preset.duration * 1000, // Convert to milliseconds if needed
            type: preset.type,
            fadeInPercent: preset.fadeInPercent,
            fadeOutPercent: preset.fadeOutPercent,
            filterType: preset.filterType,
            filterFrequency: preset.filterFrequency // Apply randomness
        });
    } else {
        console.error(`Preset "${presetName}" not found.`);
    }
}


window.playFX = playFX;




/* 

    Restore Camera
    ----------------------------------------------- 

    */

let controlsUpdateAllow = true;
let cameraAnimated = false;
let cameraPositions = [];


function controlsUpdate() {
    if(controlsUpdateAllow) {
        controls.update()
    }
}
window.controlsUpdateAllow = controlsUpdateAllow;


function restoreCameraPosition() {
     let camData;
    if (localStorage.getItem("cameraPositions")) {
            let data = JSON.parse(localStorage.getItem("cameraPositions"));
            console.log("restoreCameraPosition",data)
            camData = data[data.length - 1];
            camera.position.copy(new THREE.Vector3().copy(camData.camera.position));
            camera.rotation.set(camData.camera.rotation.x, camData.camera.rotation.y, camData.camera.rotation.z);
            if (controls) {
                controls.target.copy(new THREE.Vector3().copy(camData.controls.target));
            }
            console.log("-- 2. Setting camera from localStorage data:", camData);
    }
    controlsUpdate();
}


function saveCameraPosition() {

    if (cameraAnimated) return;
    console.log("saveCameraPosition");

    const cameraData = {
        position: camera.position.clone(),
        rotation: camera.rotation.clone(),
    };
    const controlsData = { target: controls.target.clone() };

    console.log("controlsData:", controlsData);

    // Store data in localStorage
    localStorage.setItem("cameraData", JSON.stringify(cameraData));
    localStorage.setItem("controlsData", JSON.stringify(controlsData));
    cameraPositions.push({ camera: cameraData, controls: controlsData });
    localStorage.setItem("cameraPositions", JSON.stringify(cameraPositions));

}




/* 

    Init Scene
    ----------------------------------------------- 

    */

function initScene() {


    // Scene setup
    scene = new THREE.Scene();
    // solid background color
    // you can add background from addEnvMap() 
    scene.background = new THREE.Color( 0x505050 );

    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;



    container.appendChild(renderer.domElement);      


    // Lights
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5);
    scene.add(light);


    // document.body.appendChild(renderer.domElement);
    // document.body.appendChild(VRButton.createButton(renderer));



    // ORBIT CONTROLS

    let isOrbitControlActive = false
    let lastInteractionTime = Date.now();
    const orbitControlDeactivationDelay = 300; 

    const controls = new OrbitControls(camera, container);

    controls.enableDamping = true;
    controls.dampingFactor = 0.1;

    controls.minPolarAngle = 0;
    //controls.autoRotate = false;

    //controls.maxPolarAngle = Math.PI / 2.1; // This is already the default, means camera can't go more than 90 degrees.
    controls.minDistance = 0.25; // The closest the camera can get to the target
    controls.maxDistance = 1274210; // The farthest the camera can be from the target

        // ---
        controls.maxPolarAngle = Math.PI / 1.99; // This is already the default, means camera can't go more than 90 degrees.        
        
        // controls.minDistance = 0.5; // The closest the camera can get to the target
        // controls.maxDistance = 150; // The farthest the camera can be from the target

    function debounce(func, wait) {
        let timeout;
        return function (...args) {
            const context = this;
            clearTimeout(timeout);
            timeout = setTimeout(() => func.apply(context, args), wait);
        };
    }

    const debouncedSave = debounce(saveCameraPosition, 300); // 300ms delay

    controls.addEventListener("end", () => {
        setTimeout(() => {
            
        }, orbitControlDeactivationDelay);
        isOrbitControlActive = false;

        debouncedSave();
    });

    controls.addEventListener("change", () => {

        //controls.needsUpdate = true;

        //updateControls();  // Call updateControls on each change
        
        debouncedSave();   // Debounced call to save the camera position

        // Other updates...
        // updateDummyAvatar();
        updateRigidBodies();
    });

    window.controls = controls;


    // XR Button - if yo uwant to test mixed reality
    // document.body.appendChild( XRButton.createButton( renderer, {
    //     'optionalFeatures': [ 'depth-sensing' ],
    //     'depthSensing': { 'usagePreference': [ 'gpu-optimized' ], 'dataFormatPreference': [] }
    // } ) ); 


    setupCustomVRButton()     


}


/* 

    Helpers
    ----------------------------------------------- 

    */


function addHelpers() {

    let visible = true;

    const helperLayer = new THREE.Layers();
    helperLayer.set(1); // Set to layer 1, different from the default layer 0

    // GridHelper
    const size = 500;
    const divisions = 20;
    const gridHelper = new THREE.GridHelper(size, divisions, 0x333333, 0xFFFFFF00);
    gridHelper.name = "gridHelper"
    gridHelper.layers.enable(1); // Assign to layer 1
    gridHelper.ignore = true
    gridHelper.position.set(0,-0.01,0)
    gridHelper.visible = visible;
    
    scene.add(gridHelper);

    // Create an AxesHelper
    const axesHelper = new THREE.AxesHelper(100); // 5 is the size of the axes
    axesHelper.ignore = true;
    axesHelper.name = "axesHelper";
    axesHelper.visible = visible;

    scene.add(axesHelper);

}



/* 

    Init
    ----------------------------------------------- 

    */



function init() {


    initScene();

    initRapier();

    restoreCameraPosition();    

    //addHelpers();

    addEnvMap();

    animate();

    //toggleEmittersEditGUI();

    //loadEmittersFromJSON("data/e.json")

    //toggleGameTimerGUI();


    //loadEmittersFromJSON("data/emitters_2024-07-22T19-36-35-007Z.json")

    initControllers();

    //loadEmittersFromJSON("data/emitters_2024-07-22T23-35-56-724Z.json")


    // startAllEmitters();


    //loadEmittersJSON('data/emitters_2024-07-21T18-13-55-176Z.json');


    //loadEmittersFromJSON("data/emitters_2024-07-24T12-20-37-841Z.json")


    //toggleEmittersEditGUI()


}



/* 

    Animate
    ----------------------------------------------- 

    */


function animate() {

    renderer.setAnimationLoop(render);


}



/* 

    Render Loop
    ----------------------------------------------- 

    */

function render() {

    // if (myRapierWorld) {
    //     myRapierWorld.step();
    // }


    //console.log("render")

    controlsUpdate()


    updateRapier();

    updateRaycasting();

    checkRingCollision();


    renderer.render(scene, camera);
}






function onSelectStart(event) {
    const controller = event.target;
    const intersections = getIntersections(controller);
    if (intersections.length > 0) {
        const intersection = intersections[0];
        controller.userData.selected = intersection.object;
    }
}

function onSelectEnd(event) {
    const controller = event.target;
    if (controller.userData.selected !== undefined) {
        const object = controller.userData.selected;
        object.material.emissive.b = 0;
        controller.userData.selected = undefined;
    }
}

function getIntersections(controller) {
    const tempMatrix = new THREE.Matrix4();
    tempMatrix.identity().extractRotation(controller.matrixWorld);

    const raycaster = new THREE.Raycaster();
    raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
    raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

    return raycaster.intersectObjects(scene.children, false);
}



/* 

    GUIs draggable window
    ----------------------------------------------- 

    */

function makePanelDraggable(element, dragHandle) {
    
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    dragHandle.onmousedown = dragMouseDown;

    function dragMouseDown(e) {
        e = e || window.event;
        e.preventDefault();
        // Get the mouse cursor position at startup:
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.onmouseup = closeDragElement;
        // Call a function whenever the cursor moves:
        document.onmousemove = elementDrag;
        element.style.zIndex += 1;
    }
    function elementDrag(e) {
        e = e || window.event;
        e.preventDefault();
        // Calculate the new cursor position:
        pos1 = pos3 - e.clientX;
        pos2 = pos4 - e.clientY;
        pos3 = e.clientX;
        pos4 = e.clientY;
        // Set the element's new position:
        element.style.top = (element.offsetTop - pos2) + "px";
        element.style.left = (element.offsetLeft - pos1) + "px";
    }
    function closeDragElement() {
        // Stop moving when mouse button is released:
        document.onmouseup = null;
        document.onmousemove = null;
    }
    // display it
    element.style.display = "block";
}
window.makePanelDraggable = makePanelDraggable;



/* 

    Window Resize Update
    ----------------------------------------------- 

    */

let resizeTimeout;

function onWindowResize() {

    clearTimeout(resizeTimeout);

    resizeTimeout = setTimeout(() => {

        const width = document.documentElement.clientWidth;
        const height = document.documentElement.clientHeight;

        camera.aspect = width / height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);

     }, 200); 

}


/* 

    DOM Loaded - execute init()
    ----------------------------------------------- 

    */


document.addEventListener("DOMContentLoaded", function() {

    window.addEventListener('resize', onWindowResize);
    window.addEventListener('orientationchange', onWindowResize);

    init();

});



</script>




</body>

</html>