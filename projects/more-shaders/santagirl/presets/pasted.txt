<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Three.js — Snowdrifts + Gusts + Sticking + Presets</title>
  <style>
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0a1220; }
    #app { position: fixed; inset: 0; }
    .hud{
      position: fixed; left: 12px; top: 12px;
      font: 12px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
      user-select: none;
      pointer-events: none;
    }
    .hud b{ color: rgba(255,255,255,0.98); }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="app"></div>
  <div class="hud">
    <b>Snowdrifts + gusts + sticking snow</b><br/>
    Drag: orbit · Wheel: zoom · Right-drag: pan · Keys: G (toggle GUI) · R (reset) · F (fullscreen)
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.20/+esm";

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    function nowStamp() {
      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      return (
        d.getFullYear() +
        pad(d.getMonth() + 1) +
        pad(d.getDate()) +
        "-" +
        pad(d.getHours()) +
        pad(d.getMinutes()) +
        pad(d.getSeconds())
        );
    }

    function downloadJson(obj, filename) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.rel = "noopener";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    function makeRadialTexture(size = 96) {
      const c = document.createElement("canvas");
      c.width = c.height = size;
      const g = c.getContext("2d");
      const grad = g.createRadialGradient(size / 2, size / 2, 0, size / 2, size / 2, size / 2);
      grad.addColorStop(0.00, "rgba(255,255,255,1.00)");
      grad.addColorStop(0.42, "rgba(255,255,255,0.92)");
      grad.addColorStop(0.78, "rgba(255,255,255,0.22)");
      grad.addColorStop(1.00, "rgba(255,255,255,0.00)");
      g.clearRect(0, 0, size, size);
      g.fillStyle = grad;
      g.beginPath();
      g.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
      g.fill();
      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = 4;
      tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
      return tex;
    }

    // Storage & presets: localStorage last-settings + IndexedDB named presets + JSON import/export.
    const STORAGE_LAST = "snow:lastSettings:v1";
    const IDB_NAME = "snow-presets";
    const IDB_STORE = "presets";
    const IDB_VERSION = 1;

    function safeCloneSettings(src) {
      const out = {};
      for (const k of Object.keys(src)) {
        const v = src[k];
        if (typeof v === "number" || typeof v === "boolean" || typeof v === "string") out[k] = v;
      }
      return out;
    }

    let persistBlocked = false;
    let persistTimer = 0;

    /**
     * Persists current settings to localStorage immediately (non-debounced).
     */
    function persistLastNow() {
      if (persistBlocked) return;
      try {
        const payload = { v: 1, savedAt: Date.now(), settings: safeCloneSettings(params) };
        localStorage.setItem(STORAGE_LAST, JSON.stringify(payload));
        if (params.debug) console.info("[snow] settings persisted (localStorage)");
      } catch (e) {
        console.warn("[snow] persist failed", e);
      }
    }

    /**
     * Persists current settings to localStorage with a short debounce to avoid spam during slider drags.
     */
    function persistLastDebounced() {
      if (persistBlocked) return;
      if (persistTimer) clearTimeout(persistTimer);
      persistTimer = setTimeout(() => {
        persistTimer = 0;
        persistLastNow();
      }, 200);
    }


    function loadLastIntoParams() {
      try {
        const raw = localStorage.getItem(STORAGE_LAST);
        if (!raw) return false;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object" || parsed.v !== 1 || !parsed.settings) return false;
        applySettings(parsed.settings, { rebuild: true, log: true, persist: false });
        return true;
      } catch (e) {
        console.warn("[snow] load last failed", e);
        return false;
      }
    }

    function applySettings(obj, { rebuild, log, persist } = {}) {
      if (!obj || typeof obj !== "object") return;

      const doRebuild = !!rebuild;
      const doLog = !!log;
      const doPersist = persist !== false;

      persistBlocked = true;
      try {
        for (const [k, v] of Object.entries(obj)) {
          if (!(k in params)) continue;
          const t = typeof params[k];
          if (t === "number" && typeof v === "number" && Number.isFinite(v)) params[k] = v;
          if (t === "boolean" && typeof v === "boolean") params[k] = v;
          if (t === "string" && typeof v === "string") params[k] = v;
        }

        params.timeScale = clamp(params.timeScale, 0.05, 5.0);
        params.dtMax = clamp(params.dtMax, 0.008, 0.050);
        params.pixelRatio = clamp(params.pixelRatio, 1.0, 2.0);

        params.windStrength = clamp(params.windStrength, 0.0, 3.0);
        params.windSpeed = clamp(params.windSpeed, 0.01, 1.0);

        params.fallSpeed = clamp(params.fallSpeed, 0.02, 2.50);
        params.fallJitter = clamp(params.fallJitter, 0.0, 0.90);
        params.flakeSize = clamp(params.flakeSize, 0.6, 10.0);
        params.flakeSizeJitter = clamp(params.flakeSizeJitter, 0.0, 0.90);

        params.visualCount = clamp(params.visualCount | 0, 20000, 600000);
        params.settlerCount = clamp(params.settlerCount | 0, 1000, 30000);

        params.groundDepositBudget = clamp(params.groundDepositBudget | 0, 1, 5000);
        params.depositUnit = clamp(params.depositUnit, 0.0, 0.01);

        params.objectTestsPerFrame = clamp(params.objectTestsPerFrame | 0, 0, 5000);
        params.objectDeposit = clamp(params.objectDeposit, 0.0, 0.05);

        params.stuckMax = clamp(params.stuckMax | 0, 1000, 120000);
        params.decalSize = clamp(params.decalSize, 0.04, 0.80);

        params.driftGrid = clamp(params.driftGrid | 0, 32, 256);
        params.driftMaxHeight = clamp(params.driftMaxHeight, 0.5, 8.0);

        params.coverBase = clamp(params.coverBase, 0.0, 0.30);
        params.coverMacroAmp = clamp(params.coverMacroAmp, 0.0, 0.30);
        params.coverMacroFreq = clamp(params.coverMacroFreq, 0.5, 6.0);
        params.coverMicroAmp = clamp(params.coverMicroAmp, 0.0, 0.20);
        params.coverMicroFreq = clamp(params.coverMicroFreq, 2.0, 16.0);

        params.driftDiffusion = clamp(params.driftDiffusion, 0.0, 0.25);
        params.driftAdvection = clamp(params.driftAdvection, 0.0, 0.30);

        params.gustMinInterval = clamp(params.gustMinInterval, 0.1, 20.0);
        params.gustMaxInterval = clamp(params.gustMaxInterval, Math.max(params.gustMinInterval + 0.1, 0.2), 40.0);
        params.gustTornadoChance = clamp(params.gustTornadoChance, 0.0, 1.0);
        params.gustStrengthMul = clamp(params.gustStrengthMul, 0.0, 4.0);
        params.gustSwirlMul = clamp(params.gustSwirlMul, 0.0, 4.0);
        params.gustUpdraftMul = clamp(params.gustUpdraftMul, 0.0, 4.0);
        params.gustScour = clamp(params.gustScour, 0.0, 0.10);
        params.gustRedeposit = clamp(params.gustRedeposit, 0.0, 0.10);

        params.obstacleShapeInterval = clamp(params.obstacleShapeInterval | 0, 1, 600);
        params.driftWriteInterval = clamp(params.driftWriteInterval | 0, 1, 120);
        params.normalUpdateInterval = clamp(params.normalUpdateInterval | 0, 4, 600);

      } finally {
        persistBlocked = false;
      }

      refreshGuiDisplays();

      if (doRebuild) rebuildAndReset();
      if (!doRebuild && doPersist) persistLastDebounced();

      if (doLog) console.info("[snow] settings applied");
    }

    function idbOpen() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(IDB_NAME, IDB_VERSION);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(IDB_STORE)) db.createObjectStore(IDB_STORE, { keyPath: "name" });
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbPutPreset(name, settings) {
      const db = await idbOpen();
      try {
        await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite");
          tx.onerror = () => reject(tx.error);
          tx.objectStore(IDB_STORE).put({ name, savedAt: Date.now(), settings });
          tx.oncomplete = () => resolve();
        });
      } finally {
        db.close();
      }
    }

    async function idbGetPreset(name) {
      const db = await idbOpen();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readonly");
          tx.onerror = () => reject(tx.error);
          const req = tx.objectStore(IDB_STORE).get(name);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    async function idbDeletePreset(name) {
      const db = await idbOpen();
      try {
        await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite");
          tx.onerror = () => reject(tx.error);
          tx.objectStore(IDB_STORE).delete(name);
          tx.oncomplete = () => resolve();
        });
      } finally {
        db.close();
      }
    }

    async function idbListPresetNames() {
      const db = await idbOpen();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readonly");
          tx.onerror = () => reject(tx.error);
          const req = tx.objectStore(IDB_STORE).getAllKeys();
          req.onsuccess = () => resolve((req.result || []).map(String).sort());
          req.onerror = () => reject(tx.error);
        });
      } finally {
        db.close();
      }
    }

    function sanitizePresetName(s) {
      const name = String(s ?? "").replace(/\.[a-z0-9]+$/i, "").trim();
      if (!name) return "";
      return name.replace(/\s+/g, " ").slice(0, 96);
    }

    async function ensureUniquePresetName(baseName) {
      const base = sanitizePresetName(baseName) || `preset-${nowStamp()}`;
      let name = base;
      let i = 2;
      while (true) {
        const existing = await idbGetPreset(name);
        if (!existing) return name;
        name = `${base}-${i++}`;
      }
    }

    let importInput = null;

    function ensureImportInput() {
      if (importInput) return importInput;

      importInput = document.createElement("input");
      importInput.type = "file";
      importInput.accept = "application/json,.json";
      importInput.style.position = "fixed";
      importInput.style.left = "-9999px";
      importInput.style.top = "-9999px";

      importInput.addEventListener("change", async () => {
        const file = importInput.files && importInput.files[0];
        importInput.value = "";
        if (!file) return;

        try {
          const text = await file.text();
          const json = JSON.parse(text);
          if (!json || typeof json !== "object") throw new Error("Invalid JSON");

          const settings = json.settings && typeof json.settings === "object" ? json.settings : json;
          if (!settings || typeof settings !== "object") throw new Error("Invalid settings");

          const baseName = sanitizePresetName(json.name || json.presetName || json.title || file.name) || `preset-${nowStamp()}`;
          const name = await ensureUniquePresetName(baseName);

          applySettings(settings, { rebuild: true, log: true });

          await idbPutPreset(name, safeCloneSettings(params));
          presetState.selected = name;
          presetState.presetName = name;
          await refreshPresetList();
          refreshGuiDisplays();

          console.info("[snow] imported preset:", name);
        } catch (e) {
          console.error("[snow] import failed", e);
        }
      });

      document.body.appendChild(importInput);
      return importInput;
    }

    // Simulation parameters and defaults.
    const DEFAULTS = {
      paused: false,
      debug: false,

      timeScale: 1.0,
      dtMax: 0.020,

      pixelRatio: 1.75,

      driftGrid: 128,
      driftMaxHeight: 3.6,

      coverBase: 0.06,
      coverMacroAmp: 0.09,
      coverMacroFreq: 2.4,
      coverMicroAmp: 0.05,
      coverMicroFreq: 8.5,

      windStrength: 0.75,
      windSpeed: 0.14,

      fallSpeed: 0.42,
      fallJitter: 0.45,
      flakeSize: 3.0,
      flakeSizeJitter: 0.35,

      gustMinInterval: 1.4,
      gustMaxInterval: 3.2,
      gustTornadoChance: 0.22,
      gustStrengthMul: 1.0,
      gustSwirlMul: 1.0,
      gustUpdraftMul: 1.0,
      gustScour: 0.0100,
      gustRedeposit: 0.0080,

      visualCount: 180000,

      settlerCount: 8000,
      groundDepositBudget: 420,
      depositUnit: 0.00035,

      driftDiffusion: 0.070,
      driftAdvection: 0.125,

      obstacleShapeInterval: 10,
      driftWriteInterval: 8,
      normalUpdateInterval: 36,

      objectTestsPerFrame: 900,
      objectDeposit: 0.0020,

      stuckMax: 24000,
      decalSize: 0.14,

      reset: () => reset(true),
      rebuild: () => rebuildAndReset()
    };

    const params = { ...DEFAULTS };

    // Three.js scene setup: renderer, camera, controls, lighting.
    const root = document.getElementById("app");

    /**
     * Reads the actual render container size (not window size), so resize/fullscreen/mobile UI changes track correctly.
     */
    const viewport = { w: 1, h: 1 };
    function readViewport() {
      const r = root.getBoundingClientRect();
      viewport.w = Math.max(1, Math.floor(r.width || innerWidth));
      viewport.h = Math.max(1, Math.floor(r.height || innerHeight));
      return viewport;
    }



    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a1220);
    scene.fog = new THREE.FogExp2(0x0a1220, 0.045);

    const s0 = readViewport();
    const camera = new THREE.PerspectiveCamera(55, s0.w / s0.h, 0.1, 320);

    camera.position.set(10, 9, 14);

    const renderer = new THREE.WebGLRenderer({ antialias: true });

    renderer.setPixelRatio(Math.min(devicePixelRatio, params.pixelRatio));
    const s1 = readViewport();
    renderer.setSize(s1.w, s1.h, false);


    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    root.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.06;
    controls.target.set(0, 2, 0);

    scene.add(new THREE.HemisphereLight(0xdce7ff, 0x0b0f18, 0.72));

    const dir = new THREE.DirectionalLight(0xffffff, 1.05);
    dir.position.set(8, 14, 6);
    dir.castShadow = true;
    dir.shadow.mapSize.set(2048, 2048);
    dir.shadow.camera.left = -26;
    dir.shadow.camera.right = 26;
    dir.shadow.camera.top = 26;
    dir.shadow.camera.bottom = -26;
    dir.shadow.camera.near = 0.1;
    dir.shadow.camera.far = 120;
    scene.add(dir);

    const snowTex = makeRadialTexture(96);

    // World geometry: ground plane + drift heightfield mesh.
    const GROUND_SIZE = 50;
    const halfGround = GROUND_SIZE * 0.5;

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE),
      new THREE.MeshStandardMaterial({ color: 0x0f1726, roughness: 1.0, metalness: 0.0 })
      );
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    let GRID = params.driftGrid;
    let stride = GRID + 1;
    let VERTS = stride * stride;

    let heights = new Float32Array(VERTS);
    let heightsTmp = new Float32Array(VERTS);

    let snowGeo = null;
    let snowSurface = null;
    let snowPosAttr = null;
    let snowPosArr = null;

    function gridIndex(i, j) { return j * stride + i; }

    function buildSnowSurface() {
      if (snowSurface) {
        scene.remove(snowSurface);
        snowSurface.geometry.dispose();
        snowSurface.material.dispose();
      }

      GRID = Math.max(32, Math.min(256, (params.driftGrid | 0)));
      stride = GRID + 1;
      VERTS = stride * stride;

      heights = new Float32Array(VERTS);
      heightsTmp = new Float32Array(VERTS);

      snowGeo = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE, GRID, GRID);
      snowGeo.rotateX(-Math.PI / 2);

      const snowMat = new THREE.MeshStandardMaterial({
        color: 0xf7faff,
        roughness: 0.995,
        metalness: 0.0,
        polygonOffset: true,
        polygonOffsetFactor: -2,
        polygonOffsetUnits: -2
      });

      snowSurface = new THREE.Mesh(snowGeo, snowMat);
      snowSurface.position.y = 0.02;
      snowSurface.receiveShadow = true;
      scene.add(snowSurface);

      snowPosAttr = snowGeo.attributes.position;
      snowPosArr = snowPosAttr.array;

      initSnowCover();
      applyHeightsToGeometry();
      snowGeo.computeVertexNormals();
      snowGeo.attributes.normal.needsUpdate = true;
    }

    /**
     * Initializes the drift heightfield with a thin base layer and small, controllable unevenness.
     * Macro frequency controls broader rolls; micro frequency adds smaller lumps.
     */
    function initSnowCover() {
      const base = Math.max(0, params.coverBase);
      const macroAmp = Math.max(0, params.coverMacroAmp);
      const macroFreq = Math.max(0.1, params.coverMacroFreq);
      const microAmp = Math.max(0, params.coverMicroAmp);
      const microFreq = Math.max(0.1, params.coverMicroFreq);

      const TAU = Math.PI * 2;

      for (let j = 0; j <= GRID; j++) {
        for (let i = 0; i <= GRID; i++) {
          const u = i / GRID;
          const v = j / GRID;

          const sin1 = Math.sin((u * macroFreq + 0.11) * TAU);
          const cos1 = Math.cos((v * macroFreq - 0.07) * TAU);
          const sin2 = Math.sin(((u * 0.75 + v * 0.90) * macroFreq + 0.31) * TAU);
          const macro = (sin1 + cos1 + sin2) * (1.0 / 3.0);

          const sin3 = Math.sin(((u * microFreq + v * (microFreq * 0.70)) + 0.19) * TAU);
          const cos2 = Math.cos(((v * microFreq - u * (microFreq * 0.80)) - 0.23) * TAU);
          const micro = (sin3 + cos2) * 0.5;

          const h = base + macro * macroAmp + micro * microAmp;
          heights[gridIndex(i, j)] = clamp(h, 0, Math.max(0.5, params.driftMaxHeight));
        }
      }
    }

    /**
     * Writes heightfield values into the drift surface mesh vertices.
     */
    function applyHeightsToGeometry() {
      for (let v = 0; v < VERTS; v++) snowPosArr[v * 3 + 1] = heights[v];
        snowPosAttr.needsUpdate = true;
    }

    /**
     * Bilinear sampling of snow height at world x,z.
     */
    function sampleSnowHeight(x, z) {
      const u = clamp((x + halfGround) / GROUND_SIZE, 0, 0.999999);
      const v = clamp((z + halfGround) / GROUND_SIZE, 0, 0.999999);

      const fx = u * GRID;
      const fz = v * GRID;

      const i0 = fx | 0;
      const j0 = fz | 0;
      const i1 = i0 + 1;
      const j1 = j0 + 1;

      const tx = fx - i0;
      const tz = fz - j0;

      const h00 = heights[gridIndex(i0, j0)];
      const h10 = heights[gridIndex(i1, j0)];
      const h01 = heights[gridIndex(i0, j1)];
      const h11 = heights[gridIndex(i1, j1)];

      const hx0 = h00 + (h10 - h00) * tx;
      const hx1 = h01 + (h11 - h01) * tx;
      return hx0 + (hx1 - hx0) * tz;
    }

    // Drift deposition and evolution.
    const KERNEL_RADIUS = 3;
    const KERNEL_SIGMA = 1.05;

    const kernel = [];
    for (let dz = -KERNEL_RADIUS; dz <= KERNEL_RADIUS; dz++) {
      for (let dx = -KERNEL_RADIUS; dx <= KERNEL_RADIUS; dx++) {
        const r2 = dx * dx + dz * dz;
        if (r2 > KERNEL_RADIUS * KERNEL_RADIUS) continue;
        kernel.push({ dx, dz, w: Math.exp(-r2 / (2 * KERNEL_SIGMA * KERNEL_SIGMA)) });
      }
    }

    let wsum = 0;
    for (const k of kernel) wsum += k.w;
      for (const k of kernel) k.w /= wsum;

    /**
     * Deposits (positive) or erodes (negative) snow near a point; wind biases slightly downwind.
     * Uses a compact kernel so deposits form small drifts rather than broad plateaus.
     */
        function depositHeightAtWorld(x, z, amount, windX, windZ) {
          const drift = 0.35;
          const nx = x + windX * drift;
          const nz = z + windZ * drift;

          const u = clamp((nx + halfGround) / GROUND_SIZE, 0, 1);
          const v = clamp((nz + halfGround) / GROUND_SIZE, 0, 1);

          const ci = clamp((u * GRID) | 0, 0, GRID);
          const cj = clamp((v * GRID) | 0, 0, GRID);

          const maxH = Math.max(0.5, params.driftMaxHeight);

          for (const k of kernel) {
            const i = ci + k.dx;
            const j = cj + k.dz;
            if (i < 0 || i > GRID || j < 0 || j > GRID) continue;

            const idx = gridIndex(i, j);
            const h = heights[idx];

            const shelter = clamp(1.0 - h / maxH, 0.1, 1.0);
            const a = amount * k.w * shelter;

            heights[idx] = clamp(h + a, 0, maxH);
          }
        }

    /**
     * Diffusion + wind advection to merge deposits into coherent snowdrifts (small hills).
     */
        function evolveDrifts(windX, windZ) {
          const diff = clamp(params.driftDiffusion, 0.0, 0.25);
          const adv = clamp(params.driftAdvection, 0.0, 0.30);

          const wx = clamp(windX, -1, 1);
          const wz = clamp(windZ, -1, 1);

          for (let j = 0; j <= GRID; j++) {
            const jb = (j > 0) ? j - 1 : j;
            const jt = (j < GRID) ? j + 1 : j;

            for (let i = 0; i <= GRID; i++) {
              const il = (i > 0) ? i - 1 : i;
              const ir = (i < GRID) ? i + 1 : i;

              const idx = gridIndex(i, j);
              const h = heights[idx];

              const hl = heights[gridIndex(il, j)];
              const hr = heights[gridIndex(ir, j)];
              const hb = heights[gridIndex(i, jb)];
              const ht = heights[gridIndex(i, jt)];
              const avg = (hl + hr + hb + ht) * 0.25;

              const upI = clamp(i - Math.round(wx), 0, GRID);
              const upJ = clamp(j - Math.round(wz), 0, GRID);
              const upH = heights[gridIndex(upI, upJ)];

              let nh = h + diff * (avg - h) + adv * (upH - h);
              nh = Math.max(0, nh * 0.99982);
              heightsTmp[idx] = nh;
            }
          }
          heights.set(heightsTmp);
        }

    // Props/obstacles placed in the world (trees, rocks).
        const cones = [];
        const rocks = [];

        const coneGeo = new THREE.ConeGeometry(0.9, 3.3, 24, 1);
        const coneMat = new THREE.MeshStandardMaterial({ color: 0x27d66b, roughness: 0.75 });

        const treePositions = [
          [-6, 1.65, -3],
          [-2, 1.65,  4],
          [ 3, 1.65, -1],
          [ 7, 1.65,  5],
          [ 1, 1.65,  8]
        ];

        for (let i = 0; i < treePositions.length; i++) {
          const m = new THREE.Mesh(coneGeo, coneMat);
          m.position.set(treePositions[i][0], treePositions[i][1], treePositions[i][2]);
          m.rotation.y = (i * 0.9) % (Math.PI * 2);
          m.castShadow = true;
          m.receiveShadow = true;
          scene.add(m);
          cones.push(m);
        }

        const rockGeo = new THREE.IcosahedronGeometry(1.1, 0);
        const rockMat = new THREE.MeshStandardMaterial({ color: 0x2b3442, roughness: 1.0 });

        const rockPos = [
          [-9, 1.0,  6],
          [-7, 0.8, -8],
          [ 8, 1.0, -6]
        ];

        for (let i = 0; i < rockPos.length; i++) {
          const r = new THREE.Mesh(rockGeo, rockMat);
          r.position.set(rockPos[i][0], rockPos[i][1], rockPos[i][2]);
          r.scale.setScalar(1.0 + i * 0.25);
          r.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
          r.castShadow = true;
          r.receiveShadow = true;
          scene.add(r);
          rocks.push(r);
        }

        const colliderObjects = [...cones, ...rocks];

    // Sticking snow visuals: decals (instanced). Cap meshes are intentionally disabled.
        let stuck = null;
        let stuckGeo = null;
        let stuckMat = null;
        let stuckCount = 0;
        let stuckWrite = 0;

        const tmpM = new THREE.Matrix4();
        const tmpQ = new THREE.Quaternion();
        const tmpS = new THREE.Vector3();
        const tmpP = new THREE.Vector3();
        const tmpN = new THREE.Vector3();
        const zAxis = new THREE.Vector3(0, 0, 1);
        const normalMatrix = new THREE.Matrix3();

        function buildStuckSystem() {
          if (stuck) {
            scene.remove(stuck);
            stuck.geometry.dispose();
            stuck.material.dispose();
          }

          const max = Math.max(1000, (params.stuckMax | 0));
          stuckGeo = new THREE.CircleGeometry(Math.max(0.05, params.decalSize), 20);
          stuckMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.97,
            metalness: 0.0,
            map: snowTex,
            transparent: true,
            opacity: 1.0,
            depthWrite: false,
            polygonOffset: true,
            polygonOffsetFactor: -1,
            polygonOffsetUnits: -1,
            emissive: new THREE.Color(0x202020),
            emissiveIntensity: 0.65
          });

          stuck = new THREE.InstancedMesh(stuckGeo, stuckMat, max);
          stuck.frustumCulled = false;
          stuck.renderOrder = 3;
          scene.add(stuck);

          stuckCount = 0;
          stuckWrite = 0;
          stuck.count = 0;
          stuck.instanceMatrix.needsUpdate = true;
        }

    /**
     * Adds/updates a snow decal at an impact point; uses a ring buffer so sticking continues indefinitely.
     * Allows sticking on sides/branches while scaling decals down on steep surfaces.
     */
        function addStuckSnow(point, normal) {
          if (!stuck) return;
          if (!Number.isFinite(point.x + point.y + point.z)) return;

          tmpN.set(0, 1, 0);
          if (normal && Number.isFinite(normal.x + normal.y + normal.z)) tmpN.copy(normal);

          const nLen = tmpN.length();
          if (nLen < 1e-6) tmpN.set(0, 1, 0);
          else tmpN.multiplyScalar(1.0 / nLen);

          const max = stuck.instanceMatrix.count;
          const idx = stuckWrite % max;

          const up01 = clamp((tmpN.y + 1.0) * 0.5, 0.0, 1.0);

          const lift = 0.008 + Math.random() * 0.012;
          tmpP.copy(point).addScaledVector(tmpN, lift);

          const baseSize = Math.max(0.05, params.decalSize);
          const slopeMul = 0.25 + 0.75 * up01;
          const base = baseSize * (0.55 + Math.random() * 1.05) * slopeMul;

          const anis = 0.70 + Math.random() * 0.85;
          const steep = 1.0 - up01;
          const sx = base * (1.0 - 0.15 * steep);
          const sy = base * anis * (1.0 + 0.35 * steep);
          tmpS.set(sx, sy, 1);

          tmpQ.setFromUnitVectors(zAxis, tmpN);
          tmpQ.multiply(new THREE.Quaternion().setFromAxisAngle(tmpN, Math.random() * Math.PI * 2));

          tmpM.compose(tmpP, tmpQ, tmpS);
          stuck.setMatrixAt(idx, tmpM);

          stuckWrite++;
          stuckCount = Math.min(stuckCount + 1, max);
          stuck.count = stuckCount;
          stuck.instanceMatrix.needsUpdate = true;
        }

        const caps = [];

    /**
     * Cap meshes are disabled; sticking is represented by decals on surfaces and drift buildup on the ground.
     */
        function buildCaps() {}

    /**
     * No-op: cap meshes are disabled.
     */
        function updateCaps(_dt) {}

    // Gust system: spawn, evolve, wind field sampling, and drift interaction.
        class Gust {
          constructor() {
            this.x = 0;
            this.z = 0;
            this.radius = 1;
            this.strength = 0;
            this.swirl = 0;
            this.updraft = 0;
            this.ttl = 0;
            this.life = 0;
          }
          reset(x, z, radius, strength, swirl, updraft, ttl) {
            this.x = x; this.z = z;
            this.radius = radius;
            this.strength = strength;
            this.swirl = swirl;
            this.updraft = updraft;
            this.ttl = ttl;
            this.life = ttl;
          }
          step(dt) { this.life = Math.max(0, this.life - dt); }
          get active() { return this.life > 0; }
          get fade() {
            if (this.ttl <= 1e-6) return 0;
            const t = this.life / this.ttl;
            return t * t;
          }
        }

        const GUST_MAX = 6;
        const gusts = Array.from({ length: GUST_MAX }, () => new Gust());
        let gustSpawnTimer = 0;

    /**
     * Spawns gusts near trees: local blizzards and occasional small tornado-like swirls.
     */
        function spawnGusts(dt) {
          gustSpawnTimer -= dt;
          if (gustSpawnTimer > 0) return;

          gustSpawnTimer = clamp(params.gustMinInterval, 0.2, 10.0) +
          Math.random() * clamp(params.gustMaxInterval - params.gustMinInterval, 0.1, 20.0);

          const tpos = cones[(Math.random() * cones.length) | 0].position;
          const gx = tpos.x + (Math.random() * 2 - 1) * 2.2;
          const gz = tpos.z + (Math.random() * 2 - 1) * 2.2;

          const isTornado = Math.random() < clamp(params.gustTornadoChance, 0, 1);

          const radius = isTornado ? (1.8 + Math.random() * 1.2) : (3.4 + Math.random() * 3.2);
          const strength = (isTornado ? (2.4 + Math.random() * 2.2) : (0.9 + Math.random() * 1.2)) * params.gustStrengthMul;
          const swirl = (Math.random() < 0.5 ? -1 : 1) * (isTornado ? 4.4 : 2.2) * params.gustSwirlMul;
          const updraft = (isTornado ? (2.2 + Math.random() * 2.0) : (0.20 + Math.random() * 0.55)) * params.gustUpdraftMul;
          const ttl = isTornado ? (1.5 + Math.random() * 1.8) : (1.1 + Math.random() * 1.8);

          for (let i = 0; i < gusts.length; i++) {
            if (!gusts[i].active) { gusts[i].reset(gx, gz, radius, strength, swirl, updraft, ttl); return; }
          }
          gusts[0].reset(gx, gz, radius, strength, swirl, updraft, ttl);
        }

        const gustTmp = new THREE.Vector3();

    /**
     * Local gust wind field: swirl near ground and quickly fades with height.
     */
        function gustWindAt(x, z, heightAboveSnow, out) {
          out.set(0, 0, 0);

          for (let i = 0; i < gusts.length; i++) {
            const g = gusts[i];
            if (!g.active) continue;

            const dx = x - g.x;
            const dz = z - g.z;
            const r2 = dx * dx + dz * dz;
            const r = g.radius;
            if (r2 > r * r) continue;

            const rr = Math.max(1e-6, Math.sqrt(r2));
            const npx = dx / rr;
            const npz = dz / rr;

            const heightK = 1.0 / (1.0 + heightAboveSnow * 1.15);
            const radial = 1.0 - rr / r;
            const k = g.fade * g.strength * radial * radial * heightK;

            const tx = -npz;
            const tz = npx;

            out.x += tx * (g.swirl * k) + (-npx) * (0.18 * k);
            out.z += tz * (g.swirl * k) + (-npz) * (0.18 * k);

            out.y += g.updraft * k * (radial * radial);
          }

          return out;
        }

    /**
     * Gusts scour snow at the core and redeposit downwind to form drifts.
     */
        function applyGustScour(baseWindX, baseWindZ) {
          const scourBase = clamp(params.gustScour, 0.0, 0.05);
          const redepBase = clamp(params.gustRedeposit, 0.0, 0.05);

          for (let i = 0; i < gusts.length; i++) {
            const g = gusts[i];
            if (!g.active) continue;

            const fade = g.fade;
            const scour = -scourBase * fade;
            const redeposit = redepBase * fade;

            depositHeightAtWorld(g.x, g.z, scour, 0, 0);
            depositHeightAtWorld(g.x, g.z, scour * 0.7, 0, 0);
            depositHeightAtWorld(g.x, g.z, redeposit, baseWindX, baseWindZ);
          }
        }

    // GPU visual snow: point-sprite flake field driven by base wind + gust uniforms.
        let visualSnow = null;
        let visualGeo = null;
        let visualMat = null;

        const bounds = { x: 22, z: 22, yMin: -2.0, yMax: 22.0 };
        const gustPosRad = new Float32Array(GUST_MAX * 3);
        const gustParams = new Float32Array(GUST_MAX * 3);

        function buildVisualSnow() {
          if (visualSnow) {
            scene.remove(visualSnow);
            visualSnow.geometry.dispose();
            visualSnow.material.dispose();
          }

          const count = Math.max(20000, params.visualCount | 0);
          const pos = new Float32Array(count * 3);
          const seed = new Float32Array(count);

          for (let i = 0; i < count; i++) {
            const p = i * 3;
            pos[p + 0] = (Math.random() * 2 - 1) * bounds.x;
            pos[p + 1] = bounds.yMin + Math.random() * (bounds.yMax - bounds.yMin);
            pos[p + 2] = (Math.random() * 2 - 1) * bounds.z;
            seed[i] = Math.random();
          }

          visualGeo = new THREE.BufferGeometry();
          visualGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
          visualGeo.setAttribute("aSeed", new THREE.BufferAttribute(seed, 1));

          visualMat = new THREE.ShaderMaterial({
            transparent: true,
            depthWrite: false,
            uniforms: {
              uTime: { value: 0 },
              uTex: { value: snowTex },
              uWind: { value: new THREE.Vector2(0, 0) },
              uBounds: { value: new THREE.Vector2(bounds.x, bounds.z) },
              uYTop: { value: bounds.yMax },
              uYBot: { value: bounds.yMin },
              uGroundY: { value: 0.06 },
              uFallSpeed: { value: params.fallSpeed },
              uFallJitter: { value: params.fallJitter },
              uFlakeSize: { value: params.flakeSize },
              uFlakeSizeJitter: { value: params.flakeSizeJitter },
              uGustPosRad: { value: gustPosRad },
              uGustParams: { value: gustParams }
            },
            vertexShader: `
          uniform float uTime;
          uniform vec2 uWind;
          uniform vec2 uBounds;
          uniform float uYTop;
          uniform float uYBot;
          uniform float uGroundY;

          uniform float uFallSpeed;
          uniform float uFallJitter;
          uniform float uFlakeSize;
          uniform float uFlakeSizeJitter;

          uniform float uGustPosRad[18];
          uniform float uGustParams[18];

          attribute float aSeed;

          varying float vAlpha;

          float wrap(float x, float halfSpan) {
            float span = halfSpan * 2.0;
            return -halfSpan + mod(x + halfSpan + span * 1000.0, span);
          }

          float jitter01(float x) {
            return fract(sin(x) * 43758.5453123);
          }

          void main() {
            vec3 p = position;

            float spanY = (uYTop - uYBot);

            float jf = jitter01(aSeed * 91.7 + 3.1);
            float fallMul = mix(1.0 - uFallJitter, 1.0 + uFallJitter, jf);
            float speed = max(0.001, uFallSpeed) * fallMul;

            float phase = aSeed * 37.0;
            float y = uYTop - mod(uTime * speed + phase, spanY);

            float nearGround = clamp(1.0 - (y - uYBot) / 6.0, 0.0, 1.0);

            float flutter = sin(uTime * 1.15 + aSeed * 83.0) * 0.10 + sin(uTime * 1.85 + aSeed * 19.0) * 0.05;
            vec2 drift = uWind * (0.22 + 0.16 * sin(aSeed * 11.0)) + vec2(flutter * 0.18, cos(uTime * 0.9 + aSeed * 41.0) * 0.03);

            vec2 gustVec = vec2(0.0);
            float lift = 0.0;

            for (int gi = 0; gi < 6; gi++) {
              float gx = uGustPosRad[gi * 3 + 0];
              float gz = uGustPosRad[gi * 3 + 1];
              float gr = uGustPosRad[gi * 3 + 2];

              float gs  = uGustParams[gi * 3 + 0];
              float gsw = uGustParams[gi * 3 + 1];
              float gup = uGustParams[gi * 3 + 2];

              vec2 d = vec2(p.x - gx, p.z - gz);
              float r2 = dot(d, d);
              float rr = sqrt(max(r2, 1e-6));
              if (rr > gr) continue;

              float radial = 1.0 - rr / gr;
              float k = radial * radial * nearGround * gs;

              vec2 n = d / rr;
              vec2 t = vec2(-n.y, n.x);

              gustVec += t * (gsw * k) + (-n) * (0.12 * k);
              lift += gup * k * (radial * radial);
            }

            y += lift * 0.12;

            float x = p.x + drift.x * uTime + gustVec.x;
            float z = p.z + drift.y * uTime + gustVec.y;

            x = wrap(x, uBounds.x);
            z = wrap(z, uBounds.y);

            vec3 worldPos = vec3(x, y, z);
            vec4 mvPosition = modelViewMatrix * vec4(worldPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float js = jitter01(aSeed * 13.9 + 7.7);
            float sizeMul = mix(1.0 - uFlakeSizeJitter, 1.0 + uFlakeSizeJitter, js);
            float size = max(0.05, uFlakeSize) * sizeMul;

            gl_PointSize = size * (300.0 / -mvPosition.z);

            float groundFade = clamp((y - uGroundY) / 0.9, 0.0, 1.0);
            vAlpha = (mix(0.55, 0.95, fract(aSeed * 4.77)) * (0.65 + 0.35 * nearGround)) * groundFade;
          }
              `,
              fragmentShader: `
          uniform sampler2D uTex;
          varying float vAlpha;

          void main() {
            vec4 tex = texture2D(uTex, gl_PointCoord);
            float a = tex.a * vAlpha;
            if (a < 0.01) discard;
            gl_FragColor = vec4(1.0, 1.0, 1.0, a);
          }
                `
              });

visualSnow = new THREE.Points(visualGeo, visualMat);
visualSnow.frustumCulled = false;
scene.add(visualSnow);
}

    // CPU settlers: simulated flakes that deposit on drift surface and can hit objects.
let SETTLER_COUNT = params.settlerCount | 0;
let settlerPos = null;
let settlerPrev = null;
let settlerVel = null;

const settleBounds = { x: 22, z: 22, yMin: -2.0, yMax: 18.0 };

function buildSettlers() {
  SETTLER_COUNT = Math.max(1000, params.settlerCount | 0);
  settlerPos = new Float32Array(SETTLER_COUNT * 3);
  settlerPrev = new Float32Array(SETTLER_COUNT * 3);
  settlerVel = new Float32Array(SETTLER_COUNT * 3);
  for (let i = 0; i < SETTLER_COUNT; i++) respawnSettler(i);
}

function respawnSettler(i) {
  const p = i * 3;
  const x = (Math.random() * 2 - 1) * settleBounds.x;
  const y = settleBounds.yMax * (0.72 + Math.random() * 0.28);
  const z = (Math.random() * 2 - 1) * settleBounds.z;

  settlerPos[p + 0] = x; settlerPos[p + 1] = y; settlerPos[p + 2] = z;
  settlerPrev[p + 0] = x; settlerPrev[p + 1] = y; settlerPrev[p + 2] = z;

  settlerVel[p + 0] = (Math.random() * 2 - 1) * 0.02;
  settlerVel[p + 1] = -(0.35 + Math.random() * 0.35);
  settlerVel[p + 2] = (Math.random() * 2 - 1) * 0.02;
}

    // Object collision: broadphase + segment raycasts for decals and drift interaction.
const boundCenter = new THREE.Vector3();
const raycaster = new THREE.Raycaster();
const segDir = new THREE.Vector3();
const segDelta = new THREE.Vector3();
const hitFrom = new THREE.Vector3();

    /**
     * Builds world-space bounding spheres for fast broadphase collision checks.
     */
function buildColliderBounds(objects) {
  const out = [];
  for (const obj of objects) {
    if (!obj.geometry.boundingSphere) obj.geometry.computeBoundingSphere();
    const bs = obj.geometry.boundingSphere;

    boundCenter.copy(bs.center);
    obj.localToWorld(boundCenter);

    const sx = obj.scale.x, sy = obj.scale.y, sz = obj.scale.z;
    const maxS = Math.max(Math.abs(sx), Math.abs(sy), Math.abs(sz));
    const radius = bs.radius * maxS;

    out.push({ obj, center: boundCenter.clone(), radius });
  }
  return out;
}

const colliderBounds = buildColliderBounds(colliderObjects);

    /**
     * Shapes leeward drifts around obstacles by scouring upwind and depositing downwind.
     */
function shapeDriftsAroundObstacles(baseWindX, baseWindZ) {
  const wx = baseWindX;
  const wz = baseWindZ;
  const wLen = Math.sqrt(wx * wx + wz * wz);
  if (wLen < 1e-4) return;

  const nx = wx / wLen;
  const nz = wz / wLen;

  for (let o = 0; o < colliderBounds.length; o++) {
    const cb = colliderBounds[o];
    const ox = cb.center.x;
    const oz = cb.center.z;

    const scourX = ox - nx * (cb.radius * 1.20);
    const scourZ = oz - nz * (cb.radius * 1.20);

    const driftX = ox + nx * (cb.radius * 1.55);
    const driftZ = oz + nz * (cb.radius * 1.55);

    depositHeightAtWorld(scourX, scourZ, -0.0016, 0, 0);
    depositHeightAtWorld(driftX, driftZ,  0.0030, wx, wz);
  }
}

    // Rebuild/reset pipeline: (re)create buffers/meshes/systems and reset state.
function reset(randomize) {
  persistBlocked = true;
  try {
    if (randomize) {
      stuckCount = 0;
      stuckWrite = 0;
      if (stuck) {
        stuck.count = 0;
        stuck.instanceMatrix.needsUpdate = true;
      }
      for (const cap of caps) cap.userData.amount = 0.0;
    }

  initSnowCover();
  applyHeightsToGeometry();
  snowGeo.computeVertexNormals();
  snowGeo.attributes.normal.needsUpdate = true;

  for (let i = 0; i < SETTLER_COUNT; i++) respawnSettler(i);

    gustSpawnTimer = 0;
  for (let i = 0; i < gusts.length; i++) gusts[i].life = 0;

} finally {
  persistBlocked = false;
}
persistLastDebounced();
}

function rebuildAndReset() {
  renderer.setPixelRatio(Math.min(devicePixelRatio, params.pixelRatio));

  buildSnowSurface();
  buildVisualSnow();
  buildSettlers();
  buildStuckSystem();
  buildCaps();

  reset(true);
  refreshGuiDisplays();
  persistLastDebounced();
}

    // lil-gui wiring: controllers, persistence hooks, preset actions.
const gui = new GUI({ width: 380 });
const guiControllers = [];

function track(c) { guiControllers.push(c); return c; }

function refreshGuiDisplays() {
  for (const c of guiControllers) c.updateDisplay();
}


/**
 * Wires a lil-gui controller to persistence and optional rebuild behavior.
 * Persists immediately on change for non-rebuild controls so refresh always restores the last value.
 */
function wirePersist(c, rebuildOnChange) {
  const hasFinish = typeof c.onFinishChange === "function";

  if (hasFinish) {
    c.onChange(() => {
      if (!rebuildOnChange) persistLastNow();
    });

    c.onFinishChange(() => {
      if (rebuildOnChange) rebuildAndReset();
      persistLastNow();
    });

    return c;
  }

  c.onChange(() => {
    if (rebuildOnChange) rebuildAndReset();
    persistLastNow();
  });

  return c;
}



const presetState = {
  presetName: "",
  selected: "",
  save: async () => {
    const name = (presetState.presetName || "").trim() || `preset-${nowStamp()}`;
    const settings = safeCloneSettings(params);
    try {
      await idbPutPreset(name, settings);
      presetState.selected = name;
      presetState.presetName = name;
      await refreshPresetList();
      console.info("[snow] preset saved:", name);
    } catch (e) {
      console.error("[snow] preset save failed", e);
    }
  },
  load: async () => {
    const name = (presetState.selected || "").trim();
    if (!name) return;
    try {
      const row = await idbGetPreset(name);
      if (!row || !row.settings) return;
      applySettings(row.settings, { rebuild: true, log: true });
      presetState.presetName = name;
      presetState.selected = name;
      refreshGuiDisplays();
      console.info("[snow] preset loaded:", name);
    } catch (e) {
      console.error("[snow] preset load failed", e);
    }
  },
  delete: async () => {
    const name = (presetState.selected || "").trim();
    if (!name) return;
    try {
      await idbDeletePreset(name);
      presetState.selected = "";
      await refreshPresetList();
      console.info("[snow] preset deleted:", name);
    } catch (e) {
      console.error("[snow] preset delete failed", e);
    }
  },
  exportJson: () => {
    const payload = { v: 1, exportedAt: Date.now(), settings: safeCloneSettings(params) };
    downloadJson(payload, `snow-settings-${nowStamp()}.json`);
  },
  importJson: () => { ensureImportInput().click(); }
};

let presetSelectCtrl = null;

function setPresetOptions(names) {
  const opts = { "(none)": "" };
  for (const n of names) opts[n] = n;

    if (presetSelectCtrl && typeof presetSelectCtrl.options === "function") {
      presetSelectCtrl.options(opts);
      presetSelectCtrl.updateDisplay();
      return;
    }

    if (presetSelectCtrl && typeof presetSelectCtrl.destroy === "function") presetSelectCtrl.destroy();

    presetSelectCtrl = guiPresets.add(presetState, "selected", opts).name("Selected").listen();
    presetSelectCtrl.onChange(() => {
      const name = (presetState.selected || "").trim();
      if (!name) return;
      presetState.load();
    });

    track(presetSelectCtrl);
  }

  async function refreshPresetList() {
    try {
      const names = await idbListPresetNames();
      setPresetOptions(names);
    } catch {
      setPresetOptions([]);
    }
  }

  track(wirePersist(gui.add(params, "paused").name("Paused").listen(), false));
  track(wirePersist(gui.add(params, "debug").name("Debug logs").listen(), false));

  
  track(wirePersist(gui.add(params, "timeScale", 0.05, 2.0, 0.01).name("Time scale").listen(), false));
  track(wirePersist(gui.add(params, "dtMax", 0.008, 0.030, 0.001).name("dtMax").listen(), false));
  track(wirePersist(gui.add(params, "pixelRatio", 1.0, 2.0, 0.01).name("Pixel ratio").listen(), true));

  const guiWind = gui.addFolder("Wind");
  track(wirePersist(guiWind.add(params, "windStrength", 0.0, 2.0, 0.01).name("Strength").listen(), false));
  track(wirePersist(guiWind.add(params, "windSpeed", 0.02, 0.40, 0.005).name("Speed").listen(), false));
  guiWind.open();

  const guiGust = gui.addFolder("Gusts");
  track(wirePersist(guiGust.add(params, "gustMinInterval", 0.2, 6.0, 0.1).name("Min interval").listen(), false));
  track(wirePersist(guiGust.add(params, "gustMaxInterval", 0.4, 12.0, 0.1).name("Max interval").listen(), false));
  track(wirePersist(guiGust.add(params, "gustTornadoChance", 0.0, 0.6, 0.01).name("Tornado chance").listen(), false));
  track(wirePersist(guiGust.add(params, "gustStrengthMul", 0.3, 2.0, 0.01).name("Strength mul").listen(), false));
  track(wirePersist(guiGust.add(params, "gustSwirlMul", 0.3, 2.0, 0.01).name("Swirl mul").listen(), false));
  track(wirePersist(guiGust.add(params, "gustUpdraftMul", 0.0, 2.0, 0.01).name("Updraft mul").listen(), false));
  track(wirePersist(guiGust.add(params, "gustScour", 0.0, 0.03, 0.0005).name("Scour").listen(), false));
  track(wirePersist(guiGust.add(params, "gustRedeposit", 0.0, 0.03, 0.0005).name("Redeposit").listen(), false));
  guiGust.open();

  const guiCounts = gui.addFolder("Counts");
  track(wirePersist(guiCounts.add(params, "visualCount", 20000, 500000, 1000).name("Visual flakes").listen(), true));
  track(wirePersist(guiCounts.add(params, "settlerCount", 1000, 20000, 250).name("Settlers (stick)").listen(), true));
  track(wirePersist(guiCounts.add(params, "groundDepositBudget", 20, 1200, 10).name("Deposit budget").listen(), false));
  guiCounts.open();

  const guiSnow = gui.addFolder("Snow");
  track(wirePersist(guiSnow.add(params, "fallSpeed", 0.001, 10.50, 0.001).name("Fall speed").listen(), false));
  track(wirePersist(guiSnow.add(params, "fallJitter", 0.0, 0.90, 0.01).name("Fall jitter").listen(), false));
  track(wirePersist(guiSnow.add(params, "flakeSize", 0.01, 10.0, 0.01).name("Flake size").listen(), false));
  track(wirePersist(guiSnow.add(params, "flakeSizeJitter", 0.0, 0.90, 0.01).name("Size jitter").listen(), false));
  guiSnow.open();

  const guiDrifts = gui.addFolder("Drifts");
  track(wirePersist(guiDrifts.add(params, "driftGrid", 32, 256, 1).name("Grid").listen(), true));
  track(wirePersist(guiDrifts.add(params, "driftMaxHeight", 0.5, 6.0, 0.1).name("Max height").listen(), false));

  track(wirePersist(guiDrifts.add(params, "coverBase", 0.0, 0.30, 0.005).name("Base cover").listen(), false));
  track(wirePersist(guiDrifts.add(params, "coverMacroAmp", 0.0, 0.30, 0.005).name("Macro amp").listen(), false));
  track(wirePersist(guiDrifts.add(params, "coverMacroFreq", 0.5, 6.0, 0.1).name("Macro freq").listen(), false));
  track(wirePersist(guiDrifts.add(params, "coverMicroAmp", 0.0, 0.20, 0.005).name("Micro amp").listen(), false));
  track(wirePersist(guiDrifts.add(params, "coverMicroFreq", 2.0, 16.0, 0.1).name("Micro freq").listen(), false));

  track(wirePersist(guiDrifts.add(params, "depositUnit", 0.00005, 0.00150, 0.00001).name("Deposit unit").listen(), false));
  track(wirePersist(guiDrifts.add(params, "driftDiffusion", 0.0, 0.25, 0.001).name("Diffusion").listen(), false));
  track(wirePersist(guiDrifts.add(params, "driftAdvection", 0.0, 0.30, 0.001).name("Advection").listen(), false));
  track(wirePersist(guiDrifts.add(params, "obstacleShapeInterval", 1, 60, 1).name("Obstacle shape N").listen(), false));
  track(wirePersist(guiDrifts.add(params, "driftWriteInterval", 1, 30, 1).name("Write mesh N").listen(), false));
  track(wirePersist(guiDrifts.add(params, "normalUpdateInterval", 4, 120, 1).name("Normals N").listen(), false));
  guiDrifts.open();

  const guiStick = gui.addFolder("Sticking");
  track(wirePersist(guiStick.add(params, "objectTestsPerFrame", 50, 2500, 10).name("Ray tests/frame").listen(), false));
  track(wirePersist(guiStick.add(params, "objectDeposit", 0.0, 0.010, 0.0001).name("Object deposit").listen(), false));
  track(wirePersist(guiStick.add(params, "stuckMax", 1000, 60000, 500).name("Max decals").listen(), true));
  track(wirePersist(guiStick.add(params, "decalSize", 0.06, 0.50, 0.01).name("Decal size").listen(), true));
  guiStick.open();

  track(gui.add(params, "reset").name("Reset"));
  track(gui.add(params, "rebuild").name("Rebuild"));

  const guiPresets = gui.addFolder("Presets");
  track(guiPresets.add(presetState, "presetName").name("Preset name").listen());
  track(guiPresets.add(presetState, "save").name("Save preset"));
  track(guiPresets.add(presetState, "load").name("Load preset"));
  track(guiPresets.add(presetState, "delete").name("Delete preset"));
  track(guiPresets.add(presetState, "exportJson").name("Export settings JSON"));
  track(guiPresets.add(presetState, "importJson").name("Import settings JSON"));
  guiPresets.open();

    // Keyboard shortcuts: toggle UI, fullscreen, reset; ignore typing targets.
  let controlsHidden = false;
  const uiDisplayCache = new Map();
  const canvas = renderer.domElement;

  function isTypingTarget(el) {
    if (!el) return false;
    const tag = (el.tagName || "").toLowerCase();
    if (tag === "input" || tag === "textarea" || tag === "select") return true;
    if (el.isContentEditable) return true;
    return false;
  }

    /**
     * Toggles all UI except the renderer canvas.
     */
  function toggleControlsHidden(force) {
    controlsHidden = typeof force === "boolean" ? force : !controlsHidden;
    const body = document.body;

    if (controlsHidden) {
      uiDisplayCache.clear();
      for (const el of body.children) {
        if (el === canvas) continue;
        uiDisplayCache.set(el, el.style.display);
        el.style.display = "none";
      }
      return;
    }

    for (const [el, prev] of uiDisplayCache) el.style.display = prev;
      uiDisplayCache.clear();
  }

  async function toggleFullscreen() {
    try {
      if (document.fullscreenElement) { await document.exitFullscreen(); return; }
      await document.documentElement.requestFullscreen({ navigationUI: "hide" });
    } catch {}
  }

  addEventListener("keydown", (e) => {
    if (e.repeat) return;
    if (isTypingTarget(e.target)) return;

    const key = (e.key || "").toLowerCase();

    if (key === "g") { e.preventDefault(); toggleControlsHidden(); return; }
    if (key === "f") { e.preventDefault(); toggleFullscreen(); return; }
    if (key === "r") { e.preventDefault(); reset(true); return; }
    if (key === "escape") { e.preventDefault(); toggleControlsHidden(false); return; }
  }, { passive: false });

    // Boot: build systems, restore last settings, and start preset list refresh.
  buildSnowSurface();
  buildVisualSnow();
  buildSettlers();
  buildStuckSystem();
  buildCaps();

    // Restore last settings (if present), otherwise defaults.
  if (!loadLastIntoParams()) {
    applySettings(DEFAULTS, { rebuild: true, log: false, persist: false });
    persistLastDebounced();
  }

  refreshPresetList().catch(() => {});

  /**
   * Flush settings on tab hide / navigation so quick refreshes still restore the last GUI change.
   */
  addEventListener("pagehide", () => persistLastNow(), { capture: true });
  addEventListener("beforeunload", () => persistLastNow(), { capture: true });
  addEventListener("visibilitychange", () => {
    if (document.visibilityState === "hidden") persistLastNow();
  }, { capture: true });


    // Main loop: simulation step + rendering.
  const clock = new THREE.Clock();
  let frame = 0;
  let objectTestCursor = 0;
  let simTime = 0;
  let depositTokens = 0;

    /**
     * Advances simulation time only when not paused; rendering continues so camera controls still work.
     */
  function animate() {
    const rawDt = clamp(clock.getDelta(), 0.0, Math.max(0.001, params.dtMax));
    const timeScale = clamp(params.timeScale, 0.05, 5.0);
    const dt = params.paused ? 0.0 : rawDt * timeScale;

    if (!params.paused) simTime += dt;
    const t = simTime;

      // Base wind (driven by sim time so it freezes when paused).
    const wA = Math.sin(t * params.windSpeed) * 0.48 + Math.sin(t * (params.windSpeed * 2.4)) * 0.16;
    const wB = Math.cos(t * (params.windSpeed * 0.92)) * 0.44 + Math.sin(t * (params.windSpeed * 2.1)) * 0.14;
    const baseWindX = wA * params.windStrength;
    const baseWindZ = wB * params.windStrength;

      // Gust lifecycle.
    if (!params.paused) {
      spawnGusts(dt);
      for (let i = 0; i < gusts.length; i++) gusts[i].step(dt);
    }

      // Feed gust arrays into GPU visual snow (values freeze when paused).
  for (let i = 0; i < GUST_MAX; i++) {
    const g = gusts[i];
    const fade = g.active ? g.fade : 0.0;

    gustPosRad[i * 3 + 0] = g.x;
    gustPosRad[i * 3 + 1] = g.z;
    gustPosRad[i * 3 + 2] = g.radius;

    gustParams[i * 3 + 0] = g.strength * fade;
    gustParams[i * 3 + 1] = g.swirl * fade;
    gustParams[i * 3 + 2] = g.updraft * fade;
  }

      // GPU snow uniforms (time freezes when paused, so flakes freeze too).
  if (visualMat) {
    visualMat.uniforms.uTime.value = t;
    visualMat.uniforms.uWind.value.set(baseWindX, baseWindZ);
    visualMat.uniforms.uFallSpeed.value = params.fallSpeed;
    visualMat.uniforms.uFallJitter.value = params.fallJitter;
    visualMat.uniforms.uFlakeSize.value = params.flakeSize;
    visualMat.uniforms.uFlakeSizeJitter.value = params.flakeSizeJitter;
  }

      // Drift evolution (freeze when paused).
  if (!params.paused) {
    applyGustScour(baseWindX, baseWindZ);

    if ((frame % params.obstacleShapeInterval) === 0) shapeDriftsAroundObstacles(baseWindX, baseWindZ);
    evolveDrifts(baseWindX, baseWindZ);

    if ((frame % params.driftWriteInterval) === 0) applyHeightsToGeometry();
    if ((frame % params.normalUpdateInterval) === 0) {
      snowGeo.computeVertexNormals();
      snowGeo.attributes.normal.needsUpdate = true;
    }
  }

  updateCaps(dt);

      // Settlers: move + deposit on ground, and occasionally raycast objects for decals.
  if (settlerPos && !params.paused) {
    depositTokens += params.groundDepositBudget * dt;
    const depositStep = Math.max(1, Math.floor(depositTokens));
    if (depositStep > 0) depositTokens -= depositStep;

    const depositUnit = clamp(params.depositUnit, 0.0, 0.01);
    const objBudget = clamp(params.objectTestsPerFrame | 0, 0, 5000);
    const objDeposit = clamp(params.objectDeposit, 0.0, 0.05);

    let didDeposits = 0;
    let didObjTests = 0;

    for (let i = 0; i < SETTLER_COUNT; i++) {
      const p = i * 3;

      const px = settlerPos[p + 0];
      const py = settlerPos[p + 1];
      const pz = settlerPos[p + 2];

      settlerPrev[p + 0] = px;
      settlerPrev[p + 1] = py;
      settlerPrev[p + 2] = pz;

      let vx = settlerVel[p + 0];
      let vy = settlerVel[p + 1];
      let vz = settlerVel[p + 2];

      const h = sampleSnowHeight(px, pz);
      const heightAboveSnow = Math.max(0, py - h);

      gustWindAt(px, pz, heightAboveSnow, gustTmp);

      vx += (baseWindX * 0.20 + gustTmp.x * 0.25) * dt;
      vz += (baseWindZ * 0.20 + gustTmp.z * 0.25) * dt;

      vy += (-0.28 + gustTmp.y * 0.25) * dt;

      vx *= 0.995;
      vz *= 0.995;
      vy = Math.min(vy, -0.08);

      let nx = px + vx;
      let ny = py + vy;
      let nz = pz + vz;

      if (nx < -settleBounds.x) nx += settleBounds.x * 2;
      if (nx >  settleBounds.x) nx -= settleBounds.x * 2;
      if (nz < -settleBounds.z) nz += settleBounds.z * 2;
      if (nz >  settleBounds.z) nz -= settleBounds.z * 2;

      const groundY = sampleSnowHeight(nx, nz);

      if (ny <= groundY + 0.02) {
        if (didDeposits < depositStep && depositUnit > 0) {
          depositHeightAtWorld(nx, nz, depositUnit, baseWindX, baseWindZ);
          didDeposits++;
        }
        respawnSettler(i);
        continue;
      }

      settlerPos[p + 0] = nx;
      settlerPos[p + 1] = ny;
      settlerPos[p + 2] = nz;

      settlerVel[p + 0] = vx;
      settlerVel[p + 1] = vy;
      settlerVel[p + 2] = vz;

      if (objBudget <= 0 || didObjTests >= objBudget) continue;

      const prevX = settlerPrev[p + 0];
      const prevY = settlerPrev[p + 1];
      const prevZ = settlerPrev[p + 2];

      segDelta.set(nx - prevX, ny - prevY, nz - prevZ);
      const segLen = segDelta.length();
      if (segLen < 1e-4) continue;

      segDir.copy(segDelta).multiplyScalar(1.0 / segLen);

      for (let o = 0; o < colliderBounds.length; o++) {
        const cb = colliderBounds[o];

        const dx = cb.center.x - nx;
        const dy = cb.center.y - ny;
        const dz = cb.center.z - nz;

        const dist2 = dx * dx + dy * dy + dz * dz;
        const r = cb.radius + 0.35;
        if (dist2 > r * r) continue;

        hitFrom.set(prevX, prevY, prevZ);
        raycaster.set(hitFrom, segDir);
        raycaster.far = segLen;

        const hit = raycaster.intersectObject(cb.obj, false)[0];
        didObjTests++;

        if (hit) {
          tmpN.set(0, 1, 0);
          if (hit.face) {
            tmpN.copy(hit.face.normal);
            normalMatrix.getNormalMatrix(hit.object.matrixWorld);
            tmpN.applyMatrix3(normalMatrix).normalize();
            if (tmpN.dot(segDir) > 0) tmpN.negate();
          }

          addStuckSnow(hit.point, tmpN);

          if (objDeposit > 0) depositHeightAtWorld(hit.point.x, hit.point.z, objDeposit, baseWindX, baseWindZ);

          respawnSettler(i);
          break;
        }
      }
    }
  }

  controls.update();
  renderer.render(scene, camera);

  frame++;
  requestAnimationFrame(animate);
}

animate();

function handleResize() {
  const s = readViewport();
  camera.aspect = s.w / s.h;
  camera.updateProjectionMatrix();
  renderer.setSize(s.w, s.h, false);
  renderer.setPixelRatio(Math.min(devicePixelRatio, params.pixelRatio));
}

addEventListener("resize", handleResize, { passive: true });
addEventListener("orientationchange", handleResize, { passive: true });
handleResize();



</script>
</body>
</html>
