<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js – Snowdrifts, Gusts, Sticking & Presets (importmap)</title>
  <link rel="icon" href="data:,">

  <meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  />

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0a1220;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    #app {
      position: fixed;
      inset: 0;
    }
    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      font: 12px/1.4 ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
      user-select: none;
      pointer-events: none;
      max-width: 380px;
    }
    .hud b {
      color: rgba(255,255,255,0.98);
    }


    .avatar-ui {
      position: fixed;
      right: 12px;
      bottom: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      z-index: 20;
      pointer-events: auto;
    }

    .avatar-btn {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.24);
      background: rgba(0,0,0,0.55);
      color: #f5f5f5;
      font-size: 11px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      backdrop-filter: blur(10px);
    }

    .avatar-btn:hover {
      background: rgba(0,0,0,0.8);
    }

    .avatar-btn:active {
      background: rgba(0,0,0,0.95);
    }

    .joystick {
      position: fixed;
      left: 16px;
      bottom: 16px;
      width: 96px;
      height: 96px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.18), rgba(0, 0, 0, 0.6));
      backdrop-filter: blur(10px);
      touch-action: none;
      z-index: 20;
    }

    .joystick-inner {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 40px;
      height: 40px;
      margin-left: -20px;
      margin-top: -20px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.2);
      pointer-events: none;
      transition: transform 0.08s ease-out;
    }

    .vehicle-ui {
      position: absolute;
      left: 12px;
      right: 12px;
      bottom: 96px;
      max-width: 520px;
      margin: 0 auto; /* <-- center horizontally */
      padding: 10px 12px;
      border-radius: 12px;
      color: #fff;
      background: rgba(0, 0, 0, 0.58);
      backdrop-filter: blur(10px);
      z-index: 25;
      display: none;
      pointer-events: auto;
    }


    .vehicle-ui__title {
      font-weight: 700;
      margin-bottom: 4px;
      line-height: 1.2;
    }

    .vehicle-ui__desc {
      opacity: 0.92;
      font-size: 13px;
      line-height: 1.25;
      margin-bottom: 10px;
    }

    .vehicle-ui__row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }




  </style>

  <!-- Import map for Three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
      }
    }
  </script>
</head>
<body>
  <div id="app"></div>


  <div class="avatar-ui">
    <button id="avatarToggle" class="avatar-btn">Avatar: OFF</button>
    <button id="avatarViewToggle" class="avatar-btn">View: Behind</button>
  </div> 

  <div id="joystick" class="joystick">
    <div id="joystickInner" class="joystick-inner"></div>
  </div> 

  <div id="vehiclePrompt" class="vehicle-ui" aria-hidden="true">
    <div id="vehiclePromptTitle" class="vehicle-ui__title"></div>
    <div id="vehiclePromptDesc" class="vehicle-ui__desc"></div>
    <div class="vehicle-ui__row">
      <button id="vehicleEnterBtn" class="avatar-btn">Get in/on</button>
      <button id="vehicleExitBtn" class="avatar-btn" style="display:none;">Exit</button>
      <button id="vehicleCloseBtn" class="avatar-btn">Close</button>
    </div>
  </div>

  <div class="hud" style="visibility: hidden;">
    <b>Snowdrifts + gusts + sticking snow + presets</b><br />
    Drag: orbit · Wheel: zoom · Right-drag: pan<br />
    Gust parameters, sticking, drifts, and presets are all controlled from the GUI.
  </div>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { VRButton } from "three/addons/webxr/VRButton.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";    
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.20/+esm";

    // -------------------------------------------------------------------------
    // Helpers / persistence utilities
    // -------------------------------------------------------------------------

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // Simple seedable RNG (LCG)
    function makeSeededRandom(seed) {
      let s = (seed | 0) || 1;
      return function () {
        s = (s * 1664525 + 1013904223) | 0;
        return (s >>> 0) / 4294967296;
      };
    }

    function nowStamp() {

      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      return (
        d.getFullYear() +
        pad(d.getMonth() + 1) +
        pad(d.getDate()) +
        "-" +
        pad(d.getHours()) +
        pad(d.getMinutes()) +
        pad(d.getSeconds())
        );
    }

    function safeCloneSettings(src) {
      const out = {};
      for (const k of Object.keys(src)) {
        const v = src[k];
        if (typeof v === "number" || typeof v === "boolean" || typeof v === "string") {
          out[k] = v;
        }
      }
      return out;
    }

    function downloadJson(obj, filename) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.rel = "noopener";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // localStorage (last used settings)
    const STORAGE_LAST = "snow:lastSettings:v1";

    let persistTimer = 0;
    let persistBlocked = false;

    function saveLastNow(params) {
      if (persistBlocked) return;
      try {
        const payload = {
          v: 1,
          savedAt: Date.now(),
          settings: safeCloneSettings(params)
        };
        localStorage.setItem(STORAGE_LAST, JSON.stringify(payload));
      } catch (e) {
        console.warn("[snow] save last failed", e);
      }
    }

    function saveLastDebounced(params) {
      if (persistBlocked) return;
      if (persistTimer) clearTimeout(persistTimer);
      persistTimer = setTimeout(() => {
        persistTimer = 0;
        saveLastNow(params);
      }, 200);
    }

    function loadLastSettings(params) {
      try {
        const raw = localStorage.getItem(STORAGE_LAST);
        if (!raw) return;
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object" || !parsed.settings) return;
        applySettings(parsed.settings, { rebuild: false, updateGui: false, persist: false });
      } catch (e) {
        console.warn("[snow] load last failed", e);
      }
    }

    // IndexedDB presets -------------------------------------------------------

    const IDB_NAME = "snow-presets";
    const IDB_STORE = "presets";
    const IDB_VERSION = 1;

    function idbOpen() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(IDB_NAME, IDB_VERSION);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(IDB_STORE)) {
            db.createObjectStore(IDB_STORE, { keyPath: "name" });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbPutPreset(name, settings) {
      const db = await idbOpen();
      try {
        await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite");
          tx.onerror = () => reject(tx.error);
          tx.objectStore(IDB_STORE).put({ name, savedAt: Date.now(), settings });
          tx.oncomplete = () => resolve();
        });
      } finally {
        db.close();
      }
    }

    async function idbGetPreset(name) {
      const db = await idbOpen();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readonly");
          tx.onerror = () => reject(tx.error);
          const req = tx.objectStore(IDB_STORE).get(name);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    async function idbDeletePreset(name) {
      const db = await idbOpen();
      try {
        await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite");
          tx.onerror = () => reject(tx.error);
          tx.objectStore(IDB_STORE).delete(name);
          tx.oncomplete = () => resolve();
        });
      } finally {
        db.close();
      }
    }

    async function idbListPresetNames() {
      const db = await idbOpen();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readonly");
          tx.onerror = () => reject(tx.error);
          const req = tx.objectStore(IDB_STORE).getAllKeys();
          req.onsuccess = () => {
            const list = (req.result || []).map(String).sort();
            resolve(list);
          };
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    function sanitizePresetName(s) {
      const name = String(s ?? "").replace(/\.[a-z0-9]+$/i, "").trim();
      if (!name) return "";
      return name.replace(/\s+/g, " ").slice(0, 96);
    }

    // File input for JSON import ---------------------------------------------

    let importInput = null;
    function ensureImportInput() {
      if (importInput) return importInput;
      importInput = document.createElement("input");
      importInput.type = "file";
      importInput.accept = "application/json,.json";
      importInput.style.position = "fixed";
      importInput.style.left = "-9999px";
      importInput.style.top = "-9999px";
      document.body.appendChild(importInput);
      return importInput;
    }

    // Parameters (includes gust/turbulence)
    // -------------------------------------------------------------------------

    const DEFAULTS = {
      // Core
      paused: false,
      debug: false,
      timeScale: 1.0,
      dtMax: 0.020,
      pixelRatio: 1.75,

      // Flakes & base wind
      visualCount: 180000,
      windStrength: 0,
      windSpeed: 0,
      fallSpeed: 0.42,
      fallJitter: 0.45,
      flakeSize: 3.0,
      flakeSizeJitter: 0.35,

      // Gusts / turbulence
      gustMinInterval: 1.4,
      gustMaxInterval: 3.2,
      gustTornadoChance: 0.22,
      gustStrengthMul: 1.0,
      gustSwirlMul: 1.0,
      gustUpdraftMul: 1.0,
      gustScour: 0.0100,
      gustRedeposit: 0.0080,

      // Drifts / cover
      driftGrid: 128,
      driftMaxHeight: 3.6,
      coverBase: 0.06,
      coverMacroAmp: 0.09,
      coverMacroFreq: 2.4,
      coverMicroAmp: 0.05,
      coverMicroFreq: 8.5,
      driftDiffusion: 0.07,
      driftAdvection: 0.125,
      obstacleShapeInterval: 10,
      driftWriteInterval: 8,
      normalUpdateInterval: 36,

      // Settlers & deposition
      settlerCount: 8000,
      groundDepositBudget: 420,
      depositUnit: 0.00035,
      objectTestsPerFrame: 900,
      objectDeposit: 0.002,

      // Sticking decals
      stuckMax: 24000,
      decalSize: 0.14,

      // Fog
      fogNear: 18,
      fogFar: 60,
      fogColor: "#0a1220",

      // Snowman path animation
      snowmanMoveEnabled: true,
      snowmanPathRadius: 4.0,  // approximate radius of his wander area
      snowmanSpeed: 0.03,       // loops per second (small = snail-slow)

      // Forest
      forestCount: 24,
      forestRadius: 14,
      forestInnerRadius: 3,
      forestMinScale: 0.7,
      forestMaxScale: 1.6,
      forestSeed: 1234,
      forestJitter: 1.0,

      // Clouds
      cloudEnabled: true,
      cloudHeightBase: 18.0,
      cloudHeightRange: 6.0,
      cloudRadius: 40.0,
      cloudSliceCount: 10,
      cloudSpeed: 0.010,
      cloudDensity: 0.85,
      cloudSoftness: 0.25,
      // NEW: color + opacity (saved into presets / files)
      cloudColor: "#f5f7ff",
      cloudSkyColor: "#0a1220",
      // multiplier on alpha, 1.35 keeps your current look
      cloudOpacity: 1.35,


    };

    const params = { ...DEFAULTS };


    // Scene globals
    // -------------------------------------------------------------------------

    const GROUND_SIZE = 150;
    const HALF_GROUND = GROUND_SIZE * 0.5;

    /**
     * Playable world bounds in X/Z. Defaults to the ground plane edge (HALF_GROUND).
     * Adjust this single value to expand/shrink the playable area without touching other systems.
     */
    const WORLD_BOUNDS_XZ = HALF_GROUND;

    const visualBounds = { x: WORLD_BOUNDS_XZ, z: WORLD_BOUNDS_XZ, yMin: -2.0, yMax: 22.0 };
    const settleBounds = { x: WORLD_BOUNDS_XZ, z: WORLD_BOUNDS_XZ, yMin: -2.0, yMax: 18.0 };


    let scene, camera, renderer, controls;
    let ground, cube;
    const cones = [];
    const rocks = [];

    // Forest cone shared resources
    let forestConeGeo = null;
    let forestConeMat = null;

    let snowTex;


    function updateFogFromParams() {
      if (!scene) return;

      const color = new THREE.Color(params.fogColor || "#0a1220");
      scene.background = color;
      scene.fog = new THREE.Fog(color, params.fogNear, params.fogFar);
    }

    // Clouds runtime
    let cloudLayer = null;
    let cloudMaterial = null;


      // -------------------------------------------------------------------------
      // Minimal WebAudio: background mp3 + simple gust FX
      // -------------------------------------------------------------------------

    let audioListener = null;
    let audioCtx = null;
    let audioMaster = null;

    let musicGain = null;
    let musicSource = null;
    let musicBuffer = null;
    let musicEnabled = false;

      // Put your mp3 here
    const MUSIC_URL = "./audio/song.mp3";
    const MUSIC_MAX_GAIN = 0.35;

    function initAudio() {
      if (audioListener) return;
      if (!camera) return;

      audioListener = new THREE.AudioListener();
      camera.add(audioListener);

      audioCtx = audioListener.context;

      audioMaster = audioCtx.createGain();
      audioMaster.gain.value = 1.0;
      audioMaster.connect(audioCtx.destination);

      musicGain = audioCtx.createGain();
      musicGain.gain.value = 0.0;
      musicGain.connect(audioMaster);
    }

    async function ensureAudioResumed() {
      if (!audioCtx) return;
      if (audioCtx.state === "suspended") {
        await audioCtx.resume();
      }
    }

    async function loadMusicBuffer() {
      if (musicBuffer) return musicBuffer;
      if (!audioCtx) return null;

      const res = await fetch(MUSIC_URL);
      const arr = await res.arrayBuffer();
      musicBuffer = await audioCtx.decodeAudioData(arr);
      return musicBuffer;
    }

    async function startMusic() {
      if (!audioListener) initAudio();
      if (!audioCtx) return;

      await ensureAudioResumed();
      const buffer = await loadMusicBuffer();
      if (!buffer) return;

      if (musicSource) {
        musicSource.stop();
        musicSource.disconnect();
        musicSource = null;
      }

      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      src.loop = true;
      src.connect(musicGain);
      src.start();

      musicSource = src;
      musicEnabled = true;

      const now = audioCtx.currentTime;
      musicGain.gain.cancelScheduledValues(now);
      musicGain.gain.setValueAtTime(musicGain.gain.value, now);
      musicGain.gain.linearRampToValueAtTime(MUSIC_MAX_GAIN, now + 2.0);
    }

    function stopMusic() {
      if (!audioCtx || !musicSource) {
        musicEnabled = false;
        return;
      }

      const now = audioCtx.currentTime;
      musicGain.gain.cancelScheduledValues(now);
      musicGain.gain.setValueAtTime(musicGain.gain.value, now);
      musicGain.gain.linearRampToValueAtTime(0.0, now + 1.5);

      musicSource.stop(now + 1.6);
      musicSource.disconnect();
      musicSource = null;
      musicEnabled = false;
    }

      // Short filtered-noise whoosh for gusts
    function playGustFx(strength) {
      if (!audioCtx || !audioMaster) return;
      if (audioCtx.state === "suspended") return;

      const ctx = audioCtx;
      const duration = 0.8;
      const now = ctx.currentTime;

      const bufferSize = Math.floor(ctx.sampleRate * duration);
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        const t = i / bufferSize;
        const fadeIn = Math.min(1.0, t * 4.0);
        const fadeOut = 1.0 - t;
        data[i] = (Math.random() * 2.0 - 1.0) * fadeIn * fadeOut;
      }

      const src = ctx.createBufferSource();
      src.buffer = buffer;

      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = 400 + Math.random() * 600;
      bp.Q.value = 0.8 + Math.random() * 1.2;

      const gain = ctx.createGain();
      const peak = 0.5 * (strength || 1.0);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.linearRampToValueAtTime(peak, now + 0.1);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      src.connect(bp);
      bp.connect(gain);
      gain.connect(audioMaster);

      src.start(now);
      src.stop(now + duration + 0.05);
    }



    // GLTF / DRACO model system
    // ---------------------------------------------------------------------------

    const modelTemplates = {};   // name -> THREE.Object3D (original loaded scene)
    const modelInstances = {};   // id   -> THREE.Object3D (instance in scene)

    // Configure all GLB models and their instances here.
    // Per-instance `stick: true` means “snow can stick to this model”.

    const MODEL_CONFIG = [
      {
        name: "model1",
        url: "models/gingerbread_man-c.glb",
        instances: [
          {
            id: "model1_center",
            position: [3, 0, -5],
            rotation: [0, 0, 0],
            scale: 1.0,
            stick: true,
            collide: false
          }
        ]
      },
      {
        name: "model2",
        url: "models/christmas_tree_polycraft-c.glb",
        instances: [
          {
            id: "tree_center",
            position: [0, 0, 0],
            rotation: [0, 0, 0],
            scale: 0.05,
            stick: true,
            collide: false
          }
        ]
      },
      {
        name: "model3",
        url: "models/snowman-c.glb",
        instances: [
          {
            id: "snowman",
            position: [-7, -0.2, -1],
            rotation: [0, 1, 0],
            scale: 1.0,
            stick: false,
            collide: false
          }
        ]
      },
      {
        name: "model4",
        url: "models/car-c.glb",
        instances: [
          {
            id: "car",
            position: [4, -0.5, 6],
            rotation: [0, 1, 0],
            scale: 1.0,
            stick: false,
            collide: false,
            vehicle: {
              type: "Car",
              description: "Ground vehicle",
              seatLocal: [0.0, 0.55, 0.15],
              yawOffset: 0.0,
              profile: {
                maxSpeed: 1.0,
                maxReverse: 1.0,
                accel: 10.0,
                brake: 14.0,
                coastDecel: 3.2,
                turnRate: 5,
                radius: 0.85
              }
            }
          }
        ]
      },

      {
        name: "skipatrol",
        url: "models/vehicles/ski_patrol1.glb",
        instances: [
          {
            id: "skipatrol",
            position: [9, 0, 4],
            rotation: [0, 1, 0],
            scale: 1.0,
            stick: false,
            collide: true,

            vehicle: {
              type: "Ski Patrol",
              description: "Snow vehicle / patrol sled",
              seatLocal: [0.0, 0.62, -0.05],
              yawOffset: 0.0,

              profile: {
                maxSpeed: 13.0,
                maxReverse: 5.0,
                accel: 13.0,
                brake: 18.0,
                coastDecel: 4.0,
                turnRate: 2.8,
                radius: 0.95
              }
            }



          }
        ]
      },

      {

        name: "snowcar",
        url: "models/vehicles/snowcar.glb",
        instances: [
          {
            id: "car2",
            position: [-4, -0.0, 6],
            rotation: [0, 1, 0],
            scale: 1.0,
            stick: false,
            collide: true,



            vehicle: {
              type: "Snowcar",
              description: "Snow-capable car",
              seatLocal: [0.0, 0.58, 0.1],
              yawOffset: 0.0,



              profile: {
                maxSpeed: 16.0,
                maxReverse: 6.9,
                accel: 6.2,
                brake: 25.3,
                coastDecel: 3.6,
                turnRate: 0.64,
                radius: 0.7,
                wheelBase: 1.9,
                minTurnRadius: 3.8,
                minSteerSpeed: 0.55,
                steerResponse: 5.7,
                steerReturn: 7.0,
                lateralGrip: 9.0,

                propAxis: "z",
                propSpinIdle: 8.0,
                propSpinMax: 80.0,
                propSpinMul: 1.0,
                propInvert: false                
              }



            }



          }
        ]
      }
    ];


    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(
      "https://www.gstatic.com/draco/versioned/decoders/1.5.7/"
      );

    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);





    function loadAllModels() {
      avatarModelColliderObjects.length = 0;
      avatarModelColliderBounds.length = 0;
      avatarModelColliderOBBs.length = 0;

      vehicleInteractables.length = 0;
      setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);

      function buildOBBForInstance(root, id) {
        root.updateWorldMatrix(true, true);

        obbTmpBox.setFromObject(root);
        if (!Number.isFinite(obbTmpBox.min.x) || !Number.isFinite(obbTmpBox.max.x)) return null;

        obbTmpBox.getCenter(obbTmpCenter);
        obbTmpBox.getSize(obbTmpSize);

        root.getWorldQuaternion(obbTmpQuat);
        obbTmpEuler.setFromQuaternion(obbTmpQuat);

        const hx = Math.max(0.10, (obbTmpSize.x * 0.5) * 0.48);
        const hz = Math.max(0.10, (obbTmpSize.z * 0.5) * 0.48);

        return {
          id: id || "",
          object: root,
          center: obbTmpCenter.clone(),
          halfX: hx,
          halfZ: hz,
          yaw: obbTmpEuler.y
        };
      }

      for (const entry of MODEL_CONFIG) {
        gltfLoader.load(
          entry.url,
          (gltf) => {
            const baseScene = gltf.scene;
            modelTemplates[entry.name] = baseScene;

            for (const instCfg of entry.instances) {
              const inst = baseScene.clone(true);

              const p = instCfg.position || [0, 0, 0];
              const r = instCfg.rotation || [0, 0, 0];
              const s = instCfg.scale != null ? instCfg.scale : 1.0;

              inst.position.set(p[0], p[1], p[2]);
              inst.rotation.set(r[0], r[1], r[2]);
              inst.scale.setScalar(s);

              inst.traverse((obj) => {
                if (!obj.isMesh) return;
                obj.castShadow = true;
                obj.receiveShadow = true;

                if (instCfg.stick) {
                  colliderObjects.push(obj);
                }
              });

              scene.add(inst);

              if (instCfg.id) {
                modelInstances[instCfg.id] = inst;
              }

              if (instCfg.vehicle) {
                registerVehicleInstance(inst, instCfg);
              }

              if (instCfg.collide) {
                avatarModelColliderObjects.push(inst);

                const obb = buildOBBForInstance(inst, instCfg.id);
                if (obb) avatarModelColliderOBBs.push(obb);
              }
            }

            if (colliderObjects.length) {
              colliderBounds = buildColliderBounds(colliderObjects);
              rebuildAvatarCollisionGrid();
            }

            // Keep legacy var empty; collision uses avatarModelColliderOBBs instead.
            avatarModelColliderBounds = [];
          },
          undefined,
          (error) => {
            console.error("[snow] failed to load GLB", entry.url, error);
          }
          );
      }
    }








    function getModelInstance(id) {
      return modelInstances[id] || null;
    }





// -------------------------------------------------------------------------
// Avatar character setup and control
// -------------------------------------------------------------------------

    const AVATAR_GLTF_URL = "models/ready/santagirl.glb";

    let avatar = null;
    let avatarMixer = null;
    const avatarActions = {};
    let avatarCurrentAction = null;
    let avatarCurrentActionName = "";


    const avatarState = {
      enabled: false,
      viewMode: "third", // "third" | "first"
      moveX: 0,
      moveZ: 0
    };

    const avatarKeys = {
      forward: false,
      back: false,
      left: false,
      right: false,
      run: false
    };

    const AVATAR_WALK_SPEED = 2.4;
    const AVATAR_RUN_SPEED  = 4.0;


    /**
     * Resolves avatar XZ overlaps against collider bounds (trees/rocks) plus model-only colliders (cars).
     * Pushes the avatar out of penetration and removes velocity component into the obstacle for sliding.
     */
    const avatarCollision = {
      radius: 0.35,
      skin: 0.02,
      iterations: 3
    };

    const avatarColTmpPos = new THREE.Vector3();
    const avatarColN = new THREE.Vector3();


    /**
     * Builds a spatial hash (XZ grid) of collider sphere-bounds for fast avatar collision broadphase.
     * Each collider is inserted into all cells overlapped by its XZ radius expanded by avatar radius + skin.
     */
    const avatarCollisionGrid = new Map(); // Map<number, Map<number, number[]>>
    const avatarCollisionCellSize = 3.0;
    const avatarCollisionCellInv = 1.0 / avatarCollisionCellSize;

    function rebuildAvatarCollisionGrid() {
      avatarCollisionGrid.clear();

      if (!colliderBounds || colliderBounds.length === 0) return;

      const pad = avatarCollision.radius + avatarCollision.skin;

      for (let i = 0; i < colliderBounds.length; i++) {
        const b = colliderBounds[i];
        if (!b) continue;

        const baseR = Number.isFinite(b.radius) ? b.radius : 0;
        const r = baseR + pad;

        const minX = Math.floor((b.center.x - r) * avatarCollisionCellInv);
        const maxX = Math.floor((b.center.x + r) * avatarCollisionCellInv);
        const minZ = Math.floor((b.center.z - r) * avatarCollisionCellInv);
        const maxZ = Math.floor((b.center.z + r) * avatarCollisionCellInv);

        for (let ix = minX; ix <= maxX; ix++) {
          let col = avatarCollisionGrid.get(ix);
          if (!col) {
            col = new Map();
            avatarCollisionGrid.set(ix, col);
          }

          for (let iz = minZ; iz <= maxZ; iz++) {
            let bucket = col.get(iz);
            if (!bucket) {
              bucket = [];
              col.set(iz, bucket);
            }
            bucket.push(i);
          }
        }
      }
    }

    /**
     * Returns colliderBounds indices potentially overlapping the avatar at the given position.
     */
    function getAvatarCollisionCandidatesXZ(pos) {
      const ix = Math.floor(pos.x * avatarCollisionCellInv);
      const iz = Math.floor(pos.z * avatarCollisionCellInv);
      const col = avatarCollisionGrid.get(ix);
      if (!col) return null;
      return col.get(iz) || null;
    }







    function resolveAvatarXZCollisions(pos) {
      const limX = Math.max(0.5, visualBounds.x - (avatarCollision.radius + 0.25));
      const limZ = Math.max(0.5, visualBounds.z - (avatarCollision.radius + 0.25));

      pos.x = clamp(pos.x, -limX, limX);
      pos.z = clamp(pos.z, -limZ, limZ);

      const rA = avatarCollision.radius;
      const skin = avatarCollision.skin;

      for (let iter = 0; iter < avatarCollision.iterations; iter++) {
        let pushed = false;

        // --- sphere bounds (forest/rocks + any stick meshes), grid-broadened ---
        const candidates = getAvatarCollisionCandidatesXZ(pos);
        if (candidates && candidates.length) {
          for (let c = 0; c < candidates.length; c++) {
            const b = colliderBounds[candidates[c]];
            if (!b) continue;

            const sumR = rA + b.radius + skin;
            const dx = pos.x - b.center.x;
            const dz = pos.z - b.center.z;
            const d2 = dx * dx + dz * dz;

            if (d2 >= sumR * sumR) continue;

            const d = Math.sqrt(d2) || 1e-6;
            const push = sumR - d;

            const nx = dx / d;
            const nz = dz / d;

            pos.x += nx * push;
            pos.z += nz * push;

            const velDot = avatarVelocity.x * nx + avatarVelocity.z * nz;
            if (velDot < 0) {
              avatarVelocity.x -= velDot * nx;
              avatarVelocity.z -= velDot * nz;
            }

            pushed = true;
          }
        }

        // --- OBB bounds (cars etc), built once at load-time ---
        if (avatarModelColliderOBBs && avatarModelColliderOBBs.length) {
          for (let i = 0; i < avatarModelColliderOBBs.length; i++) {
            const obb = avatarModelColliderOBBs[i];
            if (!obb) continue;

            const dxw = pos.x - obb.center.x;
            const dzw = pos.z - obb.center.z;

            const c = Math.cos(obb.yaw);
            const s = Math.sin(obb.yaw);

        // world -> local
            const lx = dxw * c + dzw * s;
            const lz = -dxw * s + dzw * c;

            const cx = clamp(lx, -obb.halfX, obb.halfX);
            const cz = clamp(lz, -obb.halfZ, obb.halfZ);

            const dxl = lx - cx;
            const dzl = lz - cz;

            const d2 = dxl * dxl + dzl * dzl;
            const sumR = rA + skin;

            if (d2 >= sumR * sumR) continue;

            const d = Math.sqrt(d2) || 1e-6;
            const push = sumR - d;

            let nlx = dxl / d;
            let nlz = dzl / d;

        // if inside (rare), choose shortest axis
            if (!Number.isFinite(nlx) || !Number.isFinite(nlz)) {
              const px = obb.halfX - Math.abs(lx);
              const pz = obb.halfZ - Math.abs(lz);
              if (px < pz) {
                nlx = lx >= 0 ? 1 : -1;
                nlz = 0;
              } else {
                nlx = 0;
                nlz = lz >= 0 ? 1 : -1;
              }
            }

        // local -> world normal
            const nx = nlx * c - nlz * s;
            const nz = nlx * s + nlz * c;

            pos.x += nx * push;
            pos.z += nz * push;

            const velDot = avatarVelocity.x * nx + avatarVelocity.z * nz;
            if (velDot < 0) {
              avatarVelocity.x -= velDot * nx;
              avatarVelocity.z -= velDot * nz;
            }

            pushed = true;
          }
        }

        pos.x = clamp(pos.x, -limX, limX);
        pos.z = clamp(pos.z, -limZ, limZ);

        if (!pushed) break;
      }
    }





    const avatarViewConfig = {
      thirdPersonDistance: 4.0,
      thirdPersonHeight: 1.6,
      thirdPersonHeightLift: 0.4,
      firstPersonHeight: 1.6
    };

    const avatarMotionConfig = {
      maxAccel: 5.0,
      maxDecel: 3.0,
      stopEps: 0.03,
      yawLerpThird: 0.2,
      yawLerpFirst: 0.2
    };

    const avatarVelocity = new THREE.Vector3();
    const avatarMoveDir = new THREE.Vector3();

    const avatarWorldPos = new THREE.Vector3();
    const avatarHeadPos = new THREE.Vector3();
    const avatarForwardWorld = new THREE.Vector3();
    const avatarLastWorldPos = new THREE.Vector3();
    let avatarHasLastPos = false;

    const avatarTmpVec = new THREE.Vector3();
    const avatarTmpDir = new THREE.Vector3();
    const avatarToTarget = new THREE.Vector3();

    const camForward = new THREE.Vector3();
    const camRight = new THREE.Vector3();
    const worldUp = new THREE.Vector3(0, 1, 0);

    // Joystick state
    const joystickState = {
      active: false,
      pointerId: null,
      centerX: 0,
      centerY: 0,
      radius: 0,
      valueX: 0, // -1..1 (left/right)
      valueY: 0  // -1..1 (up/down screen); forward uses -valueY
    };

    const preAvatarCameraState = {
      has: false,
      position: new THREE.Vector3(),
      target: new THREE.Vector3(),
      enablePan: true,
      enableZoom: true,
      minDistance: 0.0,
      maxDistance: 0.0,
      minPolarAngle: 0.0,
      maxPolarAngle: Math.PI,
      autoRotateEnabled: false
    };

    /**
     * Smooth yaw interpolation that always takes the shortest arc.
     */
    function lerpYaw(current, target, t) {
      let d = target - current;
      while (d > Math.PI) d -= Math.PI * 2;
      while (d < -Math.PI) d += Math.PI * 2;
      return current + d * t;
    }

    /**
     * Captures camera + OrbitControls state before entering avatar mode.
     */
    function savePreAvatarCameraState() {
      if (!controls) return;

      preAvatarCameraState.has = true;
      preAvatarCameraState.position.copy(camera.position);
      if (controls.target) preAvatarCameraState.target.copy(controls.target);

      preAvatarCameraState.enablePan = !!controls.enablePan;
      preAvatarCameraState.enableZoom = !!controls.enableZoom;
      preAvatarCameraState.minDistance = controls.minDistance;
      preAvatarCameraState.maxDistance = controls.maxDistance;
      preAvatarCameraState.minPolarAngle = controls.minPolarAngle;
      preAvatarCameraState.maxPolarAngle = controls.maxPolarAngle;

      preAvatarCameraState.autoRotateEnabled = !!autoRotateEnabled;
    }

    /**
     * Restores camera + OrbitControls state to the exact pre-avatar snapshot.
     */
    function restorePreAvatarCameraState() {
      if (!controls) return;

      if (!preAvatarCameraState.has) {
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.minDistance = 0.5;
        controls.maxDistance = 200.0;
        return;
      }

      camera.position.copy(preAvatarCameraState.position);
      if (controls.target) controls.target.copy(preAvatarCameraState.target);

      controls.enablePan = preAvatarCameraState.enablePan;
      controls.enableZoom = preAvatarCameraState.enableZoom;
      controls.minDistance = preAvatarCameraState.minDistance;
      controls.maxDistance = preAvatarCameraState.maxDistance;
      controls.minPolarAngle = preAvatarCameraState.minPolarAngle;
      controls.maxPolarAngle = preAvatarCameraState.maxPolarAngle;

      autoRotateEnabled = preAvatarCameraState.autoRotateEnabled;

      controls.update();
    }

    /**
     * Positions the camera behind the avatar and targets the avatar head.
     */
    function placeCameraBehindAvatar() {
      if (!avatar || !controls) return;

      avatar.getWorldPosition(avatarWorldPos);

      avatarHeadPos.copy(avatarWorldPos);
      avatarHeadPos.y += avatarViewConfig.thirdPersonHeight;

      avatarForwardWorld.set(0, 0, 1).applyQuaternion(avatar.quaternion).normalize();

      avatarTmpVec
      .copy(avatarHeadPos)
      .addScaledVector(avatarForwardWorld, -avatarViewConfig.thirdPersonDistance)
      .addScaledVector(worldUp, avatarViewConfig.thirdPersonHeightLift);

      camera.position.copy(avatarTmpVec);
      camera.lookAt(avatarHeadPos);
      controls.target.copy(avatarHeadPos);

      avatarLastWorldPos.copy(avatarWorldPos);
      avatarHasLastPos = true;
    }

    /**
     * Switches avatar view mode and configures OrbitControls constraints for that mode.
     */
    function setAvatarViewMode(mode, snapCamera = true) {
      if (!avatarState.enabled || !controls) return;

      avatarState.viewMode = mode;
      avatarHasLastPos = false;

      if (mode === "third") {
        if (avatar) avatar.visible = true;

        controls.enablePan = false;
        controls.enableZoom = true;
        controls.minDistance = 0.5;
        controls.maxDistance = 80.0;

        if (snapCamera) {
          placeCameraBehindAvatar();
          controls.update();
        }
        return;
      }

      if (avatar) avatar.visible = false;

      controls.enablePan = false;
      controls.enableZoom = false;
      controls.minDistance = 0.01;
      controls.maxDistance = 0.01;

      if (avatar) {
        avatar.getWorldPosition(avatarWorldPos);

        avatarHeadPos.copy(avatarWorldPos);
        avatarHeadPos.y += avatarViewConfig.firstPersonHeight;

        camera.position.copy(avatarHeadPos);

        avatarForwardWorld.set(0, 0, 1).applyQuaternion(avatar.quaternion).normalize();
        avatarTmpVec.copy(avatarHeadPos).add(avatarForwardWorld);

        camera.lookAt(avatarTmpVec);
        controls.target.copy(avatarTmpVec);
        controls.update();
      }
    }

    /**
     * Clears joystick values and re-centers the thumb indicator.
     */
    function resetJoystick() {
      joystickState.active = false;
      joystickState.pointerId = null;
      joystickState.valueX = 0;
      joystickState.valueY = 0;

      const inner = document.getElementById("joystickInner");
      if (inner) {
        inner.style.transform = "translate(0px, 0px)";
      }
    }

    /**
     * Maps pointer position to joystick values with dead-zone and clamped thumb motion.
     */
    function updateJoystickFromPointer(px, py) {
      if (!joystickState.radius) return;

      const dx = px - joystickState.centerX;
      const dy = py - joystickState.centerY;

      const knobRadius = 20;
      const maxDist = Math.max(1, joystickState.radius - knobRadius);

      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const clamped = Math.min(dist, maxDist);
      const ratio = clamped / dist;

      const thumbX = dx * ratio;
      const thumbY = dy * ratio;

      const inner = document.getElementById("joystickInner");
      if (inner) {
        inner.style.transform = `translate(${thumbX}px, ${thumbY}px)`;
      }

      const nx = dx / maxDist;
      const ny = dy / maxDist;

      const len = Math.min(1, Math.sqrt(nx * nx + ny * ny));

      if (len < 0.2) {
        joystickState.valueX = 0;
        joystickState.valueY = 0;
        return;
      }

      joystickState.valueX = clamp(nx, -1, 1);
      joystickState.valueY = clamp(ny, -1, 1);
    }


    /**
     * Ensures an AnimationAction is active with deterministic weight/time scale.
     */
    function setActionWeight(action, weight) {
      action.enabled = true;
      action.setEffectiveTimeScale(1);
      action.setEffectiveWeight(weight);
    }


    /**
     * Plays a named avatar gait ("idle" | "walk" | "run") with a stable cross-fade.
     */
    function playAvatarAction(name) {
      if (!avatarMixer) return;

      const next = avatarActions[name];
      if (!next) {
        console.warn("[avatar] no action for", name);
        return;
      }

      if (avatarCurrentActionName === name) return;

      const prev = avatarActions[avatarCurrentActionName];
      const duration = 0.3;

      next.reset();
      setActionWeight(next, 1.0);
      next.play();

      if (prev) {
        prev.crossFadeTo(next, duration, true);
      } else {
        next.fadeIn(duration);
      }

      avatarCurrentAction = next;
      avatarCurrentActionName = name;
    }


    /**
     * Matches walk/run animation playback speed to actual movement speed to reduce foot sliding.
     */
    function updateAvatarClipSpeed(speed) {
      if (!avatarMixer) return;

      const walk = avatarActions["walk"];
      const run = avatarActions["run"];

      if (avatarCurrentActionName === "walk" && walk) {
        const base = AVATAR_WALK_SPEED || 1.0;
        const scale = clamp(speed / base, 0.4, 2.0);
        walk.setEffectiveTimeScale(scale);
      } else if (avatarCurrentActionName === "run" && run) {
        const base = AVATAR_RUN_SPEED || 1.0;
        const scale = clamp(speed / base, 0.4, 2.0);
        run.setEffectiveTimeScale(scale);
      }
    }



    function loadAvatar() {
      gltfLoader.load(
        AVATAR_GLTF_URL,
        (gltf) => {
          avatar = gltf.scene;

          avatar.traverse((obj) => {
            if (!obj.isMesh) return;
            obj.castShadow = true;
            obj.receiveShadow = true;
          });

          avatar.position.set(0, 0, 6);
          scene.add(avatar);

          if (!gltf.animations || gltf.animations.length === 0) return;

          avatarMixer = new THREE.AnimationMixer(avatar);

          for (const k in avatarActions) delete avatarActions[k];
            avatarCurrentAction = null;
          avatarCurrentActionName = "";

          for (let i = 0; i < gltf.animations.length; i++) {
            const clip = gltf.animations[i];
            const key = String(clip.name || `clip_${i}`).toLowerCase();
            avatarActions[key] = avatarMixer.clipAction(clip);
          }

          function getAction(nameFallbacks, defaultKey) {
            for (let i = 0; i < nameFallbacks.length; i++) {
              const needle = String(nameFallbacks[i]).toLowerCase();
              const found = Object.entries(avatarActions).find(([n]) => n.includes(needle));
              if (found) return found[1];
            }
            return defaultKey != null ? (avatarActions[defaultKey] || null) : null;
          }

          const keys = Object.keys(avatarActions);
          const defaultKey = keys.length ? keys[0] : null;

          const idleAction = getAction(["idle", "stand"], defaultKey);
          const walkAction = getAction(["walk"], defaultKey);
          const runAction = getAction(["run", "jog"], defaultKey);
          const sitAction = getAction(["sit", "seat", "drive"], defaultKey);

          if (idleAction) avatarActions["idle"] = idleAction;
          if (walkAction) avatarActions["walk"] = walkAction;
          if (runAction) avatarActions["run"] = runAction;
          if (sitAction) avatarActions["sit"] = sitAction;

          if (avatarActions["idle"]) {
            avatarMixer.stopAllAction();
            playAvatarAction("idle");
          }
        },
        undefined,
        (err) => {
          console.warn("[snow] avatar load failed", err);
        }
        );
    }





    /**
     * Cross-fades avatar animation states.
     */
    function switchAvatarAction(name) {
      playAvatarAction(name);
    }


    /**
     * Enables avatar mode and locks interaction to avatar-follow camera behavior.
     */
    function enableAvatarControl(initialMode = "third") {
      if (!avatar || avatarState.enabled) return;

      savePreAvatarCameraState();

      avatarState.enabled = true;
      autoRotateEnabled = false;
      avatarHasLastPos = false;

      if (controls) {
        controls.autoRotate = false;
      }

      setAvatarViewMode(initialMode, true);
      updateAvatarButtons();
    }

    /**
     * Disables avatar mode and restores camera + controls to pre-avatar state.
     */
    function disableAvatarControl() {
      if (!avatarState.enabled) return;

      avatarState.enabled = false;

      avatarKeys.forward = false;
      avatarKeys.back = false;
      avatarKeys.left = false;
      avatarKeys.right = false;
      avatarKeys.run = false;

      avatarState.moveX = 0;
      avatarState.moveZ = 0;

      avatarVelocity.set(0, 0, 0);
      avatarMoveDir.set(0, 0, 0);

      avatarHasLastPos = false;

      resetJoystick();

      if (avatar) avatar.visible = true;

      if (avatarMixer && avatarActions.idle) {
        switchAvatarAction("idle");
      }

      restorePreAvatarCameraState();
      updateAvatarButtons();
    }

    /**
     * Recomputes keyboard movement intent from pressed keys.
     */
    function recomputeAvatarMoveFromKeys() {
      const f = avatarKeys.forward ? 1 : 0;
      const b = avatarKeys.back ? -1 : 0;
      const l = avatarKeys.left ? -1 : 0;
      const r = avatarKeys.right ? 1 : 0;

      avatarState.moveZ = f + b;
      avatarState.moveX = l + r;
    }




    /**
     * Swept XZ collision and sliding against scene collider meshes.
     * Uses ray tests with a radius offset to avoid tunneling and prevents "teleport to corner" failure modes.
     */
    // const avatarCollision = {
    //   radius: 0.38,
    //   skin: 0.03,
    //   probeY: 1.05,
    //   maxStep: 0.22,
    //   maxSlideIters: 3,
    //   broadphasePad: 0.9
    // };

    const avatarRaycaster = new THREE.Raycaster();
    const avatarSweepFrom = new THREE.Vector3();
    const avatarSweepDir = new THREE.Vector3();
    const avatarSweepVec = new THREE.Vector3();
    const avatarAttemptVec = new THREE.Vector3();
    const avatarCenterTmp = new THREE.Vector3();
    const avatarHitNormal = new THREE.Vector3();
    const avatarHitMat3 = new THREE.Matrix3();
    const avatarPrevPosTmp = new THREE.Vector3();

    /**
     * Clamps avatar XZ to the playable snow area while respecting the collision radius.
     */
    function clampAvatarToPlayableXZ(pos) {
      const margin = avatarCollision.radius + 0.25;
      const limX = Math.max(0.5, (visualBounds?.x ?? HALF_GROUND) - margin);
      const limZ = Math.max(0.5, (visualBounds?.z ?? HALF_GROUND) - margin);
      pos.x = clamp(pos.x, -limX, limX);
      pos.z = clamp(pos.z, -limZ, limZ);
    }

    /**
     * Moves the avatar in XZ with swept collisions and surface sliding.
     * Returns the actual horizontal distance traveled.
     */
    function moveAvatarXZWithCollisions(pos, moveX, moveZ) {
      if (!colliderBounds || colliderBounds.length === 0) {
        pos.x += moveX;
        pos.z += moveZ;
        clampAvatarToPlayableXZ(pos);
        return Math.sqrt(moveX * moveX + moveZ * moveZ);
      }

      let traveled = 0;

      avatarSweepVec.set(moveX, 0, moveZ);
      let remainingLen = avatarSweepVec.length();
      if (remainingLen <= 1e-8) return 0;

      clampAvatarToPlayableXZ(pos);

      while (remainingLen > 1e-6) {
        const stepLen = Math.min(avatarCollision.maxStep, remainingLen);
        avatarSweepDir.copy(avatarSweepVec).setLength(1);
        avatarAttemptVec.copy(avatarSweepDir).multiplyScalar(stepLen);

        let resolvedThisStep = false;

        for (let slideIter = 0; slideIter < avatarCollision.maxSlideIters; slideIter++) {
          const attemptLen = avatarAttemptVec.length();
          if (attemptLen <= 1e-6) {
            resolvedThisStep = true;
            break;
          }

          avatarSweepDir.copy(avatarAttemptVec).multiplyScalar(1 / attemptLen);
          avatarSweepFrom.set(pos.x, pos.y + avatarCollision.probeY, pos.z);

          avatarRaycaster.set(avatarSweepFrom, avatarSweepDir);
          avatarRaycaster.far = attemptLen + avatarCollision.radius + avatarCollision.skin;

          let bestHit = null;
          let bestDist = Infinity;

          for (const cb of colliderBounds) {
            const obj = cb && cb.obj;
            if (!obj || !obj.isMesh) continue;

            obj.updateWorldMatrix(true, false);

            obj.getWorldPosition(avatarCenterTmp);
            const dx = avatarCenterTmp.x - pos.x;
            const dz = avatarCenterTmp.z - pos.z;

            const rBase = Number.isFinite(cb.radius) ? cb.radius : 0;
            const r = rBase + avatarCollision.radius + attemptLen + avatarCollision.broadphasePad;
            if (dx * dx + dz * dz > r * r) continue;

            const hits = avatarRaycaster.intersectObject(obj, false);
            if (!hits || hits.length === 0) continue;

            const h = hits[0];
            if (h.distance < bestDist) {
              bestDist = h.distance;
              bestHit = h;
            }
          }

          if (!bestHit || !(bestDist < Infinity)) {
            pos.x += avatarAttemptVec.x;
            pos.z += avatarAttemptVec.z;
            traveled += attemptLen;
            resolvedThisStep = true;
            break;
          }

          if (bestHit.face) {
            avatarHitNormal.copy(bestHit.face.normal);
            avatarHitMat3.getNormalMatrix(bestHit.object.matrixWorld);
            avatarHitNormal.applyMatrix3(avatarHitMat3).normalize();
          } else {
            avatarHitNormal.set(-avatarSweepDir.x, 0, -avatarSweepDir.z);
          }

          avatarHitNormal.y = 0;
          if (avatarHitNormal.lengthSq() < 1e-10) {
            avatarHitNormal.set(-avatarSweepDir.x, 0, -avatarSweepDir.z);
          } else {
            avatarHitNormal.normalize();
          }

          const allowed = Math.max(0, bestDist - avatarCollision.radius - avatarCollision.skin);

          if (allowed > 1e-6) {
            pos.x += avatarSweepDir.x * allowed;
            pos.z += avatarSweepDir.z * allowed;
            traveled += allowed;
          } else if (bestDist < 1e-4) {
            pos.x += avatarHitNormal.x * (avatarCollision.skin + 0.01);
            pos.z += avatarHitNormal.z * (avatarCollision.skin + 0.01);
          }

          clampAvatarToPlayableXZ(pos);

          const remainAfter = attemptLen - allowed;
          if (remainAfter <= 1e-6) {
            resolvedThisStep = true;
            break;
          }

          avatarSweepVec.copy(avatarSweepDir).multiplyScalar(remainAfter);
          const intoN = avatarSweepVec.dot(avatarHitNormal);
          avatarSweepVec.addScaledVector(avatarHitNormal, -intoN);

          if (avatarSweepVec.lengthSq() <= 1e-10) {
            resolvedThisStep = true;
            break;
          }

          avatarAttemptVec.copy(avatarSweepVec);
        }

        if (!resolvedThisStep) {
          break;
        }

        remainingLen -= stepLen;
        if (remainingLen <= 1e-6) break;
      }

      return traveled;
    }




    function updateAvatarFromInputs(dt) {
      if (!avatar || !avatarState.enabled) return;

      let forwardAmount = 0;
      let strafeAmount = 0;
      let inputMag = 0;
      let wantsRun = false;

      const joyForward = -joystickState.valueY;
      const joyStrafe = joystickState.valueX;
      const joyMag = Math.min(1, Math.sqrt(joyForward * joyForward + joyStrafe * joyStrafe));

      if (joystickState.active && joyMag > 0) {
        forwardAmount = joyForward;
        strafeAmount = joyStrafe;
        inputMag = joyMag;
        wantsRun = joyMag >= 0.82;
      } else {
        forwardAmount = avatarState.moveZ;
        strafeAmount = avatarState.moveX;
        inputMag = Math.min(1, Math.sqrt(forwardAmount * forwardAmount + strafeAmount * strafeAmount));
        wantsRun = !!avatarKeys.run && inputMag > 0;
      }

      if (inputMag <= 0) {
        const speedNow = avatarVelocity.length();
        if (speedNow > 0) {
          avatarToTarget.copy(avatarVelocity).multiplyScalar(-1);
          const maxStep = avatarMotionConfig.maxDecel * dt;
          if (avatarToTarget.length() <= maxStep) {
            avatarVelocity.set(0, 0, 0);
          } else {
            avatarToTarget.setLength(maxStep);
            avatarVelocity.add(avatarToTarget);
          }
        }
      } else {
        camera.getWorldDirection(camForward);
        camForward.y = 0;
        if (camForward.lengthSq() < 1e-8) camForward.set(0, 0, -1);
        camForward.normalize();

        camRight.crossVectors(camForward, worldUp).normalize();

        avatarMoveDir
        .copy(camForward)
        .multiplyScalar(forwardAmount)
        .addScaledVector(camRight, strafeAmount);

        if (avatarMoveDir.lengthSq() > 1e-8) {
          avatarMoveDir.normalize();
        } else {
          avatarMoveDir.set(0, 0, 0);
        }

        const speedTarget = (wantsRun ? AVATAR_RUN_SPEED : AVATAR_WALK_SPEED) * inputMag;
        const desiredVel = avatarTmpVec.copy(avatarMoveDir).multiplyScalar(speedTarget);

        const speedNow = avatarVelocity.length();
        avatarToTarget.subVectors(desiredVel, avatarVelocity);
        const distToTarget = avatarToTarget.length();

        if (distToTarget > 1e-6) {
          const accelerating = speedTarget > speedNow;
          const accel = accelerating ? avatarMotionConfig.maxAccel : avatarMotionConfig.maxDecel;
          const maxStep = accel * dt;

          if (distToTarget <= maxStep) {
            avatarVelocity.copy(desiredVel);
          } else {
            avatarToTarget.setLength(maxStep);
            avatarVelocity.add(avatarToTarget);
          }
        }
      }

      if (avatarVelocity.length() < avatarMotionConfig.stopEps) {
        avatarVelocity.set(0, 0, 0);
      }

      const prevX = avatar.position.x;
      const prevZ = avatar.position.z;

      if (avatarVelocity.lengthSq() > 0) {
        avatarTmpVec.copy(avatarVelocity).multiplyScalar(dt);
        avatarTmpVec.y = 0;

        avatar.position.add(avatarTmpVec);

        resolveAvatarXZCollisions(avatar.position);

        if (avatarState.viewMode === "third") {
          const dx = avatar.position.x - prevX;
          const dz = avatar.position.z - prevZ;
          if (dx * dx + dz * dz > 1e-10) {
            const targetYaw = Math.atan2(dx, dz);
            avatar.rotation.y = lerpYaw(avatar.rotation.y, targetYaw, avatarMotionConfig.yawLerpThird);
          }
        }
      } else {
        resolveAvatarXZCollisions(avatar.position);
      }

      const dx = avatar.position.x - prevX;
      const dz = avatar.position.z - prevZ;
      const actualSpeed = dt > 0 ? (Math.sqrt(dx * dx + dz * dz) / dt) : 0;

      let targetAction = "idle";
      if (actualSpeed < avatarMotionConfig.stopEps) {
        targetAction = "idle";
      } else {
        const runThreshold = (AVATAR_WALK_SPEED + AVATAR_RUN_SPEED) * 0.5;
        targetAction = actualSpeed >= runThreshold ? "run" : "walk";
      }

      switchAvatarAction(targetAction);
      updateAvatarClipSpeed(actualSpeed);
    }





    /**
     * Updates camera rig to follow the avatar.
     * third-person: move camera+target by avatar movement delta.
     * first-person: camera pinned to head; avatar yaw follows camera look.
     */
    function updateAvatarCamera(dt) {
      if (!avatarState.enabled || !avatar || !controls) return;

      avatar.getWorldPosition(avatarWorldPos);

      if (avatarState.viewMode === "third") {
        if (avatar) avatar.visible = true;

        if (!avatarHasLastPos) {
          placeCameraBehindAvatar();
          return;
        }

        avatarTmpVec.subVectors(avatarWorldPos, avatarLastWorldPos);
        if (avatarTmpVec.lengthSq() > 0) {
          controls.target.add(avatarTmpVec);
          camera.position.add(avatarTmpVec);
        }

        avatarLastWorldPos.copy(avatarWorldPos);
        return;
      }

      if (avatar) avatar.visible = false;

      avatarHeadPos.copy(avatarWorldPos);
      avatarHeadPos.y += avatarViewConfig.firstPersonHeight;

      camera.getWorldDirection(avatarTmpDir);
      avatarTmpDir.normalize();

      const desiredYaw = Math.atan2(avatarTmpDir.x, avatarTmpDir.z);
      avatar.rotation.y = lerpYaw(avatar.rotation.y, desiredYaw, avatarMotionConfig.yawLerpFirst);

      camera.position.copy(avatarHeadPos);
      controls.target.copy(avatarHeadPos).add(avatarTmpDir);

      avatarHasLastPos = false;
    }

    function tickAvatar(dt) {
      if (avatarState.enabled) {
        if (vehicleDriveState.enabled) {
          tickVehicle(dt);
        } else {
          updateAvatarFromInputs(dt);
          tickVehicleProximity();
        }
      } else {
        if (vehicleDriveState.enabled) {
          exitVehicle();
        } else {
          if (vehiclePromptState.open) setVehiclePrompt(false, null);
          updateVehicleOutlineFor(null);
        }
      }

      if (avatarMixer) {
        avatarMixer.update(dt);
      }
    }



    // Binds avatar toggle buttons and joystick pointer events
    function setupAvatarUI() {
      const avatarToggleBtn = document.getElementById("avatarToggle");
      const avatarViewToggleBtn = document.getElementById("avatarViewToggle");
      const joystickEl = document.getElementById("joystick");

      const vehicleEnterBtn = document.getElementById("vehicleEnterBtn");
      const vehicleExitBtn = document.getElementById("vehicleExitBtn");
      const vehicleCloseBtn = document.getElementById("vehicleCloseBtn");

      if (avatarToggleBtn) {
        avatarToggleBtn.addEventListener("click", () => {
          if (avatarState.enabled) {
            disableAvatarControl();
          } else {
            enableAvatarControl(avatarState.viewMode);
          }
          updateAvatarButtons();
        });
      }

      if (avatarViewToggleBtn) {
        avatarViewToggleBtn.addEventListener("click", () => {
          const next = avatarState.viewMode === "third" ? "first" : "third";

          if (avatarState.enabled) {
            setAvatarViewMode(next, true);
          } else {
            avatarState.viewMode = next;
          }

          updateAvatarButtons();
        });
      }

      if (vehicleEnterBtn) {
        vehicleEnterBtn.addEventListener("click", () => {
          if (!vehicleDriveState.enabled && vehiclePromptState.nearby) {
            enterVehicle(vehiclePromptState.nearby);
          }
        });
      }

      if (vehicleExitBtn) {
        vehicleExitBtn.addEventListener("click", () => {
          if (vehicleDriveState.enabled) exitVehicle();
        });
      }

      if (vehicleCloseBtn) {
        vehicleCloseBtn.addEventListener("click", () => {
          setVehiclePrompt(false, null);
          updateVehicleOutlineFor(null);
        });
      }

      if (joystickEl) {
        joystickEl.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          joystickState.active = true;
          joystickState.pointerId = event.pointerId;

          const rect = joystickEl.getBoundingClientRect();
          joystickState.centerX = rect.left + rect.width * 0.5;
          joystickState.centerY = rect.top + rect.height * 0.5;
          joystickState.radius = rect.width * 0.5;

          joystickEl.setPointerCapture(event.pointerId);
          updateJoystickFromPointer(event.clientX, event.clientY);
        });

        joystickEl.addEventListener("pointermove", (event) => {
          if (!joystickState.active || event.pointerId !== joystickState.pointerId) return;
          event.preventDefault();
          updateJoystickFromPointer(event.clientX, event.clientY);
        });

        const endHandler = (event) => {
          if (event.pointerId !== joystickState.pointerId) return;
          event.preventDefault();

          joystickEl.releasePointerCapture(event.pointerId);
          resetJoystick();
        };

        joystickEl.addEventListener("pointerup", endHandler);
        joystickEl.addEventListener("pointercancel", endHandler);
      }

      updateAvatarButtons();
      setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);
    }






    function updateAvatarButtons() {
      const toggle = document.getElementById("avatarToggle");
      const view = document.getElementById("avatarViewToggle");

      if (toggle) {
        toggle.textContent = avatarState.enabled ? "Avatar: ON" : "Avatar: OFF";
      }
      if (view) {
        view.textContent =
        avatarState.viewMode === "third" ? "View: Behind" : "View: Eyes";
      }
    }







    // -------------------------------------------------------------------------
    // Snowman path animation – curvy, local “snail” trajectory
    // -------------------------------------------------------------------------

    const snowmanPathCenter = new THREE.Vector3(-7, 0, -1);
    const snowmanPathPoints = [];
    const SNOWMAN_PATH_SEGMENTS = 9;

    (function buildSnowmanPath() {
      const baseR = DEFAULTS.snowmanPathRadius;
      for (let i = 0; i < SNOWMAN_PATH_SEGMENTS; i++) {
        const a = (i / SNOWMAN_PATH_SEGMENTS) * Math.PI * 2.0;

        // radius modulation -> mixture of almost circles and arcs
        const rMul = 0.72 + 0.20 * Math.sin(i * 1.47) + 0.12 * Math.cos(i * 2.17);
        const r = baseR * rMul;

        const x = snowmanPathCenter.x + Math.cos(a) * r;
        const z = snowmanPathCenter.z + Math.sin(a) * r;
        const y = 0.0;

        snowmanPathPoints.push(new THREE.Vector3(x, y, z));
      }
    })();

    const snowmanPathCurve = new THREE.CatmullRomCurve3(
      snowmanPathPoints,
      true,
      "catmullrom",
      0.5
      );

    const snowmanState = {
      t: 0,
      lastPos: new THREE.Vector3(NaN, NaN, NaN)
    };

    function updateSnowman(dt) {
      if (dt <= 0) return;
      if (!params.snowmanMoveEnabled) return;

      const snowmanObj = getModelInstance("snowman");
      if (!snowmanObj) return;

      // loops per second along the closed curve
      const speed = clamp(params.snowmanSpeed, 0.0, 1.0);
      if (speed <= 0.0) return;

      snowmanState.t = (snowmanState.t + dt * speed) % 1.0;

      // position on curve
      const curvePos = snowmanPathCurve.getPointAt(snowmanState.t);

      // place him on top of snow surface
      const groundY = sampleSnowHeight(curvePos.x, curvePos.z);
      snowmanObj.position.set(curvePos.x, groundY, curvePos.z);

      // face along direction of motion (XZ plane)
      const tangent = snowmanPathCurve.getTangentAt(snowmanState.t);
      const dirX = tangent.x;
      const dirZ = tangent.z;

      if (dirX !== 0 || dirZ !== 0) {
        // world +Z = forward. atan2(x, z) gives heading around Y.
        const heading = Math.atan2(dirX, dirZ);
        snowmanObj.rotation.y = heading;
      }

      snowmanState.lastPos.copy(snowmanObj.position);
    }







    // Drifts (heightfield)
    let DRIFT_GRID = 0;
    let DRIFT_STRIDE = 0;
    let DRIFT_VERTS = 0;
    let driftHeights = null;
    let driftHeightsTmp = null;
    let driftGeo = null;
    let driftPosAttr = null;
    let driftPosArray = null;
    let snowSurface = null;

    // Visual flakes
    let snowGeo = null;
    let snowMat = null;
    let snowPoints = null;

    // Sticking decals
    let stuck = null;
    let stuckGeo = null;
    let stuckMat = null;
    let stuckCount = 0;
    let stuckWrite = 0;

    // Settlers
    let SETTLER_COUNT = 0;
    let settlerPos = null;
    let settlerPrev = null;
    let settlerVel = null;
    let depositTokens = 0;


    // Colliders
    let colliderObjects = [];
    let colliderBounds = [];

    // Model-only colliders (cars etc): simplified oriented boxes built once at load-time
    let avatarModelColliderObjects = [];
    let avatarModelColliderBounds = [];
    let avatarModelColliderOBBs = [];

    // Vehicle interaction + driving state (POC)
    const vehicleInteractables = [];
    const vehiclePromptState = {
      open: false,
      nearby: null
    };

    const vehicleDriveState = {
      enabled: false,
      vehicle: null,
      speed: 0.0,
      yaw: 0.0
    };

    const vehicleTmpBox = new THREE.Box3();
    const vehicleTmpCenter = new THREE.Vector3();
    const vehicleTmpSize = new THREE.Vector3();
    const vehicleTmpPos = new THREE.Vector3();
    const vehicleTmpVel = new THREE.Vector3();
    const vehicleTmpMove = new THREE.Vector3();
    const vehicleSeatLocal = new THREE.Vector3();
    const vehicleSeatWorld = new THREE.Vector3();

    const vehicleOutlineBox = new THREE.Box3();
    let vehicleOutlineHelper = null;


/**
 * Attaches a non-window debug bridge for vehicle inspection/manipulation to the renderer canvas element.
 * Access from DevTools: document.querySelector("#app canvas").vehicleDebug
 */
    function installVehicleDebugBridge(canvasEl) {
      if (!canvasEl) return;

      const api = {
    /**
     * Lists loaded vehicles with ids and types.
     */
        list() {
          return vehicleInteractables.map((v) => ({
            id: v.id || "",
            type: (v.meta && v.meta.type) || "Vehicle"
          }));
        },

    /**
     * Returns the per-vehicle debug handle (same shape as the one logged at load-time).
     */
        get(id) {
          const key = String(id || "");
          for (let i = 0; i < vehicleInteractables.length; i++) {
            const v = vehicleInteractables[i];
            if (!v) continue;
            if (String(v.id || "") !== key) continue;
            const h = v.object && v.object.userData ? v.object.userData.vehicleDebug : null;
            return h || null;
          }
          return null;
        },

    /**
     * Returns the vehicle root Object3D for a given id.
     */
        root(id) {
          const h = api.get(id);
          return h ? h.object : null;
        },

    /**
     * Returns detected parts for a given id.
     */
        parts(id) {
          const h = api.get(id);
          return h ? h.parts : null;
        },

    /**
     * Sets an internal selection for quicker console iteration.
     */
        select(id) {
          const h = api.get(id);
          canvasEl.vehicleSelectedId = h ? h.id : "";
          return h;
        },

    /**
     * Gets current selection debug handle.
     */
        selected() {
          const id = String(canvasEl.vehicleSelectedId || "");
          return id ? api.get(id) : null;
        }
      };

      canvasEl.vehicleDebug = api;
      if (!canvasEl.vehicleSelectedId) canvasEl.vehicleSelectedId = "";
    }


    /**
     * Shows/hides the vehicle prompt panel and refreshes the current selection.
     */
    function setVehiclePrompt(open, v) {
      vehiclePromptState.open = !!open;
      vehiclePromptState.nearby = open ? (v || null) : null;

      syncVehicleTuningSelection();

      const panel = document.getElementById("vehiclePrompt");
      const title = document.getElementById("vehiclePromptTitle");
      const desc = document.getElementById("vehiclePromptDesc");
      const enterBtn = document.getElementById("vehicleEnterBtn");
      const exitBtn = document.getElementById("vehicleExitBtn");

      if (!panel || !title || !desc || !enterBtn || !exitBtn) return;

      if (uiHidden) {
        panel.style.display = "none";
        panel.setAttribute("aria-hidden", "true");
        return;
      }

      if (!vehiclePromptState.open || !vehiclePromptState.nearby) {
        panel.style.display = "none";
        panel.setAttribute("aria-hidden", "true");
        title.textContent = "";
        desc.textContent = "";
        enterBtn.style.display = "";
        exitBtn.style.display = "none";
        return;
      }

      const meta = vehiclePromptState.nearby.meta;
      title.textContent = meta.type || "Vehicle";
      desc.textContent = meta.description || "";

      if (vehicleDriveState.enabled) {
        enterBtn.style.display = "none";
        exitBtn.style.display = "";
      } else {
        enterBtn.style.display = "";
        exitBtn.style.display = "none";
      }

      panel.style.display = "block";
      panel.setAttribute("aria-hidden", "false");
    }


    /**
     * Updates (or hides) a simple bounding-box outline around a selected vehicle.
     */
    function updateVehicleOutlineFor(v) {
      if (!v || !v.object || uiHidden) {
        if (vehicleOutlineHelper && vehicleOutlineHelper.parent) {
          vehicleOutlineHelper.parent.remove(vehicleOutlineHelper);
        }
        return;
      }

      v.object.updateWorldMatrix(true, true);
      vehicleOutlineBox.setFromObject(v.object);

      if (!vehicleOutlineHelper) {
        vehicleOutlineHelper = new THREE.Box3Helper(vehicleOutlineBox, 0xffffff);
      } else {
        vehicleOutlineHelper.box.copy(vehicleOutlineBox);
      }

      if (!vehicleOutlineHelper.parent) {
        scene.add(vehicleOutlineHelper);
      }
    }



    /**
     * Registers a vehicle instance for proximity interaction and driving.
     */
    function registerVehicleInstance(inst, instCfg) {
  /**
   * Collects named sub-parts for vehicles (wheels/propellers/etc.) for debugging and future animation hooks.
   * Returns stable references to Object3D nodes found by name heuristics and a full name index.
   */
      function scanVehicleNamedParts(root) {
        const wheels = [];
        const propellers = [];
        const named = Object.create(null);
        const allNames = [];

        root.traverse((obj) => {
          const raw = typeof obj.name === "string" ? obj.name.trim() : "";
          if (!raw) return;

          named[raw] = obj;
          allNames.push(raw);

          const n = raw.toLowerCase();

          if (n.includes("wheel") || n.startsWith("whl") || n.includes("tyre") || n.includes("tire")) {
            wheels.push(obj);
            return;
          }

          if (
            n.includes("propeller") ||
            n === "prop" ||
            n.startsWith("prop_") ||
            n.includes("rotor") ||
            n.includes("fan")
            ) {
            propellers.push(obj);
        }
      });

        wheels.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
        propellers.sort((a, b) => (a.name || "").localeCompare(b.name || ""));

        return { wheels, propellers, named, allNames };
      }

  /**
   * Builds a lightweight debug handle that can be stored from the console for manual traversal.
   * No globals are created; the handle is only emitted via console logging.
   */
      function makeVehicleDebugHandle(id, meta, root, parts) {
        return {
          id,
          type: (meta && meta.type) || "Vehicle",
          object: root,
          parts: {
            wheels: parts.wheels,
            propellers: parts.propellers,
            named: parts.named
          },
          listNames() {
            return parts.allNames.slice();
          },
          getByName(name) {
            if (!name) return null;
            return parts.named[name] || null;
          },
          findBySubstring(substr) {
            const q = (substr || "").toLowerCase();
            if (!q) return [];
            const out = [];
            for (let i = 0; i < parts.allNames.length; i++) {
              const nm = parts.allNames[i];
              if (nm.toLowerCase().includes(q)) out.push(nm);
            }
            return out;
          }
        };
      }

      if (!instCfg || !instCfg.vehicle) return;

      inst.updateWorldMatrix(true, true);
      vehicleTmpBox.setFromObject(inst);

      if (!Number.isFinite(vehicleTmpBox.min.x) || !Number.isFinite(vehicleTmpBox.max.x)) return;

      vehicleTmpBox.getCenter(vehicleTmpCenter);
      vehicleTmpBox.getSize(vehicleTmpSize);

      const radius = Math.max(0.35, 0.5 * Math.max(vehicleTmpSize.x, vehicleTmpSize.z));
      const meta = instCfg.vehicle;

      const parts = scanVehicleNamedParts(inst);
      inst.userData.vehicleParts = parts;

      const v = {
        id: instCfg.id || "",
        object: inst,
        meta,
        radius,
        parts
      };

      vehicleInteractables.push(v);

      const debugHandle = makeVehicleDebugHandle(v.id, meta, inst, parts);
      inst.userData.vehicleDebug = debugHandle;

      console.groupCollapsed(
    `[vehicle] loaded "${v.id || "(no-id)"}" (${(meta && meta.type) || "Vehicle"})`
    );
      console.log("root:", inst);
      console.log("meta:", meta);
      console.log("detected:", {
        wheels: parts.wheels.map((o) => o.name),
        propellers: parts.propellers.map((o) => o.name),
        namedCount: parts.allNames.length
      });
      console.log("debug-handle:", debugHandle);
      console.groupEnd();
    }


    /**
     * Finds the nearest vehicle within interaction range.
     */
    function findNearbyVehicle() {
      if (!avatar) return null;

      const pos = avatar.position;
      let best = null;
      let bestD2 = Infinity;

      for (let i = 0; i < vehicleInteractables.length; i++) {
        const v = vehicleInteractables[i];
        if (!v || !v.object) continue;

        v.object.getWorldPosition(vehicleTmpPos);

        const dx = pos.x - vehicleTmpPos.x;
        const dz = pos.z - vehicleTmpPos.z;

        const reach = (avatarCollision.radius + v.radius + 0.65);
        const d2 = dx * dx + dz * dz;

        if (d2 <= reach * reach && d2 < bestD2) {
          bestD2 = d2;
          best = v;
        }
      }

      return best;
    }

    /**
     * Enters vehicle mode: locks controls to the vehicle and seats the avatar.
     */
    function enterVehicle(v) {
      if (!v || !v.object || !v.meta) return;
      if (!avatar || !avatarState.enabled) return;

      vehicleDriveState.enabled = true;
      vehicleDriveState.vehicle = v;
      vehicleDriveState.speed = 0.0;
      vehicleDriveState.yaw = v.object.rotation.y + (v.meta.yawOffset || 0.0);

      if (avatarMixer && avatarActions.sit) {
        switchAvatarAction("sit");
      } else if (avatarMixer && avatarActions.idle) {
        switchAvatarAction("idle");
      }

      setVehiclePrompt(true, v);
    }

    /**
     * Exits vehicle mode: restores avatar walking controls and places avatar beside the vehicle.
     */
    function exitVehicle() {
      const v = vehicleDriveState.vehicle;
      if (!vehicleDriveState.enabled || !v || !v.object) return;

      v.object.getWorldPosition(vehicleTmpPos);

      const side = 1.1 + (v.radius || 0.8);
      const yaw = v.object.rotation.y;

      avatar.position.set(
        vehicleTmpPos.x + Math.sin(yaw + Math.PI * 0.5) * side,
        avatar.position.y,
        vehicleTmpPos.z + Math.cos(yaw + Math.PI * 0.5) * side
        );

      vehicleDriveState.enabled = false;
      vehicleDriveState.vehicle = null;
      vehicleDriveState.speed = 0.0;

      if (avatarMixer && avatarActions.idle) {
        switchAvatarAction("idle");
      }

      setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);
      resetJoystick();
    }

    /**
     * Vehicle profile tuning state for lil-gui, bound to the currently selected vehicle:
     * - while driving: the driven vehicle
     * - otherwise: the currently nearby (prompt) vehicle
     */
    const vehicleTuningState = {
      available: false,
      id: "",
      type: "",
      description: "",

      maxSpeed: 10.0,
      maxReverse: 4.0,
      accel: 10.0,
      brake: 14.0,
      coastDecel: 3.0,
      turnRate: 2.4,

      radius: 0.9,
      wheelBase: 2.5,
      minTurnRadius: 3.0,
      minSteerSpeed: 0.35,
      steerResponse: 8.0,
      steerReturn: 6.0,
      lateralGrip: 8.0
    };

    let vehicleTuningLastId = "";
    let vehicleTuningFolder = null;

    /**
     * Resolves the current tuning target vehicle based on interaction/drive state.
     */
    function getVehicleTuningTarget() {
      if (vehicleDriveState.enabled && vehicleDriveState.vehicle) return vehicleDriveState.vehicle;
      if (vehiclePromptState.open && vehiclePromptState.nearby) return vehiclePromptState.nearby;
      return null;
    }

    /**
     * Copies vehicle profile values into the tuning state (used for GUI display/listen).
     */
    function readVehicleProfileIntoTuningState(v) {
      if (!v || !v.meta) return;

      const prof = v.meta.profile || {};
      vehicleTuningState.available = true;

      vehicleTuningState.id = v.id || "";
      vehicleTuningState.type = v.meta.type || "Vehicle";
      vehicleTuningState.description = v.meta.description || "";

      vehicleTuningState.maxSpeed = Math.max(0.1, prof.maxSpeed ?? 10.0);
      vehicleTuningState.maxReverse = Math.max(0.1, prof.maxReverse ?? 4.0);
      vehicleTuningState.accel = Math.max(0.1, prof.accel ?? 10.0);
      vehicleTuningState.brake = Math.max(0.1, prof.brake ?? 14.0);
      vehicleTuningState.coastDecel = Math.max(0.1, prof.coastDecel ?? 3.0);
      vehicleTuningState.turnRate = Math.max(0.1, prof.turnRate ?? 2.4);

      const r = Math.max(0.35, (prof.radius ?? v.radius ?? 0.9));
      vehicleTuningState.radius = r;

      vehicleTuningState.wheelBase = Math.max(0.5, prof.wheelBase ?? (r * 2.8));
      vehicleTuningState.minTurnRadius = Math.max(1.0, prof.minTurnRadius ?? 3.0);
      vehicleTuningState.minSteerSpeed = Math.max(0.0, prof.minSteerSpeed ?? 0.35);
      vehicleTuningState.steerResponse = Math.max(0.1, prof.steerResponse ?? 8.0);
      vehicleTuningState.steerReturn = Math.max(0.1, prof.steerReturn ?? 6.0);
      vehicleTuningState.lateralGrip = Math.max(0.0, prof.lateralGrip ?? 8.0);
    }

    /**
     * Writes the tuning state back to the target vehicle profile (live steering changes).
     */
    function writeTuningStateIntoVehicleProfile(v) {
      if (!v || !v.meta) return;

      if (!v.meta.profile || typeof v.meta.profile !== "object") v.meta.profile = {};
      const prof = v.meta.profile;

      prof.maxSpeed = Math.max(0.1, vehicleTuningState.maxSpeed);
      prof.maxReverse = Math.max(0.1, vehicleTuningState.maxReverse);
      prof.accel = Math.max(0.1, vehicleTuningState.accel);
      prof.brake = Math.max(0.1, vehicleTuningState.brake);
      prof.coastDecel = Math.max(0.1, vehicleTuningState.coastDecel);
      prof.turnRate = Math.max(0.1, vehicleTuningState.turnRate);

      prof.radius = Math.max(0.35, vehicleTuningState.radius);
      v.radius = prof.radius;

      prof.wheelBase = Math.max(0.5, vehicleTuningState.wheelBase);
      prof.minTurnRadius = Math.max(1.0, vehicleTuningState.minTurnRadius);
      prof.minSteerSpeed = Math.max(0.0, vehicleTuningState.minSteerSpeed);
      prof.steerResponse = Math.max(0.1, vehicleTuningState.steerResponse);
      prof.steerReturn = Math.max(0.1, vehicleTuningState.steerReturn);
      prof.lateralGrip = Math.max(0.0, vehicleTuningState.lateralGrip);
    }

    /**
     * Keeps the tuning state aligned with the current selection (no polling/traversal hacks).
     */
    function syncVehicleTuningSelection() {
      if (!vehicleTuningFolder) return;

      const v = getVehicleTuningTarget();
      const id = v ? (v.id || "") : "";

      if (!v) {
        vehicleTuningState.available = false;
        vehicleTuningState.id = "";
        vehicleTuningState.type = "";
        vehicleTuningState.description = "";
        vehicleTuningLastId = "";
        return;
      }

      if (id === vehicleTuningLastId) return;

      vehicleTuningLastId = id;
      readVehicleProfileIntoTuningState(v);
    }

    /**
     * Sets up lil-gui controls for the selected vehicle profile and provides an export action.
     */
    function setupVehicleTuningGui(folder) {
      vehicleTuningFolder = folder;

      const info = folder.addFolder("Selection");
      info.add(vehicleTuningState, "available").name("Available").listen();
      info.add(vehicleTuningState, "id").name("Id").listen();
      info.add(vehicleTuningState, "type").name("Type").listen();
      info.add(vehicleTuningState, "description").name("Description").listen();
      info.close();

      const profile = folder.addFolder("Profile");

      profile.add(vehicleTuningState, "maxSpeed", 0.5, 40.0, 0.1).name("Max speed").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "maxReverse", 0.5, 20.0, 0.1).name("Max reverse").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "accel", 0.1, 40.0, 0.1).name("Accel").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "brake", 0.1, 60.0, 0.1).name("Brake").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "coastDecel", 0.1, 20.0, 0.1).name("Coast decel").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "turnRate", 0.2, 6.0, 0.01).name("Turn rate").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "radius", 0.35, 4.0, 0.01).name("Collider radius").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "wheelBase", 0.5, 12.0, 0.01).name("Wheelbase").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "minTurnRadius", 1.0, 30.0, 0.1).name("Min turn radius").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "minSteerSpeed", 0.0, 5.0, 0.01).name("Min steer speed").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "steerResponse", 0.1, 25.0, 0.1).name("Steer response").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "steerReturn", 0.1, 25.0, 0.1).name("Steer return").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      profile.add(vehicleTuningState, "lateralGrip", 0.0, 25.0, 0.1).name("Lateral grip").listen().onChange(() => {
        const v = getVehicleTuningTarget();
        writeTuningStateIntoVehicleProfile(v);
      });

      const actions = {
        exportProfile: async () => {
          const v = getVehicleTuningTarget();
          if (!v || !v.meta) return;

          writeTuningStateIntoVehicleProfile(v);

          function fmtNum(n, digits = 3) {
            const x = Number(n);
            if (!Number.isFinite(x)) return "0.0";
            const p = Math.pow(10, digits);
            const r = Math.round(x * p) / p;
            let s = r.toFixed(digits).replace(/0+$/, "").replace(/\.$/, "");
            if (!s.includes(".")) s += ".0";
            return s;
          }

          function fmtStr(s) {
            return JSON.stringify(String(s ?? ""));
          }

          function fmtArr3(a, d0, d1, d2) {
            const x = Array.isArray(a) ? a : [d0, d1, d2];
            return `[${fmtNum(x[0])}, ${fmtNum(x[1])}, ${fmtNum(x[2])}]`;
          }

          const type = v.meta.type || "Vehicle";
          const description = v.meta.description || "";
          const seatLocal = v.meta.seatLocal || [0, 0.6, 0];
          const yawOffset = Number.isFinite(v.meta.yawOffset) ? v.meta.yawOffset : 0.0;

          const prof = (v.meta.profile && typeof v.meta.profile === "object") ? v.meta.profile : {};

          const out =
          `vehicle: {
  type: ${fmtStr(type)},
  description: ${fmtStr(description)},
  seatLocal: ${fmtArr3(seatLocal, 0, 0.6, 0)},
  yawOffset: ${fmtNum(yawOffset)},
  profile: {
    maxSpeed: ${fmtNum(prof.maxSpeed)},
    maxReverse: ${fmtNum(prof.maxReverse)},
    accel: ${fmtNum(prof.accel)},
    brake: ${fmtNum(prof.brake)},
    coastDecel: ${fmtNum(prof.coastDecel)},
    turnRate: ${fmtNum(prof.turnRate)},
    radius: ${fmtNum(prof.radius)},
    wheelBase: ${fmtNum(prof.wheelBase)},
    minTurnRadius: ${fmtNum(prof.minTurnRadius)},
    minSteerSpeed: ${fmtNum(prof.minSteerSpeed)},
    steerResponse: ${fmtNum(prof.steerResponse)},
    steerReturn: ${fmtNum(prof.steerReturn)},
    lateralGrip: ${fmtNum(prof.lateralGrip)}
  }
        }`;

        console.log(out);

        try {
          if (navigator.clipboard && navigator.clipboard.writeText) {
            await navigator.clipboard.writeText(out);
          }
        } catch (e) {
        }
      }
    };


    profile.add(actions, "exportProfile").name("Export to MODEL_CONFIG");

    profile.close();

    syncVehicleTuningSelection();
  }






    /**
     * Resolves simplified XZ collisions for a moving vehicle using prebuilt sphere bounds and model OBBs.
     */
  function resolveVehicleXZCollisions(pos, vel, radius, ignoreObject) {
    const limX = Math.max(0.5, visualBounds.x - (radius + 0.25));
    const limZ = Math.max(0.5, visualBounds.z - (radius + 0.25));

    pos.x = clamp(pos.x, -limX, limX);
    pos.z = clamp(pos.z, -limZ, limZ);

    const skin = avatarCollision.skin;

    for (let iter = 0; iter < avatarCollision.iterations; iter++) {
      let pushed = false;

      const candidates = getAvatarCollisionCandidatesXZ(pos);
      if (candidates && candidates.length) {
        for (let c = 0; c < candidates.length; c++) {
          const b = colliderBounds[candidates[c]];
          if (!b) continue;

          const sumR = radius + b.radius + skin;
          const dx = pos.x - b.center.x;
          const dz = pos.z - b.center.z;
          const d2 = dx * dx + dz * dz;

          if (d2 >= sumR * sumR) continue;

          const d = Math.sqrt(d2) || 1e-6;
          const push = sumR - d;

          const nx = dx / d;
          const nz = dz / d;

          pos.x += nx * push;
          pos.z += nz * push;

          const velDot = vel.x * nx + vel.z * nz;
          if (velDot < 0) {
            vel.x -= velDot * nx;
            vel.z -= velDot * nz;
          }

          pushed = true;
        }
      }

      if (avatarModelColliderOBBs && avatarModelColliderOBBs.length) {
        for (let i = 0; i < avatarModelColliderOBBs.length; i++) {
          const obb = avatarModelColliderOBBs[i];
          if (!obb) continue;
          if (ignoreObject && obb.object === ignoreObject) continue;

          const dxw = pos.x - obb.center.x;
          const dzw = pos.z - obb.center.z;

          const c = Math.cos(obb.yaw);
          const s = Math.sin(obb.yaw);

          const lx = dxw * c + dzw * s;
          const lz = -dxw * s + dzw * c;

          const cx = clamp(lx, -obb.halfX, obb.halfX);
          const cz = clamp(lz, -obb.halfZ, obb.halfZ);

          const dxl = lx - cx;
          const dzl = lz - cz;

          const d2 = dxl * dxl + dzl * dzl;
          const sumR = radius + skin;

          if (d2 >= sumR * sumR) continue;

          const d = Math.sqrt(d2) || 1e-6;
          const push = sumR - d;

          let nlx = dxl / d;
          let nlz = dzl / d;

          if (!Number.isFinite(nlx) || !Number.isFinite(nlz)) {
            const px = obb.halfX - Math.abs(lx);
            const pz = obb.halfZ - Math.abs(lz);
            if (px < pz) {
              nlx = lx >= 0 ? 1 : -1;
              nlz = 0;
            } else {
              nlx = 0;
              nlz = lz >= 0 ? 1 : -1;
            }
          }

          const nx = nlx * c - nlz * s;
          const nz = nlx * s + nlz * c;

          pos.x += nx * push;
          pos.z += nz * push;

          const velDot = vel.x * nx + vel.z * nz;
          if (velDot < 0) {
            vel.x -= velDot * nx;
            vel.z -= velDot * nz;
          }

          pushed = true;
        }
      }

      pos.x = clamp(pos.x, -limX, limX);
      pos.z = clamp(pos.z, -limZ, limZ);

      if (!pushed) break;
    }
  }



  function tickVehicle(dt) {
    const v = vehicleDriveState.vehicle;
    if (!vehicleDriveState.enabled || !v || !v.object || !v.meta) return;

    const prof = v.meta.profile || {};

    const maxSpeed = Math.max(0.1, prof.maxSpeed ?? 10.0);
    const maxReverse = Math.max(0.1, prof.maxReverse ?? 4.0);
    const accel = Math.max(0.1, prof.accel ?? 10.0);
    const brake = Math.max(0.1, prof.brake ?? 14.0);
    const coastDecel = Math.max(0.1, prof.coastDecel ?? 3.0);
    const turnRate = Math.max(0.1, prof.turnRate ?? 2.4);

    const radius = Math.max(0.35, (prof.radius ?? v.radius ?? 0.9));
    const minSteerSpeed = Math.max(0.0, prof.minSteerSpeed ?? 0.35);
    const steerResponse = Math.max(0.1, prof.steerResponse ?? 8.0);
    const steerReturn = Math.max(0.1, prof.steerReturn ?? 6.0);
    const lateralGrip = Math.max(0.0, prof.lateralGrip ?? 8.0);

    let forwardAmount = 0;
    let steerAmount = 0;

    const joyForward = -joystickState.valueY;
    const joySteer = joystickState.valueX;
    const joyMag = Math.min(1, Math.sqrt(joyForward * joyForward + joySteer * joySteer));

    if (joystickState.active && joyMag > 0) {
      forwardAmount = clamp(joyForward, -1, 1);
      steerAmount = clamp(joySteer, -1, 1);
    } else {
      forwardAmount = clamp(avatarState.moveZ, -1, 1);
      steerAmount = clamp(avatarState.moveX, -1, 1);
    }

    const targetSpeed = forwardAmount >= 0 ? forwardAmount * maxSpeed : forwardAmount * maxReverse;

    const speedNow = vehicleDriveState.speed;
    const speedDiff = targetSpeed - speedNow;

    if (Math.abs(forwardAmount) > 1e-3) {
      const rate = (Math.sign(targetSpeed) === Math.sign(speedNow) || speedNow === 0) ? accel : brake;
      const step = clamp(speedDiff, -rate * dt, rate * dt);
      vehicleDriveState.speed = speedNow + step;
    } else {
      const s = speedNow;
      const decelStep = coastDecel * dt;
      if (Math.abs(s) <= decelStep) vehicleDriveState.speed = 0.0;
      else vehicleDriveState.speed = s - Math.sign(s) * decelStep;
    }

    const speedAbs = Math.abs(vehicleDriveState.speed);

    const steerAngleNow = Number.isFinite(vehicleDriveState.steerAngle) ? vehicleDriveState.steerAngle : 0.0;

    const steerGate = clamp(
      (speedAbs - minSteerSpeed) / Math.max(1e-6, (maxSpeed - minSteerSpeed)),
      0,
      1
      );

    const speedRatio = clamp(speedAbs / maxSpeed, 0, 1);

  // More steering authority overall (low speed), still reduces at higher speeds.
    const maxSteerLow = clamp(turnRate * 0.30, 0.35, 0.95);
    const minSteerHigh = clamp(maxSteerLow * 0.45, 0.12, 0.40);
    const dynamicMaxSteer = maxSteerLow + (minSteerHigh - maxSteerLow) * Math.pow(speedRatio, 0.65);

    const steerTarget = (steerGate > 0 ? steerAmount : 0.0) * dynamicMaxSteer;

    let steerAngle = steerAngleNow;
    if (Math.abs(steerTarget) > 1e-4) {
      const diff = steerTarget - steerAngle;
      const step = clamp(diff, -steerResponse * dt, steerResponse * dt);
      steerAngle += step;
    } else {
      const step = steerReturn * dt;
      if (Math.abs(steerAngle) <= step) steerAngle = 0.0;
      else steerAngle -= Math.sign(steerAngle) * step;
    }

    steerAngle = clamp(steerAngle, -dynamicMaxSteer, dynamicMaxSteer);
    vehicleDriveState.steerAngle = steerAngle;

  // Bicycle yaw model: yawRate = v / R, R = max(minTurnRadius, wheelBase / tan(|delta|))
    if (steerGate > 0 && Math.abs(steerAngle) > 1e-4) {
      const wheelBase = Math.max(0.5, prof.wheelBase ?? (radius * 2.8));
      const minTurnRadius = Math.max(0.5, prof.minTurnRadius ?? 3.0);

      const steerAbsNow = Math.abs(steerAngle);
      const tanA = Math.tan(steerAbsNow);

      if (tanA > 1e-4 && Number.isFinite(tanA)) {
        let turnRadius = wheelBase / tanA;
        if (!Number.isFinite(turnRadius)) turnRadius = 1e6;
        turnRadius = Math.max(minTurnRadius, turnRadius);

        const steerSign = steerAngle > 0 ? 1 : -1;

      // No “high speed yaw kill”; slight scaling keeps response consistent across speeds.
        const responseScale = 0.9 + 0.35 * steerGate;

        const yawRate = (vehicleDriveState.speed / turnRadius) * responseScale;
        vehicleDriveState.yaw += (-steerSign) * yawRate * dt;
      }
    }

    v.object.rotation.y = vehicleDriveState.yaw - (v.meta.yawOffset || 0.0);

    const fx = Math.sin(vehicleDriveState.yaw);
    const fz = Math.cos(vehicleDriveState.yaw);

    vehicleTmpVel.set(fx * vehicleDriveState.speed, 0, fz * vehicleDriveState.speed);

    vehicleTmpMove.copy(vehicleTmpVel).multiplyScalar(dt);
    v.object.position.add(vehicleTmpMove);

    resolveVehicleXZCollisions(v.object.position, vehicleTmpVel, radius, v.object);

  // Lateral damping (simple grip)
    const long = vehicleTmpVel.x * fx + vehicleTmpVel.z * fz;
    const latX = vehicleTmpVel.x - fx * long;
    const latZ = vehicleTmpVel.z - fz * long;

    const latDamp = Math.exp(-lateralGrip * dt);
    vehicleTmpVel.x = fx * long + latX * latDamp;
    vehicleTmpVel.z = fz * long + latZ * latDamp;

  // Clamp longitudinal speed to profile
    const clampedSpeed = clamp(long, -maxReverse, maxSpeed);
    const deltaLong = clampedSpeed - long;
    if (Math.abs(deltaLong) > 1e-6) {
      vehicleTmpVel.x += fx * deltaLong;
      vehicleTmpVel.z += fz * deltaLong;
    }
    vehicleDriveState.speed = clampedSpeed;

  /**
   * Propeller spin driven by signed vehicle speed.
   * Supports per-vehicle tuning via profile:
   *  - propAxis: "x" | "y" | "z" (default "y")
   *  - propSpinIdle: rad/s at near-zero speed (default 8)
   *  - propSpinMax: rad/s at max speed (default 80)
   *  - propSpinMul: scalar multiplier (default 1)
   *  - propInvert: boolean to flip direction (default false)
   */
    if (v.parts && v.parts.propellers && v.parts.propellers.length) {
      const axisRaw = (prof.propAxis || "y");
      const axis = axisRaw === "x" || axisRaw === "y" || axisRaw === "z" ? axisRaw : "y";

      const idle = Math.max(0.0, prof.propSpinIdle ?? 8.0);
      const max = Math.max(idle, prof.propSpinMax ?? 80.0);
      const mul = Math.max(0.0, prof.propSpinMul ?? 1.0);
      const invert = !!prof.propInvert;

      const signed =
      Math.abs(vehicleDriveState.speed) > 1e-3
      ? Math.sign(vehicleDriveState.speed)
      : Math.abs(targetSpeed) > 1e-3
      ? Math.sign(targetSpeed)
      : Math.abs(forwardAmount) > 1e-3
      ? Math.sign(forwardAmount)
      : 1;

      const denom = vehicleDriveState.speed >= 0 ? maxSpeed : maxReverse;
      const n = clamp(Math.abs(vehicleDriveState.speed) / Math.max(1e-6, denom), 0, 1);

      let spinRate = idle + (max - idle) * n;
      spinRate *= signed;

      let dAng = spinRate * dt * mul;
      if (invert) dAng = -dAng;

      for (let i = 0; i < v.parts.propellers.length; i++) {
        const p = v.parts.propellers[i];
        if (!p) continue;
        if (axis === "x") p.rotation.x += dAng;
        else if (axis === "z") p.rotation.z += dAng;
        else p.rotation.y += dAng;
      }
    }

    v.object.updateWorldMatrix(true, true);

    vehicleSeatLocal.set(
      (v.meta.seatLocal && v.meta.seatLocal[0]) || 0,
      (v.meta.seatLocal && v.meta.seatLocal[1]) || 0.6,
      (v.meta.seatLocal && v.meta.seatLocal[2]) || 0
      );

    vehicleSeatWorld.copy(vehicleSeatLocal);
    v.object.localToWorld(vehicleSeatWorld);

    avatar.position.copy(vehicleSeatWorld);
    avatar.rotation.y = vehicleDriveState.yaw;

    updateVehicleOutlineFor(v);
    setVehiclePrompt(true, v);
  }







    /**
     * Updates prompt state based on avatar proximity (transaction state before entering).
     */
  function tickVehicleProximity() {
    if (!avatarState.enabled || vehicleDriveState.enabled) {
      if (vehiclePromptState.open) setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);
      return;
    }

    const near = findNearbyVehicle();
    if (!near) {
      if (vehiclePromptState.open) setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);
      return;
    }

    setVehiclePrompt(true, near);
    updateVehicleOutlineFor(near);
  }


  const boundCenter = new THREE.Vector3();
  const raycaster = new THREE.Raycaster();
  const segDir = new THREE.Vector3();
  const segDelta = new THREE.Vector3();
  const hitFrom = new THREE.Vector3();
  const tmpNormal = new THREE.Vector3();
  const tmpMatrix3 = new THREE.Matrix3();

  const obbTmpBox = new THREE.Box3();
  const obbTmpCenter = new THREE.Vector3();
  const obbTmpSize = new THREE.Vector3();
  const obbTmpQuat = new THREE.Quaternion();
  const obbTmpEuler = new THREE.Euler(0, 0, 0, "YXZ");



    // Decal helpers
  const tmpM = new THREE.Matrix4();
  const tmpQ = new THREE.Quaternion();
  const tmpS = new THREE.Vector3();
  const tmpP = new THREE.Vector3();
  const zAxis = new THREE.Vector3(0, 0, 1);

    // extra helpers for object sticking burst
  const tmpMatrix = new THREE.Matrix4();
  const tmpDir = new THREE.Vector3();


    // Forest builder ----------------------------------------------------------

  function rebuildForest() {
    if (!scene) return;

  // Remove old forest trees from scene and colliders
    for (const t of cones) {
      if (t && t.parent === scene) scene.remove(t);
    }
    cones.length = 0;

    colliderObjects = colliderObjects.filter((obj) => !obj.__isForestTree);

    if (!forestConeGeo) {
      forestConeGeo = new THREE.ConeGeometry(0.9, 3.3, 24, 1);
    }
    if (!forestConeMat) {
      forestConeMat = new THREE.MeshStandardMaterial({
        color: 0x2b7a2b,
        roughness: 1.0,
        metalness: 0.0
      });
    }

    const rng = makeSeededRandom((params.forestSeed * 1000003) | 0);

    const count = clamp(params.forestCount | 0, 0, 400);
    const maxR = clamp(params.forestRadius, 1.0, HALF_GROUND - 1.0);
    const minR = clamp(
      params.forestInnerRadius,
      0.0,
      Math.max(maxR - 1.0, 0.0)
      );
    const minS = Math.max(0.2, params.forestMinScale);
    const maxS = Math.max(minS, params.forestMaxScale);
    const jitter = clamp(params.forestJitter, 0.0, 3.0);

    for (let i = 0; i < count; i++) {
      const t = rng();
      const rBase = Math.sqrt(t);
      const r = minR + (maxR - minR) * rBase;

      let ang = rng() * Math.PI * 2.0;
      ang += (rng() - 0.5) * jitter * 0.4;

      let x = Math.cos(ang) * r;
      let z = Math.sin(ang) * r;

      x += (rng() - 0.5) * jitter;
      z += (rng() - 0.5) * jitter;

      const tree = new THREE.Mesh(forestConeGeo, forestConeMat);

      const scale = minS + (maxS - minS) * rng();
      tree.scale.set(scale, scale, scale);

      const y = 1.65 * scale;
      tree.position.set(x, y, z);

      tree.rotation.y = rng() * Math.PI * 2.0;
      tree.castShadow = true;
      tree.receiveShadow = true;
      tree.__isForestTree = true;

      scene.add(tree);
      cones.push(tree);
      colliderObjects.push(tree);
    }

    colliderBounds = buildColliderBounds(colliderObjects);
    rebuildAvatarCollisionGrid();
  }






    // Gust system -------------------------------------------------------------

  class Gust {
    constructor() {
      this.x = 0;
      this.z = 0;
      this.radius = 1;
      this.strength = 0;
      this.swirl = 0;
      this.updraft = 0;
      this.ttl = 0;
      this.life = 0;
    }
    reset(x, z, radius, strength, swirl, updraft, ttl) {
      this.x = x;
      this.z = z;
      this.radius = radius;
      this.strength = strength;
      this.swirl = swirl;
      this.updraft = updraft;
      this.ttl = ttl;
      this.life = ttl;
    }
    step(dt) {
      this.life = Math.max(0, this.life - dt);
    }
    get active() {
      return this.life > 0;
    }
    get fade() {
      if (this.ttl <= 1e-6) return 0;
      const t = this.life / this.ttl;
      return t * t;
    }
  }

  const GUST_MAX = 6;
  const gusts = Array.from({ length: GUST_MAX }, () => new Gust());
  let gustSpawnTimer = 0;

  const gustTmp = new THREE.Vector3();
  const gustPosRad = new Float32Array(GUST_MAX * 3);
  const gustParams = new Float32Array(GUST_MAX * 3);


  function spawnGusts(dt) {
    gustSpawnTimer -= dt;
    if (gustSpawnTimer > 0) return;

    const minI = clamp(params.gustMinInterval, 0.2, 20.0);
    const maxI = clamp(params.gustMaxInterval, minI + 0.1, 40.0);
    gustSpawnTimer = minI + Math.random() * (maxI - minI);

    if (!cones.length) return;
    const tpos = cones[(Math.random() * cones.length) | 0].position;
    const gx = tpos.x + (Math.random() * 2 - 1) * 2.2;
    const gz = tpos.z + (Math.random() * 2 - 1) * 2.2;

    const tornadoChance = clamp(params.gustTornadoChance, 0.0, 1.0);
    const isTornado = Math.random() < tornadoChance;

    const radius = isTornado ? (1.8 + Math.random() * 1.2) : (3.4 + Math.random() * 3.2);
    const strength =
    (isTornado ? (2.4 + Math.random() * 2.2) : (0.9 + Math.random() * 1.2)) *
    clamp(params.gustStrengthMul, 0.0, 4.0);
    const swirlSign = Math.random() < 0.5 ? -1 : 1;
    const swirl =
    swirlSign *
    (isTornado ? 4.4 : 2.2) *
    clamp(params.gustSwirlMul, 0.0, 4.0);
    const updraft =
    (isTornado ? (2.2 + Math.random() * 2.0) : (0.20 + Math.random() * 0.55)) *
    clamp(params.gustUpdraftMul, 0.0, 4.0);
    const ttl = isTornado ? (1.5 + Math.random() * 1.8) : (1.1 + Math.random() * 1.8);

      // find slot
    let slot = 0;
    for (let i = 0; i < gusts.length; i++) {
      if (!gusts[i].active) {
        slot = i;
        break;
      }
    }

    gusts[slot].reset(gx, gz, radius, strength, swirl, updraft, ttl);

    // audio whoosh tied to gust strength
    //playGustFx(strength);

  }


  function gustWindAt(x, z, heightAboveSnow, out) {
    out.set(0, 0, 0);
    for (let i = 0; i < gusts.length; i++) {
      const g = gusts[i];
      if (!g.active) continue;

      const dx = x - g.x;
      const dz = z - g.z;
      const r2 = dx * dx + dz * dz;
      const r = g.radius;
      if (r2 > r * r) continue;

      const rr = Math.max(1e-6, Math.sqrt(r2));
      const npx = dx / rr;
      const npz = dz / rr;

      const heightK = 1.0 / (1.0 + Math.max(0, heightAboveSnow) * 1.15);
      const radial = 1.0 - rr / r;
      const k = g.fade * g.strength * radial * radial * heightK;

      const tx = -npz;
      const tz = npx;

      out.x += tx * (g.swirl * k) + (-npx) * (0.18 * k);
      out.z += tz * (g.swirl * k) + (-npz) * (0.18 * k);
      out.y += g.updraft * k * (radial * radial);
    }
    return out;
  }

  function applyGustScour(baseWindX, baseWindZ) {
    const scourBase = clamp(params.gustScour, 0.0, 0.10);
    const redepBase = clamp(params.gustRedeposit, 0.0, 0.10);
    if (scourBase === 0 && redepBase === 0) return;

    for (let i = 0; i < gusts.length; i++) {
      const g = gusts[i];
      if (!g.active) continue;

      const fade = g.fade;
      const scour = -scourBase * fade;
      const redeposit = redepBase * fade;

        // scour around gust center, redeposit downwind
      depositHeightAtWorld(g.x, g.z, scour, 0, 0);
      depositHeightAtWorld(g.x, g.z, scour * 0.7, 0, 0);
      depositHeightAtWorld(g.x, g.z, redeposit, baseWindX, baseWindZ);
    }
  }

    // GUI / presets -----------------------------------------------------------

  let gui = null;
  const guiControllers = [];




  const presetState = {
    presetName: "",
    selected: "<none>"
  };
  let presetSelectCtrl = null;



    // JSON file presets (edit / extend this list)
  const FILE_PRESET_URLS = [
    "presets/snow-Hello.json",
    "presets/snow-Forrest.json",
    "presets/snow-Moist-1.json",
    "presets/snow-More-Snow.json",
    "presets/snow-Delicate.json",
    "presets/snow-heavy.json"
  ];

  function getBuiltinPresets() {
    return FILE_PRESET_URLS.map((url) => {
      const parts = url.split("/");
      const file = parts[parts.length - 1] || url;
      const withoutExt = file.replace(/\.json$/i, "");
      const spaced = withoutExt
      .replace(/^snow-/, "")
      .replace(/[-_]+/g, " ");
      const name = sanitizePresetName(spaced);
      return { name: name || withoutExt, url };
    });
  }



    // Drift deposition kernel -------------------------------------------------

  const KERNEL_RADIUS = 3;
  const KERNEL_SIGMA = 1.05;
  const driftKernel = [];

  (function buildKernel() {
    let sum = 0;
    for (let dz = -KERNEL_RADIUS; dz <= KERNEL_RADIUS; dz++) {
      for (let dx = -KERNEL_RADIUS; dx <= KERNEL_RADIUS; dx++) {
        const r2 = dx * dx + dz * dz;
        const w = Math.exp(-r2 / (2 * KERNEL_SIGMA * KERNEL_SIGMA));
        driftKernel.push({ dx, dz, w });
        sum += w;
      }
    }
    for (const k of driftKernel) k.w /= sum || 1;
  })();

    // -------------------------------------------------------------------------
    // Apply settings (clamps)
    // -------------------------------------------------------------------------

function applySettings(
  obj,
  { rebuild = false, updateGui = true, persist = true } = {}
  ) {
  if (!obj || typeof obj !== "object") return;

  persistBlocked = true;
  try {
    // Accept all primitive keys, even if they didn't exist in DEFAULTS yet
    for (const [k, v] of Object.entries(obj)) {
      const cur = params[k];
      const tCur = typeof cur;

      if (tCur === "number" && typeof v === "number" && Number.isFinite(v)) {
        params[k] = v;
      } else if (tCur === "boolean" && typeof v === "boolean") {
        params[k] = v;
      } else if (tCur === "string" && typeof v === "string") {
        params[k] = v;
      } else if (cur === undefined) {
        // New param that wasn’t in DEFAULTS yet – accept sane primitives
        if (typeof v === "number" && Number.isFinite(v)) {
          params[k] = v;
        } else if (typeof v === "boolean") {
          params[k] = v;
        } else if (typeof v === "string") {
          params[k] = v;
        }
      }
    }

    // --- clamps: same as before + extras for clouds / forest ---

    // core sim
    params.timeScale = clamp(params.timeScale, 0.05, 5.0);
    params.dtMax = clamp(params.dtMax, 0.005, 0.05);
    params.pixelRatio = clamp(params.pixelRatio, 0.5, 3.0);

    // wind
    params.windStrength = clamp(params.windStrength, 0.0, 3.0);
    params.windSpeed = clamp(params.windSpeed, 0.01, 1.0);

    // flakes
    params.fallSpeed = clamp(params.fallSpeed, 0.001, 10.5);
    params.fallJitter = clamp(params.fallJitter, 0.0, 0.9);
    params.flakeSize = clamp(params.flakeSize, 0.01, 10.0);
    params.flakeSizeJitter = clamp(params.flakeSizeJitter, 0.0, 0.9);

    // counts
    params.visualCount = clamp(params.visualCount | 0, 20000, 600000);
    params.settlerCount = clamp(params.settlerCount | 0, 1000, 30000);

    // drifts
    params.driftGrid = clamp(params.driftGrid | 0, 32, 256);
    params.driftMaxHeight = clamp(params.driftMaxHeight, 0.5, 8.0);

    params.coverBase = clamp(params.coverBase, 0.0, 0.30);
    params.coverMacroAmp = clamp(params.coverMacroAmp, 0.0, 0.30);
    params.coverMacroFreq = clamp(params.coverMacroFreq, 0.5, 6.0);
    params.coverMicroAmp = clamp(params.coverMicroAmp, 0.0, 0.20);
    params.coverMicroFreq = clamp(params.coverMicroFreq, 2.0, 16.0);

    params.driftDiffusion = clamp(params.driftDiffusion, 0.0, 0.25);
    params.driftAdvection = clamp(params.driftAdvection, 0.0, 0.30);

    params.groundDepositBudget = clamp(
      params.groundDepositBudget | 0,
      1,
      5000
      );
    params.depositUnit = clamp(params.depositUnit, 0.0, 0.01);

    // sticking / decals
    params.objectTestsPerFrame = clamp(
      params.objectTestsPerFrame | 0,
      0,
      5000
      );
    params.objectDeposit = clamp(params.objectDeposit, 0.0, 0.05);

    params.stuckMax = clamp(params.stuckMax | 0, 1000, 120000);
    params.decalSize = clamp(params.decalSize, 0.04, 0.80);

    params.obstacleShapeInterval = clamp(
      params.obstacleShapeInterval | 0,
      1,
      600
      );
    params.driftWriteInterval = clamp(
      params.driftWriteInterval | 0,
      1,
      120
      );
    params.normalUpdateInterval = clamp(
      params.normalUpdateInterval | 0,
      4,
      600
      );

    // gusts
    params.gustMinInterval = clamp(params.gustMinInterval, 0.1, 20.0);
    params.gustMaxInterval = clamp(
      params.gustMaxInterval,
      Math.max(params.gustMinInterval + 0.1, 0.2),
      40.0
      );
    params.gustTornadoChance = clamp(params.gustTornadoChance, 0.0, 1.0);
    params.gustStrengthMul = clamp(params.gustStrengthMul, 0.0, 4.0);
    params.gustSwirlMul = clamp(params.gustSwirlMul, 0.0, 4.0);
    params.gustUpdraftMul = clamp(params.gustUpdraftMul, 0.0, 4.0);
    params.gustScour = clamp(params.gustScour, 0.0, 0.10);
    params.gustRedeposit = clamp(params.gustRedeposit, 0.0, 0.10);

    // fog
    params.fogNear = clamp(params.fogNear, 0.1, 200.0);
    params.fogFar = clamp(params.fogFar, params.fogNear + 1.0, 400.0);

    // forest
    if (typeof params.forestCount === "number") {
      params.forestCount = clamp(params.forestCount | 0, 0, 400);
    }
    if (typeof params.forestRadius === "number") {
      params.forestRadius = clamp(
        params.forestRadius,
        1.0,
        HALF_GROUND - 1.0
        );
    }
    if (typeof params.forestInnerRadius === "number") {
      params.forestInnerRadius = clamp(
        params.forestInnerRadius,
        0.0,
        Math.max((params.forestRadius || 0) - 1.0, 0.0)
        );
    }
    if (typeof params.forestMinScale === "number") {
      params.forestMinScale = Math.max(0.2, params.forestMinScale);
    }
    if (typeof params.forestMaxScale === "number") {
      params.forestMaxScale = Math.max(
        params.forestMinScale || 0.2,
        params.forestMaxScale
        );
    }
    if (typeof params.forestJitter === "number") {
      params.forestJitter = clamp(params.forestJitter, 0.0, 3.0);
    }

    // clouds
    if (typeof params.cloudHeightBase === "number") {
      params.cloudHeightBase = clamp(params.cloudHeightBase, 0.0, 200.0);
    }
    if (typeof params.cloudHeightRange === "number") {
      params.cloudHeightRange = clamp(params.cloudHeightRange, 0.0, 80.0);
    }
    if (typeof params.cloudRadius === "number") {
      params.cloudRadius = clamp(params.cloudRadius, 5.0, 400.0);
    }
    if (typeof params.cloudSliceCount === "number") {
      params.cloudSliceCount = clamp(
        params.cloudSliceCount | 0,
        4,
        512
        );
    }
    if (typeof params.cloudSpeed === "number") {
      params.cloudSpeed = clamp(params.cloudSpeed, 0.0, 0.05);
    }
    if (typeof params.cloudDensity === "number") {
      params.cloudDensity = clamp(params.cloudDensity, 0.0, 2.0);
    }
    if (typeof params.cloudSoftness === "number") {
      params.cloudSoftness = clamp(params.cloudSoftness, 0.0, 1.0);
    }

    // apply fog + background color from params (fogNear, fogFar, fogColor)
    if (scene) {
      updateFogFromParams();
    }

    // On preset / import loads we pass rebuild: true
    if (rebuild) {
      rebuildWorld();
      // forest + clouds depend on params but are built separately
      rebuildForest();
      rebuildClouds();
    } else {
      // No full rebuild: at least push new cloud uniforms
      applyCloudParamsToUniforms();
    }

    if (updateGui && gui) {
      refreshGuiDisplays();
    }

    if (persist && !persistBlocked) {
      saveLastDebounced(params);
    }
  } finally {
    persistBlocked = false;
  }
}

    // -------------------------------------------------------------------------
    // Snow texture (point sprite)
    // -------------------------------------------------------------------------

function makeRadialTexture(size = 96) {
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const g = c.getContext("2d");

  const grad = g.createRadialGradient(
    size / 2, size / 2, 0,
    size / 2, size / 2, size / 2
    );
  grad.addColorStop(0.00, "rgba(255,255,255,1.00)");
  grad.addColorStop(0.42, "rgba(255,255,255,0.92)");
  grad.addColorStop(0.78, "rgba(255,255,255,0.22)");
  grad.addColorStop(1.00, "rgba(255,255,255,0.00)");

  g.clearRect(0, 0, size, size);
  g.fillStyle = grad;
  g.beginPath();
  g.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
  g.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.anisotropy = 4;
  tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
  return tex;
}

    // -------------------------------------------------------------------------
    // Drifts: heightfield
    // -------------------------------------------------------------------------

function gridIndex(i, j) {
  return j * DRIFT_STRIDE + i;
}

function initSnowCover() {
  if (!driftHeights) return;
  const base = Math.max(0, params.coverBase);
  const macroAmp = Math.max(0, params.coverMacroAmp);
  const macroFreq = Math.max(0.1, params.coverMacroFreq);
  const microAmp = Math.max(0, params.coverMicroAmp);
  const microFreq = Math.max(0.1, params.coverMicroFreq);
  const TAU = Math.PI * 2;

  for (let j = 0; j <= DRIFT_GRID; j++) {
    for (let i = 0; i <= DRIFT_GRID; i++) {
      const u = i / DRIFT_GRID;
      const v = j / DRIFT_GRID;

      const sin1 = Math.sin((u * macroFreq + 0.11) * TAU);
      const cos1 = Math.cos((v * macroFreq - 0.07) * TAU);
      const sin2 = Math.sin(((u * 0.75 + v * 0.90) * macroFreq + 0.31) * TAU);
      const macro = (sin1 + cos1 + sin2) * (1.0 / 3.0);

      const sin3 = Math.sin(((u * microFreq + v * (microFreq * 0.70)) + 0.19) * TAU);
      const cos2 = Math.cos(((v * microFreq - u * (microFreq * 0.80)) - 0.23) * TAU);
      const micro = (sin3 + cos2) * 0.5;

      const h = base + macro * macroAmp + micro * microAmp;
      driftHeights[gridIndex(i, j)] =
      clamp(h, 0, Math.max(0.5, params.driftMaxHeight));
    }
  }
}

function applyHeightsToGeometry() {
  if (!driftHeights || !driftPosArray) return;
  for (let v = 0; v < DRIFT_VERTS; v++) {
    driftPosArray[v * 3 + 1] = driftHeights[v];
  }
  driftPosAttr.needsUpdate = true;
}

function sampleSnowHeight(x, z) {
  if (!driftHeights) return 0;
  let u = (x + HALF_GROUND) / GROUND_SIZE;
  let v = (z + HALF_GROUND) / GROUND_SIZE;
  u = clamp(u, 0, 0.999999);
  v = clamp(v, 0, 0.999999);

  const fx = u * DRIFT_GRID;
  const fz = v * DRIFT_GRID;

  const i0 = fx | 0;
  const j0 = fz | 0;
  const i1 = Math.min(DRIFT_GRID, i0 + 1);
  const j1 = Math.min(DRIFT_GRID, j0 + 1);

  const tx = fx - i0;
  const tz = fz - j0;

  const h00 = driftHeights[gridIndex(i0, j0)];
  const h10 = driftHeights[gridIndex(i1, j0)];
  const h01 = driftHeights[gridIndex(i0, j1)];
  const h11 = driftHeights[gridIndex(i1, j1)];

  const hx0 = h00 + (h10 - h00) * tx;
  const hx1 = h01 + (h11 - h01) * tx;
  return hx0 + (hx1 - hx0) * tz;
}

function depositHeightAtWorld(x, z, amount, windX = 0, windZ = 0) {
  if (!driftHeights || amount === 0) return;

      // push deposits slightly downwind (turbulence bias)
  const drift = 0.35;
  const nx = x + windX * drift;
  const nz = z + windZ * drift;

  let u = (nx + HALF_GROUND) / GROUND_SIZE;
  let v = (nz + HALF_GROUND) / GROUND_SIZE;
  u = clamp(u, 0, 1);
  v = clamp(v, 0, 1);

  const ci = clamp((u * DRIFT_GRID) | 0, 0, DRIFT_GRID);
  const cj = clamp((v * DRIFT_GRID) | 0, 0, DRIFT_GRID);

  const maxH = Math.max(0.5, params.driftMaxHeight);
  const baseAmount = amount;

  for (const k of driftKernel) {
    const i = ci + k.dx;
    const j = cj + k.dz;
    if (i < 0 || i > DRIFT_GRID || j < 0 || j > DRIFT_GRID) continue;
    const idx = gridIndex(i, j);
    const h = driftHeights[idx];
    const shelter = clamp(1.0 - h / maxH, 0.1, 1.0);
    const delta = baseAmount * k.w * shelter;
    driftHeights[idx] = clamp(h + delta, 0, maxH);
  }
}

function evolveDrifts(windX, windZ) {
  if (!driftHeights || !driftHeightsTmp) return;

  const diff = clamp(params.driftDiffusion, 0.0, 0.25);
  const adv = clamp(params.driftAdvection, 0.0, 0.30);
  if (diff <= 0 && adv <= 0) return;

  const wx = clamp(windX, -1, 1);
  const wz = clamp(windZ, -1, 1);

  for (let j = 0; j <= DRIFT_GRID; j++) {
    const jb = j > 0 ? j - 1 : j;
    const jf = j < DRIFT_GRID ? j + 1 : j;
    for (let i = 0; i <= DRIFT_GRID; i++) {
      const ib = i > 0 ? i - 1 : i;
      const ifw = i < DRIFT_GRID ? i + 1 : i;

      const idx = gridIndex(i, j);
      const h = driftHeights[idx];

      const hL = driftHeights[gridIndex(ib, j)];
      const hR = driftHeights[gridIndex(ifw, j)];
      const hD = driftHeights[gridIndex(i, jb)];
      const hU = driftHeights[gridIndex(i, jf)];
      const avg = (hL + hR + hD + hU) * 0.25;

          // simple upwind sample
      const upI = clamp(i - Math.round(wx), 0, DRIFT_GRID);
      const upJ = clamp(j - Math.round(wz), 0, DRIFT_GRID);
      const upH = driftHeights[gridIndex(upI, upJ)];

      let nh = h + diff * (avg - h) + adv * (upH - h);
      nh = Math.max(0, nh * 0.99982);
      driftHeightsTmp[idx] = nh;
    }
  }

  const tmp = driftHeights;
  driftHeights = driftHeightsTmp;
  driftHeightsTmp = tmp;
}

function shapeDriftsAroundObstacles(windX, windZ) {
  if (!driftHeights || !colliderBounds.length) return;
  const wx = windX;
  const wz = windZ;
  const len = Math.sqrt(wx * wx + wz * wz);
  if (len < 1e-4) return;

  const nx = wx / len;
  const nz = wz / len;

  for (const cb of colliderBounds) {
    const ox = cb.center.x;
    const oz = cb.center.z;

    const scourX = ox - nx * (cb.radius * 1.20);
    const scourZ = oz - nz * (cb.radius * 1.20);

    const driftX = ox + nx * (cb.radius * 1.55);
    const driftZ = oz + nz * (cb.radius * 1.55);

    depositHeightAtWorld(scourX, scourZ, -0.0016, 0, 0);
    depositHeightAtWorld(driftX, driftZ, 0.0030, wx, wz);
  }
}

function buildSnowSurface() {
  if (snowSurface) {
    scene.remove(snowSurface);
    snowSurface.geometry.dispose();
    snowSurface.material.dispose();
  }

  DRIFT_GRID = clamp(params.driftGrid | 0, 32, 256);
  DRIFT_STRIDE = DRIFT_GRID + 1;
  DRIFT_VERTS = DRIFT_STRIDE * DRIFT_STRIDE;

  driftHeights = new Float32Array(DRIFT_VERTS);
  driftHeightsTmp = new Float32Array(DRIFT_VERTS);

  driftGeo = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE, DRIFT_GRID, DRIFT_GRID);
  driftGeo.rotateX(-Math.PI / 2);

  const mat = new THREE.MeshStandardMaterial({
    color: 0xf7faff,
    roughness: 0.995,
    metalness: 0.0,
    polygonOffset: true,
    polygonOffsetFactor: -2,
    polygonOffsetUnits: -2
  });

  snowSurface = new THREE.Mesh(driftGeo, mat);
  snowSurface.position.y = 0.02;
  snowSurface.receiveShadow = true;
  scene.add(snowSurface);

  driftPosAttr = driftGeo.attributes.position;
  driftPosArray = driftPosAttr.array;

  initSnowCover();
  applyHeightsToGeometry();
  driftGeo.computeVertexNormals();
  driftGeo.attributes.normal.needsUpdate = true;
}


    // Clouds Shaders
const CLOUD_VERTEX_SHADER = /* glsl */ `
  attribute float aLayer;
  uniform float uRadius;
  uniform float uHeightBase;
  uniform float uHeightRange;

  varying vec3 vWorldPos;
  varying float vLayer;

  void main() {
    vec3 pos = position;

    float layerT = aLayer;
    float ang = layerT * 6.2831853;
    float h = uHeightBase + (layerT - 0.5) * uHeightRange;

    pos.x += cos(ang) * uRadius * 0.4;
    pos.z += sin(ang) * uRadius * 0.4;
    pos.y = h;

    vec4 world = modelMatrix * vec4(pos, 1.0);
    vWorldPos = world.xyz;
    vLayer = layerT;

    gl_Position = projectionMatrix * viewMatrix * world;
  }
`;





const CLOUD_FRAGMENT_SHADER = /* glsl */ `
  precision highp float;

  varying vec3 vWorldPos;
  varying float vLayer;

  uniform float uTime;
  uniform float uRadius;
  uniform float uHeightBase;
  uniform float uHeightRange;
  uniform float uDensity;
  uniform float uSoftness;
  uniform float uSpeed;
  uniform vec3 uCloudColor;
  uniform vec3 uSkyColor;
  // NEW: overall opacity mul, driven from params.cloudOpacity
  uniform float uOpacity;

  float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
  }

  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
  }

  float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    float f = 1.0;
    for (int i = 0; i < 4; i++) {
      v += a * noise(p * f);
      f *= 2.0;
      a *= 0.5;
    }
    return v;
  }

  void main() {
    vec2 uv = vWorldPos.xz / uRadius;

    float scroll = uTime * uSpeed;
    vec2 p = uv * 1.2 + vec2(scroll, vLayer * 0.27);

    float n = fbm(p);

    // center of the cloud band in noise space
    float center = 1.0 - uDensity;

    // softness controls *band width* around that center
    float halfWidth = max(0.001, uSoftness * 0.5);

    // alpha = 0 below center - halfWidth
    // alpha = 1 above center + halfWidth
    // smooth fade in between → nice white → transparent gradient
    float alpha = smoothstep(center - halfWidth, center + halfWidth, n);

    float dist = length(vWorldPos.xz) / uRadius;
    float edgeFade = smoothstep(1.0, 0.6, dist);
    alpha *= edgeFade;

    float hFade = smoothstep(0.0, 0.4, vLayer) * smoothstep(1.0, 0.5, vLayer);
    alpha *= hFade;

    // NEW: use uniform instead of hard-coded 1.35
    alpha = clamp(alpha * uOpacity, 0.0, 1.0);

    if (alpha < 0.02) discard;

    // color is still a blend between sky and cloud colors
    vec3 rgb = mix(uSkyColor, uCloudColor, alpha);
    gl_FragColor = vec4(rgb, alpha);
  }
`;




function setupClouds() {
  if (!params.cloudEnabled) return;

  const sliceCount = Math.max(1, params.cloudSliceCount | 0);

  const geo = new THREE.PlaneGeometry(
    params.cloudRadius * 2.0,
    params.cloudRadius * 1.4,
    1,
    1
    );
  geo.rotateX(-Math.PI / 2);

  const layerAttr = new Float32Array(sliceCount);
  const denom = sliceCount > 1 ? sliceCount - 1 : 1;
  for (let i = 0; i < sliceCount; i++) {
    layerAttr[i] = i / denom;
  }
  geo.setAttribute(
    "aLayer",
    new THREE.InstancedBufferAttribute(layerAttr, 1)
    );

  cloudMaterial = new THREE.ShaderMaterial({
    vertexShader: CLOUD_VERTEX_SHADER,
    fragmentShader: CLOUD_FRAGMENT_SHADER,
    transparent: true,
    depthWrite: false,
    depthTest: true,
    side: THREE.DoubleSide
  });

  cloudMaterial.uniforms = {
    uTime: { value: 0 },
    uRadius: { value: params.cloudRadius },
    uHeightBase: { value: params.cloudHeightBase },
    uHeightRange: { value: params.cloudHeightRange },
    uDensity: { value: params.cloudDensity },
    uSoftness: { value: params.cloudSoftness },
    uSpeed: { value: params.cloudSpeed },
    // NEW: driven from params so presets/files carry it
    uCloudColor: { value: new THREE.Color(params.cloudColor || "#f5f7ff") },
    uSkyColor: { value: new THREE.Color(params.cloudSkyColor || "#0a1220") },
    uOpacity: { value: params.cloudOpacity }
  };

  cloudLayer = new THREE.InstancedMesh(geo, cloudMaterial, sliceCount);
  // draw clouds after snow points (2) and stuck decals (3)
  cloudLayer.renderOrder = 4;

  const dummy = new THREE.Object3D();
  for (let i = 0; i < sliceCount; i++) {
    dummy.position.set(0, 0, 0);
    dummy.rotation.set(0, 0, 0);
    dummy.scale.set(1, 1, 1);
    dummy.updateMatrix();
    cloudLayer.setMatrixAt(i, dummy.matrix);
  }

  cloudLayer.instanceMatrix.needsUpdate = true;
  scene.add(cloudLayer);
}






function updateClouds(dt) {
  if (!cloudMaterial) return;
  cloudMaterial.uniforms.uTime.value += dt;
}

function applyCloudParamsToUniforms() {
  if (!cloudMaterial) return;
  const u = cloudMaterial.uniforms;

  u.uRadius.value = params.cloudRadius;
  u.uHeightBase.value = params.cloudHeightBase;
  u.uHeightRange.value = params.cloudHeightRange;
  u.uDensity.value = params.cloudDensity;
  u.uSoftness.value = params.cloudSoftness;
  u.uSpeed.value = params.cloudSpeed;

  // NEW:
  if (params.cloudColor) {
    u.uCloudColor.value.set(params.cloudColor);
  }
  if (params.cloudSkyColor) {
    u.uSkyColor.value.set(params.cloudSkyColor);
  }
  u.uOpacity.value = params.cloudOpacity;
}


function disposeClouds() {
  if (cloudLayer) {
    scene.remove(cloudLayer);
    cloudLayer.geometry.dispose();
    cloudLayer.material.dispose();
    cloudLayer = null;
    cloudMaterial = null;
  }
}

function rebuildClouds() {
  disposeClouds();
  if (!params.cloudEnabled) return;
  setupClouds();
  applyCloudParamsToUniforms();
}









    // -------------------------------------------------------------------------
    // Visual flakes (GPU point sprites + gust uniforms)
    // -------------------------------------------------------------------------

function buildSnowField() {
  if (snowPoints) {
    scene.remove(snowPoints);
    snowGeo.dispose();
    snowMat.dispose();
  }

  const count = clamp(params.visualCount | 0, 20000, 600000);
  const pos = new Float32Array(count * 3);
  const seeds = new Float32Array(count);

  for (let i = 0; i < count; i++) {
    const p = i * 3;
    pos[p + 0] = (Math.random() * 2 - 1) * visualBounds.x;
    pos[p + 1] = visualBounds.yMin + Math.random() * (visualBounds.yMax - visualBounds.yMin);
    pos[p + 2] = (Math.random() * 2 - 1) * visualBounds.z;
    seeds[i] = Math.random();
  }

  snowGeo = new THREE.BufferGeometry();
  snowGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  snowGeo.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));

  snowMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    uniforms: {
      uTime: { value: 0 },
      uTex: { value: snowTex },
      uWind: { value: new THREE.Vector2(0, 0) },
      uBounds: { value: new THREE.Vector2(visualBounds.x, visualBounds.z) },
      uYTop: { value: visualBounds.yMax },
      uYBot: { value: visualBounds.yMin },
      uGroundY: { value: 0.06 },
      uFallSpeed: { value: params.fallSpeed },
      uFallJitter: { value: params.fallJitter },
      uFlakeSize: { value: params.flakeSize },
      uFlakeSizeJitter: { value: params.flakeSizeJitter },
      uGustPosRad: { value: gustPosRad },
      uGustParams: { value: gustParams }
    },
    vertexShader: `
          uniform float uTime;
          uniform vec2 uWind;
          uniform vec2 uBounds;
          uniform float uYTop;
          uniform float uYBot;
          uniform float uGroundY;

          uniform float uFallSpeed;
          uniform float uFallJitter;
          uniform float uFlakeSize;
          uniform float uFlakeSizeJitter;

          uniform float uGustPosRad[${GUST_MAX * 3}];
          uniform float uGustParams[${GUST_MAX * 3}];

          attribute float aSeed;

          varying float vAlpha;

          float wrapCoord(float x, float halfSpan) {
            float span = halfSpan * 2.0;
            return -halfSpan + mod(x + halfSpan + span * 1000.0, span);
          }

          float jitter01(float x) {
            return fract(sin(x) * 43758.5453123);
          }

          void main() {
            vec3 p = position;

            float spanY = (uYTop - uYBot);

            float jf = jitter01(aSeed * 91.7 + 3.1);
            float fallMul = mix(1.0 - uFallJitter, 1.0 + uFallJitter, jf);
            float speed = max(0.001, uFallSpeed) * fallMul;

            float phase = aSeed * 37.0;
            float y = uYTop - mod(uTime * speed + phase, spanY);

            float nearGround = clamp(1.0 - (y - uYBot) / 6.0, 0.0, 1.0);

            float flutter =
              sin(uTime * 1.15 + aSeed * 83.0) * 0.10 +
              sin(uTime * 1.85 + aSeed * 19.0) * 0.05;

            vec2 drift =
              uWind * (0.22 + 0.16 * sin(aSeed * 11.0)) +
              vec2(flutter * 0.18,
                   cos(uTime * 0.9 + aSeed * 41.0) * 0.03);

            // vec2 gustVec = vec2(0.0);
            // float lift = 0.0;

            // for (int gi = 0; gi < ${GUST_MAX}; gi++) {
            //   float gx = uGustPosRad[gi * 3 + 0];
            //   float gz = uGustPosRad[gi * 3 + 1];
            //   float gr = uGustPosRad[gi * 3 + 2];

            //   float gs  = uGustParams[gi * 3 + 0];
            //   float gsw = uGustParams[gi * 3 + 1];
            //   float gup = uGustParams[gi * 3 + 2];

            //   vec2 d = vec2(p.x - gx, p.z - gz);
            //   float r2 = dot(d, d);
            //   float rr = sqrt(max(r2, 1e-6));
            //   if (rr > gr) continue;

            //   float radial = 1.0 - rr / gr;
            //   float k = radial * radial * nearGround * gs;

            //   vec2 n = d / rr;
            //   vec2 t = vec2(-n.y, n.x);

            //   gustVec += t * (gsw * k) + (-n) * (0.12 * k);
            //   lift += gup * k * (radial * radial);
            // }

            // y += lift * 0.12;

            // float x = p.x + drift.x * uTime + gustVec.x;
            // float z = p.z + drift.y * uTime + gustVec.y;


            vec2 gustVec = vec2(0.0);
            float lift = 0.0;

            for (int gi = 0; gi < ${GUST_MAX}; gi++) {
              float gx = uGustPosRad[gi * 3 + 0];
              float gz = uGustPosRad[gi * 3 + 1];
              float gr = uGustPosRad[gi * 3 + 2];

              float gs  = uGustParams[gi * 3 + 0];
              float gsw = uGustParams[gi * 3 + 1];
              float gup = uGustParams[gi * 3 + 2];

              vec2 d = vec2(p.x - gx, p.z - gz);
              float r2 = dot(d, d);
              float rr = sqrt(max(r2, 1e-6));
              if (rr > gr) continue;

              float radial = 1.0 - rr / gr;
              float k = radial * radial * nearGround * gs;

              vec2 n = d / rr;
              vec2 t = vec2(-n.y, n.x);

              gustVec += t * (gsw * k) + (-n) * (0.12 * k);
              lift += gup * k * (radial * radial);
            }

            // --- clamp gust influence so craziness can't explode ---
            float gustLen = length(gustVec);
            float gustMax = 3.0;  // lower = calmer, higher = wilder
            if (gustLen > gustMax) {
              gustVec *= gustMax / max(gustLen, 1e-5);
            }
            lift = clamp(lift, -3.0, 3.0);
            // -------------------------------------------------------

            y += lift * 0.12;

            float x = p.x + drift.x * uTime + gustVec.x;
            float z = p.z + drift.y * uTime + gustVec.y;



            x = wrapCoord(x, uBounds.x);
            z = wrapCoord(z, uBounds.y);

            vec3 worldPos = vec3(x, y, z);
            vec4 mvPosition = modelViewMatrix * vec4(worldPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float js = jitter01(aSeed * 13.9 + 7.7);
            float sizeMul = mix(1.0 - uFlakeSizeJitter, 1.0 + uFlakeSizeJitter, js);
            float size = max(0.05, uFlakeSize) * sizeMul;

            gl_PointSize = size * (300.0 / -mvPosition.z);

            float groundFade = clamp((y - uGroundY) / 0.9, 0.0, 1.0);
            vAlpha = (mix(0.55, 0.95, fract(aSeed * 4.77))
                     * (0.65 + 0.35 * nearGround)) * groundFade;
          }
      `,

      fragmentShader: `
          uniform sampler2D uTex;
          varying float vAlpha;

          void main() {
            vec4 tex = texture2D(uTex, gl_PointCoord);
            // make each flake a bit less opaque, so background (clouds) can bleed through
            float a = tex.a * vAlpha * 0.65;
            if (a < 0.01) discard;
            gl_FragColor = vec4(1.0, 1.0, 1.0, a);
          }
        `
      });




snowPoints = new THREE.Points(snowGeo, snowMat);
snowPoints.frustumCulled = false;
// render before stuck decals & clouds (which will have higher renderOrder)
snowPoints.renderOrder = 2;
scene.add(snowPoints);
}


    // -------------------------------------------------------------------------
    // Decals (sticking snow)
    // -------------------------------------------------------------------------

function buildStuckSystem() {
  if (stuck) {
    scene.remove(stuck);
    stuck.geometry.dispose();
    stuck.material.dispose();
  }

  const max = Math.max(1000, params.stuckMax | 0);
  stuckGeo = new THREE.CircleGeometry(Math.max(0.05, params.decalSize), 20);
  stuckMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.97,
    metalness: 0.0,
    map: snowTex,
    transparent: true,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1,
    emissive: new THREE.Color(0x202020),
    emissiveIntensity: 0.65
  });

  stuck = new THREE.InstancedMesh(stuckGeo, stuckMat, max);
  stuck.frustumCulled = false;
  stuck.renderOrder = 3;
  scene.add(stuck);

  stuckCount = 0;
  stuckWrite = 0;
  stuck.count = 0;
  stuck.instanceMatrix.needsUpdate = true;
}

function addStuckSnow(point, normal) {
  if (!stuck) return;
  if (!Number.isFinite(point.x + point.y + point.z)) return;

  tmpNormal.set(0, 1, 0);
  if (normal && Number.isFinite(normal.x + normal.y + normal.z)) {
    tmpNormal.copy(normal);
  }

  const len = tmpNormal.length();
  if (len < 1e-6) tmpNormal.set(0, 1, 0);
  else tmpNormal.multiplyScalar(1.0 / len);

  const max = stuck.instanceMatrix.count;
  const idx = stuckWrite % max;

  const up01 = clamp((tmpNormal.y + 1.0) * 0.5, 0.0, 1.0);

  const lift = 0.008 + Math.random() * 0.012;
  tmpP.copy(point).addScaledVector(tmpNormal, lift);

  const baseSize = Math.max(0.05, params.decalSize);
  const slopeMul = 0.25 + 0.75 * up01;
  const base = baseSize * (0.55 + Math.random() * 1.05) * slopeMul;

  const anis = 0.70 + Math.random() * 0.85;
  const steep = 1.0 - up01;
  const sx = base * (1.0 - 0.15 * steep);
  const sy = base * anis * (1.0 + 0.35 * steep);
  tmpS.set(sx, sy, 1);

  tmpQ.setFromUnitVectors(zAxis, tmpNormal);
  tmpQ.multiply(new THREE.Quaternion().setFromAxisAngle(tmpNormal, Math.random() * Math.PI * 2));

  tmpM.compose(tmpP, tmpQ, tmpS);
  stuck.setMatrixAt(idx, tmpM);

  stuckWrite++;
  stuckCount = Math.min(stuckCount + 1, max);
  stuck.count = stuckCount;
  stuck.instanceMatrix.needsUpdate = true;
}

    // -------------------------------------------------------------------------
    // Settlers (CPU flakes building drifts + decals)
    // -------------------------------------------------------------------------

function buildSettlers() {
  SETTLER_COUNT = clamp(params.settlerCount | 0, 1000, 300000);
  settlerPos = new Float32Array(SETTLER_COUNT * 3);
  settlerPrev = new Float32Array(SETTLER_COUNT * 3);
  settlerVel = new Float32Array(SETTLER_COUNT * 3);
  for (let i = 0; i < SETTLER_COUNT; i++) respawnSettler(i);
    depositTokens = 0;
}

function respawnSettler(i) {
  const p = i * 3;
  const x = (Math.random() * 2 - 1) * settleBounds.x;
  const y = settleBounds.yMax * (0.72 + Math.random() * 0.28);
  const z = (Math.random() * 2 - 1) * settleBounds.z;

  settlerPos[p + 0] = x;
  settlerPos[p + 1] = y;
  settlerPos[p + 2] = z;

  settlerPrev[p + 0] = x;
  settlerPrev[p + 1] = y;
  settlerPrev[p + 2] = z;

  settlerVel[p + 0] = (Math.random() * 2 - 1) * 0.02;
  settlerVel[p + 1] = -(0.35 + Math.random() * 0.35);
  settlerVel[p + 2] = (Math.random() * 2 - 1) * 0.02;
}







/**
 * Builds simple sphere bounds for collision broadphase.
 * - Meshes: uses geometry.boundingSphere (fast).
 * - Non-mesh roots (e.g., GLTF instance roots): uses Box3.setFromObject once (built-time only).
 * - Forest cone trees: uses cone base radius in XZ to avoid oversized bounding-sphere radii.
 */
function buildColliderBounds(objs) {
  const out = [];

  const box = new THREE.Box3();
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();

  for (const obj of objs) {
    if (!obj) continue;

    obj.updateWorldMatrix(true, false);

    if (obj.isMesh && obj.geometry) {
      if (!obj.geometry.boundingSphere) obj.geometry.computeBoundingSphere();
      const bs = obj.geometry.boundingSphere;
      if (!bs) continue;

      boundCenter.copy(bs.center);
      obj.localToWorld(boundCenter);

      tmpS.set(1, 1, 1);
      obj.getWorldScale(tmpS);

      const sx = Math.abs(tmpS.x);
      const sy = Math.abs(tmpS.y);
      const sz = Math.abs(tmpS.z);

      const maxS = Math.max(sx, sy, sz);
      const maxXZ = Math.max(sx, sz);

      let radius;

      if (
        obj.__isForestTree &&
        obj.geometry &&
        obj.geometry.parameters &&
        Number.isFinite(obj.geometry.parameters.radius)
        ) {
        radius = obj.geometry.parameters.radius * maxXZ;
    } else {
      radius = bs.radius * (Number.isFinite(maxS) ? maxS : 1);
    }

    out.push({
      obj,
      center: boundCenter.clone(),
      radius: Number.isFinite(radius) ? radius : bs.radius
    });

    continue;
  }

  box.setFromObject(obj);
  if (!Number.isFinite(box.min.x) || !Number.isFinite(box.max.x)) continue;

  box.getCenter(center);
  box.getSize(size);

  const radius = 0.5 * Math.sqrt(
    size.x * size.x +
    size.y * size.y +
    size.z * size.z
    );

  out.push({
    obj,
    center: center.clone(),
    radius: Number.isFinite(radius) ? radius : 0.0
  });
}

return out;
}





const gustVec = new THREE.Vector3();

function updateSettlers(dt, baseWindX, baseWindZ) {
  if (!settlerPos || dt <= 0) return;

  depositTokens += params.groundDepositBudget * dt;
  let depositsRemaining = Math.max(0, Math.floor(depositTokens));
  if (depositsRemaining > 0) {
    depositTokens -= depositsRemaining;
  }

  const depositUnit = params.depositUnit;
  const objectDepositAmount = params.objectDeposit;
  const maxObjectTests = clamp(params.objectTestsPerFrame | 0, 0, 20000);
  let objectTests = 0;

  const gravity = 1.5;

  for (let i = 0; i < SETTLER_COUNT; i++) {
    const p = i * 3;

    const px = settlerPos[p + 0];
    const py = settlerPos[p + 1];
    const pz = settlerPos[p + 2];

    let vx = settlerVel[p + 0];
    let vy = settlerVel[p + 1];
    let vz = settlerVel[p + 2];

    settlerPrev[p + 0] = px;
    settlerPrev[p + 1] = py;
    settlerPrev[p + 2] = pz;

        // base wobble
    vx += (Math.random() * 2 - 1) * 0.25 * dt;
    vz += (Math.random() * 2 - 1) * 0.25 * dt;

        // global wind
    vx += baseWindX * dt * 0.5;
    vz += baseWindZ * dt * 0.5;

        // gust field (local turbulence + updraft)
    const snowY = sampleSnowHeight(px, pz);
    gustWindAt(px, pz, py - snowY, gustVec);
    vx += gustVec.x * dt;
    vy += gustVec.y * dt;
    vz += gustVec.z * dt;

    vy -= gravity * dt;

    let nx = px + vx * dt;
    let ny = py + vy * dt;
    let nz = pz + vz * dt;

        // wrap in XZ
    if (nx < -settleBounds.x) nx += settleBounds.x * 2;
    if (nx > settleBounds.x) nx -= settleBounds.x * 2;
    if (nz < -settleBounds.z) nz += settleBounds.z * 2;
    if (nz > settleBounds.z) nz -= settleBounds.z * 2;

    const groundY = sampleSnowHeight(nx, nz);

        // Hit ground -> deposit and respawn
    if (ny <= groundY + 0.02) {
      if (depositsRemaining > 0 && depositUnit > 0) {
        depositHeightAtWorld(nx, nz, depositUnit, baseWindX, baseWindZ);
        depositsRemaining--;
      }
      respawnSettler(i);
      continue;
    }

    settlerPos[p + 0] = nx;
    settlerPos[p + 1] = ny;
    settlerPos[p + 2] = nz;

    settlerVel[p + 0] = vx;
    settlerVel[p + 1] = vy;
    settlerVel[p + 2] = vz;




    // Object collisions (trees, rocks, cube)
    if (!colliderBounds.length || objectTests >= maxObjectTests) continue;

    const prevX = settlerPrev[p + 0];
    const prevY = settlerPrev[p + 1];
    const prevZ = settlerPrev[p + 2];

    // segment from previous to current position
    segDelta.set(nx - prevX, ny - prevY, nz - prevZ);
    const segLen = segDelta.length();
    if (segLen < 1e-4) continue;
    segDir.copy(segDelta).multiplyScalar(1.0 / segLen);

    hitFrom.set(prevX, prevY, prevZ);
    raycaster.set(hitFrom, segDir);
    raycaster.far = segLen;

    let hitSomething = false;

    for (const cb of colliderBounds) {
      if (objectTests >= maxObjectTests) break;

      // looser bounding-sphere cull so more flakes can hit
      const dx = cb.center.x - nx;
      const dy = cb.center.y - ny;
      const dz = cb.center.z - nz;
      const dist2 = dx * dx + dy * dy + dz * dz;
      const extraRadius = 1.5;
      const r = cb.radius + extraRadius;
      if (dist2 > r * r) continue;

      const intersections = raycaster.intersectObject(cb.obj, false);
      objectTests++;
      if (!intersections.length) continue;

      const hit = intersections[0];

      tmpNormal.set(0, 1, 0);
      if (hit.face) {
        tmpNormal.copy(hit.face.normal);
        tmpMatrix3.getNormalMatrix(hit.object.matrixWorld);
        tmpNormal.applyMatrix3(tmpMatrix3).normalize();
      }

      // more sticking: many decals per hit, scaled by objectDeposit
      const baseBurst = Math.floor(objectDepositAmount * 900); // 0.02 -> ~18
      const burst = clamp(baseBurst, 6, 40);

      for (let b = 0; b < burst; b++) {
        // jitter along normal
        const jitterN = (Math.random() - 0.5) * 0.05;

        // small tangent jitter so they spread over the surface
        const jitterT = 0.08;
        tmpP.copy(hit.point);
        tmpP.addScaledVector(tmpNormal, jitterN);

        tmpMatrix.makeRotationAxis(tmpNormal, Math.random() * Math.PI * 2.0);
        tmpDir.set(1, 0, 0).applyMatrix4(tmpMatrix);
        tmpP.addScaledVector(tmpDir, (Math.random() - 0.5) * jitterT);

        addStuckSnow(tmpP, tmpNormal);
      }

      if (objectDepositAmount > 0 && depositsRemaining > 0) {
        depositHeightAtWorld(
          hit.point.x,
          hit.point.z,
          objectDepositAmount,
          baseWindX,
          baseWindZ
          );
        depositsRemaining--;
      }

      respawnSettler(i);
      hitSomething = true;
      break;
    }

    if (hitSomething) continue;


  }


      depositTokens += depositsRemaining; // put back unused
    }


    // -------------------------------------------------------------------------
    // Camera idle auto-rotate (desktop only, not in XR)
    // -------------------------------------------------------------------------
    const AUTO_ROTATE_IDLE_SECONDS = 1.5;   // how long to wait
    const AUTO_ROTATE_SPEED = 0.35;        // OrbitControls autoRotateSpeed
    let lastInteractionTime = performance.now() * 0.001; // seconds
    let autoRotateEnabled = true;

    function markUserInteraction() {
      lastInteractionTime = performance.now() * 0.001;
      if (controls) {
        // disable auto-rotate immediately when the user touches the controls
        controls.autoRotate = false;
      }
    }


    // -------------------------------------------------------------------------
    // Scene / world setup
    // -------------------------------------------------------------------------
    function setupScene() {
      const container = document.getElementById("app");

      scene = new THREE.Scene();
      updateFogFromParams();

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        params.fogFar
        );
      camera.position.set(10, 7, 12);


      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.xr.enabled = true; // WebXR ON

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, params.pixelRatio));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      // temp to debug vehicles
      installVehicleDebugBridge(renderer.domElement);




      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 0.3;
      controls.maxDistance = 30;
      controls.target.set(0, 0.5, 0);

      // If your ground is at y = 0:
      const groundY = 0;
      const margin = 0.2; // “always slightly above”

      // Keep the orbit in the upper hemisphere (above the ground)
      controls.maxPolarAngle = Math.PI / 2 - 0.001; // never go below horizon

      // Optional: keep the orbit from going perfectly top-down / perfectly flat
      controls.minPolarAngle = 0.05;

      // Optional: keep target a bit above the surface (helps a lot)
      // controls.target.y = groundY + margin;

      // Auto-rotate is controlled per-frame based on idle time
      controls.autoRotate = false;
      controls.autoRotateSpeed = AUTO_ROTATE_SPEED;

      // Any pointer/touch/wheel interaction on the canvas resets idle timer
      const orbitInteractionEvents = [
        "pointerdown",
        "pointermove",
        "wheel",
        "touchstart",
        "touchmove"
      ];

      for (const ev of orbitInteractionEvents) {
        renderer.domElement.addEventListener(ev, markUserInteraction, {
          passive: true
        });
      }

      controls.update();





      // WebXR “Enter VR” button (Quest 3 etc.)
      const sessionInit = {
        optionalFeatures: ["local-floor", "bounded-floor"]
      };
      const vrButton = VRButton.createButton(renderer, sessionInit);
      document.body.appendChild(vrButton);

      // Disable desktop OrbitControls while in XR so they don't fight head pose
      renderer.xr.addEventListener("sessionstart", () => {
        if (controls) controls.enabled = false;
      });
      renderer.xr.addEventListener("sessionend", () => {
        if (controls) controls.enabled = true;
      });

      // Lights
      scene.add(new THREE.HemisphereLight(0xdce7ff, 0x0b0f18, 1));

      const dir = new THREE.DirectionalLight(0xffffff, 1.35);
      dir.position.set(8, 14, 6);
      dir.castShadow = true;
      dir.shadow.mapSize.set(2048, 2048);
      dir.shadow.camera.left = -26;
      dir.shadow.camera.right = 26;
      dir.shadow.camera.top = 26;
      dir.shadow.camera.bottom = -26;
      dir.shadow.camera.near = 0.1;
      dir.shadow.camera.far = 120;
      scene.add(dir);

      // Ground
      const groundMat = new THREE.MeshStandardMaterial({
        color: 0x0f1726,
        roughness: 1.0,
        metalness: 0.0
      });
      ground = new THREE.Mesh(
        new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE),
        groundMat
        );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // Axes helper at origin
      const axes = new THREE.AxesHelper(5);
      //scene.add(axes);


      // Cube centered at origin (sitting on ground)
      const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
      const cubeMat = new THREE.MeshStandardMaterial({
        color: 0x4e9cff,
        roughness: 0.4,
        metalness: 0.2
      });
      cube = new THREE.Mesh(cubeGeo, cubeMat);
      cube.position.set(0, 0.5, 0);
      cube.castShadow = true;
      //scene.add(cube);

      // Rocks
      const rockGeo = new THREE.IcosahedronGeometry(1.1, 0);
      const rockMat = new THREE.MeshStandardMaterial({
        color: 0x2b3442,
        roughness: 1.0
      });

      const rockPos = [
        [-9, 1.0,  6],
        [-7, 0.8, -8],
        [ 8, 1.0, -6]
      ];

      for (let i = 0; i < rockPos.length; i++) {
        const [x, y, z] = rockPos[i];
        const r = new THREE.Mesh(rockGeo, rockMat);
        r.position.set(x, y, z);
        r.scale.setScalar(1.0 + i * 0.25);
        r.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
        r.castShadow = true;
        r.receiveShadow = true;
        scene.add(r);
        rocks.push(r);
      }

      // Base colliders: rocks + cube, forest trees added in rebuildForest()
      colliderObjects = [...rocks, cube];

      // Build forest according to params (fills cones[] and colliderObjects)
      rebuildForest();


      //loadModel1();
      //loadAllModels();

      setupClouds();

      initAudio();

    }


    function rebuildWorld() {
      buildSnowSurface();
      buildSnowField();
      buildStuckSystem();
      buildSettlers();
      colliderBounds = buildColliderBounds(colliderObjects);
      rebuildAvatarCollisionGrid();
    }


    // -------------------------------------------------------------------------
    // GUI (with gust controls + preset dropdown)
    // -------------------------------------------------------------------------

    function trackController(ctrl, { rebuild = false, instant = true } = {}) {
      guiControllers.push(ctrl);
      const needsFinish = typeof ctrl.onFinishChange === "function";

      if (needsFinish && !instant) {
        ctrl.onChange(() => {
          saveLastDebounced(params);
        });
        ctrl.onFinishChange(() => {
          if (rebuild) rebuildWorld();
          saveLastDebounced(params);
        });
      } else {
        ctrl.onChange(() => {
          if (rebuild) rebuildWorld();
          saveLastDebounced(params);
        });
      }
      return ctrl;
    }

    function refreshGuiDisplays() {
      for (const c of guiControllers) {
        c.updateDisplay();
      }
    }

    async function refreshPresetList() {
      try {
        const builtin = getBuiltinPresets();
        const builtinNames = builtin.map((p) => p.name);

        const savedNames = await idbListPresetNames();

        const seen = new Set();
        const mergedNames = [];

        function pushName(raw) {
          const key = sanitizePresetName(raw);
          if (!key || key === "<none>") return;
          if (seen.has(key)) return;
          seen.add(key);
          mergedNames.push(raw);
        }

        for (const n of builtinNames) pushName(n);
          for (const n of savedNames) pushName(n);

            const names = mergedNames;
          const opts = names.length ? names : ["<none>"];

          presetSelectCtrl.options(opts);

          if (!names.includes(presetState.selected)) {
            presetState.selected = names[0] || "<none>";
          }

          presetSelectCtrl.updateDisplay();
        } catch (e) {
          console.error("[snow] refresh presets failed", e);
        }
      }



      async function savePreset() {
        const name = sanitizePresetName(presetState.presetName || `preset-${nowStamp()}`);
        if (!name) return;
        presetState.presetName = name;
        const settings = safeCloneSettings(params);
        try {
          await idbPutPreset(name, settings);
          presetState.selected = name;
          await refreshPresetList();
          saveLastDebounced(params);
        } catch (e) {
          console.error("[snow] preset save failed", e);
        }
      }



      async function loadPreset() {
        const selectedRaw = presetState.selected;
        const key = sanitizePresetName(selectedRaw);
        if (!key || key === "<none>") return;

        const builtin = getBuiltinPresets().find(
          (p) => sanitizePresetName(p.name) === key
          );

        try {
          if (builtin) {
            const response = await fetch(builtin.url, {
              cache: "no-store"
            });

            if (!response.ok) {
              console.warn(
                "[snow] builtin preset fetch failed:",
                builtin.url,
                response.status,
                response.statusText
                );
              return;
            }

            const json = await response.json();

            const srcSettings =
            json &&
            typeof json === "object" &&
            json.settings &&
            typeof json.settings === "object"
            ? json.settings
            : json;

            if (!srcSettings || typeof srcSettings !== "object") {
              console.warn("[snow] builtin preset JSON has no settings object");
              return;
            }

            const merged = Object.assign({}, DEFAULTS, srcSettings);

            applySettings(merged, {
              rebuild: true,
              updateGui: true,
              persist: true
            });

            presetState.presetName = builtin.name;
            return;
          }

          const row = await idbGetPreset(key);
          if (!row || !row.settings) {
            console.warn("[snow] preset not found:", key);
            return;
          }

          applySettings(row.settings, {
            rebuild: true,
            updateGui: true,
            persist: true
          });
          presetState.presetName = key;
        } catch (e) {
          console.error("[snow] preset load failed", e);
        }
      }



      async function deletePreset() {
        const name = sanitizePresetName(presetState.selected);
        if (!name || name === "<none>") return;
        try {
          await idbDeletePreset(name);
          presetState.selected = "<none>";
          await refreshPresetList();
        } catch (e) {
          console.error("[snow] preset delete failed", e);
        }
      }

      function exportSettings() {
        const hasSelection =
        presetState.selected && presetState.selected !== "<none>";

        const baseName = hasSelection
        ? presetState.selected
        : (presetState.presetName || `preset-${nowStamp()}`);

        const name = sanitizePresetName(baseName);

        const payload = {
          v: 1,
          kind: "snow-preset",
          exportedAt: Date.now(),
          name,
          settings: safeCloneSettings(params)
        };

        const safeName = name
        ? name.replace(/\s+/g, "-")
        : `preset-${nowStamp()}`;

        const filename = `snow-${safeName}.json`;
        downloadJson(payload, filename);
      }

      function importSettings() {
        const input = ensureImportInput();

        input.onchange = async () => {
          const file = input.files && input.files[0];
          input.value = "";
          if (!file) return;

          try {
            const text = await file.text();
            const json = JSON.parse(text);

            if (!json || typeof json !== "object") {
              throw new Error("Invalid JSON root");
            }

          // Accept both:
          //   { v: 1, kind, name, settings: { ... } }
          //   { ...paramsDirectly }
            const srcSettings =
            json.settings && typeof json.settings === "object"
            ? json.settings
            : json;

            if (!srcSettings || typeof srcSettings !== "object") {
              throw new Error("No settings object found");
            }

          // Merge onto DEFAULTS so missing keys get sane values
            const merged = { ...DEFAULTS, ...srcSettings };

            applySettings(merged, {
              rebuild: true,
              updateGui: true,
              persist: true
            });

          // Update preset name in GUI if present in file
            let importedName = null;
            if (typeof json.name === "string" && json.name.trim()) {
              importedName = sanitizePresetName(json.name);
            } else if (
              typeof json.presetName === "string" &&
              json.presetName.trim()
              ) {
              importedName = sanitizePresetName(json.presetName);
            }

            if (importedName) {
              presetState.presetName = importedName;
              presetState.selected = importedName;
              if (presetSelectCtrl) {
                await refreshPresetList();
              }
            }
          } catch (e) {
            console.error("[snow] import failed", e);
          }
        };

        input.click();
      }




      function setupGui() {
        gui = new GUI({ width: 380 });

        trackController(gui.add(params, "paused").name("Paused"), { instant: true });
        trackController(gui.add(params, "debug").name("Debug logs"), { instant: true });

        const sim = gui.addFolder("Simulation");
        trackController(sim.add(params, "timeScale", 0.05, 2.0, 0.01).name("Time scale"));
        trackController(sim.add(params, "dtMax", 0.008, 0.050, 0.001).name("dt max (clamp)"));
        trackController(sim.add(params, "pixelRatio", 0.5, 2.5, 0.01).name("Pixel ratio"), {
          rebuild: false
        });

      //sim.open();

        const wind = gui.addFolder("Wind");
        trackController(wind.add(params, "windStrength", 0.0, 2.0, 0.01).name("Strength"));
        trackController(wind.add(params, "windSpeed", 0.0, 5, 0.01).name("Speed"));
        //wind.open();

        const forest = gui.addFolder("Forest");

        const forestCountCtrl = forest
        .add(params, "forestCount", 0, 2000, 1)
        .name("Tree count");
        const forestRadiusCtrl = forest
        .add(params, "forestRadius", 2.0, 150.0, 0.5)
        .name("Radius");
        const forestInnerCtrl = forest
        .add(params, "forestInnerRadius", 0.0, 16.0, 0.5)
        .name("Inner radius");
        const forestMinScaleCtrl = forest
        .add(params, "forestMinScale", 0.3, 2.5, 0.05)
        .name("Min scale");
        const forestMaxScaleCtrl = forest
        .add(params, "forestMaxScale", 0.3, 3.0, 0.05)
        .name("Max scale");
        const forestSeedCtrl = forest
        .add(params, "forestSeed", 0, 9999, 1)
        .name("Seed");
        const forestJitterCtrl = forest
        .add(params, "forestJitter", 0.0, 2.0, 0.05)
        .name("Randomness");

        const forestCtrls = [
          forestCountCtrl,
          forestRadiusCtrl,
          forestInnerCtrl,
          forestMinScaleCtrl,
          forestMaxScaleCtrl,
          forestSeedCtrl,
          forestJitterCtrl
        ];

        forestCtrls.forEach((ctrl) => {
          trackController(ctrl, { rebuild: false, instant: true });
          if (typeof ctrl.onFinishChange === "function") {
            ctrl.onFinishChange(() => {
              applySettings(params, { rebuild: false, updateGui: false });
              rebuildForest();
              saveLastDebounced(params);
            });
          }
        });

        forest
        .add(
        {
          rebuildForest: () => {
            applySettings(params, { rebuild: false, updateGui: false });
            rebuildForest();
            saveLastDebounced(params);
          }
        },
        "rebuildForest"
        )
        .name("Rebuild forest");

        //wind.open();

        const fogFolder = gui.addFolder("Fog");
        const fogUpdate = () => {
          updateFogFromParams();
          saveLastDebounced(params);
        };

        const fogNearCtrl = fogFolder
        .add(params, "fogNear", 0.1, 200.0, 0.5)
        .name("Near");
        const fogFarCtrl = fogFolder
        .add(params, "fogFar", 1.0, 400.0, 0.5)
        .name("Far");
        const fogColorCtrl = fogFolder
        .addColor(params, "fogColor")
        .name("Color");

        fogNearCtrl.onChange(fogUpdate);
        fogFarCtrl.onChange(fogUpdate);
        fogColorCtrl.onChange(fogUpdate);
        //fogFolder.open();

        const gustFolder = gui.addFolder("Gusts");



        trackController(
          gustFolder.add(params, "gustMinInterval", 0.2, 6.0, 0.1).name("Min interval")
          );
        trackController(
          gustFolder.add(params, "gustMaxInterval", 0.4, 12.0, 0.1).name("Max interval")
          );
        trackController(
          gustFolder.add(params, "gustTornadoChance", 0.0, 0.6, 0.01).name("Tornado chance")
          );
        trackController(
          gustFolder.add(params, "gustStrengthMul", 0.3, 2.0, 0.01).name("Strength mul")
          );
        trackController(
          gustFolder.add(params, "gustSwirlMul", 0.3, 2.0, 0.01).name("Swirl mul")
          );
        trackController(
          gustFolder.add(params, "gustUpdraftMul", 0.0, 2.0, 0.01).name("Updraft mul")
          );
        trackController(
          gustFolder.add(params, "gustScour", 0.0, 0.03, 0.0005).name("Scour")
          );
        trackController(
          gustFolder.add(params, "gustRedeposit", 0.0, 0.03, 0.0005).name("Redeposit")
          );
      //gustFolder.open();



        const cloudFolder = gui.addFolder("Clouds");

        cloudFolder
        .add(params, "cloudEnabled")
        .name("Enabled")
        .onChange((v) => {
          params.cloudEnabled = !!v;

          if (!params.cloudEnabled) {
            if (cloudLayer) cloudLayer.visible = false;
          } else {
            if (!cloudLayer) {
              rebuildClouds();
            } else {
              cloudLayer.visible = true;
              applyCloudParamsToUniforms();
            }
          }
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudHeightBase", 0.0, 100.0, 0.5)
        .name("Base height")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudHeightRange", 0.0, 25.0, 0.5)
        .name("Height range")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudRadius", 1.0, 300.0, 1.0)
        .name("Radius")
        .onChange(() => {
          rebuildClouds();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudSliceCount", 1, 256, 1)
        .name("Slices")
        .onChange(() => {
          rebuildClouds();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudDensity", 0.0, 1.0, 0.01)
        .name("Density")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudSoftness", 0.001, 1, 0.001)
        .name("Softness")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudSpeed", -0.05, 0.05, 0.001)
        .name("Scroll speed")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        // NEW: color + opacity controls

        const cloudColorCtrl = cloudFolder
        .addColor(params, "cloudColor")
        .name("Cloud color");

        const skyColorCtrl = cloudFolder
        .addColor(params, "cloudSkyColor")
        .name("Sky color");

        const cloudOpacityCtrl = cloudFolder
        .add(params, "cloudOpacity", 0.0, 3.0, 0.05)
        .name("Opacity");

        const updateCloudAppearance = () => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        };

        cloudColorCtrl.onChange(updateCloudAppearance);
        skyColorCtrl.onChange(updateCloudAppearance);
        cloudOpacityCtrl.onChange(updateCloudAppearance);







        const flakes = gui.addFolder("Flakes");
        trackController(
          flakes.add(params, "visualCount", 20000, 600000, 5000).name("Visual flakes"),
          { rebuild: true, instant: false }
          );
        trackController(flakes.add(params, "fallSpeed", 0.001, 10.5, 0.001).name("Fall speed"));
        trackController(flakes.add(params, "fallJitter", 0.0, 0.9, 0.01).name("Fall jitter"));
        trackController(flakes.add(params, "flakeSize", 0.01, 10.0, 0.01).name("Flake size"));
        trackController(
          flakes.add(params, "flakeSizeJitter", 0.0, 0.9, 0.01).name("Size jitter")
          );
        
        //flakes.open();

        const drifts = gui.addFolder("Drifts");
        trackController(drifts.add(params, "driftGrid", 32, 256, 1).name("Grid"), {
          rebuild: true,
          instant: false
        });
        trackController(
          drifts.add(params, "driftMaxHeight", 0.5, 8.0, 0.1).name("Max height")
          );
        trackController(drifts.add(params, "coverBase", 0.0, 0.30, 0.005).name("Base cover"));
        trackController(
          drifts.add(params, "coverMacroAmp", 0.0, 0.30, 0.005).name("Macro amp")
          );
        trackController(
          drifts.add(params, "coverMacroFreq", 0.5, 6.0, 0.1).name("Macro freq")
          );
        trackController(
          drifts.add(params, "coverMicroAmp", 0.0, 0.20, 0.005).name("Micro amp")
          );
        trackController(
          drifts.add(params, "coverMicroFreq", 2.0, 16.0, 0.1).name("Micro freq")
          );
        trackController(
          drifts.add(params, "depositUnit", 0.00005, 0.0015, 0.00001).name("Deposit unit")
          );
        trackController(
          drifts.add(params, "driftDiffusion", 0.0, 0.25, 0.001).name("Diffusion")
          );
        trackController(
          drifts.add(params, "driftAdvection", 0.0, 0.30, 0.001).name("Advection")
          );
        trackController(
          drifts.add(params, "obstacleShapeInterval", 1, 60, 1).name("Obstacle shape N")
          );
        trackController(
          drifts.add(params, "driftWriteInterval", 1, 60, 1).name("Write mesh N")
          );
        trackController(
          drifts.add(params, "normalUpdateInterval", 4, 180, 1).name("Normals N")
          );
      //drifts.open();

        const sticking = gui.addFolder("Sticking");
        trackController(
          sticking.add(params, "settlerCount", 1000, 300000, 500).name("Settlers"),
          { rebuild: true, instant: false }
          );
        trackController(
          sticking.add(params, "groundDepositBudget", 20, 10200, 10).name("Deposit budget")
          );
        trackController(
          sticking.add(params, "objectTestsPerFrame", 0, 50000, 50).name("Ray tests/frame")
          );
        trackController(
          sticking.add(params, "objectDeposit", 0.0, 1, 0.0005).name("Object deposit")
          );
        trackController(
          sticking.add(params, "stuckMax", 1000, 600000, 500).name("Max decals"),
          { rebuild: true, instant: false }
          );
        trackController(
          sticking.add(params, "decalSize", 0.06, 0.50, 0.01).name("Decal size"),
          { rebuild: true, instant: false }
          );
      //ticking.open();

        const misc = {
          resetDefaults() {
            applySettings(DEFAULTS, { rebuild: true, updateGui: true, persist: true });
          }
        };
        gui.add(misc, "resetDefaults").name("Reset to defaults");

        const presets = gui.addFolder("Presets");
        presets.add(presetState, "presetName").name("Save as").listen();

        presetSelectCtrl = presets
        .add(presetState, "selected", ["<none>"])
        .name("Saved presets");

      // auto-load preset (file or DB) when selection changes
        presetSelectCtrl.onChange(async (value) => {
          const name = sanitizePresetName(value);
          presetState.selected = name || "<none>";
          if (name && name !== "<none>") {
            await loadPreset();
          }
        });

        presets.add({ savePreset }, "savePreset").name("Save");
      // no Load button – selection loads instantly
        presets.add({ deletePreset }, "deletePreset").name("Delete");
        presets.add({ exportJson: exportSettings }, "exportJson").name("Export JSON");
        presets.add({ importJson: importSettings }, "importJson").name("Import JSON");
      //presets.open();
      //presets.open();


        const snowmanFolder = gui.addFolder("Snowman");

        trackController(
          snowmanFolder.add(params, "snowmanMoveEnabled").name("Moving")
          );

        trackController(
          snowmanFolder
          .add(params, "snowmanSpeed", 0.002, 0.15, 0.001)
          .name("Path speed")
          );

        trackController(
          snowmanFolder
          .add(params, "snowmanPathRadius", 1.0, 8.0, 0.1)
          .name("Path radius")
          );

        // start folded to not spam the UI
        // snowmanFolder.open(); // enable if you prefer it open by default

        const vehiclesFolder = gui.addFolder("Vehicles");
        setupVehicleTuningGui(vehiclesFolder);
        vehiclesFolder.close();



        sim.close();
        wind.close();
        fogFolder.close();
        gustFolder.close();
        flakes.close();
        drifts.close();
        sticking.close();
        presets.close();
        snowmanFolder.close();
        forest.close();

        gui.close()

      }

    // -------------------------------------------------------------------------
    // Events / main loop
    // -------------------------------------------------------------------------

      function handleResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      const clock = new THREE.Clock();
      let frame = 0;
      let simTime = 0;


      function animate() {
        const rawDt = clamp(
          clock.getDelta(),
          0.0,
          Math.max(0.001, params.dtMax)
          );

        const timeScale = clamp(params.timeScale, 0.05, 5.0);

  // Simulation time (snow/drifts) honors timeScale; avatar uses real-time delta.
        const dtSim = params.paused ? 0.0 : rawDt * timeScale;
        const dtAvatar = params.paused ? 0.0 : rawDt;

        if (!params.paused) simTime += dtSim;
        const t = simTime;

  // Base wind
        const wA =
        Math.sin(t * params.windSpeed) * 0.48 +
        Math.sin(t * (params.windSpeed * 2.4)) * 0.16;
        const wB =
        Math.cos(t * (params.windSpeed * 0.92)) * 0.44 +
        Math.sin(t * (params.windSpeed * 2.1)) * 0.14;
        const baseWindX = wA * params.windStrength;
        const baseWindZ = wB * params.windStrength;

  // Gust lifecycle
        if (!params.paused) {
          spawnGusts(dtSim);
          for (let i = 0; i < gusts.length; i++) {
            gusts[i].step(dtSim);
          }
        }

  // Feed gust arrays for GPU snow
        for (let i = 0; i < GUST_MAX; i++) {
          const g = gusts[i];
          const fade = g.active ? g.fade : 0.0;

          gustPosRad[i * 3 + 0] = g.x;
          gustPosRad[i * 3 + 1] = g.z;
          gustPosRad[i * 3 + 2] = g.radius;

          gustParams[i * 3 + 0] = g.strength * fade;
          gustParams[i * 3 + 1] = g.swirl * fade;
          gustParams[i * 3 + 2] = g.updraft * fade;
        }

  // GPU flakes
        if (snowMat) {
          snowMat.uniforms.uTime.value = t;
          snowMat.uniforms.uWind.value.set(baseWindX, baseWindZ);
          snowMat.uniforms.uFallSpeed.value = params.fallSpeed;
          snowMat.uniforms.uFallJitter.value = params.fallJitter;
          snowMat.uniforms.uFlakeSize.value = params.flakeSize;
          snowMat.uniforms.uFlakeSizeJitter.value = params.flakeSizeJitter;
        }

  // Drifts / settlers (freeze when paused)
        if (!params.paused) {
          if (driftHeights) {
            applyGustScour(baseWindX, baseWindZ);

            if (frame % clamp(params.obstacleShapeInterval | 0, 1, 600) === 0) {
              shapeDriftsAroundObstacles(baseWindX, baseWindZ);
            }
            evolveDrifts(baseWindX, baseWindZ);

            if (frame % clamp(params.driftWriteInterval | 0, 1, 120) === 0) {
              applyHeightsToGeometry();
            }
            if (
              frame % clamp(params.normalUpdateInterval | 0, 1, 240) === 0 &&
              driftGeo
              ) {
              driftGeo.computeVertexNormals();
            driftGeo.attributes.normal.needsUpdate = true;
          }
        }

        updateSettlers(dtSim, baseWindX, baseWindZ);

    // Snowman animation along curved path
        updateSnowman(dtSim);

        updateClouds(dtSim);
      }

  // Avatar + camera (no dependency on simulation timeScale)
      tickAvatar(dtAvatar);

      const inXR = renderer.xr.isPresenting;

      if (!inXR && controls) {
        if (avatarState.enabled) {
          controls.autoRotate = false;
          controls.autoRotateSpeed = AUTO_ROTATE_SPEED;

          if (!joystickState.active) {
            controls.update();
          }

          updateAvatarCamera(dtAvatar);
        } else {
          const nowSeconds = performance.now() * 0.001;
          const idleSeconds = nowSeconds - lastInteractionTime;

          const shouldAutoRotate =
          autoRotateEnabled &&
          idleSeconds >= AUTO_ROTATE_IDLE_SECONDS;

          controls.autoRotate = shouldAutoRotate;
          controls.autoRotateSpeed = AUTO_ROTATE_SPEED;

          controls.update();
        }
      }

      renderer.render(scene, camera);

      frame++;
    }




// -------------------------------------------------------------------------
// Keyboard: fullscreen (F) and UI toggle (ESC)
// -------------------------------------------------------------------------

    let uiHidden = false;

/**
 * Toggle visibility of GUI and HUD without destroying state.
 */
    function setUIHidden(hidden) {
      uiHidden = hidden;

      if (gui && gui.domElement) {
        gui.domElement.style.display = hidden ? "none" : "";
      }

      const hud = document.querySelector(".hud");
      if (hud) {
        hud.style.display = hidden ? "none" : "";
      }

      const avatarUi = document.querySelector(".avatar-ui");
      if (avatarUi) {
        avatarUi.style.display = hidden ? "none" : "";
      }

      const joystickEl = document.getElementById("joystick");
      if (joystickEl) {
        joystickEl.style.display = hidden ? "none" : "";
      }

      const vehiclePanel = document.getElementById("vehiclePrompt");
      if (vehiclePanel) {
        if (hidden) {
          vehiclePanel.style.display = "none";
          vehiclePanel.setAttribute("aria-hidden", "true");
        } else {
          const show = !!(vehiclePromptState.open && vehiclePromptState.nearby);
          vehiclePanel.style.display = show ? "block" : "none";
          vehiclePanel.setAttribute("aria-hidden", show ? "false" : "true");
        }
      }

      if (hidden) {
        updateVehicleOutlineFor(null);
      } else {
        if (vehiclePromptState.open && vehiclePromptState.nearby) {
          updateVehicleOutlineFor(vehiclePromptState.nearby);
        }
      }
    }



/**
 * Cross-browser fullscreen state check.
 */
    function isFullscreen() {
      return (
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement
        );
    }

/**
 * Toggle fullscreen on the document root.
 */
    function toggleFullscreen() {
      const el = document.documentElement;

      if (!isFullscreen()) {
        if (el.requestFullscreen) el.requestFullscreen();
        else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
        else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
        else if (el.msRequestFullscreen) el.msRequestFullscreen();
      } else {
        if (document.exitFullscreen) document.exitFullscreen();
        else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
        else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
        else if (document.msExitFullscreen) document.msExitFullscreen();
      }
    }



/**
 * Unified key handler.
 */
    function onKeyDown(event) {
      const tag = event.target && event.target.tagName;
      if (tag === "INPUT" || tag === "TEXTAREA") return;

      if (event.code === "KeyF") {
        event.preventDefault();
        toggleFullscreen();
        return;
      }

      if (event.code === "Escape") {
        if (isFullscreen()) {
          if (document.exitFullscreen) document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
          else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
          else if (document.msExitFullscreen) document.msExitFullscreen();
          return;
        }

        if (vehiclePromptState.open) {
          setVehiclePrompt(false, null);
          updateVehicleOutlineFor(null);
          return;
        }

        setUIHidden(!uiHidden);
        return;
      }

      if (event.code === "KeyE") {
        event.preventDefault();

        if (vehicleDriveState.enabled) {
          exitVehicle();
          return;
        }

        if (vehiclePromptState.nearby && avatarState.enabled) {
          enterVehicle(vehiclePromptState.nearby);
          return;
        }

        return;
      }

      switch (event.code) {
      case "ShiftLeft":
      case "ShiftRight":
        avatarKeys.run = true;
        break;

      case "KeyW":
      case "ArrowUp":
        avatarKeys.forward = true;
        recomputeAvatarMoveFromKeys();
        break;

      case "KeyS":
      case "ArrowDown":
        avatarKeys.back = true;
        recomputeAvatarMoveFromKeys();
        break;

      case "KeyA":
      case "ArrowLeft":
        avatarKeys.left = true;
        recomputeAvatarMoveFromKeys();
        break;

      case "KeyD":
      case "ArrowRight":
        avatarKeys.right = true;
        recomputeAvatarMoveFromKeys();
        break;

      case "KeyV":
        event.preventDefault();
        if (avatarState.enabled) {
          disableAvatarControl();
        } else if (avatar) {
          enableAvatarControl(avatarState.viewMode);
        }
        break;

      case "KeyC":
        event.preventDefault();
        if (avatarState.enabled) {
          const next = avatarState.viewMode === "third" ? "first" : "third";
          setAvatarViewMode(next, true);
          updateAvatarButtons();
        } else {
          avatarState.viewMode = avatarState.viewMode === "third" ? "first" : "third";
          updateAvatarButtons();
        }
        break;

      default:
        break;
      }
    }




    function onKeyUp(event) {
      const tag = event.target && event.target.tagName;
      if (tag === "INPUT" || tag === "TEXTAREA") return;

      switch (event.code) {
      case "ShiftLeft":
      case "ShiftRight":
        avatarKeys.run = false;
        break;

      case "KeyW":
      case "ArrowUp":
        avatarKeys.forward = false;
        recomputeAvatarMoveFromKeys();
        break;

      case "KeyS":
      case "ArrowDown":
        avatarKeys.back = false;
        recomputeAvatarMoveFromKeys();
        break;

      case "KeyA":
      case "ArrowLeft":
        avatarKeys.left = false;
        recomputeAvatarMoveFromKeys();
        break;

      case "KeyD":
      case "ArrowRight":
        avatarKeys.right = false;
        recomputeAvatarMoveFromKeys();
        break;

      default:
        break;
      }
    }




    // -------------------------------------------------------------------------
    // Boot
    // -------------------------------------------------------------------------


    async function loadDefaultPresetFromFile() {
      try {
        const response = await fetch("presets/snow-Hello.json", {
          cache: "no-store"
        });

        if (!response.ok) {
          console.warn(
            "[snow] default preset fetch failed:",
            response.status,
            response.statusText
            );
          return;
        }

        const json = await response.json();

    // Accept both formats:
    // 1) { "v": 1, "settings": { ... } }
    // 2) { ...paramsDirectly }
        const srcSettings =
        json &&
        typeof json === "object" &&
        json.settings &&
        typeof json.settings === "object"
        ? json.settings
        : json;

        if (!srcSettings || typeof srcSettings !== "object") {
          console.warn("[snow] default preset JSON has no settings object");
          return;
        }

    // Merge onto DEFAULTS so missing keys get sane values
        const merged = Object.assign({}, DEFAULTS, srcSettings);

    // Apply without rebuild/GUI/persist – world not built yet
        applySettings(merged, {
          rebuild: false,
          updateGui: false,
          persist: false
        });
      } catch (e) {
        console.warn("[snow] default preset load failed", e);
      }
    }





    async function init() {

      loadLastSettings(params);

      setupScene();

      snowTex = makeRadialTexture(96);
      rebuildWorld();

      setupGui();
      refreshGuiDisplays();
      refreshPresetList();

      handleResize();
      window.addEventListener("resize", handleResize, { passive: true });

      window.addEventListener("keydown", onKeyDown);
      window.addEventListener("keyup", onKeyUp);

      addEventListener("pagehide", () => saveLastNow(params), { capture: true });
      addEventListener("beforeunload", () => saveLastNow(params), { capture: true });
      addEventListener(
        "visibilitychange",
        () => {
          if (document.visibilityState === "hidden") saveLastNow(params);
        },
        { capture: true }
        );

      loadAllModels(() => {
        // models ready
      });

      loadAvatar();
      setupAvatarUI();

      try {
        await loadDefaultPresetFromFile("presets/snow-default.json");
      } catch (e) {
        console.warn("[snow] default preset load failed", e);
      }

      renderer.setAnimationLoop(animate);
    }

    init();





  </script>
</body>
</html>
