<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Three.js – Snowdrifts, Gusts, Sticking & Presets (importmap)</title>
  <link rel="icon" href="data:,">

  <meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
  />

  <style>

    @font-face {
      font-family: "Minimalo";
      src: url("fonts/minimalo-font/Minimalo-LVzzy.ttf") format("truetype");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #0a1220;
      font-family: "Minimalo", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    button {
      font-family: "Minimalo", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    #app {
      position: fixed;
      inset: 0;
    }
    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      font: 12px/1.4 "Minimalo", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
      color: rgba(255,255,255,0.92);
      background: rgba(0,0,0,0.28);
      border: 1px solid rgba(255,255,255,0.14);
      border-radius: 12px;
      padding: 10px 12px;
      backdrop-filter: blur(8px);
      user-select: none;
      pointer-events: none;
      max-width: 380px;
    }
    .hud b {
      color: rgba(255,255,255,0.98);
    }

    .avatar-ui {
      position: fixed;
      right: 12px;
      bottom: 12px;
      display: flex;
      gap: 8px;
      align-items: center;
      z-index: 20;
      pointer-events: auto;
    }

    .avatar-btn {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.24);
      background: rgba(0,0,0,0.55);
      color: #f5f5f5;
      font-size: 12px;;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      cursor: pointer;
      backdrop-filter: blur(10px);
    }

    .avatar-btn:hover {
      background: rgba(0,0,0,0.8);
    }

    .avatar-btn:active {
      background: rgba(0,0,0,0.95);
    }

    .joystick {
      position: fixed;
      left: 16px;
      bottom: 74px;
      width: 96px;
      height: 96px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.4);
      background: radial-gradient(circle at 30% 30%, rgba(255, 255, 255, 0.18), rgba(0, 0, 0, 0.6));
      backdrop-filter: blur(10px);
      touch-action: none;
      z-index: 20;
    }

    .joystick-inner {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 40px;
      height: 40px;
      margin-left: -20px;
      margin-top: -20px;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.7);
      background: rgba(255, 255, 255, 0.2);
      pointer-events: none;
      transition: transform 0.08s ease-out;
    }

    .vehicle-ui {
      position: absolute;
      right: 12px;
      bottom: 96px;
      max-width: 520px;
      margin: 0 auto; /* <-- center horizontally */
      padding: 10px 12px;
      border-radius: 12px;
      color: #fff;
      background: rgba(0, 0, 0, 0.58);
      backdrop-filter: blur(10px);
      z-index: 25;
      display: none;
      pointer-events: auto;
    }


    .vehicle-ui__title {
      font-weight: 700;
      margin-bottom: 4px;
      line-height: 1.2;
    }

    .vehicle-ui__desc {
      opacity: 0.92;
      font-size: 14px;
      line-height: 1.25;
      margin-bottom: 10px;
    }

    .vehicle-ui__row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }


    .kbd-help {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 60;
      background: rgba(0, 0, 0, 0.55);
      pointer-events: auto;
    }

    .kbd-help.is-open {
      display: flex;
    }

    .kbd-help__panel {
      width: min(520px, calc(100vw - 24px));
      background: rgba(18, 18, 18, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 14px;
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
      padding: 14px 14px 12px 14px;
      color: rgba(255, 255, 255, 0.95);
    }

    .kbd-help__header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 10px;
    }

    .kbd-help__title {
      font-weight: 700;
      font-size: 24px;;
      letter-spacing: 0.2px;
    }

    .kbd-help__grid {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
    }

    .kbd-help__row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .kbd {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 34px;
      padding: 4px 8px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: rgba(255, 255, 255, 0.08);
      font-size: 14px;;
      font-weight: 700;
      font-family: "Minimalo", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select: none;
    }

    .kbd--wide {
      min-width: 90px;
    }

    .kbd-help__text {
      font-size: 14px;;
      line-height: 1.25;
      color: rgba(255, 255, 255, 0.88);
    }

    .kbd-help__note {
      margin-top: 10px;
      font-size: 14px;;
      color: rgba(255, 255, 255, 0.75);
    }


    .edit-transform-mode-btn {
      position: fixed;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      width: 44px;
      height: 44px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.24);
      background: rgba(0,0,0,0.55);
      color: #f5f5f5;
      font-size: 14px;;
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 22;
      pointer-events: auto;
      cursor: pointer;
      backdrop-filter: blur(10px);
    }

    .edit-transform-mode-btn:hover {
      background: rgba(0,0,0,0.8);
    }

    .edit-transform-mode-btn:active {
      background: rgba(0,0,0,0.95);
    }

    #worldEditUndoBtn {
      top: auto;
      bottom: calc(128px + env(safe-area-inset-bottom));
      transform: none;
    }

    #worldEditRedoBtn {
      top: auto;
      bottom: calc(76px + env(safe-area-inset-bottom));
      transform: none;
    }

    #worldEditTransformMode {
      top: 50%;
      transform: translateY(-50%);
    }

    #worldEditDuplicateBtn {
      top: calc(50% + 52px);
      transform: none;
    }

    #worldEditDeleteBtn {
      top: calc(50% + 104px);
      transform: none;
    }

    .action-toast {
      position: fixed;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%) scale(0.98);
      padding: 10px 14px;
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.22);
      background: rgba(0,0,0,0.68);
      color: #f5f5f5;
      font-size: 14px;;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      opacity: 0;
      pointer-events: none;
      z-index: 25;
      backdrop-filter: blur(10px);
      transition: opacity 180ms ease, transform 180ms ease;
    }

    .action-toast.is-open {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }


    .edit-transform-mode-btn[disabled] {
      opacity: 0.35;
      cursor: default;
    }

    .profile-help {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 65;
      background: rgba(0, 0, 0, 0.55);
      pointer-events: auto;
    }

    .profile-help.is-open {
      display: flex;
    }

    .profile-help__panel {
      width: min(520px, calc(100vw - 24px));
      background: rgba(18, 18, 18, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 14px;
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
      padding: 14px 14px 12px 14px;
      color: rgba(255, 255, 255, 0.95);
    }

    .profile-form {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      margin-top: 6px;
    }

    .profile-field {
      display: grid;
      grid-template-columns: 1fr;
      gap: 6px;
    }

    .profile-label {
      font-size: 14px;;
      color: rgba(255, 255, 255, 0.78);
      letter-spacing: 0.2px;
    }

    .profile-input,
    .profile-textarea {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.18);
      background: rgba(0, 0, 0, 0.35);
      color: rgba(255, 255, 255, 0.92);
      padding: 10px 10px;
      outline: none;
      font-size: 14px;;
      line-height: 1.2;
    }

    .profile-textarea {
      resize: none;
      min-height: 74px;
    }

    .profile-input:focus,
    .profile-textarea:focus {
      border-color: rgba(255, 255, 255, 0.32);
      background: rgba(0, 0, 0, 0.45);
    }

    .profile-readonly {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.88);
      padding: 10px 10px;
      font-size: 14px;;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      user-select: text;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .profile-color {
      height: 44px;
      padding: 4px 6px;
    }

    .profile-actions {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      margin-top: 2px;
    }


    .world-picker {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 70;
      background: rgba(0, 0, 0, 0.62);
      pointer-events: auto;
      padding: 12px;
    }

    .world-picker.is-open {
      display: flex;
    }

    @media (max-width: 540px) {
      .world-picker {
        align-items: flex-end;
        padding: 0;
      }
    }

    .world-picker__panel {
      width: min(920px, calc(100vw - 24px));
      max-height: min(760px, calc(100vh - 24px));
      overflow: hidden;
      display: flex;
      flex-direction: column;
      background: rgba(18, 18, 18, 0.92);
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 14px;
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
      padding: 14px 14px 12px 14px;
      color: rgba(255, 255, 255, 0.95);
    }

    @media (max-width: 540px) {
      .world-picker__panel {
        width: 100vw;
        max-height: calc(100vh - env(safe-area-inset-top));
        border-radius: 16px 16px 0 0;
        padding: 12px 12px calc(12px + env(safe-area-inset-bottom)) 12px;
      }
    }

    .world-picker__save {
      display: none;
      gap: 10px;
      margin-bottom: 12px;
    }

    .world-picker.is-editing .world-picker__save {
      display: grid;
    }

    .world-picker__save-row {
      display: flex;
      justify-content: flex-end;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 2px;
    }

    .world-picker__list {
      display: grid;
      grid-template-columns: 1fr;
      gap: 10px;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      flex: 1 1 auto;
      min-height: 0;
      padding: 2px;
    }

    @media (min-width: 720px) {
      .world-picker__list {
        grid-template-columns: 1fr 1fr;
      }
    }

    .world-card {
      border: 1px solid rgba(255, 255, 255, 0.16);
      border-radius: 12px;
      overflow: hidden;
      background: rgba(0, 0, 0, 0.35);
      position: relative;
      height: clamp(220px, 32vw, 290px);
      display: block;
      isolation: isolate;
    }

    .world-card.is-active {
      border-color: rgba(34, 197, 94, 0.60);
    }

    .world-card__thumb {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: rgba(255, 255, 255, 0.06);
      display: block;
      transform: scale(1.01);
      filter: saturate(1.02) contrast(1.02);
    }

    .world-card__body {
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      padding: 10px;
      display: flex;
      flex-direction: column;
      gap: 8px;
      background: linear-gradient(
        to top,
        rgba(0, 0, 0, 0.78),
        rgba(0, 0, 0, 0.46) 52%,
        rgba(0, 0, 0, 0.00)
      );
      color: rgba(255, 255, 255, 0.95);
      z-index: 2;
    }

    .world-card__titleRow {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      min-width: 0;
    }

    .world-card__title {
      font-weight: 700;
      font-size: 14px;;
      letter-spacing: 0.2px;
      line-height: 1.2;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.85);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      min-width: 0;
      flex: 1 1 auto;
    }

    .world-card__meta {
      font-size: 12px;
      opacity: 0.85;
      white-space: nowrap;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.85);
      flex: 0 0 auto;
    }

    .world-card__desc {
      font-size: 12px;
      opacity: 0.92;
      line-height: 1.25;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.85);
      overflow: hidden;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 3;
      max-height: 3.75em;
    }

    .world-card__actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      justify-content: flex-end;
      align-items: center;
    }

    .world-card .avatar-btn {
      padding: 6px 10px;
      font-size: 12px;;
      touch-action: manipulation;
    }

    @media (max-width: 420px) {
      .world-card {
        height: 230px;
      }

      .world-card__body {
        padding: 10px 10px 12px 10px;
        gap: 8px;
      }

      .world-card__title {
        font-size: 14px;;
      }

      .world-card__desc {
        font-size: 12px;
        -webkit-line-clamp: 2;
        max-height: 2.5em;
      }

      .world-card__actions {
        gap: 6px;
      }
    }

    .world-name {
      position: fixed;
      left: 50%;
      top: calc(30px + env(safe-area-inset-top));
      transform: translateX(-50%);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgb(192 192 192 / 42%);
      color: rgb(50 50 50 / 92%);
      font-size: 22px;;
      font-weight: 800;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      z-index: 23;
      pointer-events: none;
      backdrop-filter: blur(10px);
      max-width: min(84vw, 520px);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .world-name[aria-hidden="true"] {
      display: none;
    }


  </style>



  <!-- Import map for Three.js -->
  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
      }
    }
  </script>


</head>


<body>
  <div id="app"></div>

  <div id="worldName" class="world-name" aria-hidden="true" aria-live="polite"></div>

  <div class="avatar-ui">
    <button id="avatarToggle" class="avatar-btn">Avatar: OFF</button>
    <button id="avatarViewToggle" class="avatar-btn">View: Behind</button>
    <button id="worldEditToggle" class="avatar-btn">Edit World: OFF</button>
    <button id="worldsBtn" class="avatar-btn">Worlds</button>
    <button id="saveWorldBtn" class="avatar-btn">Save World</button>
    <button id="playerProfileBtn" class="avatar-btn">Profile</button>
  </div>




  <button id="worldEditUndoBtn" class="edit-transform-mode-btn" type="button" aria-label="Undo edit action" aria-hidden="true">↶</button>
  <button id="worldEditRedoBtn" class="edit-transform-mode-btn" type="button" aria-label="Redo edit action" aria-hidden="true">↷</button>
  <button id="worldEditTransformMode" class="edit-transform-mode-btn" type="button" aria-label="Edit transform mode" aria-hidden="true">P</button>
  <button id="worldEditDuplicateBtn" class="edit-transform-mode-btn" type="button" aria-label="Duplicate selected model" aria-hidden="true">D</button>
  <button id="worldEditDeleteBtn" class="edit-transform-mode-btn" type="button" aria-label="Delete selected model" aria-hidden="true">X</button>

  <div id="actionToast" class="action-toast" aria-hidden="true"></div>




  <div id="joystick" class="joystick">
    <div id="joystickInner" class="joystick-inner"></div>
  </div> 

  <div id="vehiclePrompt" class="vehicle-ui" aria-hidden="true">
    <div id="vehiclePromptTitle" class="vehicle-ui__title"></div>
    <div id="vehiclePromptDesc" class="vehicle-ui__desc"></div>
    <div class="vehicle-ui__row">
      <button id="vehicleEnterBtn" class="avatar-btn">Get in/on</button>
      <button id="vehicleExitBtn" class="avatar-btn" style="display:none;">Exit</button>
      <button id="vehicleCloseBtn" class="avatar-btn">Close</button>
    </div>
  </div>


  <div id="keyboardHelp" class="kbd-help" aria-hidden="true">
    <div class="kbd-help__panel" role="dialog" aria-modal="true" aria-label="Keyboard controls">
      <div class="kbd-help__header">
        <div class="kbd-help__title">Keyboard</div>
        <button id="keyboardHelpClose" class="avatar-btn">Close</button>
      </div>

      <div class="kbd-help__grid">
        <div class="kbd-help__row"><span class="kbd">V</span><span class="kbd-help__text">Toggle avatar control on/off</span></div>
        <div class="kbd-help__row"><span class="kbd">C</span><span class="kbd-help__text">Toggle avatar camera view (third ↔ first) when avatar is enabled</span></div>
        <div class="kbd-help__row"><span class="kbd">B</span><span class="kbd-help__text">Toggle chase camera behind avatar/vehicle</span></div>

        <div class="kbd-help__row"><span class="kbd">P</span><span class="kbd-help__text">Pause / resume simulation</span></div>
        <div class="kbd-help__row"><span class="kbd kbd--wide">⌘/Ctrl+S</span><span class="kbd-help__text">Save current world</span></div>

        <div class="kbd-help__row"><span class="kbd kbd--wide">W/A/S/D</span><span class="kbd-help__text">Move avatar (and drive vehicles when mounted)</span></div>
        <div class="kbd-help__row"><span class="kbd kbd--wide">Arrows</span><span class="kbd-help__text">Move avatar (and drive vehicles when mounted)</span></div>
        <div class="kbd-help__row"><span class="kbd kbd--wide">Shift</span><span class="kbd-help__text">Run (avatar)</span></div>
        <div class="kbd-help__row"><span class="kbd kbd--wide">Space</span><span class="kbd-help__text">Jump (avatar)</span></div>

        <div class="kbd-help__row"><span class="kbd">E</span><span class="kbd-help__text">Enter nearest vehicle / exit current vehicle</span></div>
        <div class="kbd-help__row"><span class="kbd">I</span><span class="kbd-help__text">Enter nearest vehicle (only when near and not already driving)</span></div>
        <div class="kbd-help__row"><span class="kbd">O</span><span class="kbd-help__text">Exit vehicle (only when driving)</span></div>

        <div class="kbd-help__row"><span class="kbd">F</span><span class="kbd-help__text">Toggle fullscreen</span></div>
        <div class="kbd-help__row"><span class="kbd kbd--wide">Esc</span><span class="kbd-help__text">Exit fullscreen (if active)</span></div>
      </div>


      <div class="kbd-help__note">Toggle with Cmd+/ (Mac) or Ctrl+/ (Windows/Linux).</div>
    </div>
  </div>


  <div id="playerProfile" class="profile-help" aria-hidden="true">
    <div class="profile-help__panel" role="dialog" aria-modal="true" aria-label="Player profile">
      <div class="kbd-help__header">
        <div class="kbd-help__title">Profile</div>
        <button id="playerProfileClose" class="avatar-btn">Close</button>
      </div>

      <div class="profile-form">
        <div class="profile-field">
          <label class="profile-label" for="playerProfileId">Player ID</label>
          <div id="playerProfileId" class="profile-readonly" aria-live="polite"></div>
        </div>

        <div class="profile-field">
          <label class="profile-label" for="playerNameInput">Name</label>
          <input id="playerNameInput" class="profile-input" type="text" maxlength="32" autocomplete="nickname" />
        </div>

        <div class="profile-field">
          <label class="profile-label" for="playerColorInput">Color</label>
          <input id="playerColorInput" class="profile-input profile-color" type="color" />
        </div>

        <div class="profile-field">
          <label class="profile-label" for="playerBioInput">About</label>
          <textarea id="playerBioInput" class="profile-textarea" rows="3" maxlength="256"></textarea>
        </div>

        <div class="profile-actions">
          <button id="playerProfileReset" class="avatar-btn" type="button">Reset</button>
          <button id="playerProfileSave" class="avatar-btn" type="button">Save</button>
        </div>
      </div>
    </div>
  </div>

  <div id="worldPicker" class="world-picker" aria-hidden="true">
    <div class="world-picker__panel" role="dialog" aria-modal="true" aria-label="Worlds">
      <div class="kbd-help__header">
        <div class="kbd-help__title">Worlds</div>
        <button id="worldPickerClose" class="avatar-btn">Close</button>
      </div>

      <div class="world-picker__save">
        <div class="profile-field">
          <label class="profile-label" for="worldTitleInput">Title</label>
          <input id="worldTitleInput" class="profile-input" type="text" maxlength="64" autocomplete="off" />
        </div>

        <div class="profile-field">
          <label class="profile-label" for="worldDescInput">Description</label>
          <textarea id="worldDescInput" class="profile-textarea" rows="2" maxlength="256"></textarea>
        </div>

        <div class="world-picker__save-row">
          <button id="worldSaveBtn" class="avatar-btn" type="button">Save Current</button>
          <button id="worldImportBtn" class="avatar-btn" type="button">Import JSON</button>
        </div>
      </div>

      <div id="worldPickerList" class="world-picker__list"></div>

      <div class="kbd-help__note">Selecting a world reloads the page to fully swap loaded models.</div>
    </div>
  </div>


  <div class="hud" style="visibility: hidden;">
    <b>Snowdrifts + gusts + sticking snow + presets</b><br />
    Drag: orbit · Wheel: zoom · Right-drag: pan<br />
    Gust parameters, sticking, drifts, and presets are all controlled from the GUI.
  </div>

  <script type="module">

    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { TransformControls } from "three/addons/controls/TransformControls.js";
    import { VRButton } from "three/addons/webxr/VRButton.js";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";    
    import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.20/+esm";

    // -------------------------------------------------------------------------
    // Helpers / persistence utilities
    // -------------------------------------------------------------------------

    const PLAYER_PROFILE_STORAGE_KEY = "snow:playerProfile:v1";

    /**
     * Creates a stable per-player id for future multiuser transport.
     */
    function makePlayerId() {
      try {
        const bytes = new Uint8Array(8);
        crypto.getRandomValues(bytes);
        let out = "";
        for (let i = 0; i < bytes.length; i++) out += bytes[i].toString(16).padStart(2, "0");
          return out;
      } catch {
        return Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2);
      }
    }

    /**
     * Normalizes a display name for UI and future networking.
     */
    function sanitizePlayerName(name) {
      const s = String(name ?? "").trim().replace(/\s+/g, " ");
      if (!s) return "Anonymous";
      return s.slice(0, 32);
    }

    /**
     * Generates a default local profile (anonymous by default).
     */
    function createDefaultPlayerProfile() {
      const id = makePlayerId();
      return {
        v: 1,
        id,
        name: "Anonymous",
        color: "#22c55e",
        meta: { about: "" }
      };
    }

    /**
     * Loads the local player profile from storage, falling back to defaults.
     */
    function loadPlayerProfile() {
      try {
        const raw = localStorage.getItem(PLAYER_PROFILE_STORAGE_KEY);
        if (!raw) return createDefaultPlayerProfile();

        const json = JSON.parse(raw);
        if (!json || typeof json !== "object") return createDefaultPlayerProfile();

        const p = createDefaultPlayerProfile();
        p.id = typeof json.id === "string" && json.id.trim() ? json.id.trim() : p.id;
        p.name = sanitizePlayerName(json.name);
        p.color = typeof json.color === "string" && /^#([0-9a-fA-F]{6})$/.test(json.color) ? json.color : p.color;

        if (json.meta && typeof json.meta === "object") {
          p.meta.about = typeof json.meta.about === "string" ? json.meta.about.slice(0, 256) : "";
        }
        return p;
      } catch {
        return createDefaultPlayerProfile();
      }
    }

    /**
     * Persists the local player profile.
     */
    function savePlayerProfile(profile) {
      try {
        localStorage.setItem(PLAYER_PROFILE_STORAGE_KEY, JSON.stringify(profile));
      } catch {}
    }

    let playerProfile = loadPlayerProfile();

    /**
     * Updates the local player profile and optionally persists it.
     */
    function setPlayerProfile(next, { persist = true } = {}) {
      const base = createDefaultPlayerProfile();
      base.id = typeof next?.id === "string" && next.id.trim() ? next.id.trim() : playerProfile.id;
      base.name = sanitizePlayerName(next?.name);
      base.color = typeof next?.color === "string" && /^#([0-9a-fA-F]{6})$/.test(next.color) ? next.color : playerProfile.color;

      if (next?.meta && typeof next.meta === "object") {
        base.meta.about = typeof next.meta.about === "string" ? next.meta.about.slice(0, 256) : "";
      } else {
        base.meta.about = typeof playerProfile?.meta?.about === "string" ? playerProfile.meta.about : "";
      }

      playerProfile = base;
      if (persist) savePlayerProfile(playerProfile);

      applyLocalPlayerProfileToAvatar();
    }

    /**
     * Applies local profile metadata onto the avatar object for future multiuser sync.
     */
    function applyLocalPlayerProfileToAvatar() {
      if (!avatar) return;

      avatar.userData.playerProfile = {
        id: playerProfile.id,
        name: playerProfile.name,
        color: playerProfile.color,
        meta: { about: playerProfile.meta.about }
      };
    }

    /**
     * Builds a compact state packet suitable for sending over a websocket.
     * Not transmitted by default; this is a stable schema for future multiuser work.
     */
    function buildLocalPlayerNetPacket() {
      const pose = avatar
      ? {
        p: [avatar.position.x, avatar.position.y, avatar.position.z],
        q: [avatar.quaternion.x, avatar.quaternion.y, avatar.quaternion.z, avatar.quaternion.w]
      }
      : null;

      const driving =
      vehicleDriveState &&
      vehicleDriveState.enabled &&
      vehicleDriveState.vehicle &&
      vehicleDriveState.vehicle.userData &&
      vehicleDriveState.vehicle.userData.vehicleId
      ? String(vehicleDriveState.vehicle.userData.vehicleId)
      : "";

      return {
        v: 1,
        t: "player",
        id: playerProfile.id,
        profile: {
          name: playerProfile.name,
          color: playerProfile.color,
          meta: { about: playerProfile.meta.about }
        },
        pose,
        driving
      };
    }








    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // Simple seedable RNG (LCG)
    function makeSeededRandom(seed) {
      let s = (seed | 0) || 1;
      return function () {
        s = (s * 1664525 + 1013904223) | 0;
        return (s >>> 0) / 4294967296;
      };
    }

    function nowStamp() {

      const d = new Date();
      const pad = (n) => String(n).padStart(2, "0");
      return (
        d.getFullYear() +
        pad(d.getMonth() + 1) +
        pad(d.getDate()) +
        "-" +
        pad(d.getHours()) +
        pad(d.getMinutes()) +
        pad(d.getSeconds())
        );
    }

    function safeCloneSettings(src) {
      const out = {};
      for (const k of Object.keys(src)) {
        const v = src[k];
        if (typeof v === "number" || typeof v === "boolean" || typeof v === "string") {
          out[k] = v;
        }
      }
      return out;
    }

    function downloadJson(obj, filename) {
      const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      a.rel = "noopener";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    // localStorage (last used settings)
    const STORAGE_LAST = "snow:lastSettings:v1";

    let persistTimer = 0;
    let persistBlocked = false;

    function saveLastNow(params) {
      if (persistBlocked) return;
      try {
        const payload = {
          v: 1,
          savedAt: Date.now(),
          settings: safeCloneSettings(params)
        };
        localStorage.setItem(STORAGE_LAST, JSON.stringify(payload));
      } catch (e) {
        console.warn("[snow] save last failed", e);
      }
    }

    function saveLastDebounced(params) {
      if (persistBlocked) return;
      if (persistTimer) clearTimeout(persistTimer);
      persistTimer = setTimeout(() => {
        persistTimer = 0;
        saveLastNow(params);
      }, 200);
    }

    /* Loads last-used settings; before scene init it only patches params (no rebuild calls). */
    function loadLastSettings(params) {
      try {
        const raw = localStorage.getItem(STORAGE_LAST);
        if (!raw) return;

        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object" || !parsed.settings || typeof parsed.settings !== "object") return;

        // If the scene is already ready, use the normal settings pipeline.
        if (typeof scene !== "undefined" && scene) {
          applySettings(parsed.settings, { rebuild: false, updateGui: false, persist: false });
          return;
        }

        // Early boot: copy only known primitive params (prevents calling rebuild* before scene exists).
        const s = parsed.settings;
        for (const k of Object.keys(s)) {
          if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
          const v = s[k];
          if (typeof v === "number" || typeof v === "boolean" || typeof v === "string") {
            params[k] = v;
          }
        }
      } catch (e) {
        console.warn("[snow] load last failed", e);
      }
    }


    // IndexedDB presets -------------------------------------------------------

    const IDB_NAME = "snow-presets";
    const IDB_STORE = "presets";
    const IDB_VERSION = 1;

    function idbOpen() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(IDB_NAME, IDB_VERSION);
        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(IDB_STORE)) {
            db.createObjectStore(IDB_STORE, { keyPath: "name" });
          }
        };
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
      });
    }

    async function idbPutPreset(name, settings) {
      const db = await idbOpen();
      try {
        await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite");
          tx.onerror = () => reject(tx.error);
          tx.objectStore(IDB_STORE).put({ name, savedAt: Date.now(), settings });
          tx.oncomplete = () => resolve();
        });
      } finally {
        db.close();
      }
    }

    async function idbGetPreset(name) {
      const db = await idbOpen();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readonly");
          tx.onerror = () => reject(tx.error);
          const req = tx.objectStore(IDB_STORE).get(name);
          req.onsuccess = () => resolve(req.result || null);
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    async function idbDeletePreset(name) {
      const db = await idbOpen();
      try {
        await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readwrite");
          tx.onerror = () => reject(tx.error);
          tx.objectStore(IDB_STORE).delete(name);
          tx.oncomplete = () => resolve();
        });
      } finally {
        db.close();
      }
    }

    async function idbListPresetNames() {
      const db = await idbOpen();
      try {
        return await new Promise((resolve, reject) => {
          const tx = db.transaction(IDB_STORE, "readonly");
          tx.onerror = () => reject(tx.error);
          const req = tx.objectStore(IDB_STORE).getAllKeys();
          req.onsuccess = () => {
            const list = (req.result || []).map(String).sort();
            resolve(list);
          };
          req.onerror = () => reject(req.error);
        });
      } finally {
        db.close();
      }
    }

    function sanitizePresetName(s) {
      const name = String(s ?? "").replace(/\.[a-z0-9]+$/i, "").trim();
      if (!name) return "";
      return name.replace(/\s+/g, " ").slice(0, 96);
    }

    // File input for JSON import ---------------------------------------------

    let importInput = null;
    function ensureImportInput() {
      if (importInput) return importInput;
      importInput = document.createElement("input");
      importInput.type = "file";
      importInput.accept = "application/json,.json";
      importInput.style.position = "fixed";
      importInput.style.left = "-9999px";
      importInput.style.top = "-9999px";
      document.body.appendChild(importInput);
      return importInput;
    }

    // Parameters (includes gust/turbulence)
    // -------------------------------------------------------------------------

    const DEFAULTS = {

  // Performance
      shadowsEnabled: true,
      shadowsAutoUpdate: true,
      shadowType: "PCFSoft",   // "PCFSoft" | "PCF" | "Basic"
      shadowMapSize: 1024,     // 256 | 512 | 1024 | 2048 | 4096

  // Core
      paused: false,
      debug: false,
      timeScale: 1.0,
      dtMax: 0.020,
      pixelRatio: 1.75,

  // Flakes & base wind
      snowEnabled: true,
      visualCount: 180000,
      windStrength: 0,
      windSpeed: 0,
      fallSpeed: 0.42,
      fallJitter: 0.45,
      flakeSize: 3.0,
      flakeSizeJitter: 0.35,


  // Gusts / turbulence
      gustMinInterval: 1.4,
      gustMaxInterval: 3.2,
      gustTornadoChance: 0.22,
      gustStrengthMul: 1.0,
      gustSwirlMul: 1.0,
      gustUpdraftMul: 1.0,
      gustScour: 0.0100,
      gustRedeposit: 0.0080,

  // Drifts / cover
      driftGrid: 2048,
      driftMaxHeight: 3.6,
      coverBase: 0.06,
      coverMacroAmp: 0.09,
      coverMacroFreq: 2.4,
      coverMicroAmp: 0.05,
      coverMicroFreq: 8.5,


  // Terrain (procedural base heightfield; saved with worlds)
      terrainEnabled: false,
      terrainSeed: 1337,
      terrainRadius: 80.0,
      terrainInnerRadius: 0.0,
      terrainEdgeFade: 10.0,
      terrainEdgeNoiseAmp: 0.18,
      terrainEdgeNoiseFreq: 0.025,

      terrainAmp: 1.2,
      terrainFreq: 0.035,
      terrainOctaves: 5,
      terrainLacunarity: 2.0,
      terrainGain: 0.5,
      terrainWarpAmp: 12.0,
      terrainWarpFreq: 0.012,
      terrainRidge: false,
      terrainExponent: 1.35,

      terrainColorLow: "#e9f1ff",
      terrainColorHigh: "#ffffff",
      terrainColorStrength: 0.25,



      driftDiffusion: 0.07,
      driftAdvection: 0.125,
      obstacleShapeInterval: 10,
      driftWriteInterval: 8,
      normalUpdateInterval: 36,

  // Settlers & deposition
      settlerCount: 8000,
      groundDepositBudget: 420,
      depositUnit: 0.00035,
      objectTestsPerFrame: 900,
      objectDeposit: 0.002,

  // Sticking decals
      stuckMax: 24000,
      decalSize: 0.14,

  // Fog
      fogNear: 18,
      fogFar: 60,
      fogColor: "#0a1220",

  // Surface colors
      groundColor: "#ffffff",
      rockColor: "#2b3442",
      forestColor: "#2b7a2b",
      cubeColor: "#4e9cff",      

  // Snowman path animation
      snowmanMoveEnabled: true,
      snowmanPathRadius: 4.0,  // approximate radius of his wander area
      snowmanSpeed: 0.03,       // loops per second (small = snail-slow)

      // Forest
      forestCount: 24,
      forestRadius: 14,
      forestInnerRadius: 3,
      forestMinScale: 0.7,
      forestMaxScale: 1.6,
      forestSeed: 1234,
      forestJitter: 1.0,

      // Rocks
      rockCount: 18,
      rockRadius: 16,
      rockInnerRadius: 2,
      rockMinScale: 0.65,
      rockMaxScale: 1.85,
      rockSeed: 2468,
      rockJitter: 1.0,

      // Clouds
      cloudEnabled: true,
      cloudHeightBase: 18.0,
      cloudHeightRange: 6.0,
      cloudRadius: 40.0,
      cloudSliceCount: 10,
      cloudSpeed: 0.010,
      cloudDensity: 0.85,
      cloudSoftness: 0.25,
      cloudColor: "#f5f7ff",
      cloudSkyColor: "#0a1220",
      cloudOpacity: 1.35,

      // Dust / fire column (atmospheric phenomenon; persisted in worlds/presets)
      dustEnabled: false,
      dustRadius: 5.0,
      dustFloorY: 0.10,
      dustCeilY: 4.0,
      dustSpeed: 2.3,
      dustCount: 600,
      dustSize: 0.10,
      dustNoise: 0.10,
      dustCenterX: 0.0,
      dustCenterZ: -3.5,
      dustColorInner: "#ffc57a",
      dustColorOuter: "#222222",


      // Rain (GPU point-sprite streaks; persisted in worlds/presets)
      rainEnabled: false,
      rainRadius: 28.0,
      rainTopY: 26.0,
      rainBottomY: 0.0,
      rainSpeed: 2.4,
      rainCount: 12000,
      rainSize: 0.12,
      rainThickness: 0.06,
      rainStreak: 0.85,
      rainWindX: 0.40,
      rainWindZ: 0.10,
      rainCenterX: 0.0,
      rainCenterZ: 0.0,
      rainColor: "#bcd7ff",
      rainOpacity: 0.30,


      // Grass (instanced blades + wind shader; persisted in worlds/presets)
      grassEnabled: false,
      grassCount: 9000,
      grassRadius: 26.0,
      grassCenterX: 0.0,
      grassCenterZ: 0.0,
      grassBaseY: 0.02,
      grassBladeHeight: 0.22,
      grassBladeWidth: 0.055,
      grassHeightJitter: 0.55,
      grassWidthJitter: 0.50,
      grassBend: 0.55,
      grassWindSpeed: 1.6,
      grassWindStrength: 1.0,
      grassStiffness: 1.7,

      grassNoiseScale: 0.35,
      grassNoiseStrength: 0.75,
      grassNoiseSpeed: 0.35,

      grassStaticHeightNoise: 0.35,
      grassStaticWidthNoise: 0.35,
      grassBorderNoise: 0.35,

      grassColorVariation: 0.12,

      grassColorBottom: "#1f5f2e",
      grassColorTop: "#7ee36c",
      grassOpacity: 0.95,
      grassAlphaCutoff: 0.03,
      grassSeed: 4242,




    };


    const params = { ...DEFAULTS };


    // Scene globals
    // -------------------------------------------------------------------------

    const GROUND_SIZE = 1050;
    const HALF_GROUND = GROUND_SIZE * 0.5;

    /**
     * Playable world bounds in X/Z. Defaults to the ground plane edge (HALF_GROUND).
     * Adjust this single value to expand/shrink the playable area without touching other systems.
     */
    const WORLD_BOUNDS_XZ = HALF_GROUND;

    const visualBounds = { x: WORLD_BOUNDS_XZ, z: WORLD_BOUNDS_XZ, yMin: -2.0, yMax: 22.0 };
    const settleBounds = { x: WORLD_BOUNDS_XZ, z: WORLD_BOUNDS_XZ, yMin: -2.0, yMax: 18.0 };


    let scene, camera, renderer, controls, hemiLight, dirLight;
    let ground, cube;
    const cones = [];
    const rocks = [];

    /* Tracks last-applied renderer/light shadow settings to avoid per-frame churn. */
    const shadowApplied = {
      enabled: null,
      autoUpdate: null,
      typeKey: null,
      mapSize: null
    };


    // Forest cone shared resources
    let forestConeGeo = null;
    let forestConeMat = null;

    // Rock shared resources
    let rockGeo = null;
    let rockMat = null;
    let rockGeoMidY = 0.0;

    let snowTex;
    let wetTrailTex;
    let wetFootTex;
    let wetFootSig = ""; 


    function updateFogFromParams() {
      if (!scene) return;

      const color = new THREE.Color(params.fogColor || "#0a1220");
      scene.background = color;
      scene.fog = new THREE.Fog(color, params.fogNear, params.fogFar);
    }

    /* Normalizes color values to "#rrggbb" for persistence and GUI compatibility. */
    function normalizeHexColor(value, fallback = "#ffffff") {
      if (typeof fallback !== "string" || !fallback.trim()) fallback = "#ffffff";

      if (typeof value === "number" && Number.isFinite(value)) {
        const n = (value >>> 0) & 0xffffff;
        return `#${n.toString(16).padStart(6, "0")}`;
      }

      if (typeof value !== "string") return fallback;

      const s = value.trim();
      if (!s) return fallback;

      if (s[0] === "#") {
        const hex = s.slice(1);
        if (/^[0-9a-fA-F]{3}$/.test(hex)) {
          return `#${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}`.toLowerCase();
        }
        if (/^[0-9a-fA-F]{6}$/.test(hex)) return `#${hex.toLowerCase()}`;
        return fallback;
      }

      if (/^0x[0-9a-fA-F]{6}$/.test(s)) return `#${s.slice(2).toLowerCase()}`;

      return fallback;
    }

    /* Applies persisted surface colors to existing materials (ground/rocks/forest/cube). */
    function applySurfaceColorsFromParams() {
      const g = normalizeHexColor(params.groundColor, DEFAULTS.groundColor || "#ffffff");
      const r = normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442");
      const f = normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b");
      const c = normalizeHexColor(params.cubeColor, DEFAULTS.cubeColor || "#4e9cff");

      if (ground && ground.material && ground.material.color) {
        ground.material.color.set(g);
      }

      if (cube && cube.material && cube.material.color) {
        cube.material.color.set(c);
      }

      if (rockMat && rockMat.color) {
        rockMat.color.set(r);
      }

      if (forestConeMat && forestConeMat.color) {
        forestConeMat.color.set(f);
      }
    }



    // Clouds runtime
    let cloudLayer = null;
    let cloudMaterial = null;

    // Dust runtime
    const dustCenterTmp = new THREE.Vector3();
    let dustGeometry = null;
    let dustMaterial = null;
    let dustPoints = null;
    let dustUniforms = null;
    let dustLastCount = -1;

    // Rain runtime
    const rainCenterTmp = new THREE.Vector3();
    let rainGeometry = null;
    let rainMaterial = null;
    let rainPoints = null;
    let rainUniforms = null;
    let rainLastCount = -1;



      // -------------------------------------------------------------------------
      // Minimal WebAudio: background mp3 + simple gust FX
      // -------------------------------------------------------------------------

    let audioListener = null;
    let audioCtx = null;
    let audioMaster = null;

    let musicGain = null;
    let musicSource = null;
    let musicBuffer = null;
    let musicEnabled = false;

      // Put your mp3 here
    const MUSIC_URL = "./audio/song.mp3";
    const MUSIC_MAX_GAIN = 0.35;

    function initAudio() {
      if (audioListener) return;
      if (!camera) return;

      audioListener = new THREE.AudioListener();
      camera.add(audioListener);

      audioCtx = audioListener.context;

      audioMaster = audioCtx.createGain();
      audioMaster.gain.value = 1.0;
      audioMaster.connect(audioCtx.destination);

      musicGain = audioCtx.createGain();
      musicGain.gain.value = 0.0;
      musicGain.connect(audioMaster);
    }

    async function ensureAudioResumed() {
      if (!audioCtx) return;
      if (audioCtx.state === "suspended") {
        await audioCtx.resume();
      }
    }

    async function loadMusicBuffer() {
      if (musicBuffer) return musicBuffer;
      if (!audioCtx) return null;

      const res = await fetch(MUSIC_URL);
      const arr = await res.arrayBuffer();
      musicBuffer = await audioCtx.decodeAudioData(arr);
      return musicBuffer;
    }

    async function startMusic() {
      if (!audioListener) initAudio();
      if (!audioCtx) return;

      await ensureAudioResumed();
      const buffer = await loadMusicBuffer();
      if (!buffer) return;

      if (musicSource) {
        musicSource.stop();
        musicSource.disconnect();
        musicSource = null;
      }

      const src = audioCtx.createBufferSource();
      src.buffer = buffer;
      src.loop = true;
      src.connect(musicGain);
      src.start();

      musicSource = src;
      musicEnabled = true;

      const now = audioCtx.currentTime;
      musicGain.gain.cancelScheduledValues(now);
      musicGain.gain.setValueAtTime(musicGain.gain.value, now);
      musicGain.gain.linearRampToValueAtTime(MUSIC_MAX_GAIN, now + 2.0);
    }

    function stopMusic() {
      if (!audioCtx || !musicSource) {
        musicEnabled = false;
        return;
      }

      const now = audioCtx.currentTime;
      musicGain.gain.cancelScheduledValues(now);
      musicGain.gain.setValueAtTime(musicGain.gain.value, now);
      musicGain.gain.linearRampToValueAtTime(0.0, now + 1.5);

      musicSource.stop(now + 1.6);
      musicSource.disconnect();
      musicSource = null;
      musicEnabled = false;
    }

      // Short filtered-noise whoosh for gusts
    function playGustFx(strength) {
      if (!audioCtx || !audioMaster) return;
      if (audioCtx.state === "suspended") return;

      const ctx = audioCtx;
      const duration = 0.8;
      const now = ctx.currentTime;

      const bufferSize = Math.floor(ctx.sampleRate * duration);
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);

      for (let i = 0; i < bufferSize; i++) {
        const t = i / bufferSize;
        const fadeIn = Math.min(1.0, t * 4.0);
        const fadeOut = 1.0 - t;
        data[i] = (Math.random() * 2.0 - 1.0) * fadeIn * fadeOut;
      }

      const src = ctx.createBufferSource();
      src.buffer = buffer;

      const bp = ctx.createBiquadFilter();
      bp.type = "bandpass";
      bp.frequency.value = 400 + Math.random() * 600;
      bp.Q.value = 0.8 + Math.random() * 1.2;

      const gain = ctx.createGain();
      const peak = 0.5 * (strength || 1.0);
      gain.gain.setValueAtTime(0.0001, now);
      gain.gain.linearRampToValueAtTime(peak, now + 0.1);
      gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

      src.connect(bp);
      bp.connect(gain);
      gain.connect(audioMaster);

      src.start(now);
      src.stop(now + duration + 0.05);
    }



    // GLTF / DRACO model system
    // ---------------------------------------------------------------------------

    const modelTemplates = {};   // name -> THREE.Object3D (original loaded scene)
    const modelInstances = {};   // id   -> THREE.Object3D (instance in scene)

    // Configure all GLB models and their instances here.

    // -------------------------------------------------------------------------
    // World editor mode (TransformControls selection + move/rotate/scale)
    // -------------------------------------------------------------------------

    let transformControls = null;
    let transformControlsHelper = null;

    const worldEditState = {
      enabled: false,
      selected: null
    };

    const worldEditSelectableRoots = new Set();
    const worldEditPointerNDC = new THREE.Vector2();
    const worldEditRaycaster = new THREE.Raycaster();

    const worldEditObbBox = new THREE.Box3();
    const worldEditObbCenter = new THREE.Vector3();
    const worldEditObbSize = new THREE.Vector3();
    const worldEditObbQuat = new THREE.Quaternion();
    const worldEditObbEuler = new THREE.Euler(0, 0, 0, "YXZ");


    /**
     * Registers a model instance root as selectable in world editor mode.
     */
    function registerWorldEditRoot(root, instCfg) {
      if (!root || !instCfg) return;
      worldEditSelectableRoots.add(root);

      root.userData.worldEditSelectable = true;
      root.userData.worldEditId = instCfg.id || "";
    }

    /**
     * Returns true when `obj` is a descendant of `ancestor` in the scene graph.
     */
    function isDescendantOf(obj, ancestor) {
      let n = obj;
      while (n) {
        if (n === ancestor) return true;
        n = n.parent;
      }
      return false;
    }



    /**
     * Clears current world editor selection, hides the gizmo, and refreshes UI state.
     */
    function clearWorldEditSelection() {
      worldEditState.selected = null;

      if (transformControls) {
        transformControls.detach();
      }

      if (transformControlsHelper) {
        transformControlsHelper.visible = false;
      }

      updateAvatarButtons();
    }


    /**
     * Selects a world-editable root, attaches TransformControls to it, and refreshes UI state.
     */
    function selectWorldEditRoot(root) {
      if (!root || !worldEditSelectableRoots.has(root) || !transformControls) return;

      worldEditState.selected = root;
      transformControls.attach(root);

      if (transformControlsHelper) {
        transformControlsHelper.visible = true;
      }

      if (controls) {
        controls.autoRotate = false;
      }

      updateAvatarButtons();
    }


    /**
     * Rebuilds collision/sticking bounds after a world edit transform is committed.
     */
    function commitWorldEditTransform() {
      if (colliderObjects && colliderObjects.length) {
        colliderBounds = buildColliderBounds(colliderObjects);
        rebuildAvatarCollisionGrid();
      }

      if (avatarModelColliderObjects && avatarModelColliderObjects.length && Array.isArray(avatarModelColliderOBBs)) {
        avatarModelColliderOBBs.length = 0;

        for (const root of avatarModelColliderObjects) {
          if (!root) continue;

          root.updateWorldMatrix(true, true);

          worldEditObbBox.setFromObject(root);
          if (!Number.isFinite(worldEditObbBox.min.x) || !Number.isFinite(worldEditObbBox.max.x)) continue;

          worldEditObbBox.getCenter(worldEditObbCenter);
          worldEditObbBox.getSize(worldEditObbSize);

          root.getWorldQuaternion(worldEditObbQuat);
          worldEditObbEuler.setFromQuaternion(worldEditObbQuat);

          const hx = Math.max(0.10, (worldEditObbSize.x * 0.5) * 0.48);
          const hz = Math.max(0.10, (worldEditObbSize.z * 0.5) * 0.48);

          avatarModelColliderOBBs.push({
            id: root.userData.worldEditId || "",
            object: root,
            center: worldEditObbCenter.clone(),
            halfX: hx,
            halfZ: hz,
            yaw: worldEditObbEuler.y
          });
        }
      }

      if (vehiclePromptState && vehiclePromptState.open) {
        tickVehicleProximity();
      }
    }

    /**
     * Enables/disables world editor mode. When disabled, selection is cleared.
     */
    function setWorldEditEnabled(enabled) {
      const next = !!enabled;
      if (worldEditState.enabled === next) return;

      worldEditState.enabled = next;

      if (!next) {
        clearWorldEditSelection();
      } else {
        if (transformControlsHelper) {
          transformControlsHelper.visible = !!worldEditState.selected;
        }
      }

      updateAvatarButtons();
    }

    // World editor history + duplicate/delete + undo/redo
    // -------------------------------------------------------------------------

    const worldEditHistory = {
      undo: [],
      redo: [],
      limit: 64,
      applying: false,
      dragPushed: false
    };

    /**
     * Ensures edits are applied to a mutable worldModelsConfig (never mutates MODEL_CONFIG).
     * Initializes from the current scene snapshot so transforms/features are preserved.
     */
    function ensureEditableWorldModelsConfig() {
      if (worldModelsConfig) return;

      const snap = snapshotWorldModelsConfig();
      const normalized = normalizeWorldModelsConfig(snap);

      worldModelsConfig = normalized || JSON.parse(JSON.stringify(MODEL_CONFIG));
      worldModelsConfigLoaded = true;

      for (const entry of worldModelsConfig) {
        if (!entry || !Array.isArray(entry.instances)) continue;

        for (const instCfg of entry.instances) {
          if (!instCfg || typeof instCfg !== "object") continue;

          const id = instCfg.id != null ? String(instCfg.id) : "";
          const inst = id ? modelInstances[id] : null;
          if (!inst) continue;

          Object.defineProperty(instCfg, "runtimeObject", {
            value: inst,
            enumerable: false,
            configurable: true
          });
        }
      }
    }

    /**
     * Pushes a snapshot of the current world models state to the undo stack and clears redo.
     */
    function pushWorldEditUndoSnapshot() {
      if (worldEditHistory.applying) return;

      ensureEditableWorldModelsConfig();

      const snap = snapshotWorldModelsConfig();
      worldEditHistory.undo.push(snap);

      if (worldEditHistory.undo.length > worldEditHistory.limit) {
        worldEditHistory.undo.shift();
      }

      worldEditHistory.redo.length = 0;
    }

    /**
     * Finds the (entry, instCfg, instIndex) that owns a given runtime root.
     */
    function findWorldEditConfigForRoot(root) {
      const base = worldModelsConfig || MODEL_CONFIG;

      for (let ei = 0; ei < base.length; ei++) {
        const entry = base[ei];
        if (!entry || !Array.isArray(entry.instances)) continue;

        for (let ii = 0; ii < entry.instances.length; ii++) {
          const instCfg = entry.instances[ii];
          if (!instCfg || typeof instCfg !== "object") continue;

          const bound = instCfg.runtimeObject || null;
          if (bound === root) return { entry, instCfg, entryIndex: ei, instIndex: ii };

          const id = instCfg.id != null ? String(instCfg.id) : "";
          if (id && modelInstances[id] === root) return { entry, instCfg, entryIndex: ei, instIndex: ii };
        }
      }

      return null;
    }

    /**
     * Generates a unique instance id for duplicates (keeps exporter/importer stable).
     */
    function makeUniqueWorldModelId(seed) {
      const base = worldModelsConfig || MODEL_CONFIG;
      const ids = new Set();

      for (const e of base) {
        if (!e || !Array.isArray(e.instances)) continue;
        for (const inst of e.instances) {
          const id = inst && inst.id != null ? String(inst.id) : "";
          if (id) ids.add(id);
        }
      }

      for (const k in modelInstances) ids.add(String(k));

        const cleanSeed = String(seed || "model").trim() || "model";
      let baseId = cleanSeed.endsWith("_copy") ? cleanSeed : `${cleanSeed}_copy`;

      if (!ids.has(baseId)) return baseId;

      let n = 2;
      while (true) {
        const cand = `${baseId}${n}`;
        if (!ids.has(cand)) return cand;
        n++;
      }
    }

    /**
     * Applies instCfg transform values to a runtime instance.
     */
    function applyInstCfgTransformToInstance(inst, instCfg) {
      const p = instCfg.position || [0, 0, 0];
      const r = instCfg.rotation || [0, 0, 0];
      const s = instCfg.scale != null ? instCfg.scale : 1.0;

      inst.position.set(p[0] || 0, p[1] || 0, p[2] || 0);
      inst.rotation.set(r[0] || 0, r[1] || 0, r[2] || 0);

      if (Array.isArray(s) && s.length === 3) {
        inst.scale.set(s[0] || 1, s[1] || 1, s[2] || 1);
      } else {
        const u = Number.isFinite(s) ? s : 1.0;
        inst.scale.setScalar(u);
      }
    }

    /**
     * Syncs a runtime instance transform back into its instCfg (position/rotation/scale).
     */
    function syncInstanceTransformToInstCfg(inst, instCfg) {
      instCfg.position = [inst.position.x, inst.position.y, inst.position.z];
      instCfg.rotation = [inst.rotation.x, inst.rotation.y, inst.rotation.z];

      const sx = inst.scale.x;
      const sy = inst.scale.y;
      const sz = inst.scale.z;

      const eps = 1e-6;
      const uniform = Math.abs(sx - sy) < eps && Math.abs(sx - sz) < eps;

      instCfg.scale = uniform ? sx : [sx, sy, sz];
    }

    /**
     * Builds an OBB record for a model root (used by avatar collisions).
     */
    function buildWorldEditOBBForRoot(root, id) {
      root.updateWorldMatrix(true, true);

      worldEditObbBox.setFromObject(root);
      if (!Number.isFinite(worldEditObbBox.min.x) || !Number.isFinite(worldEditObbBox.max.x)) return null;

      worldEditObbBox.getCenter(worldEditObbCenter);
      worldEditObbBox.getSize(worldEditObbSize);

      root.getWorldQuaternion(worldEditObbQuat);
      worldEditObbEuler.setFromQuaternion(worldEditObbQuat);

      const hx = Math.max(0.10, (worldEditObbSize.x * 0.5) * 0.48);
      const hz = Math.max(0.10, (worldEditObbSize.z * 0.5) * 0.48);

      return {
        id: id || "",
        object: root,
        center: worldEditObbCenter.clone(),
        halfX: hx,
        halfZ: hz,
        yaw: worldEditObbEuler.y
      };
    }

    /**
     * Removes a model instance from the scene and runtime maps by id.
     */
    function removeWorldModelInstanceById(id) {
      const key = String(id || "");
      if (!key) return;

      const inst = modelInstances[key] || null;
      if (!inst) return;

      if (transformControls && worldEditState.selected === inst) {
        clearWorldEditSelection();
      }

      if (inst.parent) inst.parent.remove(inst);
      delete modelInstances[key];
    }

    /**
     * Rebuilds runtime caches for world models without touching non-model colliders (forest/rocks/etc).
     */
    function rebuildWorldModelsRuntimeCaches() {
      vehicleInteractables.length = 0;
      setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);

      avatarModelColliderObjects.length = 0;
      avatarModelColliderBounds.length = 0;
      avatarModelColliderOBBs.length = 0;

      colliderObjects = colliderObjects.filter((obj) => !(obj && obj.userData && obj.userData.worldModelStick));

      worldEditSelectableRoots.clear();
      clearWorldEditSelection();

      const base = worldModelsConfig || MODEL_CONFIG;

      for (const entry of base) {
        if (!entry || !Array.isArray(entry.instances)) continue;

        for (const instCfg of entry.instances) {
          if (!instCfg || typeof instCfg !== "object") continue;

          const id = instCfg.id != null ? String(instCfg.id) : "";
          const inst = (instCfg.runtimeObject || (id ? modelInstances[id] : null)) || null;
          if (!inst) continue;

          Object.defineProperty(instCfg, "runtimeObject", {
            value: inst,
            enumerable: false,
            configurable: true
          });

          registerWorldEditRoot(inst, instCfg);

          inst.traverse((obj) => {
            if (!obj.isMesh) return;
            obj.castShadow = true;
            obj.receiveShadow = true;

            if (instCfg.stick) {
              obj.userData.worldModelStick = true;
              colliderObjects.push(obj);
            }
          });

          if (instCfg.vehicle) {
            registerVehicleInstance(inst, instCfg);
          }

          if (instCfg.collide) {
            avatarModelColliderObjects.push(inst);
            const obb = buildWorldEditOBBForRoot(inst, id);
            if (obb) avatarModelColliderOBBs.push(obb);
          }
        }
      }

      if (colliderObjects.length) {
        colliderBounds = buildColliderBounds(colliderObjects);
        rebuildAvatarCollisionGrid();
      }

      if (vehiclePromptState && vehiclePromptState.open) {
        tickVehicleProximity();
      }
    }

    /**
     * Applies a full world-models snapshot to the scene (adds/removes instances by id and updates transforms).
     */
    function applyWorldModelsSnapshot(snapshot) {
      const normalized = normalizeWorldModelsConfig(snapshot);
      if (!normalized) return;

      worldEditHistory.applying = true;

      try {
        const desiredIds = new Set();
        const desiredById = new Map();

        for (const entry of normalized) {
          if (!entry || !Array.isArray(entry.instances)) continue;

          for (const instCfg of entry.instances) {
            if (!instCfg || typeof instCfg !== "object") continue;

            const id = instCfg.id != null ? String(instCfg.id) : "";
            if (!id) continue;

            desiredIds.add(id);
            desiredById.set(id, { entryName: entry.name, instCfg });
          }
        }

        for (const id in modelInstances) {
          if (!desiredIds.has(String(id))) {
            removeWorldModelInstanceById(id);
          }
        }

        for (const [id, rec] of desiredById.entries()) {
          let inst = modelInstances[id] || null;

          if (!inst) {
            const template = modelTemplates[rec.entryName] || null;
            if (!template) continue;

            inst = template.clone(true);
            scene.add(inst);
            modelInstances[id] = inst;
          }

          applyInstCfgTransformToInstance(inst, rec.instCfg);
        }

        worldModelsConfig = normalized;
        worldModelsConfigLoaded = true;

        for (const entry of worldModelsConfig) {
          if (!entry || !Array.isArray(entry.instances)) continue;

          for (const instCfg of entry.instances) {
            if (!instCfg || typeof instCfg !== "object") continue;
            const id = instCfg.id != null ? String(instCfg.id) : "";
            const inst = id ? (modelInstances[id] || null) : null;
            if (!inst) continue;

            Object.defineProperty(instCfg, "runtimeObject", {
              value: inst,
              enumerable: false,
              configurable: true
            });
          }
        }

        rebuildWorldModelsRuntimeCaches();
      } finally {
        worldEditHistory.applying = false;
      }
    }

    /**
     * Performs an undo (restores previous snapshot). Redo receives the current snapshot.
     */
    function worldEditUndo() {
      if (!worldEditHistory.undo.length) return;

      ensureEditableWorldModelsConfig();

      const current = snapshotWorldModelsConfig();
      const prev = worldEditHistory.undo.pop();

      worldEditHistory.redo.push(current);
      if (worldEditHistory.redo.length > worldEditHistory.limit) {
        worldEditHistory.redo.shift();
      }

      applyWorldModelsSnapshot(prev);
      updateAvatarButtons();
      showActionToast("Undo");
    }


    /**
     * Performs a redo (restores next snapshot). Undo receives the current snapshot.
     */
    function worldEditRedo() {
      if (!worldEditHistory.redo.length) return;

      ensureEditableWorldModelsConfig();

      const current = snapshotWorldModelsConfig();
      const next = worldEditHistory.redo.pop();

      worldEditHistory.undo.push(current);
      if (worldEditHistory.undo.length > worldEditHistory.limit) {
        worldEditHistory.undo.shift();
      }

      applyWorldModelsSnapshot(next);
      updateAvatarButtons();
      showActionToast("Redo");
    }


    /**
     * Duplicates the selected model instance (Shift+D).
     */
    function duplicateSelectedWorldModel() {
      if (!worldEditState.enabled || !worldEditState.selected) return;

      ensureEditableWorldModelsConfig();

      const found = findWorldEditConfigForRoot(worldEditState.selected);
      if (!found) return;

      pushWorldEditUndoSnapshot();

      const srcRoot = worldEditState.selected;
      const srcCfg = found.instCfg;

      const dupCfg = JSON.parse(JSON.stringify(srcCfg));
      dupCfg.id = makeUniqueWorldModelId(srcCfg.id || found.entry.name);

      syncInstanceTransformToInstCfg(srcRoot, dupCfg);

      if (!Array.isArray(dupCfg.position)) dupCfg.position = [0, 0, 0];
      if (dupCfg.position.length < 3) dupCfg.position = [dupCfg.position[0] || 0, dupCfg.position[1] || 0, dupCfg.position[2] || 0];

      dupCfg.position[0] += 1.0;
      dupCfg.position[2] += 1.0;

      found.entry.instances.splice(found.instIndex + 1, 0, dupCfg);

      const template = modelTemplates[found.entry.name] || null;
      if (!template) return;

      const inst = template.clone(true);
      applyInstCfgTransformToInstance(inst, dupCfg);

      Object.defineProperty(dupCfg, "runtimeObject", {
        value: inst,
        enumerable: false,
        configurable: true
      });

      scene.add(inst);
      modelInstances[dupCfg.id] = inst;

      rebuildWorldModelsRuntimeCaches();
      selectWorldEditRoot(inst);
      updateAvatarButtons();
      showActionToast("Cloned");
    }


    /**
     * Deletes the selected model instance (X).
     */
    function deleteSelectedWorldModel() {
      if (!worldEditState.enabled || !worldEditState.selected) return;

      ensureEditableWorldModelsConfig();

      const found = findWorldEditConfigForRoot(worldEditState.selected);
      if (!found) return;

      pushWorldEditUndoSnapshot();

      const root = worldEditState.selected;
      const id = found.instCfg.id != null ? String(found.instCfg.id) : "";

      clearWorldEditSelection();

      if (root.parent) root.parent.remove(root);
      if (id && modelInstances[id] === root) delete modelInstances[id];

      found.entry.instances.splice(found.instIndex, 1);

      rebuildWorldModelsRuntimeCaches();
      updateAvatarButtons();
      showActionToast("Deleted");
    }





    /**
     * Handles canvas pointer picking for world editor selection.
     */
    function onWorldEditPointerDown(event) {
      if (!worldEditState.enabled) return;
      if (!renderer || !camera || !transformControls) return;
      if (event.button !== 0) return;
      if (transformControls.dragging) return;

      const rect = renderer.domElement.getBoundingClientRect();
      const nx = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const ny = -(((event.clientY - rect.top) / rect.height) * 2 - 1);

      worldEditPointerNDC.set(nx, ny);
      worldEditRaycaster.setFromCamera(worldEditPointerNDC, camera);

      const roots = Array.from(worldEditSelectableRoots);
      if (!roots.length) return;

      const hits = worldEditRaycaster.intersectObjects(roots, true);

      let pickedRoot = null;

      for (const h of hits) {
        let obj = h.object;
        if (!obj) continue;

        if (transformControlsHelper && isDescendantOf(obj, transformControlsHelper)) continue;

        while (obj && !worldEditSelectableRoots.has(obj)) {
          obj = obj.parent;
        }

        if (obj && worldEditSelectableRoots.has(obj)) {
          pickedRoot = obj;
          break;
        }
      }

      if (!pickedRoot) {
        clearWorldEditSelection();
        return;
      }

      selectWorldEditRoot(pickedRoot);
    }




    // Per-instance `stick: true` means “snow can stick to this model”.

    const MODEL_CONFIG = [

      {
        name: "model1",
        url: "models/gingerbread_man-c.glb",
        instances: [
          {
            id: "model1_center",
            position: [3, 0, -5],
            rotation: [0, 0, 0],
            scale: 1.0,
            stick: true,
            collide: false
          }
        ]
      },

      {
        name: "5gmast",
        url: "models/buildings/5gmast.glb",
        instances: [
          {
            id: "5gmast_center",
            position: [3, 0, -5],
            rotation: [0, 0, 0],
            scale: 1.0,
            stick: true,
            collide: false
          }
        ]
      },

      {
        name: "box1",
        url: "models/boxes/box1.glb",
        instances: [
          {
            id: "box1_center",
            position: [3, 0, -5],
            rotation: [0, 0, 0],
            scale: 1.0,
            stick: false,
            collide: false
          }
        ]
      },      

      {
        name: "trees1",
        url: "models/trees/trees.glb",
        instances: [
          {
            id: "tree_center",
            position: [10, 0, -10],
            rotation: [0, 0, 0],
            scale: 1.0,
            stick: false,
            collide: false
          }
        ]
      }, 

      {
        name: "box",
        url: "models/boxes/box1.glb",
        instances: [
          {
            id: "box_center",
            position: [14, 0, -12],
            rotation: [0, 0, 0],
            scale: 1.0,
            stick: false,
            collide: false
          }
        ]
      }, 


      {
        name: "house",
        url: "models/buildings/house.glb",
        instances: [
          {
            id: "house_center",
            position: [21, -1, -11],
            rotation: [0, 0, 0],
            scale: 1.0,
            stick: false,
            collide: true
          }
        ]
      },       


      {
        name: "cinema",
        url: "models/buildings/cinema/ashford-cinema-1.glb",
        instances: [
          {
            id: "cinema_center",
            position: [32, -1, -18],
            rotation: [0, 0, 0],
            scale: 1.0,
            stick: false,
            collide: true
          }
        ]
      }, 



      {
        name: "model2",
        url: "models/christmas_tree_polycraft-c.glb",
        instances: [
          {
            id: "tree_center",
            position: [0, 0, 0],
            rotation: [0, 0, 0],
            scale: 0.05,
            stick: true,
            collide: false
          }
        ]
      },
      {
        name: "model3",
        url: "models/snowman-c.glb",
        instances: [
          {
            id: "snowman",
            position: [-7, -0.2, -1],
            rotation: [0, 1, 0],
            scale: 1.0,
            stick: false,
            collide: false
          }
        ]
      },
      {
        name: "model4",
        url: "models/car-c.glb",
        instances: [
          {
            id: "car",
            position: [4, -0.5, 6],
            rotation: [0, 1, 0],
            scale: 1.0,
            stick: false,
            collide: false,
            vehicle: {
              type: "Car",
              description: "Ground vehicle",
              seatLocal: [0.0, 0.55, 0.15],
              yawOffset: 0.0,
              profile: {
                maxSpeed: 1.0,
                maxReverse: 1.0,
                accel: 10.0,
                brake: 14.0,
                coastDecel: 3.2,
                turnRate: 5,
                radius: 0.85
              }
            }
          }
        ]
      },




      {
        name: "plane",
        url: "models/vehicles/flying/plane1.glb",

        instances: [
          {
            id: "plane",
            position: [4, 0, 15],
            rotation: [0, 1.5, 0],
            scale: 1.0,
            stick: false,
            collide: true,

            vehicle: {
              type: "Small Airplane",
              description: "Small Airplane 1",
              seatLocal: [0.0, 0.8, -0.43],
              yawOffset: 0.0,
              profile: {
                maxSpeed: 27.2,
                maxReverse: 2.1,
                accel: 7.1,
                brake: 2.7,
                coastDecel: 1.7,
                turnRate: 0.6,
                radius: 0.95,
                wheelBase: 2.66,
                minTurnRadius: 7.7,
                minSteerSpeed: 0.35,
                steerResponse: 2.0,
                steerReturn: 6.0,
                lateralGrip: 8.0,
                wetWidth: 0.05,
                wetLength: 1.04,
                trackHalfWidth: 1.0,
                airRollResponse: 1.7,
                airRollReturn: 5.0,
                climbPitchMax: 0.17,
                climbPitchSpeed: 6.6,
                pitchResponse: 3.2,
                pitchReturn: 0.1,
                turnPitchMax: 0.08,
                propAxis: "z",
                airRollMax: 1.18,
                airTurnScale: 0.21,
                liftResponse: 0.1,
                maxLift: 21.9,
                minFlySpeed: 22.3
              }
            }
          }
        ]
      },

      {
        name: "plane2",
        url: "models/vehicles/flying/plane2.glb",
        
        instances: [
          {
            id: "plane2",
            position: [4, 0, 35],
            rotation: [0, 1.5, 0],
            scale: 1.0,
            stick: false,
            collide: true,

            vehicle: {
              type: "Small Airplane 2",
              description: "Small Airplane 2",

              seatLocal: [0.19, 0.82, -0.91],

              yawOffset: 0.0,
              profile: {
                maxSpeed: 27.2,
                maxReverse: 2.1,
                accel: 7.1,
                brake: 2.7,
                coastDecel: 1.7,
                turnRate: 0.6,
                radius: 0.95,
                wheelBase: 2.66,
                minTurnRadius: 7.7,
                minSteerSpeed: 0.35,
                steerResponse: 2.0,
                steerReturn: 6.0,
                lateralGrip: 8.0,

                wetWidth: 0.05,
                wetLength: 1.04,
                
                trackHalfWidth: 1.57,

                airRollResponse: 1.7,
                airRollReturn: 5.0,
                climbPitchMax: 0.17,
                climbPitchSpeed: 6.6,
                pitchResponse: 3.2,
                pitchReturn: 0.1,
                turnPitchMax: 0.08,
                propAxis: "z",
                airRollMax: 1.18,
                airTurnScale: 0.21,
                liftResponse: 0.1,
                maxLift: 21.9,
                minFlySpeed: 22.3
              }
            }
          }
        ]
      },


      {
        name: "skipatrol",
        url: "models/vehicles/ski_patrol1.glb",
        instances: [
          {
            id: "skipatrol",
            position: [9, 0, 4],
            rotation: [0, 1, 0],
            scale: 1.0,
            stick: false,
            collide: true,

            // MODEL_CONFIG -> instance "skipatrol" (Ski Patrol)
            vehicle: {
              type: "Ski Patrol",
              description: "Snow vehicle / patrol sled",
              seatLocal: [0.0, 0.034, -0.52],
              yawOffset: 0.0,
              profile: {
                maxSpeed: 11.2,
                maxReverse: 5.0,
                accel: 4.2,
                brake: 18.0,
                coastDecel: 4.0,
                turnRate: 2.8,
                radius: 1.55,
                wheelBase: 2.66,
                minTurnRadius: 6.0,
                minSteerSpeed: 0.35,
                steerResponse: 2.1,
                steerReturn: 6.0,
                lateralGrip: 8.0,
                wetWidth: 0.05,
                wetLength: 1.04,
                trackHalfWidth: 0.5,
                airRollResponse: 8.0,
                airRollReturn: 5.0,
                climbPitchMax: 0.22,
                climbPitchSpeed: 4.0,
                pitchResponse: 4.0,
                pitchReturn: 3.0,
                turnPitchMax: 0.1,
                airRollMax: 0.35,
                airTurnScale: 0.35,
                liftResponse: 5.0,
                maxLift: 10.0,
                minFlySpeed: 14.0
              }
            }



          }
        ]
      },

      {
        name: "snowcar",
        url: "models/vehicles/snowcar.glb",
        instances: [
          {
            id: "car2",
            position: [-4, 0.19, 6],
            rotation: [0, 1, 0],
            scale: 1.0,
            stick: false,
            collide: true,
            vehicle: {
              type: "Snowcar",
              description: "Snow-capable car",
              seatLocal: [0.5, 0.54, 1.15],
              yawOffset: 0.0,
              profile: {
                maxSpeed: 13.2,
                maxReverse: 6.9,
                accel: 3.2,
                brake: 15.9,
                coastDecel: 1.8,
                turnRate: 0.64,
                radius: 0.7,
                wheelBase: 1.9,
                minTurnRadius: 3.8,
                minSteerSpeed: 0.55,
                steerResponse: 5.7,
                steerReturn: 7.0,
                lateralGrip: 9.0,
                wetWidth: 0.15,
                wetLength: 1.63,
                trackHalfWidth: 1.1,
                propSpinIdle: 8.0,
                propSpinMax: 80.0,
                propSpinMul: 1.0,
                propAxis: "z",
                propInvert: false             
              }
            }
          }
        ]
      }


    ];






    const WORLD_MODELS_URL = "worlds/default_model.json";
    const WORLD_MODELS_OVERRIDE_KEY = "snow:worldModelsOverride:v1";

    const WORLDS_DB_NAME = "snow-worlds";
    const WORLDS_DB_VERSION = 1;
    const WORLDS_STORE = "worlds";
    const ACTIVE_WORLD_ID_KEY = "snow:activeWorldId:v1";
    const PENDING_WORLD_THUMB_ID_KEY = "snow:pendingWorldThumbId:v1";
    const WORLD_PICKER_SUPPRESS_ONCE_KEY = "snow:worldPickerSuppressOnce:v1";


    const worldModelsIoState = {
      source: "defaults",
      openWorlds() {
        openWorldPickerOverlay();
      },
      exportWorldModelsJson() {
        exportWorldModelsJson();
      },
      importWorldModelsJson() {
        importWorldModelsJson();
      }
    };

    let worldModelsConfig = null;
    let worldModelsConfigLoaded = false;

    const worldPickerState = { open: false, wired: false, editId: "" };


    const worldUiState = { id: "", title: "Default" };
    let worldNameEl = null;

    /**
     * Updates the top-center world title label.
     */
    function setWorldNameLabel(title) {
      const t = String(title || "").trim() || "Default";
      worldUiState.title = t;

      if (!worldNameEl) return;

      worldNameEl.textContent = t;
      worldNameEl.setAttribute("aria-hidden", t ? "false" : "true");
    }

    /**
     * Sets the active world identity for UI display.
     */
    function setActiveWorldUi(id, title) {
      worldUiState.id = String(id || "").trim();
      setWorldNameLabel(title);
    }    

    let worldPickerEl = null;
    let worldPickerCloseBtn = null;
    let worldPickerListEl = null;
    let worldTitleInputEl = null;
    let worldDescInputEl = null;
    let worldSaveBtnEl = null;
    let worldImportBtnEl = null;

    /**
     * Validates and normalizes a model config payload into the expected MODEL_CONFIG array shape.
     * Preserves all unknown/extra fields on entries and instances; only normalizes position/rotation/scale.
     * Returns null when the payload is unusable.
     */
    function normalizeWorldModelsConfig(raw) {
      if (!Array.isArray(raw)) return null;

      const out = [];

      for (let i = 0; i < raw.length; i++) {
        const e = raw[i];
        if (!e || typeof e !== "object") continue;

        const name = typeof e.name === "string" ? e.name : "";
        const url = typeof e.url === "string" ? e.url : "";
        const instances = Array.isArray(e.instances) ? e.instances : [];

        if (!name || !url) continue;

        const cleanInstances = [];

        for (let k = 0; k < instances.length; k++) {
          const inst = instances[k];
          if (!inst || typeof inst !== "object") continue;

          const p = Array.isArray(inst.position) && inst.position.length === 3 ? inst.position : [0, 0, 0];
          const r = Array.isArray(inst.rotation) && inst.rotation.length === 3 ? inst.rotation : [0, 0, 0];

          let s = inst.scale;
          if (Array.isArray(s)) {
            if (s.length !== 3) s = 1.0;
          } else if (!Number.isFinite(s)) {
            s = 1.0;
          }

          const copy = { ...inst };
          copy.position = [
            Number.isFinite(p[0]) ? p[0] : 0,
            Number.isFinite(p[1]) ? p[1] : 0,
            Number.isFinite(p[2]) ? p[2] : 0
          ];
          copy.rotation = [
            Number.isFinite(r[0]) ? r[0] : 0,
            Number.isFinite(r[1]) ? r[1] : 0,
            Number.isFinite(r[2]) ? r[2] : 0
          ];
          copy.scale = s;

          cleanInstances.push(copy);
        }

        const entryCopy = { ...e };
        entryCopy.name = name;
        entryCopy.url = url;
        entryCopy.instances = cleanInstances;

        out.push(entryCopy);
      }

      return out.length ? out : null;
    }

    /**
     * Opens IndexedDB (worlds) and returns a live IDBDatabase instance.
     */
    function openWorldDb() {
      return new Promise((resolve, reject) => {
        if (!("indexedDB" in window)) {
          reject(new Error("IndexedDB not available"));
          return;
        }

        const req = indexedDB.open(WORLDS_DB_NAME, WORLDS_DB_VERSION);

        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(WORLDS_STORE)) {
            db.createObjectStore(WORLDS_STORE, { keyPath: "id" });
          }
        };

        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error || new Error("IndexedDB open failed"));
      });
    }

    function idbTx(db, mode) {
      return db.transaction(WORLDS_STORE, mode).objectStore(WORLDS_STORE);
    }

    /**
     * Reads all stored worlds, sorted by updatedAt descending.
     */
    async function idbGetAllWorlds() {
      const db = await openWorldDb();
      return await new Promise((resolve, reject) => {
        const store = idbTx(db, "readonly");
        const req = store.getAll();
        req.onsuccess = () => {
          const arr = Array.isArray(req.result) ? req.result : [];
          arr.sort((a, b) => (Number(b.updatedAt) || 0) - (Number(a.updatedAt) || 0));
          resolve(arr);
        };
        req.onerror = () => reject(req.error || new Error("getAll failed"));
      });
    }

    /**
     * Reads a single world by id.
     */
    async function idbGetWorld(id) {
      const db = await openWorldDb();
      return await new Promise((resolve, reject) => {
        const store = idbTx(db, "readonly");
        const req = store.get(String(id));
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error || new Error("get failed"));
      });
    }

    /**
     * Writes a world record.
     */
    async function idbPutWorld(world) {
      const db = await openWorldDb();
      return await new Promise((resolve, reject) => {
        const store = idbTx(db, "readwrite");
        const req = store.put(world);
        req.onsuccess = () => resolve(true);
        req.onerror = () => reject(req.error || new Error("put failed"));
      });
    }

    /**
     * Deletes a world by id.
     */
    async function idbDeleteWorld(id) {
      const db = await openWorldDb();
      return await new Promise((resolve, reject) => {
        const store = idbTx(db, "readwrite");
        const req = store.delete(String(id));
        req.onsuccess = () => resolve(true);
        req.onerror = () => reject(req.error || new Error("delete failed"));
      });
    }

    function getActiveWorldId() {
      try {
        const v = localStorage.getItem(ACTIVE_WORLD_ID_KEY);
        return v && String(v).trim() ? String(v) : "";
      } catch (e) {
        return "";
      }
    }

    function setActiveWorldId(id) {
      try {
        const v = id && String(id).trim() ? String(id) : "";
        if (!v) localStorage.removeItem(ACTIVE_WORLD_ID_KEY);
        else localStorage.setItem(ACTIVE_WORLD_ID_KEY, v);
      } catch (e) {}
    }

    function makeWorldId() {
      try {
        if (crypto && typeof crypto.randomUUID === "function") return crypto.randomUUID();
      } catch (e) {}
      return `w_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
    }

    function sanitizeWorldFilename(name) {
      const base = String(name || "world").trim() || "world";
      return base
      .replace(/[\/\\?%*:|"<>]/g, "-")
      .replace(/\s+/g, " ")
      .trim()
      .slice(0, 64);
    }

    function captureWorldThumbnail() {
      try {
        if (!renderer || !renderer.domElement) return "";

        const canvas = renderer.domElement;
        const w = canvas.width | 0;
        const h = canvas.height | 0;
        if (w < 2 || h < 2) return "";

        const cam =
        (typeof activeCamera !== "undefined" && activeCamera) ? activeCamera :
        (typeof camera !== "undefined" && camera) ? camera :
        null;

        if (typeof scene !== "undefined" && scene && cam) {
          renderer.render(scene, cam);
        }

        const gl = renderer.getContext();
        if (!gl || typeof gl.readPixels !== "function") {
          return canvas.toDataURL("image/jpeg", 0.72);
        }

        const pixels = new Uint8Array(w * h * 4);
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        const flipped = new Uint8ClampedArray(w * h * 4);
        for (let y = 0; y < h; y++) {
          const srcRow = (h - 1 - y) * w * 4;
          const dstRow = y * w * 4;
          flipped.set(pixels.subarray(srcRow, srcRow + w * 4), dstRow);
        }

        const full = document.createElement("canvas");
        full.width = w;
        full.height = h;

        const ctx = full.getContext("2d", { willReadFrequently: true });
        if (!ctx) return canvas.toDataURL("image/jpeg", 0.72);

        ctx.putImageData(new ImageData(flipped, w, h), 0, 0);

        const maxW = 512;
        const scale = Math.min(1, maxW / w);
        const tw = Math.max(1, Math.floor(w * scale));
        const th = Math.max(1, Math.floor(h * scale));

        const thumb = document.createElement("canvas");
        thumb.width = tw;
        thumb.height = th;

        const tctx = thumb.getContext("2d");
        if (!tctx) return full.toDataURL("image/jpeg", 0.72);

        tctx.drawImage(full, 0, 0, tw, th);
        return thumb.toDataURL("image/jpeg", 0.72);
      } catch (e) {
        try {
          if (renderer && renderer.domElement) return renderer.domElement.toDataURL("image/jpeg", 0.72);
        } catch (e2) {}
        return "";
      }
    }




    /**
     * Saves current scene model transforms into the active IndexedDB world record.
     * If there is no active world, creates one and sets it active (no reload).
     */
    async function saveActiveWorld() {
      try {
        const snapshot = snapshotWorldModelsConfig();
        const normalized = normalizeWorldModelsConfig(snapshot);
        if (!normalized) return;

        const now = Date.now();
        const thumb = captureWorldThumbnail();
        const settings = safeCloneSettings(params);

        let activeId = getActiveWorldId();
        let rec = null;

        if (activeId) {
          try {
            rec = await idbGetWorld(activeId);
          } catch (e) {
            rec = null;
          }
        }

        if (rec) {
          rec.models = normalized;
          rec.settings = settings;
          if (thumb) rec.thumbnail = thumb;
          rec.updatedAt = now;
          await idbPutWorld(rec);
          setActiveWorldUi(rec.id, rec.title);
        } else {
          const created = buildWorldRecord({
            id: makeWorldId(),
            title: worldUiState.title && worldUiState.title !== "Default" ? worldUiState.title : "Untitled",
            description: "",
            models: normalized,
            settings,
            thumbnail: thumb,
            meta: {},
            createdAt: now,
            updatedAt: now
          });

          await idbPutWorld(created);
          setActiveWorldId(created.id);
          setActiveWorldUi(created.id, created.title);
        }

        if (worldPickerState.open && worldPickerListEl) {
          try {
            const worlds = await idbGetAllWorlds();
            renderWorldPickerList(worlds);
          } catch (e) {}
        }

        showActionToast("World saved");
      } catch (e) {
        console.warn("[worlds] saveActiveWorld failed", e);
      }
    }




    function buildWorldRecord({ id, title, description, models, settings, thumbnail, meta, createdAt, updatedAt }) {
      const cleanSettings =
      settings && typeof settings === "object" ? safeCloneSettings(settings) : {};

      return {
        v: 1,
        kind: "snow-world",
        id: String(id || makeWorldId()),
        title: String(title || "Untitled").trim() || "Untitled",
        description: String(description || "").trim(),
        createdAt: Number(createdAt) || Date.now(),
        updatedAt: Number(updatedAt) || Date.now(),
        thumbnail: typeof thumbnail === "string" ? thumbnail : "",
        meta: meta && typeof meta === "object" ? meta : {},
        settings: cleanSettings,
        models
      };
    }




    /**
     * Loads world model config in this priority:
     * 1) Active world from IndexedDB (snow-worlds / worlds, keyed by ACTIVE_WORLD_ID_KEY)
     * 2) Legacy localStorage override (WORLD_MODELS_OVERRIDE_KEY)
     * 3) worlds/default_model.json (if present)
     * 4) baked MODEL_CONFIG
     */
    async function getWorldModelsConfig() {
      if (worldModelsConfigLoaded) return worldModelsConfig || MODEL_CONFIG;

      worldModelsConfigLoaded = true;
      worldModelsConfig = null;
      worldModelsIoState.source = "defaults";
      setActiveWorldUi("", "Default");

      const activeId = getActiveWorldId();

      if (activeId) {
        try {
          const rec = await idbGetWorld(activeId);
          const normalized = rec && rec.models ? normalizeWorldModelsConfig(rec.models) : null;
          if (normalized) {
            worldModelsConfig = normalized;
            worldModelsIoState.source = `idb:${rec && rec.title ? rec.title : activeId}`;
            setActiveWorldUi(rec && rec.id ? rec.id : activeId, rec && rec.title ? rec.title : "Untitled");
            return worldModelsConfig;
          }
        } catch (e) {
          worldModelsConfig = null;
          worldModelsIoState.source = "defaults";
          setActiveWorldUi("", "Default");
        }
      }

      try {
        const raw = localStorage.getItem(WORLD_MODELS_OVERRIDE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          const normalized = normalizeWorldModelsConfig(parsed);
          if (normalized) {
            worldModelsConfig = normalized;
            worldModelsIoState.source = "imported";
            setActiveWorldUi("", "Imported");
            return worldModelsConfig;
          }
        }
      } catch (e) {
        worldModelsConfig = null;
        worldModelsIoState.source = "defaults";
        setActiveWorldUi("", "Default");
      }

      try {
        const res = await fetch(WORLD_MODELS_URL, { cache: "no-store" });
        if (res && res.ok) {
          const json = await res.json();
          const normalized = normalizeWorldModelsConfig(json);
          if (normalized) {
            worldModelsConfig = normalized;
            worldModelsIoState.source = WORLD_MODELS_URL;
            setActiveWorldUi("", "Default");
          }
        }
      } catch (e) {
        worldModelsConfig = null;
        worldModelsIoState.source = "defaults";
        setActiveWorldUi("", "Default");
      }

      return worldModelsConfig || MODEL_CONFIG;
    }





    /**
     * Imports a world JSON from disk:
     * - Accepts either a raw MODEL_CONFIG array OR a { kind:"snow-world", ... , models:[...] } record.
     * Stores the result in IndexedDB and sets it active, then refreshes the page.
     */
    function importWorldModelsJson() {
      const input = ensureImportInput();
      input.value = "";

      input.onchange = async () => {
        const file = input.files && input.files[0];
        input.value = "";
        if (!file) return;

        try {
          const text = await file.text();
          const json = JSON.parse(text);

          const isWorldRecord = json && typeof json === "object" && json.kind === "snow-world" && json.models;
          const modelsPayload = isWorldRecord ? json.models : json;

          const normalized = normalizeWorldModelsConfig(modelsPayload);
          if (!normalized) return;

          const importedSettings =
          isWorldRecord && json.settings && typeof json.settings === "object" ? json.settings : null;

          const now = Date.now();
          const baseTitle = isWorldRecord && typeof json.title === "string" ? json.title : file.name.replace(/\.[^.]+$/, "");
          const baseDesc = isWorldRecord && typeof json.description === "string" ? json.description : "";

          const id = isWorldRecord && typeof json.id === "string" && json.id.trim() ? json.id.trim() : makeWorldId();

          const rec = buildWorldRecord({
            id,
            title: baseTitle,
            description: baseDesc,
            models: normalized,
            settings: importedSettings ? Object.assign({}, DEFAULTS, importedSettings) : {},
            thumbnail: isWorldRecord && typeof json.thumbnail === "string" ? json.thumbnail : "",
            meta: isWorldRecord && json.meta && typeof json.meta === "object" ? json.meta : { importedFrom: file.name },
            createdAt: isWorldRecord && Number.isFinite(json.createdAt) ? json.createdAt : now,
            updatedAt: now
          });

          await idbPutWorld(rec);
          setActiveWorldId(rec.id);

          if (!rec.thumbnail) {
            localStorage.setItem(PENDING_WORLD_THUMB_ID_KEY, rec.id);
          } else {
            localStorage.removeItem(PENDING_WORLD_THUMB_ID_KEY);
          }

          try {
            sessionStorage.setItem(WORLD_PICKER_SUPPRESS_ONCE_KEY, "1");
          } catch (e) {}

          location.reload();
        } catch (e) {
          console.warn("[worlds] import failed", e);
        }
      };

      input.click();
    }





    /**
     * Exports either:
     * - Active IndexedDB world (full record with metadata + thumbnail), or
     * - Fallback snapshot as world_models.json if no active world record exists.
     */
    function exportWorldModelsJson() {
      (async () => {
        const activeId = getActiveWorldId();
        if (activeId) {
          try {
            const rec = await idbGetWorld(activeId);
            if (rec) {
              const name = sanitizeWorldFilename(rec.title || "world");
              downloadJson(rec, `${name}.world.json`);
              return;
            }
          } catch (e) {}
        }

        const snapshot = snapshotWorldModelsConfig();
        downloadJson(snapshot, "world_models.json");
      })();
    }

    /**
     * Builds an exportable MODEL_CONFIG snapshot using current scene transforms (when instances exist).
     */
    function snapshotWorldModelsConfig() {
      const base = worldModelsConfig || MODEL_CONFIG;
      const out = JSON.parse(JSON.stringify(base));

      const eps = 1e-6;

      for (let i = 0; i < out.length; i++) {
        const outEntry = out[i];
        const baseEntry = base[i];

        if (!outEntry || !baseEntry) continue;
        if (!Array.isArray(outEntry.instances) || !Array.isArray(baseEntry.instances)) continue;

        const n = Math.min(outEntry.instances.length, baseEntry.instances.length);

        for (let k = 0; k < n; k++) {
          const outInstCfg = outEntry.instances[k];
          const baseInstCfg = baseEntry.instances[k];
          if (!outInstCfg || !baseInstCfg) continue;

          const inst =
          baseInstCfg.runtimeObject ||
          (baseInstCfg.id ? modelInstances[String(baseInstCfg.id)] : null);

          if (!inst) continue;

          outInstCfg.position = [inst.position.x, inst.position.y, inst.position.z];
          outInstCfg.rotation = [inst.rotation.x, inst.rotation.y, inst.rotation.z];

          const sx = inst.scale.x;
          const sy = inst.scale.y;
          const sz = inst.scale.z;

          const uniform = Math.abs(sx - sy) < eps && Math.abs(sx - sz) < eps;
          outInstCfg.scale = uniform ? sx : [sx, sy, sz];
        }
      }

      return out;
    }


    /**
     * Shows or hides the worlds overlay.
     */
    function setWorldPickerOpen(open) {
      worldPickerState.open = !!open;

      if (!worldPickerEl) return;

      if (!worldPickerState.open) {
        worldPickerState.editId = "";
        worldPickerEl.classList.remove("is-editing");
      }

      worldPickerEl.classList.toggle("is-open", worldPickerState.open);
      worldPickerEl.setAttribute("aria-hidden", worldPickerState.open ? "false" : "true");

      if (worldPickerState.open && worldPickerCloseBtn) {
        worldPickerCloseBtn.focus({ preventScroll: true });
      }
    }



/**
 * Renders the worlds list cards into the overlay.
 */
    function renderWorldPickerList(worlds) {
      if (!worldPickerListEl) return;

      const activeId = getActiveWorldId();
      worldPickerListEl.innerHTML = "";

      for (let i = 0; i < worlds.length; i++) {
        const w = worlds[i];
        if (!w || typeof w !== "object") continue;

        const id = String(w.id || "");
        if (!id) continue;

        const card = document.createElement("div");
        card.className = "world-card" + (activeId && id === activeId ? " is-active" : "");

        const thumb = document.createElement("img");
        thumb.className = "world-card__thumb";
        thumb.alt = "";
        thumb.loading = "lazy";
        thumb.decoding = "async";
        thumb.src = typeof w.thumbnail === "string" && w.thumbnail
        ? w.thumbnail
        : "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";

        const body = document.createElement("div");
        body.className = "world-card__body";

        const titleRow = document.createElement("div");
        titleRow.className = "world-card__titleRow";

        const title = document.createElement("div");
        title.className = "world-card__title";
        title.textContent = String(w.title || "Untitled");

        const meta = document.createElement("div");
        meta.className = "world-card__meta";
        const count = w.models && Array.isArray(w.models) ? w.models.length : 0;
        meta.textContent = `${count} models`;

        const desc = document.createElement("div");
        desc.className = "world-card__desc";
        desc.textContent = String(w.description || "");

        const actions = document.createElement("div");
        actions.className = "world-card__actions";

        const loadBtn = document.createElement("button");
        loadBtn.className = "avatar-btn";
        loadBtn.type = "button";
        loadBtn.textContent = "Load";
        loadBtn.addEventListener("click", () => {
          setActiveWorldId(id);

          try {
            sessionStorage.setItem(WORLD_PICKER_SUPPRESS_ONCE_KEY, "1");
          } catch (e) {}

          location.reload();
        });

        const cloneBtn = document.createElement("button");
        cloneBtn.className = "avatar-btn";
        cloneBtn.type = "button";
        cloneBtn.textContent = "Clone";
        cloneBtn.addEventListener("click", async () => {
          try {
            const now = Date.now();
            const newId = makeWorldId();

            const cloned = buildWorldRecord({
              id: newId,
              title: String(w.title || "Untitled") + " (Copy)",
              description: String(w.description || ""),
              models: JSON.parse(JSON.stringify(w.models || [])),
              settings: w.settings ? JSON.parse(JSON.stringify(w.settings)) : safeCloneSettings(params),
              thumbnail: typeof w.thumbnail === "string" ? w.thumbnail : "",
              meta: w.meta ? JSON.parse(JSON.stringify(w.meta)) : {},
              createdAt: now,
              updatedAt: now
            });

            await idbPutWorld(cloned);

            const updated = await idbGetAllWorlds();
            renderWorldPickerList(updated);

            showActionToast("World cloned");
          } catch (e) {
            console.warn("[worlds] clone failed", e);
          }
        });

        const editBtn = document.createElement("button");
        editBtn.className = "avatar-btn";
        editBtn.type = "button";
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", () => {
          worldPickerState.editId = id;
          if (worldPickerEl) worldPickerEl.classList.add("is-editing");

          if (worldTitleInputEl) worldTitleInputEl.value = String(w.title || "");
          if (worldDescInputEl) worldDescInputEl.value = String(w.description || "");

          if (worldTitleInputEl) worldTitleInputEl.focus({ preventScroll: true });
        });

        const exportBtn = document.createElement("button");
        exportBtn.className = "avatar-btn";
        exportBtn.type = "button";
        exportBtn.textContent = "Export";
        exportBtn.addEventListener("click", () => {
          const name = sanitizeWorldFilename(w.title || "world");
          downloadJson(w, `${name}.world.json`);
          showActionToast("World exported");
        });

        const delBtn = document.createElement("button");
        delBtn.className = "avatar-btn";
        delBtn.type = "button";
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", async () => {
          const ok = confirm(`Delete "${String(w.title || "Untitled")}"?`);
          if (!ok) return;

          try {
            await idbDeleteWorld(id);
            showActionToast("World deleted");

            const current = getActiveWorldId();
            if (current && id === current) {
              setActiveWorldId("");
              location.reload();
              return;
            }

            const updated = await idbGetAllWorlds();
            renderWorldPickerList(updated);
          } catch (e) {
            console.warn("[worlds] delete failed", e);
          }
        });

        titleRow.appendChild(title);
        titleRow.appendChild(meta);

        actions.appendChild(loadBtn);
        actions.appendChild(cloneBtn);
        actions.appendChild(editBtn);
        actions.appendChild(exportBtn);
        actions.appendChild(delBtn);

        body.appendChild(titleRow);
        body.appendChild(desc);
        body.appendChild(actions);

        card.appendChild(thumb);
        card.appendChild(body);

        worldPickerListEl.appendChild(card);
      }
    }



/**
 * Ensures the worlds overlay is wired once and can be opened from GUI or on boot.
 */
    function ensureWorldPickerOverlayWired() {
      if (worldPickerState.wired) return;

      worldPickerEl = document.getElementById("worldPicker");
      worldPickerCloseBtn = document.getElementById("worldPickerClose");
      worldPickerListEl = document.getElementById("worldPickerList");
      worldTitleInputEl = document.getElementById("worldTitleInput");
      worldDescInputEl = document.getElementById("worldDescInput");
      worldSaveBtnEl = document.getElementById("worldSaveBtn");
      worldImportBtnEl = document.getElementById("worldImportBtn");

      if (!worldPickerEl) return;

      if (worldPickerCloseBtn) {
        worldPickerCloseBtn.addEventListener("click", () => setWorldPickerOpen(false));
      }

      if (worldImportBtnEl) {
        worldImportBtnEl.addEventListener("click", () => importWorldModelsJson());
      }

      if (worldSaveBtnEl) {
        worldSaveBtnEl.addEventListener("click", async () => {
          try {
            const title = worldTitleInputEl ? worldTitleInputEl.value.trim() : "";
            const description = worldDescInputEl ? worldDescInputEl.value.trim() : "";
            const editId = String(worldPickerState.editId || "").trim();

            if (editId) {
              const rec = await idbGetWorld(editId);
              if (!rec) return;

              rec.title = title || "Untitled";
              rec.description = description;
              rec.updatedAt = Date.now();

              await idbPutWorld(rec);

              if (getActiveWorldId() === editId) {
                setWorldNameLabel(rec.title || "Default");
              }

              worldPickerState.editId = "";
              if (worldPickerEl) worldPickerEl.classList.remove("is-editing");

              if (worldTitleInputEl) worldTitleInputEl.value = "";
              if (worldDescInputEl) worldDescInputEl.value = "";

              const updated = await idbGetAllWorlds();
              renderWorldPickerList(updated);

              showActionToast("World updated");
              return;
            }

            const snapshot = snapshotWorldModelsConfig();
            const normalized = normalizeWorldModelsConfig(snapshot);
            if (!normalized) return;

            const now = Date.now();
            const rec = buildWorldRecord({
              id: makeWorldId(),
              title: title || "Untitled",
              description,
              models: normalized,
              settings: safeCloneSettings(params),
              thumbnail: captureWorldThumbnail(),
              meta: {},
              createdAt: now,
              updatedAt: now
            });

            await idbPutWorld(rec);
            setActiveWorldId(rec.id);

            if (worldTitleInputEl) worldTitleInputEl.value = "";
            if (worldDescInputEl) worldDescInputEl.value = "";

            const updated = await idbGetAllWorlds();
            renderWorldPickerList(updated);

            showActionToast("World saved");
          } catch (e) {
            console.warn("[worlds] save failed", e);
          }
        });
      }

      worldPickerState.wired = true;
    }

    /**
     * Opens the overlay and refreshes its list.
     */
    function openWorldPickerOverlay() {
      ensureWorldPickerOverlayWired();

      worldPickerState.editId = "";
      if (worldPickerEl) worldPickerEl.classList.remove("is-editing");

      (async () => {
        try {
          const worlds = await idbGetAllWorlds();
          renderWorldPickerList(worlds);
          setWorldPickerOpen(true);
        } catch (e) {
          console.warn("[worlds] list failed", e);
        }
      })();
    }


    /**
     * If an imported world had no thumbnail, capture one after first paint and update the record.
     */
    async function finalizePendingWorldThumbnail() {
      let pendingId = "";
      try {
        pendingId = localStorage.getItem(PENDING_WORLD_THUMB_ID_KEY) || "";
      } catch (e) {
        pendingId = "";
      }
      if (!pendingId) return;

      try {
        const rec = await idbGetWorld(pendingId);
        if (!rec || (typeof rec.thumbnail === "string" && rec.thumbnail)) {
          localStorage.removeItem(PENDING_WORLD_THUMB_ID_KEY);
          return;
        }

        const thumb = captureWorldThumbnail();
        if (!thumb) return;

        rec.thumbnail = thumb;
        rec.updatedAt = Date.now();
        await idbPutWorld(rec);

        localStorage.removeItem(PENDING_WORLD_THUMB_ID_KEY);
      } catch (e) {
        console.warn("[worlds] thumbnail update failed", e);
      }
    }


    /**
     * Boot behavior: if any worlds exist in IndexedDB, open the picker overlay on page load.
     */
    function bootWorldPickerOverlay() {
      ensureWorldPickerOverlayWired();

      (async () => {
        let suppressOnce = false;

        try {
          suppressOnce = !!(sessionStorage && sessionStorage.getItem(WORLD_PICKER_SUPPRESS_ONCE_KEY));
          if (suppressOnce) sessionStorage.removeItem(WORLD_PICKER_SUPPRESS_ONCE_KEY);
        } catch (e) {
          suppressOnce = false;
        }

        try {
          const worlds = await idbGetAllWorlds();
          if (worlds && worlds.length) {
            renderWorldPickerList(worlds);
            if (!suppressOnce) setWorldPickerOpen(true);
            else setWorldPickerOpen(false);
          } else {
            setWorldPickerOpen(false);
          }
        } catch (e) {}

        requestAnimationFrame(() => {
          finalizePendingWorldThumbnail();
        });
      })();
    }







    function hasAlphaTexture(mat) {
      return !!(mat && (mat.alphaMap || mat.map) && (mat.transparent || mat.opacity < 1 || mat.alphaTest > 0));
    }

    function applyAlphaCutoutShadows(mesh, cutoff = 0.5) {
      /* Forces alpha-mapped foliage to behave as depth-writing cutout (not blended transparency),
         and makes shadow/depth passes respect the same alphaTest threshold. */
      if (!mesh || !mesh.material) return;

      // Ensure per-instance materials (avoid mutating shared template materials)
      if (Array.isArray(mesh.material)) {
        mesh.material = mesh.material.map(m => (m && m.isMaterial ? m.clone() : m));
      } else if (mesh.material && mesh.material.isMaterial) {
        mesh.material = mesh.material.clone();
      }

      const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];

      let alphaTex = null;
      let alphaTest = cutoff;

      for (let i = 0; i < mats.length; i++) {
        const mat = mats[i];
        if (!mat || !mat.isMaterial) continue;

        const tex = mat.alphaMap || mat.map;
        if (tex && !alphaTex) alphaTex = tex;

        mat.alphaTest = Math.max(mat.alphaTest || 0, cutoff);
        alphaTest = Math.max(alphaTest, mat.alphaTest);

        // Critical: keep it OUT of the transparent pass, so depth sorting works with grass.
        mat.transparent = false;
        mat.opacity = 1.0;
        mat.depthTest = true;
        mat.depthWrite = true;

        mat.needsUpdate = true;
      }

      if (!alphaTex) return;

      // Make the SHADOW MAP respect alphaTest too
      const depthMat = new THREE.MeshDepthMaterial({
        depthPacking: THREE.RGBADepthPacking,
        map: alphaTex,
        alphaTest: alphaTest
      });
      depthMat.side = mats[0] && mats[0].side != null ? mats[0].side : THREE.FrontSide;

      const distMat = new THREE.MeshDistanceMaterial({
        map: alphaTex,
        alphaTest: alphaTest
      });
      distMat.side = depthMat.side;

      mesh.customDepthMaterial = depthMat;
      mesh.customDistanceMaterial = distMat;
    }










    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(
      "https://www.gstatic.com/draco/versioned/decoders/1.5.7/"
      );

    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);





    function loadAllModels() {
      avatarModelColliderObjects.length = 0;
      avatarModelColliderBounds.length = 0;
      avatarModelColliderOBBs.length = 0;

      vehicleInteractables.length = 0;
      setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);

      for (const k in modelTemplates) delete modelTemplates[k];
        for (const k in modelInstances) delete modelInstances[k];

          function buildOBBForInstance(root, id) {
            root.updateWorldMatrix(true, true);

            obbTmpBox.setFromObject(root);
            if (!Number.isFinite(obbTmpBox.min.x) || !Number.isFinite(obbTmpBox.max.x)) return null;

            obbTmpBox.getCenter(obbTmpCenter);
            obbTmpBox.getSize(obbTmpSize);

            root.getWorldQuaternion(obbTmpQuat);
            obbTmpEuler.setFromQuaternion(obbTmpQuat);

            const hx = Math.max(0.10, (obbTmpSize.x * 0.5) * 0.48);
            const hz = Math.max(0.10, (obbTmpSize.z * 0.5) * 0.48);

            return {
              id: id || "",
              object: root,
              center: obbTmpCenter.clone(),
              halfX: hx,
              halfZ: hz,
              yaw: obbTmpEuler.y
            };
          }

          (async () => {
            const config = await getWorldModelsConfig();

            for (const entry of config) {
              gltfLoader.load(
                entry.url,
                (gltf) => {
                  const baseScene = gltf.scene;
                  modelTemplates[entry.name] = baseScene;

                  for (const instCfg of entry.instances) {
                    const inst = baseScene.clone(true);

                    const p = instCfg.position || [0, 0, 0];
                    const r = instCfg.rotation || [0, 0, 0];
                    const s = instCfg.scale != null ? instCfg.scale : 1.0;

                    inst.position.set(p[0], p[1], p[2]);
                    inst.rotation.set(r[0], r[1], r[2]);

                    if (Array.isArray(s) && s.length === 3) {
                      inst.scale.set(s[0], s[1], s[2]);
                    } else {
                      inst.scale.setScalar(s);
                    }

                    Object.defineProperty(instCfg, "runtimeObject", {
                      value: inst,
                      enumerable: false,
                      configurable: true
                    });

                    inst.traverse((obj) => {
                      if (!obj.isMesh) return;

                      obj.castShadow = true;
                      obj.receiveShadow = true;

                      // Only apply to alpha-textured meshes (like your planes)
                      const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                      if (mats.some(hasAlphaTexture)) {
                        applyAlphaCutoutShadows(obj, 0.5);   // tweak cutoff: 0.3–0.7 typical
                      }

                      if (instCfg.stick) colliderObjects.push(obj);
                    });

                    scene.add(inst);

                    if (instCfg.id) {
                      modelInstances[instCfg.id] = inst;
                    }

                    registerWorldEditRoot(inst, instCfg);

                    if (instCfg.vehicle) {
                      registerVehicleInstance(inst, instCfg);
                    }

                    if (instCfg.collide) {
                      avatarModelColliderObjects.push(inst);

                      const obb = buildOBBForInstance(inst, instCfg.id);
                      if (obb) avatarModelColliderOBBs.push(obb);
                    }
                  }

                  if (colliderObjects.length) {
                    colliderBounds = buildColliderBounds(colliderObjects);
                    rebuildAvatarCollisionGrid();
                  }

                  avatarModelColliderBounds = [];
                },
                undefined,
                (error) => {
                  console.error("[snow] failed to load GLB", entry.url, error);
                }
                );
            }
          })();
        }










        function getModelInstance(id) {
          return modelInstances[id] || null;
        }





// -------------------------------------------------------------------------
// Avatar character setup and control
// -------------------------------------------------------------------------

        const AVATAR_GLTF_URL = "models/ready/tata/tata2-anims.glb";

        let avatar = null;
        let avatarMixer = null;
        const avatarActions = {};
        let avatarCurrentAction = null;
        let avatarCurrentActionName = "";


        const avatarState = {
          enabled: false,
      viewMode: "third", // "third" | "first"
      moveX: 0,
      moveZ: 0
    };

    const avatarKeys = {
      forward: false,
      back: false,
      left: false,
      right: false,
      run: false,
      jump: false
    };

    const AVATAR_WALK_SPEED = 2.4;
    const AVATAR_RUN_SPEED  = 4.0;


    /**
     * Resolves avatar XZ overlaps against collider bounds (trees/rocks) plus model-only colliders (cars).
     * Pushes the avatar out of penetration and removes velocity component into the obstacle for sliding.
     */
    const avatarCollision = {
      radius: 0.35,
      skin: 0.02,
      iterations: 3
    };

    const avatarColTmpPos = new THREE.Vector3();
    const avatarColN = new THREE.Vector3();


    /**
     * Builds a spatial hash (XZ grid) of collider sphere-bounds for fast avatar collision broadphase.
     * Each collider is inserted into all cells overlapped by its XZ radius expanded by avatar radius + skin.
     */
    const avatarCollisionGrid = new Map(); // Map<number, Map<number, number[]>>
    const avatarCollisionCellSize = 3.0;
    const avatarCollisionCellInv = 1.0 / avatarCollisionCellSize;

    function rebuildAvatarCollisionGrid() {
      avatarCollisionGrid.clear();

      if (!colliderBounds || colliderBounds.length === 0) return;

      const pad = avatarCollision.radius + avatarCollision.skin;

      for (let i = 0; i < colliderBounds.length; i++) {
        const b = colliderBounds[i];
        if (!b) continue;

        const baseR = Number.isFinite(b.radius) ? b.radius : 0;
        const r = baseR + pad;

        const minX = Math.floor((b.center.x - r) * avatarCollisionCellInv);
        const maxX = Math.floor((b.center.x + r) * avatarCollisionCellInv);
        const minZ = Math.floor((b.center.z - r) * avatarCollisionCellInv);
        const maxZ = Math.floor((b.center.z + r) * avatarCollisionCellInv);

        for (let ix = minX; ix <= maxX; ix++) {
          let col = avatarCollisionGrid.get(ix);
          if (!col) {
            col = new Map();
            avatarCollisionGrid.set(ix, col);
          }

          for (let iz = minZ; iz <= maxZ; iz++) {
            let bucket = col.get(iz);
            if (!bucket) {
              bucket = [];
              col.set(iz, bucket);
            }
            bucket.push(i);
          }
        }
      }
    }

    /**
     * Returns colliderBounds indices potentially overlapping the avatar at the given position.
     */
    function getAvatarCollisionCandidatesXZ(pos) {
      const ix = Math.floor(pos.x * avatarCollisionCellInv);
      const iz = Math.floor(pos.z * avatarCollisionCellInv);
      const col = avatarCollisionGrid.get(ix);
      if (!col) return null;
      return col.get(iz) || null;
    }







    function resolveAvatarXZCollisions(pos) {
      const limX = Math.max(0.5, visualBounds.x - (avatarCollision.radius + 0.25));
      const limZ = Math.max(0.5, visualBounds.z - (avatarCollision.radius + 0.25));

      pos.x = clamp(pos.x, -limX, limX);
      pos.z = clamp(pos.z, -limZ, limZ);

      const rA = avatarCollision.radius;
      const skin = avatarCollision.skin;

      for (let iter = 0; iter < avatarCollision.iterations; iter++) {
        let pushed = false;

        // --- sphere bounds (forest/rocks + any stick meshes), grid-broadened ---
        const candidates = getAvatarCollisionCandidatesXZ(pos);
        if (candidates && candidates.length) {
          for (let c = 0; c < candidates.length; c++) {
            const b = colliderBounds[candidates[c]];
            if (!b) continue;

            const sumR = rA + b.radius + skin;
            const dx = pos.x - b.center.x;
            const dz = pos.z - b.center.z;
            const d2 = dx * dx + dz * dz;

            if (d2 >= sumR * sumR) continue;

            const d = Math.sqrt(d2) || 1e-6;
            const push = sumR - d;

            const nx = dx / d;
            const nz = dz / d;

            pos.x += nx * push;
            pos.z += nz * push;

            const velDot = avatarVelocity.x * nx + avatarVelocity.z * nz;
            if (velDot < 0) {
              avatarVelocity.x -= velDot * nx;
              avatarVelocity.z -= velDot * nz;
            }

            pushed = true;
          }
        }

        // --- OBB bounds (cars etc), built once at load-time ---
        if (avatarModelColliderOBBs && avatarModelColliderOBBs.length) {
          for (let i = 0; i < avatarModelColliderOBBs.length; i++) {
            const obb = avatarModelColliderOBBs[i];
            if (!obb) continue;

            const dxw = pos.x - obb.center.x;
            const dzw = pos.z - obb.center.z;

            const c = Math.cos(obb.yaw);
            const s = Math.sin(obb.yaw);

        // world -> local
            const lx = dxw * c + dzw * s;
            const lz = -dxw * s + dzw * c;

            const cx = clamp(lx, -obb.halfX, obb.halfX);
            const cz = clamp(lz, -obb.halfZ, obb.halfZ);

            const dxl = lx - cx;
            const dzl = lz - cz;

            const d2 = dxl * dxl + dzl * dzl;
            const sumR = rA + skin;

            if (d2 >= sumR * sumR) continue;

            const d = Math.sqrt(d2) || 1e-6;
            const push = sumR - d;

            let nlx = dxl / d;
            let nlz = dzl / d;

        // if inside (rare), choose shortest axis
            if (!Number.isFinite(nlx) || !Number.isFinite(nlz)) {
              const px = obb.halfX - Math.abs(lx);
              const pz = obb.halfZ - Math.abs(lz);
              if (px < pz) {
                nlx = lx >= 0 ? 1 : -1;
                nlz = 0;
              } else {
                nlx = 0;
                nlz = lz >= 0 ? 1 : -1;
              }
            }

        // local -> world normal
            const nx = nlx * c - nlz * s;
            const nz = nlx * s + nlz * c;

            pos.x += nx * push;
            pos.z += nz * push;

            const velDot = avatarVelocity.x * nx + avatarVelocity.z * nz;
            if (velDot < 0) {
              avatarVelocity.x -= velDot * nx;
              avatarVelocity.z -= velDot * nz;
            }

            pushed = true;
          }
        }

        pos.x = clamp(pos.x, -limX, limX);
        pos.z = clamp(pos.z, -limZ, limZ);

        if (!pushed) break;
      }
    }





    const avatarViewConfig = {
      thirdPersonDistance: 4.0,
      thirdPersonHeight: 1.6,
      thirdPersonHeightLift: 0.4,
      firstPersonHeight: 1.6
    };

    const avatarMotionConfig = {
      maxAccel: 5.0,
      maxDecel: 3.0,
      stopEps: 0.03,
      yawLerpThird: 0.2,
      yawLerpFirst: 0.2
    };

    const avatarJumpConfig = {
      initialVelocity: 5.2,
      gravity: 12.0
    };

    const avatarJumpState = {
      active: false,
      grounded: true,
      vy: 0.0,
      groundY: 0.0
    };


    // Reusable vectors for avatar motion/camera math (avoid per-frame allocations)
    const avatarVelocity = new THREE.Vector3();
    const avatarMoveDir = new THREE.Vector3();

    const avatarWorldPos = new THREE.Vector3();
    const avatarHeadPos = new THREE.Vector3();
    const avatarForwardWorld = new THREE.Vector3();
    const avatarLastWorldPos = new THREE.Vector3();
    let avatarHasLastPos = false;

    const avatarTmpVec = new THREE.Vector3();
    const avatarTmpDir = new THREE.Vector3();
    const avatarToTarget = new THREE.Vector3();
    const avatarTmpMove = new THREE.Vector3();

    const camForward = new THREE.Vector3();
    const camRight = new THREE.Vector3();
    const worldUp = new THREE.Vector3(0, 1, 0);



    // Joystick state
    const joystickState = {
      active: false,
      pointerId: null,
      centerX: 0,
      centerY: 0,
      radius: 0,
      valueX: 0, // -1..1 (left/right)
      valueY: 0  // -1..1 (up/down screen); forward uses -valueY
    };

    const preAvatarCameraState = {
      has: false,
      position: new THREE.Vector3(),
      target: new THREE.Vector3(),
      enablePan: true,
      enableZoom: true,
      minDistance: 0.0,
      maxDistance: 0.0,
      minPolarAngle: 0.0,
      maxPolarAngle: Math.PI,
      autoRotateEnabled: false
    };

    /**
     * Smooth yaw interpolation that always takes the shortest arc.
     */
    function lerpYaw(current, target, t) {
      let d = target - current;
      while (d > Math.PI) d -= Math.PI * 2;
      while (d < -Math.PI) d += Math.PI * 2;
      return current + d * t;
    }

    /**
     * Captures camera + OrbitControls state before entering avatar mode.
     */
    function savePreAvatarCameraState() {
      if (!controls) return;

      preAvatarCameraState.has = true;
      preAvatarCameraState.position.copy(camera.position);
      if (controls.target) preAvatarCameraState.target.copy(controls.target);

      preAvatarCameraState.enablePan = !!controls.enablePan;
      preAvatarCameraState.enableZoom = !!controls.enableZoom;
      preAvatarCameraState.minDistance = controls.minDistance;
      preAvatarCameraState.maxDistance = controls.maxDistance;
      preAvatarCameraState.minPolarAngle = controls.minPolarAngle;
      preAvatarCameraState.maxPolarAngle = controls.maxPolarAngle;

      preAvatarCameraState.autoRotateEnabled = !!autoRotateEnabled;
    }

    /**
     * Restores camera + OrbitControls state to the exact pre-avatar snapshot.
     */
    function restorePreAvatarCameraState() {
      if (!controls) return;

      if (!preAvatarCameraState.has) {
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.minDistance = 0.25;
        controls.maxDistance = 200.0;
        return;
      }

      camera.position.copy(preAvatarCameraState.position);
      if (controls.target) controls.target.copy(preAvatarCameraState.target);

      controls.enablePan = preAvatarCameraState.enablePan;
      controls.enableZoom = preAvatarCameraState.enableZoom;
      controls.minDistance = preAvatarCameraState.minDistance;
      controls.maxDistance = preAvatarCameraState.maxDistance;
      controls.minPolarAngle = preAvatarCameraState.minPolarAngle;
      controls.maxPolarAngle = preAvatarCameraState.maxPolarAngle;

      autoRotateEnabled = preAvatarCameraState.autoRotateEnabled;

      controls.update();
    }

    /**
     * Positions the camera behind the avatar and targets the avatar head.
     */
    function placeCameraBehindAvatar() {
      if (!avatar || !controls) return;

      avatar.getWorldPosition(avatarWorldPos);

      avatarHeadPos.copy(avatarWorldPos);
      avatarHeadPos.y += avatarViewConfig.thirdPersonHeight;

      avatarForwardWorld.set(0, 0, 1).applyQuaternion(avatar.quaternion).normalize();

      avatarTmpVec
      .copy(avatarHeadPos)
      .addScaledVector(avatarForwardWorld, -avatarViewConfig.thirdPersonDistance)
      .addScaledVector(worldUp, avatarViewConfig.thirdPersonHeightLift);

      camera.position.copy(avatarTmpVec);
      camera.lookAt(avatarHeadPos);
      controls.target.copy(avatarHeadPos);

      avatarLastWorldPos.copy(avatarWorldPos);
      avatarHasLastPos = true;
    }

    /**
     * Switches avatar view mode and configures OrbitControls constraints for that mode.
     */
    function setAvatarViewMode(mode, snapCamera = true) {
      if (!avatarState.enabled || !controls) return;

      avatarState.viewMode = mode;
      avatarHasLastPos = false;

      if (mode === "third") {
        if (avatar) avatar.visible = true;

        controls.enablePan = false;
        controls.enableZoom = true;
        controls.minDistance = 0.25;
        controls.maxDistance = 80.0;

        if (snapCamera) {
          placeCameraBehindAvatar();
          controls.update();
        }
        return;
      }

      if (avatar) avatar.visible = false;

      controls.enablePan = false;
      controls.enableZoom = false;
      controls.minDistance = 0.01;
      controls.maxDistance = 0.01;

      if (avatar) {
        avatar.getWorldPosition(avatarWorldPos);

        avatarHeadPos.copy(avatarWorldPos);
        avatarHeadPos.y += avatarViewConfig.firstPersonHeight;

        camera.position.copy(avatarHeadPos);

        avatarForwardWorld.set(0, 0, 1).applyQuaternion(avatar.quaternion).normalize();
        avatarTmpVec.copy(avatarHeadPos).add(avatarForwardWorld);

        camera.lookAt(avatarTmpVec);
        controls.target.copy(avatarTmpVec);
        controls.update();
      }
    }

    /**
     * Clears joystick values and re-centers the thumb indicator.
     */
    function resetJoystick() {
      joystickState.active = false;
      joystickState.pointerId = null;
      joystickState.valueX = 0;
      joystickState.valueY = 0;

      const inner = document.getElementById("joystickInner");
      if (inner) {
        inner.style.transform = "translate(0px, 0px)";
      }
    }

    /**
     * Maps pointer position to joystick values with dead-zones and clamped thumb motion.
     * Uses a stronger X dead-zone while driving a vehicle to prevent unintended steering drift.
     */
    function updateJoystickFromPointer(px, py) {
      if (!joystickState.radius) return;

      const dx = px - joystickState.centerX;
      const dy = py - joystickState.centerY;

      const knobRadius = 20;
      const maxDist = Math.max(1, joystickState.radius - knobRadius);

      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const clampedDist = Math.min(dist, maxDist);
      const ratio = clampedDist / dist;

      const thumbX = dx * ratio;
      const thumbY = dy * ratio;

      const inner = document.getElementById("joystickInner");
      if (inner) {
        inner.style.transform = `translate(${thumbX}px, ${thumbY}px)`;
      }

      const isDrivingVehicle =
      typeof vehicleDriveState !== "undefined" &&
      vehicleDriveState &&
      vehicleDriveState.enabled &&
      vehicleDriveState.vehicle;

      const applyDeadZone = (v, dead) => {
        const a = Math.abs(v);
        if (a <= dead) return 0;
        const s = v < 0 ? -1 : 1;
        return s * ((a - dead) / (1 - dead));
      };

      const rawX = clamp(dx / maxDist, -1, 1);
      const rawY = clamp(dy / maxDist, -1, 1);

      const deadX = isDrivingVehicle ? 0.32 : 0.20;
      const deadY = 0.20;

      let vx = applyDeadZone(rawX, deadX);
      let vy = applyDeadZone(rawY, deadY);

      const mag = Math.sqrt(vx * vx + vy * vy);
      if (mag < 0.01) {
        joystickState.valueX = 0;
        joystickState.valueY = 0;
        return;
      }

      if (isDrivingVehicle) {
        const forwardAbs = Math.min(1, Math.abs(-vy)); // forward uses -valueY elsewhere
        const steerAttenuation = 1 - forwardAbs * 0.65;
        vx *= Math.max(0.25, steerAttenuation);
      }

      joystickState.valueX = clamp(vx, -1, 1);
      joystickState.valueY = clamp(vy, -1, 1);
    }



    /**
     * Ensures an AnimationAction is active with deterministic weight/time scale.
     */
    function setActionWeight(action, weight) {
      action.enabled = true;
      action.setEffectiveTimeScale(1);
      action.setEffectiveWeight(weight);
    }


    /**
     * Plays a named avatar gait ("idle" | "walk" | "run") with a stable cross-fade.
     */
    function playAvatarAction(name) {
      if (!avatarMixer) return;

      const next = avatarActions[name];
      if (!next) {
        console.warn("[avatar] no action for", name);
        return;
      }

      if (avatarCurrentActionName === name) return;

      const prev = avatarActions[avatarCurrentActionName];
      const duration = 0.3;

      next.reset();
      setActionWeight(next, 1.0);
      next.play();

      if (prev) {
        prev.crossFadeTo(next, duration, true);
      } else {
        next.fadeIn(duration);
      }

      avatarCurrentAction = next;
      avatarCurrentActionName = name;
    }

    /**
     * Plays a one-shot avatar jump action (if present) without being overridden by gait switching.
     */
    function playAvatarJumpAction() {
      if (!avatarMixer) return;

      const jump = avatarActions["jump"];
      if (!jump) return;

      if (avatarCurrentActionName === "jump") return;

      const prev = avatarActions[avatarCurrentActionName];
      const duration = 0.12;

      jump.reset();
      jump.clampWhenFinished = true;
      jump.setLoop(THREE.LoopOnce, 1);
      setActionWeight(jump, 1.0);
      jump.play();

      if (prev && prev !== jump) {
        prev.crossFadeTo(jump, duration, true);
      } else {
        jump.fadeIn(duration);
      }

      avatarCurrentAction = jump;
      avatarCurrentActionName = "jump";
    }

    /**
     * Requests a jump if avatar is enabled, not mounted, and currently grounded.
     */
    function requestAvatarJump() {
      if (!avatarState.enabled || !avatar) return;
      if (vehicleDriveState.enabled) return;
      if (avatarJumpState.active || !avatarJumpState.grounded) return;

      avatarJumpState.groundY = avatar.position.y;
      avatarJumpState.vy = avatarJumpConfig.initialVelocity;
      avatarJumpState.active = true;
      avatarJumpState.grounded = false;

      playAvatarJumpAction();
    }



    /**
     * Integrates vertical jump motion and resolves landing back to the current surface height.
     * Keeps groundY tracking the traversable surface so the avatar runs on terrain and lands correctly while moving.
     */
    function updateAvatarJump(dt) {
      if (!avatarState.enabled || !avatar) return;

      if (vehicleDriveState.enabled) {
        avatarJumpState.active = false;
        avatarJumpState.grounded = true;
        avatarJumpState.vy = 0.0;
        return;
      }

      let groundY = getWorldSurfaceY(avatar.position.x, avatar.position.z);
      if (!Number.isFinite(groundY)) groundY = avatarJumpState.groundY;

      if (!avatarJumpState.active) {
        avatarJumpState.grounded = true;
        avatarJumpState.vy = 0.0;
        avatarJumpState.groundY = groundY;

        if (Number.isFinite(groundY)) {
          avatar.position.y = groundY;
        }
        return;
      }

      avatarJumpState.groundY = groundY;

      avatarJumpState.vy -= avatarJumpConfig.gravity * dt;
      avatar.position.y += avatarJumpState.vy * dt;

      if (Number.isFinite(avatarJumpState.groundY) && avatar.position.y <= avatarJumpState.groundY) {
        avatar.position.y = avatarJumpState.groundY;
        avatarJumpState.vy = 0.0;
        avatarJumpState.active = false;
        avatarJumpState.grounded = true;
      } else {
        avatarJumpState.grounded = false;
      }
    }




    /**
     * Matches walk/run animation playback speed to actual movement speed to reduce foot sliding.
     */
    function updateAvatarClipSpeed(speed) {
      if (!avatarMixer) return;

      const walk = avatarActions["walk"];
      const run = avatarActions["run"];

      if (avatarCurrentActionName === "walk" && walk) {
        const base = AVATAR_WALK_SPEED || 1.0;
        const scale = clamp(speed / base, 0.4, 2.0);
        walk.setEffectiveTimeScale(scale);
      } else if (avatarCurrentActionName === "run" && run) {
        const base = AVATAR_RUN_SPEED || 1.0;
        const scale = clamp(speed / base, 0.4, 2.0);
        run.setEffectiveTimeScale(scale);
      }
    }



    function loadAvatar() {
      gltfLoader.load(
        AVATAR_GLTF_URL,
        (gltf) => {
          avatar = gltf.scene;

          avatar.traverse((obj) => {
            if (!obj.isMesh) return;
            obj.castShadow = true;
            obj.receiveShadow = true;
          });

          avatar.position.set(0, 0, 0);
          scene.add(avatar);

          if (!gltf.animations || gltf.animations.length === 0) return;

          avatarMixer = new THREE.AnimationMixer(avatar);

          for (const k in avatarActions) delete avatarActions[k];
            avatarCurrentAction = null;
          avatarCurrentActionName = "";

          for (let i = 0; i < gltf.animations.length; i++) {
            const clip = gltf.animations[i];
            const key = String(clip.name || `clip_${i}`).toLowerCase();
            avatarActions[key] = avatarMixer.clipAction(clip);
          }

          function getAction(nameFallbacks, defaultKey) {
            for (let i = 0; i < nameFallbacks.length; i++) {
              const needle = String(nameFallbacks[i]).toLowerCase();
              const found = Object.entries(avatarActions).find(([n]) => n.includes(needle));
              if (found) return found[1];
            }
            return defaultKey != null ? (avatarActions[defaultKey] || null) : null;
          }

          const keys = Object.keys(avatarActions);
          const defaultKey = keys.length ? keys[0] : null;

          const idleAction = getAction(["idle", "stand"], defaultKey);
          const walkAction = getAction(["walk"], defaultKey);
          const runAction = getAction(["run", "jog"], defaultKey);
          const sitAction = getAction(["sit", "seat", "drive"], defaultKey);

          const jumpAction = getAction(["jump"], null);

          if (idleAction) avatarActions["idle"] = idleAction;
          if (walkAction) avatarActions["walk"] = walkAction;
          if (runAction) avatarActions["run"] = runAction;
          if (sitAction) avatarActions["sit"] = sitAction;
          if (jumpAction) avatarActions["jump"] = jumpAction;

          if (avatarActions["idle"]) {
            avatarMixer.stopAllAction();
            playAvatarAction("idle");
          }
        },
        undefined,
        (err) => {
          console.warn("[snow] avatar load failed", err);
        }
        );
    }







    /**
     * Cross-fades avatar animation states.
     */
    function switchAvatarAction(name) {
      playAvatarAction(name);
    }


    /**
     * Enables avatar mode and locks interaction to avatar-follow camera behavior.
     * Initializes jump grounding baseline to current avatar Y.
     */
    function enableAvatarControl(initialMode = "third") {
      if (!avatar || avatarState.enabled) return;

      savePreAvatarCameraState();

      avatarState.enabled = true;
      autoRotateEnabled = false;
      avatarHasLastPos = false;

      avatarJumpState.active = false;
      avatarJumpState.grounded = true;
      avatarJumpState.vy = 0.0;
      avatarJumpState.groundY = avatar.position.y;

      if (controls) {
        controls.autoRotate = false;
      }

      setAvatarViewMode(initialMode, true);
      updateAvatarButtons();
    }



    /**
     * Disables avatar mode and restores camera + controls to pre-avatar state.
     * Cancels jump state and restores avatar Y to its grounded baseline.
     */
    function disableAvatarControl() {
      if (!avatarState.enabled) return;

      setAvatarChaseCameraEnabled(false);

      avatarState.enabled = false;

      avatarKeys.forward = false;
      avatarKeys.back = false;
      avatarKeys.left = false;
      avatarKeys.right = false;
      avatarKeys.run = false;
      avatarKeys.jump = false;

      avatarState.moveX = 0;
      avatarState.moveZ = 0;

      avatarVelocity.set(0, 0, 0);
      avatarMoveDir.set(0, 0, 0);

      if (avatar && Number.isFinite(avatarJumpState.groundY)) {
        avatar.position.y = avatarJumpState.groundY;
      }

      avatarJumpState.active = false;
      avatarJumpState.grounded = true;
      avatarJumpState.vy = 0.0;

      avatarHasLastPos = false;

      resetJoystick();

      if (avatar) avatar.visible = true;

      if (avatarMixer && avatarActions.idle) {
        switchAvatarAction("idle");
      }

      restorePreAvatarCameraState();
      updateAvatarButtons();
    }



    /**
     * Recomputes keyboard movement intent from pressed keys.
     */
    function recomputeAvatarMoveFromKeys() {
      const f = avatarKeys.forward ? 1 : 0;
      const b = avatarKeys.back ? -1 : 0;
      const l = avatarKeys.left ? -1 : 0;
      const r = avatarKeys.right ? 1 : 0;

      avatarState.moveZ = f + b;
      avatarState.moveX = l + r;
    }




    /**
     * Swept XZ collision and sliding against scene collider meshes.
     * Uses ray tests with a radius offset to avoid tunneling and prevents "teleport to corner" failure modes.
     */
    // const avatarCollision = {
    //   radius: 0.38,
    //   skin: 0.03,
    //   probeY: 1.05,
    //   maxStep: 0.22,
    //   maxSlideIters: 3,
    //   broadphasePad: 0.9
    // };

    const avatarRaycaster = new THREE.Raycaster();
    const avatarSweepFrom = new THREE.Vector3();
    const avatarSweepDir = new THREE.Vector3();
    const avatarSweepVec = new THREE.Vector3();
    const avatarAttemptVec = new THREE.Vector3();
    const avatarCenterTmp = new THREE.Vector3();
    const avatarHitNormal = new THREE.Vector3();
    const avatarHitMat3 = new THREE.Matrix3();
    const avatarPrevPosTmp = new THREE.Vector3();

    /**
     * Clamps avatar XZ to the playable snow area while respecting the collision radius.
     */
    function clampAvatarToPlayableXZ(pos) {
      const margin = avatarCollision.radius + 0.25;
      const limX = Math.max(0.5, (visualBounds?.x ?? HALF_GROUND) - margin);
      const limZ = Math.max(0.5, (visualBounds?.z ?? HALF_GROUND) - margin);
      pos.x = clamp(pos.x, -limX, limX);
      pos.z = clamp(pos.z, -limZ, limZ);
    }

    /**
     * Moves the avatar in XZ with swept collisions and surface sliding.
     * Returns the actual horizontal distance traveled.
     */
    function moveAvatarXZWithCollisions(pos, moveX, moveZ) {
      if (!colliderBounds || colliderBounds.length === 0) {
        pos.x += moveX;
        pos.z += moveZ;
        clampAvatarToPlayableXZ(pos);
        return Math.sqrt(moveX * moveX + moveZ * moveZ);
      }

      let traveled = 0;

      avatarSweepVec.set(moveX, 0, moveZ);
      let remainingLen = avatarSweepVec.length();
      if (remainingLen <= 1e-8) return 0;

      clampAvatarToPlayableXZ(pos);

      while (remainingLen > 1e-6) {
        const stepLen = Math.min(avatarCollision.maxStep, remainingLen);
        avatarSweepDir.copy(avatarSweepVec).setLength(1);
        avatarAttemptVec.copy(avatarSweepDir).multiplyScalar(stepLen);

        let resolvedThisStep = false;

        for (let slideIter = 0; slideIter < avatarCollision.maxSlideIters; slideIter++) {
          const attemptLen = avatarAttemptVec.length();
          if (attemptLen <= 1e-6) {
            resolvedThisStep = true;
            break;
          }

          avatarSweepDir.copy(avatarAttemptVec).multiplyScalar(1 / attemptLen);
          avatarSweepFrom.set(pos.x, pos.y + avatarCollision.probeY, pos.z);

          avatarRaycaster.set(avatarSweepFrom, avatarSweepDir);
          avatarRaycaster.far = attemptLen + avatarCollision.radius + avatarCollision.skin;

          let bestHit = null;
          let bestDist = Infinity;

          for (const cb of colliderBounds) {
            const obj = cb && cb.obj;
            if (!obj || !obj.isMesh) continue;

            obj.updateWorldMatrix(true, false);

            obj.getWorldPosition(avatarCenterTmp);
            const dx = avatarCenterTmp.x - pos.x;
            const dz = avatarCenterTmp.z - pos.z;

            const rBase = Number.isFinite(cb.radius) ? cb.radius : 0;
            const r = rBase + avatarCollision.radius + attemptLen + avatarCollision.broadphasePad;
            if (dx * dx + dz * dz > r * r) continue;

            const hits = avatarRaycaster.intersectObject(obj, false);
            if (!hits || hits.length === 0) continue;

            const h = hits[0];
            if (h.distance < bestDist) {
              bestDist = h.distance;
              bestHit = h;
            }
          }

          if (!bestHit || !(bestDist < Infinity)) {
            pos.x += avatarAttemptVec.x;
            pos.z += avatarAttemptVec.z;
            traveled += attemptLen;
            resolvedThisStep = true;
            break;
          }

          if (bestHit.face) {
            avatarHitNormal.copy(bestHit.face.normal);
            avatarHitMat3.getNormalMatrix(bestHit.object.matrixWorld);
            avatarHitNormal.applyMatrix3(avatarHitMat3).normalize();
          } else {
            avatarHitNormal.set(-avatarSweepDir.x, 0, -avatarSweepDir.z);
          }

          avatarHitNormal.y = 0;
          if (avatarHitNormal.lengthSq() < 1e-10) {
            avatarHitNormal.set(-avatarSweepDir.x, 0, -avatarSweepDir.z);
          } else {
            avatarHitNormal.normalize();
          }

          const allowed = Math.max(0, bestDist - avatarCollision.radius - avatarCollision.skin);

          if (allowed > 1e-6) {
            pos.x += avatarSweepDir.x * allowed;
            pos.z += avatarSweepDir.z * allowed;
            traveled += allowed;
          } else if (bestDist < 1e-4) {
            pos.x += avatarHitNormal.x * (avatarCollision.skin + 0.01);
            pos.z += avatarHitNormal.z * (avatarCollision.skin + 0.01);
          }

          clampAvatarToPlayableXZ(pos);

          const remainAfter = attemptLen - allowed;
          if (remainAfter <= 1e-6) {
            resolvedThisStep = true;
            break;
          }

          avatarSweepVec.copy(avatarSweepDir).multiplyScalar(remainAfter);
          const intoN = avatarSweepVec.dot(avatarHitNormal);
          avatarSweepVec.addScaledVector(avatarHitNormal, -intoN);

          if (avatarSweepVec.lengthSq() <= 1e-10) {
            resolvedThisStep = true;
            break;
          }

          avatarAttemptVec.copy(avatarSweepVec);
        }

        if (!resolvedThisStep) {
          break;
        }

        remainingLen -= stepLen;
        if (remainingLen <= 1e-6) break;
      }

      return traveled;
    }





    function updateAvatarFromInputs(dt) {
      if (!avatar || !avatarState.enabled) return;

      let forwardAmount = 0;
      let strafeAmount = 0;
      let inputMag = 0;
      let wantsRun = false;

      const joyForward = -joystickState.valueY;
      const joyStrafe = joystickState.valueX;
      const joyMag = Math.min(1, Math.sqrt(joyForward * joyForward + joyStrafe * joyStrafe));

      if (joystickState.active && joyMag > 0) {
        forwardAmount = joyForward;
        strafeAmount = joyStrafe;
        inputMag = joyMag;
        wantsRun = false;
      } else {
        forwardAmount = avatarState.moveZ;
        strafeAmount = avatarState.moveX;
        inputMag = Math.min(1, Math.sqrt(forwardAmount * forwardAmount + strafeAmount * strafeAmount));
        wantsRun = !!avatarKeys.run && inputMag > 0;
      }

      if (inputMag <= 0) {
        const speedNow = avatarVelocity.length();
        if (speedNow > 0) {
          avatarToTarget.copy(avatarVelocity).multiplyScalar(-1);
          const maxStep = avatarMotionConfig.maxDecel * dt;
          if (avatarToTarget.length() <= maxStep) {
            avatarVelocity.set(0, 0, 0);
          } else {
            avatarToTarget.setLength(maxStep);
            avatarVelocity.add(avatarToTarget);
          }
        }
      } else {
        camera.getWorldDirection(camForward);
        camForward.y = 0;
        if (camForward.lengthSq() < 1e-8) camForward.set(0, 0, -1);
        camForward.normalize();

        camRight.crossVectors(camForward, worldUp).normalize();

        avatarMoveDir
        .copy(camForward)
        .multiplyScalar(forwardAmount)
        .addScaledVector(camRight, strafeAmount);

        if (avatarMoveDir.lengthSq() > 1e-8) {
          avatarMoveDir.normalize();
        } else {
          avatarMoveDir.set(0, 0, 0);
        }

        const speedTarget = (wantsRun ? AVATAR_RUN_SPEED : AVATAR_WALK_SPEED) * inputMag;
        const desiredVel = avatarTmpVec.copy(avatarMoveDir).multiplyScalar(speedTarget);

        const speedNow = avatarVelocity.length();
        avatarToTarget.subVectors(desiredVel, avatarVelocity);
        const distToTarget = avatarToTarget.length();

        if (distToTarget > 1e-6) {
          const accelerating = speedTarget > speedNow;
          const accel = accelerating ? avatarMotionConfig.maxAccel : avatarMotionConfig.maxDecel;
          const maxStep = accel * dt;

          if (distToTarget <= maxStep) {
            avatarVelocity.copy(desiredVel);
          } else {
            avatarToTarget.setLength(maxStep);
            avatarVelocity.add(avatarToTarget);
          }
        }
      }

      if (avatarVelocity.length() < avatarMotionConfig.stopEps) {
        avatarVelocity.set(0, 0, 0);
      }

      const prevX = avatar.position.x;
      const prevZ = avatar.position.z;

      if (avatarVelocity.lengthSq() > 0) {
        avatarTmpMove.copy(avatarVelocity).multiplyScalar(dt);
        avatarTmpMove.y = 0;
        avatar.position.add(avatarTmpMove);

        resolveAvatarXZCollisions(avatar.position);

        if (avatarState.viewMode === "third") {
          const dx = avatar.position.x - prevX;
          const dz = avatar.position.z - prevZ;
          if (dx * dx + dz * dz > 1e-10) {
            const targetYaw = Math.atan2(dx, dz);
            avatar.rotation.y = lerpYaw(avatar.rotation.y, targetYaw, avatarMotionConfig.yawLerpThird);
          }
        }
      } else {
        resolveAvatarXZCollisions(avatar.position);
      }

      const dx = avatar.position.x - prevX;
      const dz = avatar.position.z - prevZ;
      const actualSpeed = dt > 0 ? (Math.sqrt(dx * dx + dz * dz) / dt) : 0;

      const airborne = !!avatarJumpState.active && !avatarJumpState.grounded;

      if (airborne) {
        if (avatarMixer && avatarActions.jump) {
          if (avatarCurrentActionName !== "jump") playAvatarJumpAction();
        }
        return;
      }

      let targetAction = "idle";
      if (actualSpeed < avatarMotionConfig.stopEps) {
        targetAction = "idle";
      } else {
        const runThreshold = (AVATAR_WALK_SPEED + AVATAR_RUN_SPEED) * 0.5;
        targetAction = actualSpeed >= runThreshold ? "run" : "walk";
      }

      switchAvatarAction(targetAction);
      updateAvatarClipSpeed(actualSpeed);

      stampSnowFromAvatar(actualSpeed);
    }









    /**
     * Updates camera rig to follow the avatar.
     * third-person: move camera+target by avatar movement delta.
     * first-person: camera pinned to head; avatar yaw follows camera look.
     */
    function updateAvatarCamera(dt) {
      if (!avatarState.enabled || !avatar || !controls) return;

      avatar.getWorldPosition(avatarWorldPos);

      if (avatarState.viewMode === "third") {
        if (avatar) avatar.visible = true;

        if (!avatarHasLastPos) {
          placeCameraBehindAvatar();
          return;
        }

        avatarTmpVec.subVectors(avatarWorldPos, avatarLastWorldPos);
        if (avatarTmpVec.lengthSq() > 0) {
          controls.target.add(avatarTmpVec);
          camera.position.add(avatarTmpVec);
        }

        avatarLastWorldPos.copy(avatarWorldPos);
        return;
      }

      if (avatar) avatar.visible = false;

      avatarHeadPos.copy(avatarWorldPos);
      avatarHeadPos.y += avatarViewConfig.firstPersonHeight;

      camera.getWorldDirection(avatarTmpDir);
      avatarTmpDir.normalize();

      const desiredYaw = Math.atan2(avatarTmpDir.x, avatarTmpDir.z);
      avatar.rotation.y = lerpYaw(avatar.rotation.y, desiredYaw, avatarMotionConfig.yawLerpFirst);

      camera.position.copy(avatarHeadPos);
      controls.target.copy(avatarHeadPos).add(avatarTmpDir);

      avatarHasLastPos = false;
    }


    const avatarChaseCamState = {
      enabled: false,

      // OrbitControls target height above the avatar origin.
      lookHeight: 1.6,

      // How quickly the target follows the avatar translation (lower = more inertia).
      targetStiffness: 6.0,

      // How quickly the camera azimuth eases behind the avatar (lower = more inertia).
      yawStiffness: 0.95,

      // Clamp on per-frame yaw blending to keep motion smooth and non-snappy.
      maxYawAlpha: 0.035,

      // Internal state
      has: false,
      userOverride: false,
      pendingRecenter: false,
      userInteracting: false,
      hooksInstalled: false
    };

    const avatarChasePrevControlsState = {
      has: false,
      enableRotate: true,
      enablePan: true,
      enableZoom: true,
      enableDamping: true
    };

    const avatarChaseWorldPos = new THREE.Vector3();
    const avatarChaseHeadPos = new THREE.Vector3();
    const avatarChaseForward = new THREE.Vector3();

    const avatarChaseOldTarget = new THREE.Vector3();
    const avatarChaseNewTarget = new THREE.Vector3();
    const avatarChaseDelta = new THREE.Vector3();

    const avatarChaseOffset = new THREE.Vector3();
    const avatarChaseSpherical = new THREE.Spherical();

    /**
     * Marks a user-driven OrbitControls interaction while avatar chase mode is active.
     * Manual orbit sets an override that blocks auto-behind until movement input resumes.
     */
    function onAvatarChaseOrbitStart() {
      if (!avatarChaseCamState.enabled) return;
      avatarChaseCamState.userInteracting = true;
      avatarChaseCamState.userOverride = true;
      avatarChaseCamState.pendingRecenter = false;
      lastInteractionTime = performance.now() * 0.001;
    }

    /**
     * Marks the end of a user-driven OrbitControls interaction while avatar chase mode is active.
     */
    function onAvatarChaseOrbitEnd() {
      if (!avatarChaseCamState.enabled) return;
      avatarChaseCamState.userInteracting = false;
      lastInteractionTime = performance.now() * 0.001;
    }

    /**
     * Installs OrbitControls hooks used by avatar chase mode exactly once.
     */
    function ensureAvatarChaseOrbitHooks() {
      if (avatarChaseCamState.hooksInstalled || !controls) return;
      controls.addEventListener("start", onAvatarChaseOrbitStart);
      controls.addEventListener("end", onAvatarChaseOrbitEnd);
      avatarChaseCamState.hooksInstalled = true;
    }

    /**
     * Enables/disables avatar chase camera mode while keeping OrbitControls usable:
     * rotate/zoom/damping remain enabled; pan is disabled so the target stays locked to the avatar.
     */
    function setAvatarChaseCameraEnabled(enabled) {
      const next = !!enabled;
      if (avatarChaseCamState.enabled === next) return;

      avatarChaseCamState.enabled = next;
      avatarChaseCamState.has = false;
      avatarChaseCamState.userOverride = false;
      avatarChaseCamState.pendingRecenter = false;
      avatarChaseCamState.userInteracting = false;

      if (!controls) return;

      if (next) {
        ensureAvatarChaseOrbitHooks();

        avatarChaseCamState.lookHeight = avatarViewConfig.thirdPersonHeight;

        if (!avatarChasePrevControlsState.has) {
          avatarChasePrevControlsState.has = true;
          avatarChasePrevControlsState.enableRotate = !!controls.enableRotate;
          avatarChasePrevControlsState.enablePan = !!controls.enablePan;
          avatarChasePrevControlsState.enableZoom = !!controls.enableZoom;
          avatarChasePrevControlsState.enableDamping = !!controls.enableDamping;
        }

        controls.enableRotate = true;
        controls.enableZoom = true;
        controls.enableDamping = true;
        controls.enablePan = false;
        controls.autoRotate = false;

        avatarHasLastPos = false;
      } else {
        controls.enableRotate = avatarChasePrevControlsState.has ? avatarChasePrevControlsState.enableRotate : true;
        controls.enablePan = avatarChasePrevControlsState.has ? avatarChasePrevControlsState.enablePan : true;
        controls.enableZoom = avatarChasePrevControlsState.has ? avatarChasePrevControlsState.enableZoom : true;
        controls.enableDamping = avatarChasePrevControlsState.has ? avatarChasePrevControlsState.enableDamping : true;
        controls.update();
      }
    }


    /**
     * Updates the avatar chase camera:
     * - Smoothly moves OrbitControls target to the avatar head while translating the camera by the same delta
     *   to preserve orbit distance and prevent drift.
     * - Auto-behind yaw easing runs while the avatar is moving, unless the user has manually orbited.
     * - Manual orbit blocks auto-behind until movement input resumes.
     */
    function updateAvatarChaseCamera(dt) {
      if (!avatarChaseCamState.enabled || !controls) return;
      if (!avatarState.enabled || !avatar) return;
      if (vehicleDriveState.enabled) return;
      if (avatarState.viewMode !== "third") return;

      avatar.getWorldPosition(avatarChaseWorldPos);

      avatarChaseHeadPos.copy(avatarChaseWorldPos);
      avatarChaseHeadPos.y += avatarChaseCamState.lookHeight;

      const targetAlpha =
      1 - Math.pow(0.001, avatarChaseCamState.targetStiffness * Math.max(0.0, dt));

      if (!avatarChaseCamState.has) {
        avatarChaseOldTarget.copy(controls.target);
        controls.target.copy(avatarChaseHeadPos);

        avatarChaseDelta.subVectors(controls.target, avatarChaseOldTarget);
        camera.position.add(avatarChaseDelta);

        avatarChaseCamState.has = true;
        controls.autoRotate = false;
        controls.update();
        return;
      }

      avatarChaseOldTarget.copy(controls.target);
      avatarChaseNewTarget.copy(controls.target).lerp(avatarChaseHeadPos, targetAlpha);

      avatarChaseDelta.subVectors(avatarChaseNewTarget, avatarChaseOldTarget);
      controls.target.copy(avatarChaseNewTarget);
      camera.position.add(avatarChaseDelta);

      const moveKeyActive =
      !!(avatarKeys.forward || avatarKeys.back || avatarKeys.left || avatarKeys.right);

      const moveJoyActive =
      !!(joystickState.active && (Math.abs(joystickState.valueX) > 0.18 || Math.abs(joystickState.valueY) > 0.18));

      const moveInputActive = moveKeyActive || moveJoyActive;

      const stopEpsSq = avatarMotionConfig.stopEps * avatarMotionConfig.stopEps;
      const movingActive = avatarVelocity.lengthSq() > stopEpsSq;

      if (avatarChaseCamState.userOverride) {
        if (moveInputActive) avatarChaseCamState.pendingRecenter = true;

        if (avatarChaseCamState.pendingRecenter && !avatarChaseCamState.userInteracting) {
          avatarChaseCamState.userOverride = false;
          avatarChaseCamState.pendingRecenter = false;
        }
      } else {
        avatarChaseCamState.pendingRecenter = false;
      }

      const allowAutoBehind =
      !avatarChaseCamState.userOverride &&
      !avatarChaseCamState.userInteracting &&
      movingActive;

      if (allowAutoBehind) {
        avatarChaseForward.set(0, 0, 1).applyQuaternion(avatar.quaternion);
        avatarChaseForward.y = 0;

        if (avatarChaseForward.lengthSq() < 1e-8) avatarChaseForward.set(0, 0, 1);
        avatarChaseForward.normalize();

        const desiredTheta = Math.atan2(-avatarChaseForward.x, -avatarChaseForward.z);

        avatarChaseOffset.copy(camera.position).sub(controls.target);

        if (avatarChaseOffset.lengthSq() > 1e-10) {
          avatarChaseSpherical.setFromVector3(avatarChaseOffset);

          let yawAlpha =
          1 - Math.pow(0.001, avatarChaseCamState.yawStiffness * Math.max(0.0, dt));

          yawAlpha = Math.min(avatarChaseCamState.maxYawAlpha, Math.max(0.0, yawAlpha));

          avatarChaseSpherical.theta = lerpYaw(avatarChaseSpherical.theta, desiredTheta, yawAlpha);

          if (Number.isFinite(controls.minPolarAngle)) {
            avatarChaseSpherical.phi = Math.max(avatarChaseSpherical.phi, controls.minPolarAngle);
          }
          if (Number.isFinite(controls.maxPolarAngle)) {
            avatarChaseSpherical.phi = Math.min(avatarChaseSpherical.phi, controls.maxPolarAngle);
          }
          if (Number.isFinite(controls.minDistance)) {
            avatarChaseSpherical.radius = Math.max(avatarChaseSpherical.radius, controls.minDistance);
          }
          if (Number.isFinite(controls.maxDistance)) {
            avatarChaseSpherical.radius = Math.min(avatarChaseSpherical.radius, controls.maxDistance);
          }

          avatarChaseOffset.setFromSpherical(avatarChaseSpherical);
          camera.position.copy(controls.target).add(avatarChaseOffset);
        }
      }

      controls.autoRotate = false;
      controls.update();
    }




    function tickAvatar(dt) {
      if (avatarState.enabled) {
        if (vehicleDriveState.enabled) {
          tickVehicle(dt);
        } else {
          updateAvatarFromInputs(dt);
          updateAvatarJump(dt);
          tickVehicleProximity();
        }
      } else {
        if (vehicleDriveState.enabled) {
          exitVehicle();
        } else {
          if (vehiclePromptState.open) setVehiclePrompt(false, null);
          updateVehicleOutlineFor(null);
        }

        avatarJumpState.active = false;
        avatarJumpState.grounded = true;
        avatarJumpState.vy = 0.0;
        if (avatar) avatarJumpState.groundY = avatar.position.y;
      }

      if (avatarMixer) {
        avatarMixer.update(dt);
      }
    }




    /**
     * Wires UI controls (avatar, edit world, transform buttons, vehicle prompt, keyboard help, joystick).
     * Keeps all handlers in one place and ensures mobile joystick state is correctly initialized.
     */
    function setupAvatarUI() {
      const avatarToggleBtn = document.getElementById("avatarToggle");
      const avatarViewToggleBtn = document.getElementById("avatarViewToggle");
      const worldEditToggleBtn = document.getElementById("worldEditToggle");
      const worldsBtn = document.getElementById("worldsBtn");
      const saveWorldBtn = document.getElementById("saveWorldBtn");
      const playerProfileBtn = document.getElementById("playerProfileBtn");

      const worldEditUndoBtn = document.getElementById("worldEditUndoBtn");
      const worldEditRedoBtn = document.getElementById("worldEditRedoBtn");
      const worldEditTransformModeBtn = document.getElementById("worldEditTransformMode");
      const worldEditDuplicateBtn = document.getElementById("worldEditDuplicateBtn");
      const worldEditDeleteBtn = document.getElementById("worldEditDeleteBtn");

      const joystickEl = document.getElementById("joystick");

      const vehicleEnterBtn = document.getElementById("vehicleEnterBtn");
      const vehicleExitBtn = document.getElementById("vehicleExitBtn");
      const vehicleCloseBtn = document.getElementById("vehicleCloseBtn");

      worldNameEl = document.getElementById("worldName");
      setWorldNameLabel(worldUiState.title);

      keyboardHelpEl = document.getElementById("keyboardHelp");
      keyboardHelpCloseBtn = document.getElementById("keyboardHelpClose");

      ensurePlayerProfileOverlayWired();

      if (keyboardHelpCloseBtn) {
        keyboardHelpCloseBtn.addEventListener("click", (event) => {
          event.preventDefault();
          setKeyboardHelpOpen(false);
        });
      }

      if (keyboardHelpEl) {
        keyboardHelpEl.addEventListener("pointerdown", (event) => {
          if (event.target === keyboardHelpEl) setKeyboardHelpOpen(false);
        });

        setKeyboardHelpOpen(keyboardHelpState.open);
      }

      if (worldsBtn) {
        worldsBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (worldPickerState && worldPickerState.open) setWorldPickerOpen(false);
          else openWorldPickerOverlay();
        });
      }

      if (saveWorldBtn) {
        saveWorldBtn.addEventListener("click", async (event) => {
          event.preventDefault();
          await saveActiveWorld();
        });
      }

      if (playerProfileBtn) {
        playerProfileBtn.addEventListener("click", (event) => {
          event.preventDefault();
          setPlayerProfileOpen(!playerProfileState.open);
        });
      }

      if (avatarToggleBtn) {
        avatarToggleBtn.addEventListener("click", () => {
          if (avatarState.enabled) {
            disableAvatarControl();
          } else {
            enableAvatarControl(avatarState.viewMode);
          }
          updateAvatarButtons();
        });
      }

      if (avatarViewToggleBtn) {
        avatarViewToggleBtn.addEventListener("click", () => {
          const next = avatarState.viewMode === "third" ? "first" : "third";

          if (avatarState.enabled) {
            setAvatarViewMode(next, true);
          } else {
            avatarState.viewMode = next;
          }

          updateAvatarButtons();
        });
      }

      if (worldEditToggleBtn) {
        worldEditToggleBtn.addEventListener("click", () => {
          setWorldEditEnabled(!worldEditState.enabled);
        });
      }

      if (worldEditUndoBtn) {
        worldEditUndoBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (!worldEditState.enabled) return;
          worldEditUndo();
          updateAvatarButtons();
        });
      }

      if (worldEditRedoBtn) {
        worldEditRedoBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (!worldEditState.enabled) return;
          worldEditRedo();
          updateAvatarButtons();
        });
      }

      if (worldEditTransformModeBtn) {
        worldEditTransformModeBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (!worldEditState.enabled || !transformControls) return;

          const mode = transformControls.mode || "translate";
          const next =
          mode === "translate" ? "rotate" :
          mode === "rotate" ? "scale" :
          "translate";

          transformControls.setMode(next);
          updateAvatarButtons();
        });
      }

      if (worldEditDuplicateBtn) {
        worldEditDuplicateBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (!worldEditState.enabled || !worldEditState.selected) return;
          duplicateSelectedWorldModel();
          updateAvatarButtons();
        });
      }

      if (worldEditDeleteBtn) {
        worldEditDeleteBtn.addEventListener("click", (event) => {
          event.preventDefault();
          if (!worldEditState.enabled || !worldEditState.selected) return;
          deleteSelectedWorldModel();
          updateAvatarButtons();
        });
      }

      if (vehicleEnterBtn) {
        vehicleEnterBtn.addEventListener("click", () => {
          if (!vehicleDriveState.enabled && vehiclePromptState.nearby) {
            enterVehicle(vehiclePromptState.nearby);
          }
        });
      }

      if (vehicleExitBtn) {
        vehicleExitBtn.addEventListener("click", () => {
          if (vehicleDriveState.enabled) exitVehicle();
        });
      }

      if (vehicleCloseBtn) {
        vehicleCloseBtn.addEventListener("click", () => {
          setVehiclePrompt(false, null);
          updateVehicleOutlineFor(null);
        });
      }

      if (joystickEl) {
        joystickEl.addEventListener("pointerdown", (event) => {
          event.preventDefault();
          joystickState.active = true;
          joystickState.pointerId = event.pointerId;

          const rect = joystickEl.getBoundingClientRect();
          joystickState.centerX = rect.left + rect.width * 0.5;
          joystickState.centerY = rect.top + rect.height * 0.5;
          joystickState.radius = rect.width * 0.5;

          joystickEl.setPointerCapture(event.pointerId);
          updateJoystickFromPointer(event.clientX, event.clientY);
        });

        joystickEl.addEventListener("pointermove", (event) => {
          if (!joystickState.active || event.pointerId !== joystickState.pointerId) return;
          event.preventDefault();
          updateJoystickFromPointer(event.clientX, event.clientY);
        });

        const endHandler = (event) => {
          if (event.pointerId !== joystickState.pointerId) return;
          event.preventDefault();

          joystickEl.releasePointerCapture(event.pointerId);
          resetJoystick();
        };

        joystickEl.addEventListener("pointerup", endHandler);
        joystickEl.addEventListener("pointercancel", endHandler);
      }

      updateAvatarButtons();
      setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);
      setPlayerProfileOpen(false);
    }







    /**
     * Refreshes UI button labels/visibility/disabled state based on avatar + world editor state.
     */
    function updateAvatarButtons() {
      const toggle = document.getElementById("avatarToggle");
      const view = document.getElementById("avatarViewToggle");
      const edit = document.getElementById("worldEditToggle");

      const undoBtn = document.getElementById("worldEditUndoBtn");
      const redoBtn = document.getElementById("worldEditRedoBtn");
      const modeBtn = document.getElementById("worldEditTransformMode");
      const dupBtn = document.getElementById("worldEditDuplicateBtn");
      const delBtn = document.getElementById("worldEditDeleteBtn");

      if (toggle) {
        toggle.textContent = avatarState.enabled ? "Avatar: ON" : "Avatar: OFF";
      }

      if (view) {
        view.textContent = avatarState.viewMode === "third" ? "View: Behind" : "View: Eyes";
      }

      if (edit) {
        edit.textContent = worldEditState.enabled ? "Edit World: ON" : "Edit World: OFF";
      }

      const visible = !!worldEditState.enabled;

      const setVisible = (el) => {
        if (!el) return;
        el.style.display = visible ? "flex" : "none";
        el.setAttribute("aria-hidden", visible ? "false" : "true");
      };

      setVisible(undoBtn);
      setVisible(redoBtn);
      setVisible(modeBtn);
      setVisible(dupBtn);
      setVisible(delBtn);

      if (!visible) return;

      const hasSelection = !!worldEditState.selected;
      const canUndo = !!(worldEditHistory && worldEditHistory.undo && worldEditHistory.undo.length);
      const canRedo = !!(worldEditHistory && worldEditHistory.redo && worldEditHistory.redo.length);
      const hasTransform = !!transformControls;

      if (undoBtn) undoBtn.disabled = !canUndo;
      if (redoBtn) redoBtn.disabled = !canRedo;
      if (dupBtn) dupBtn.disabled = !hasSelection;
      if (delBtn) delBtn.disabled = !hasSelection;

      if (modeBtn) {
        modeBtn.disabled = !hasTransform;

        const mode = hasTransform ? (transformControls.mode || "translate") : "translate";
        modeBtn.textContent = mode === "translate" ? "P" : mode === "rotate" ? "R" : "S";
      }
    }










    // -------------------------------------------------------------------------
    // Snowman path animation – curvy, local “snail” trajectory
    // -------------------------------------------------------------------------

    const snowmanPathCenter = new THREE.Vector3(-7, 0, -1);
    const snowmanPathPoints = [];
    const SNOWMAN_PATH_SEGMENTS = 9;

    (function buildSnowmanPath() {
      const baseR = DEFAULTS.snowmanPathRadius;
      for (let i = 0; i < SNOWMAN_PATH_SEGMENTS; i++) {
        const a = (i / SNOWMAN_PATH_SEGMENTS) * Math.PI * 2.0;

        // radius modulation -> mixture of almost circles and arcs
        const rMul = 0.72 + 0.20 * Math.sin(i * 1.47) + 0.12 * Math.cos(i * 2.17);
        const r = baseR * rMul;

        const x = snowmanPathCenter.x + Math.cos(a) * r;
        const z = snowmanPathCenter.z + Math.sin(a) * r;
        const y = 0.0;

        snowmanPathPoints.push(new THREE.Vector3(x, y, z));
      }
    })();

    const snowmanPathCurve = new THREE.CatmullRomCurve3(
      snowmanPathPoints,
      true,
      "catmullrom",
      0.5
      );

    const snowmanState = {
      t: 0,
      lastPos: new THREE.Vector3(NaN, NaN, NaN)
    };

    function updateSnowman(dt) {
      if (dt <= 0) return;
      if (!params.snowmanMoveEnabled) return;

      const snowmanObj = getModelInstance("snowman");
      if (!snowmanObj) return;

      // loops per second along the closed curve
      const speed = clamp(params.snowmanSpeed, 0.0, 1.0);
      if (speed <= 0.0) return;

      snowmanState.t = (snowmanState.t + dt * speed) % 1.0;

      // position on curve
      const curvePos = snowmanPathCurve.getPointAt(snowmanState.t);

      // place him on top of snow surface
      const groundY = sampleSnowHeight(curvePos.x, curvePos.z);
      snowmanObj.position.set(curvePos.x, groundY, curvePos.z);

      // face along direction of motion (XZ plane)
      const tangent = snowmanPathCurve.getTangentAt(snowmanState.t);
      const dirX = tangent.x;
      const dirZ = tangent.z;

      if (dirX !== 0 || dirZ !== 0) {
        // world +Z = forward. atan2(x, z) gives heading around Y.
        const heading = Math.atan2(dirX, dirZ);
        snowmanObj.rotation.y = heading;
      }

      snowmanState.lastPos.copy(snowmanObj.position);
    }



    // Drifts (heightfield)
    let DRIFT_GRID = 0;
    let DRIFT_STRIDE = 0;
    let DRIFT_VERTS = 0;
    let driftHeights = null;
    let driftHeightsTmp = null;
    let driftDeform = null;
    let driftGeo = null;
    let driftPosAttr = null;
    let driftPosArray = null;
    let driftColorAttr = null;
    let driftColorArray = null;
    let snowSurface = null;

    let forceDriftWrite = false;
    let forceDriftNormals = false;



        // Wet trail decals (fading surface marks)
    let wetTrailGroup = null;
    let wetTrailGeo = null;
    let wetTrailPool = [];
    let wetTrailCursor = 0;

    const wetTrailConfig = {
      enabled: true,
      maxMarks: 260,
      life: 4.5,
      opacity: 0.38,
      lift: 0.035,

      avatarSize: 0.38,
      vehicleWidth: 0.46,
      vehicleLength: 0.90,

          // Back-compat fallback (older code paths)
      color: "#1a1a1a",

          // Per-type colors (used by spawnWetTrailMark)
      avatarColor: "#ffffff",
      vehicleColor: "#1a1a1a",

          // Avatar decal alpha texture: two ovals + bridge (footprint)
      avatarUseFootprint: true,
      footTexSize: 128,
      footToeScale: 0.62,
      footHeelScale: 0.52,
      footBridge: 0.22,
      footSoftness: 0.55
    };




    /* GPU point-sprite dust/fire column; driven by params and saved/loaded with worlds/presets. */
    function disposeDust() {
      if (dustPoints) {
        scene.remove(dustPoints);
        dustPoints.geometry.dispose();
        dustPoints.material.dispose();
      }
      dustGeometry = null;
      dustMaterial = null;
      dustPoints = null;
      dustUniforms = null;
    }

    function applyDustParamsToUniforms() {
      if (!dustUniforms) return;

      const floorY = params.dustFloorY;
      const ceilY = Math.max(floorY + 0.01, params.dustCeilY);

      dustUniforms.uSpeed.value = params.dustSpeed;
      dustUniforms.uFloor.value = floorY;
      dustUniforms.uHeight.value = Math.max(0.01, ceilY - floorY);
      dustUniforms.uRadius.value = params.dustRadius;
      dustUniforms.uSize.value = params.dustSize;
      dustUniforms.uNoiseAmp.value = params.dustNoise;

      dustCenterTmp.set(params.dustCenterX, 0.0, params.dustCenterZ);
      dustUniforms.uCenter.value.copy(dustCenterTmp);

      dustUniforms.uColorInner.value.set(params.dustColorInner || "#ffc57a");
      dustUniforms.uColorOuter.value.set(params.dustColorOuter || "#222222");
    }

    function rebuildDust() {
      disposeDust();

      if (!params.dustEnabled) {
        dustLastCount = params.dustCount | 0;
        return;
      }

      const count = Math.max(1, (params.dustCount | 0) || 1);
      dustLastCount = count;

      const positions = new Float32Array(count * 3);
      const seeds = new Float32Array(count);
      const angles = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        positions[i3 + 0] = params.dustCenterX;
        positions[i3 + 1] = params.dustFloorY;
        positions[i3 + 2] = params.dustCenterZ;

        seeds[i] = Math.random() * 100.0;
        angles[i] = Math.random() * Math.PI * 2.0;
      }

      dustGeometry = new THREE.BufferGeometry();
      dustGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      dustGeometry.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));
      dustGeometry.setAttribute("aAngle", new THREE.BufferAttribute(angles, 1));

      dustUniforms = {
        uTime: { value: 0 },
        uSpeed: { value: params.dustSpeed },
        uFloor: { value: params.dustFloorY },
        uHeight: { value: Math.max(0.01, params.dustCeilY - params.dustFloorY) },
        uRadius: { value: params.dustRadius },
        uCenter: { value: new THREE.Vector3(params.dustCenterX, 0.0, params.dustCenterZ) },
        uSize: { value: params.dustSize },
        uNoiseAmp: { value: params.dustNoise },
        uColorInner: { value: new THREE.Color(params.dustColorInner || "#ffc57a") },
        uColorOuter: { value: new THREE.Color(params.dustColorOuter || "#222222") },
      };

      const dustVertexShader = /* glsl */ `
        uniform float uTime;
        uniform float uSpeed;
        uniform float uFloor;
        uniform float uHeight;
        uniform float uRadius;
        uniform vec3  uCenter;
        uniform float uSize;
        uniform float uNoiseAmp;

        attribute float aSeed;
        attribute float aAngle;

        varying float vLife;
        varying float vNoise;

        void main() {
          float t = uTime * uSpeed + aSeed;

          float life = fract(t * 0.15);
          vLife = life;

          float y = uFloor + life * uHeight;

          float baseR = uRadius * (0.65 + 0.35 * sin(aSeed * 4.123));
          float swirl = sin(t * 0.35 + aSeed * 1.7);
          float angle = aAngle + swirl * 0.8;

          float x = baseR * cos(angle);
          float z = baseR * sin(angle);

          vec3 pos = vec3(x, y, z) + uCenter;

          float wigglePhase = t * 1.7 + aSeed * 3.11;
          float wiggleStrength = uNoiseAmp * (1.0 - life);
          float wx = sin(wigglePhase) * 0.25 * wiggleStrength;
          float wz = cos(wigglePhase * 0.7) * 0.25 * wiggleStrength;
          pos.x += wx;
          pos.z += wz;

          vNoise = wiggleStrength;

          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);

          float ps = uSize * (0.7 + (1.0 - life) * 1.3);
          ps *= (300.0 / max(1.0, -mvPosition.z));
          gl_PointSize = ps;

          gl_Position = projectionMatrix * mvPosition;
        }
      `;

      const dustFragmentShader = /* glsl */ `
        uniform vec3 uColorInner;
        uniform vec3 uColorOuter;

        varying float vLife;
        varying float vNoise;

        void main() {
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          float alpha = smoothstep(0.5, 0.0, d);
          alpha *= (1.0 - vLife) * 0.9 + 0.1;

          if (alpha <= 0.01) discard;

          float mixFactor = (1.0 - vLife) + abs(vNoise) * 0.25;
          vec3 color = mix(uColorOuter, uColorInner, clamp(mixFactor, 0.0, 1.0));

          gl_FragColor = vec4(color, alpha);
        }
      `;

      dustMaterial = new THREE.ShaderMaterial({
        uniforms: dustUniforms,
        vertexShader: dustVertexShader,
        fragmentShader: dustFragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      dustPoints = new THREE.Points(dustGeometry, dustMaterial);
      dustPoints.frustumCulled = false;
      scene.add(dustPoints);

      applyDustParamsToUniforms();
    }

    function updateDust(dt) {
      if (!dustUniforms) return;
      dustUniforms.uTime.value += dt;
    }



    /* GPU point-sprite rain streaks; driven by params and saved/loaded with worlds/presets. */
    function disposeRain() {
      if (rainPoints) {
        scene.remove(rainPoints);
        rainPoints.geometry.dispose();
        rainPoints.material.dispose();
      }
      rainGeometry = null;
      rainMaterial = null;
      rainPoints = null;
      rainUniforms = null;
    }

    function applyRainParamsToUniforms() {
      if (!rainUniforms) return;

      const topY = params.rainTopY;
      const bottomY = Math.min(topY - 0.01, params.rainBottomY);

      rainUniforms.uSpeed.value = params.rainSpeed;
      rainUniforms.uTop.value = topY;
      rainUniforms.uBottom.value = bottomY;
      rainUniforms.uRadius.value = params.rainRadius;
      rainUniforms.uSize.value = params.rainSize;
      rainUniforms.uThickness.value = params.rainThickness;
      rainUniforms.uStreak.value = params.rainStreak;
      rainUniforms.uOpacity.value = params.rainOpacity;

      rainUniforms.uWind.value.set(params.rainWindX, params.rainWindZ);

      rainCenterTmp.set(params.rainCenterX, 0.0, params.rainCenterZ);
      rainUniforms.uCenter.value.copy(rainCenterTmp);

      rainUniforms.uColor.value.set(params.rainColor || "#bcd7ff");
    }

    function rebuildRain() {
      disposeRain();

      if (!params.rainEnabled) {
        rainLastCount = params.rainCount | 0;
        return;
      }

      const count = Math.max(1, (params.rainCount | 0) || 1);
      rainLastCount = count;

      const positions = new Float32Array(count * 3);
      const seeds = new Float32Array(count);
      const angles = new Float32Array(count);
      const rands = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        positions[i3 + 0] = params.rainCenterX;
        positions[i3 + 1] = params.rainTopY;
        positions[i3 + 2] = params.rainCenterZ;

        seeds[i] = Math.random() * 100.0;
        angles[i] = Math.random() * Math.PI * 2.0;
        rands[i] = Math.random();
      }

      rainGeometry = new THREE.BufferGeometry();
      rainGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      rainGeometry.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));
      rainGeometry.setAttribute("aAngle", new THREE.BufferAttribute(angles, 1));
      rainGeometry.setAttribute("aRad", new THREE.BufferAttribute(rands, 1));

      const VERT = /* glsl */`
        attribute float aSeed;
        attribute float aAngle;
        attribute float aRad;

        uniform float uTime;
        uniform float uSpeed;
        uniform float uTop;
        uniform float uBottom;
        uniform float uRadius;
        uniform vec3 uCenter;
        uniform vec2 uWind;
        uniform float uSize;

        varying float vLife;

        float hash(float n) { return fract(sin(n) * 43758.5453123); }

        void main() {
          float life = fract(uTime * uSpeed + aSeed);
          vLife = life;

          float y = mix(uTop, uBottom, life);

          float rad = sqrt(aRad) * uRadius;
          vec2 ring = vec2(cos(aAngle), sin(aAngle)) * rad;

          float h = max(0.01, uTop - uBottom);
          vec2 drift = uWind * (1.0 - life) * h;

          vec2 jitter = vec2(hash(aSeed * 1.7) - 0.5, hash(aSeed * 2.9) - 0.5) * (0.03 * uRadius);

          vec3 p = vec3(
            uCenter.x + ring.x + drift.x + jitter.x,
            y,
            uCenter.z + ring.y + drift.y + jitter.y
          );

          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          float dist = max(0.001, -mvPosition.z);
          gl_PointSize = uSize * (300.0 / dist);
        }
      `;

      const FRAG = /* glsl */`
        precision mediump float;

        uniform vec3 uColor;
        uniform float uOpacity;
        uniform float uThickness;
        uniform float uStreak;

        varying float vLife;

        void main() {
          vec2 uv = gl_PointCoord;

          float x = abs(uv.x - 0.5);
          float line = smoothstep(uThickness, 0.0, x);

          float head = smoothstep(0.0, 0.08, uv.y);
          float tail = 1.0 - smoothstep(1.0 - uStreak, 1.0, uv.y);
          float len = head * tail;

          float fadeBottom = 1.0 - smoothstep(0.85, 1.0, vLife);

          float a = line * len * fadeBottom * uOpacity;
          if (a <= 0.001) discard;

          gl_FragColor = vec4(uColor, a);
        }
      `;

      rainMaterial = new THREE.ShaderMaterial({
        vertexShader: VERT,
        fragmentShader: FRAG,
        transparent: true,
        depthWrite: false,
        depthTest: true,
        blending: THREE.NormalBlending
      });

      rainUniforms = {
        uTime: { value: 0.0 },
        uSpeed: { value: params.rainSpeed },
        uTop: { value: params.rainTopY },
        uBottom: { value: Math.min(params.rainTopY - 0.01, params.rainBottomY) },
        uRadius: { value: params.rainRadius },
        uCenter: { value: new THREE.Vector3(params.rainCenterX, 0.0, params.rainCenterZ) },
        uWind: { value: new THREE.Vector2(params.rainWindX, params.rainWindZ) },
        uSize: { value: params.rainSize },
        uThickness: { value: params.rainThickness },
        uStreak: { value: params.rainStreak },
        uColor: { value: new THREE.Color(params.rainColor || "#bcd7ff") },
        uOpacity: { value: params.rainOpacity }
      };

      rainMaterial.uniforms = rainUniforms;

      rainPoints = new THREE.Points(rainGeometry, rainMaterial);
      rainPoints.frustumCulled = false;
      rainPoints.renderOrder = 5;

      scene.add(rainPoints);

      applyRainParamsToUniforms();
    }

    function updateRain(dt) {
      if (!rainUniforms) return;
      rainUniforms.uTime.value += dt;
    }


    // -------------------------------------------------------------------------
    // Grass (instanced blades + wind shader; driven by params and saved/loaded)
    // -------------------------------------------------------------------------

    let grassBladeBaseGeo = null;

    let grassGeometry = null;
    let grassMaterial = null;
    let grassMesh = null;
    let grassUniforms = null;
    let grassLastCount = 0;

    const grassCenterV2 = new THREE.Vector2();

    /* Disposes grass GPU resources and removes from the scene. */
    function disposeGrass() {
      if (grassMesh) {
        scene.remove(grassMesh);
        grassMesh.geometry.dispose();
        grassMesh.material.dispose();
      }
      grassGeometry = null;
      grassMaterial = null;
      grassMesh = null;
      grassUniforms = null;
    }

    /* Pushes current grass params into shader uniforms (no geometry rebuild). */
    function applyGrassParamsToUniforms() {
      if (!grassUniforms) return;

      grassUniforms.uRadius.value = params.grassRadius;
      grassCenterV2.set(params.grassCenterX, params.grassCenterZ);
      grassUniforms.uCenter.value.copy(grassCenterV2);

      grassUniforms.uBaseY.value = params.grassBaseY;

      grassUniforms.uBladeHeight.value = params.grassBladeHeight;
      grassUniforms.uBladeWidth.value = params.grassBladeWidth;
      grassUniforms.uHeightJitter.value = params.grassHeightJitter;
      grassUniforms.uWidthJitter.value = params.grassWidthJitter;

      grassUniforms.uBend.value = params.grassBend;
      grassUniforms.uWindSpeed.value = params.grassWindSpeed;
      grassUniforms.uWindStrength.value = params.grassWindStrength;
      grassUniforms.uStiffness.value = params.grassStiffness;

      grassUniforms.uNoiseScale.value = params.grassNoiseScale;
      grassUniforms.uNoiseStrength.value = params.grassNoiseStrength;
      grassUniforms.uNoiseSpeed.value = params.grassNoiseSpeed;

      grassUniforms.uStaticHeightNoise.value = params.grassStaticHeightNoise;
      grassUniforms.uStaticWidthNoise.value = params.grassStaticWidthNoise;
      grassUniforms.uBorderNoise.value = params.grassBorderNoise;

      grassUniforms.uColorVar.value = params.grassColorVariation;

      params.grassColorBottom = normalizeHexColor(params.grassColorBottom, DEFAULTS.grassColorBottom || "#1f5f2e");
      params.grassColorTop = normalizeHexColor(params.grassColorTop, DEFAULTS.grassColorTop || "#7ee36c");
      grassUniforms.uColorBottom.value.set(params.grassColorBottom);
      grassUniforms.uColorTop.value.set(params.grassColorTop);

      grassUniforms.uOpacity.value = params.grassOpacity;
      grassUniforms.uAlphaCutoff.value = params.grassAlphaCutoff;
    }




/* Rebuilds grass instances and shader material; only needed for enabled/count/seed changes. */
    function rebuildGrass() {
      disposeGrass();

      const countRaw = params.grassCount | 0;
      if (!params.grassEnabled || countRaw <= 0) {
        grassLastCount = countRaw;
        return;
      }

      const count = clamp(countRaw | 0, 1, 120000);
      grassLastCount = count;

      if (!scene) return;

      if (!grassBladeBaseGeo) {
        const g = new THREE.PlaneGeometry(1, 1, 1, 4);
        g.translate(0, 0.5, 0);
        grassBladeBaseGeo = g;
      }

      const rng = makeSeededRandom((params.grassSeed | 0) || 1);

      const disk = new Float32Array(count * 2);
      const yaw = new Float32Array(count);
      const rand = new Float32Array(count * 2);
      const phase = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        const a = rng() * Math.PI * 2.0;
        const r = Math.sqrt(rng());
        disk[i * 2 + 0] = Math.cos(a) * r;
        disk[i * 2 + 1] = Math.sin(a) * r;

        yaw[i] = rng() * Math.PI * 2.0;

        rand[i * 2 + 0] = rng();
        rand[i * 2 + 1] = rng();

        phase[i] = rng() * 10.0;
      }

      grassGeometry = new THREE.InstancedBufferGeometry();
      grassGeometry.index = grassBladeBaseGeo.index;
      grassGeometry.setAttribute("position", grassBladeBaseGeo.getAttribute("position"));
      grassGeometry.setAttribute("normal", grassBladeBaseGeo.getAttribute("normal"));
      grassGeometry.setAttribute("uv", grassBladeBaseGeo.getAttribute("uv"));

      grassGeometry.setAttribute("aDisk", new THREE.InstancedBufferAttribute(disk, 2));
      grassGeometry.setAttribute("aYaw", new THREE.InstancedBufferAttribute(yaw, 1));
      grassGeometry.setAttribute("aRand", new THREE.InstancedBufferAttribute(rand, 2));
      grassGeometry.setAttribute("aPhase", new THREE.InstancedBufferAttribute(phase, 1));

      grassGeometry.instanceCount = count;

      grassUniforms = {
        uTime: { value: 0.0 },
        uBaseWind: { value: new THREE.Vector2(0.0, 0.0) },

        uCenter: { value: new THREE.Vector2(params.grassCenterX, params.grassCenterZ) },
        uRadius: { value: params.grassRadius },
        uBaseY: { value: params.grassBaseY },

        uBladeHeight: { value: params.grassBladeHeight },
        uBladeWidth: { value: params.grassBladeWidth },
        uHeightJitter: { value: params.grassHeightJitter },
        uWidthJitter: { value: params.grassWidthJitter },

        uBend: { value: params.grassBend },
        uWindSpeed: { value: params.grassWindSpeed },
        uWindStrength: { value: params.grassWindStrength },
        uStiffness: { value: params.grassStiffness },

        uNoiseScale: { value: params.grassNoiseScale },
        uNoiseStrength: { value: params.grassNoiseStrength },
        uNoiseSpeed: { value: params.grassNoiseSpeed },

        uStaticHeightNoise: { value: params.grassStaticHeightNoise },
        uStaticWidthNoise: { value: params.grassStaticWidthNoise },
        uBorderNoise: { value: params.grassBorderNoise },

        uColorVar: { value: params.grassColorVariation },

        uColorBottom: { value: new THREE.Color(params.grassColorBottom || "#1f5f2e") },
        uColorTop: { value: new THREE.Color(params.grassColorTop || "#7ee36c") },
        uOpacity: { value: params.grassOpacity },
        uAlphaCutoff: { value: params.grassAlphaCutoff }
      };


  const VERT = /* glsl */`
    precision mediump float;

    attribute vec2 aDisk;
    attribute float aYaw;
    attribute vec2 aRand;
    attribute float aPhase;

    uniform float uTime;
    uniform vec2  uBaseWind;

    uniform vec2  uCenter;
    uniform float uRadius;
    uniform float uBaseY;

    uniform float uBladeHeight;
    uniform float uBladeWidth;
    uniform float uHeightJitter;
    uniform float uWidthJitter;

    uniform float uBend;
    uniform float uWindSpeed;
    uniform float uWindStrength;
    uniform float uStiffness;

    uniform float uNoiseScale;
    uniform float uNoiseStrength;
    uniform float uNoiseSpeed;

    uniform float uStaticHeightNoise;
    uniform float uStaticWidthNoise;
    uniform float uBorderNoise;


    varying float vY;
    varying float vEdge;
    varying float vRand;
    varying float vPatch;
    varying float vMask;

    float hash12(vec2 p) {
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    float valueNoise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f * f * (3.0 - 2.0 * f);

      float a = hash12(i);
      float b = hash12(i + vec2(1.0, 0.0));
      float c = hash12(i + vec2(0.0, 1.0));
      float d = hash12(i + vec2(1.0, 1.0));

      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
    }

    void main() {
      vec3 pos = position;

      float y01 = clamp(pos.y, 0.0, 1.0);

      vec2 base = uCenter + aDisk * uRadius;
      float d01 = clamp(length(aDisk), 0.0, 1.0);

      float jitA = (aRand.x - 0.5) * 2.0;
      float jitB = (aRand.y - 0.5) * 2.0;

      vec2 nsBase = base * max(0.01, uNoiseScale);

      /* Static (build-like) coherent variation: height + width, not time-animated. */
      vec2 npStatic = nsBase + vec2(aPhase * 0.09, aRand.y * 7.31);
      float hN = (valueNoise(npStatic * 1.37 + 11.1) - 0.5) * 2.0;
      float wN = (valueNoise(npStatic * 1.93 + 27.7) - 0.5) * 2.0;

      float hK = 0.55 * clamp(uStaticHeightNoise, 0.0, 2.0);
      float wK = 0.55 * clamp(uStaticWidthNoise, 0.0, 2.0);

      float bh = max(0.01,  uBladeHeight * (1.0 + (jitA * uHeightJitter) + (hN * uHeightJitter * hK)));
      float bw = max(0.001, uBladeWidth  * (1.0 + (jitB * uWidthJitter)  + (wN * uWidthJitter  * wK)));

      /* Irregular boundary mask: affects only the outer edge (keeps interior solid). */
      float edgeT = smoothstep(0.68, 1.0, d01);
      float edgeAmp = 0.35 * clamp(uBorderNoise, 0.0, 1.0);
      float edgeN = valueNoise(nsBase * 0.45 + vec2(19.3, 7.1));
      float edgeR = 1.0 + ((edgeN - 0.5) * 2.0) * edgeAmp;
      edgeR = mix(1.0, edgeR, edgeT);
      vMask = step(d01, edgeR);


      float s = sin(aYaw);
      float c = cos(aYaw);

      float localX = (pos.x) * bw;
      float localY = (pos.y) * bh;

      vec2 pr = vec2(localX * c, localX * s);

      vec2 w = uBaseWind * uWindStrength;
      float wl = length(w);
      vec2 wdir = (wl > 0.0001) ? (w / wl) : normalize(vec2(0.7, 0.2));
      vec2 wperp = vec2(-wdir.y, wdir.x);

      float tt = uTime * uWindSpeed + aPhase + aDisk.x * 3.1 + aDisk.y * 3.3;
      float swayN = sin(tt) * 0.55 + sin(tt * 1.7 + 1.2) * 0.35;
      float swayP = cos(tt * 1.31 + 0.4) * 0.25;

      float wgt = pow(y01, max(0.25, uStiffness));
      vec2 bend = (wdir * swayN + wperp * swayP) * (uBend * wgt);

      vec2 np = nsBase +
                vec2(aPhase * 0.07, aRand.y * 7.31) +
                vec2(0.0, uTime * uNoiseSpeed);

      float nA = valueNoise(np);
      float nB = valueNoise(np * 2.13 + 17.7);

      float n1 = (nA - 0.5) * 2.0;
      float n2 = (nB - 0.5) * 2.0;

      vec2 gust = (wdir * n1 + wperp * n2) * (uBend * wgt * 0.55 * uNoiseStrength);
      bend += gust;

      vec3 worldPos = vec3(base.x, uBaseY + localY, base.y) + vec3(pr.x, 0.0, pr.y);
      worldPos.x += bend.x;
      worldPos.z += bend.y;

      vec4 mv = modelViewMatrix * vec4(worldPos, 1.0);
      gl_Position = projectionMatrix * mv;

      vY = y01;
      vEdge = abs(pos.x);
      vRand = aRand.x * 2.0 - 1.0;
      vPatch = nA;
    }
  `;

  const FRAG = /* glsl */`
    precision mediump float;

    uniform vec3  uColorBottom;
    uniform vec3  uColorTop;
    uniform float uOpacity;
    uniform float uAlphaCutoff;
    uniform float uColorVar;

    varying float vY;
    varying float vEdge;
    varying float vRand;
    varying float vPatch;
    varying float vMask;

    void main() {
      if (vMask < 0.5) discard;

      float taper = mix(1.0, 0.10, vY);
      float x = vEdge / max(0.001, taper);

      float edgeA = smoothstep(1.0, 0.82, x);
      float tipA  = 1.0 - smoothstep(0.92, 1.0, vY);

      float micro = 0.92 + 0.08 * sin(vY * 35.0 + vRand * 6.0);

      float a = edgeA * tipA * micro * uOpacity;
      if (a < uAlphaCutoff) discard;

      float patchMul = 1.0 + ((vPatch - 0.5) * 2.0) * uColorVar;

      vec3 col = mix(uColorBottom, uColorTop, pow(vY, 0.65));
      col *= patchMul;

      gl_FragColor = vec4(col, a);
    }
  `;

  grassMaterial = new THREE.ShaderMaterial({
    uniforms: grassUniforms,
    vertexShader: VERT,
    fragmentShader: FRAG,
    transparent: true,
    depthTest: true,
    depthWrite: false,
    blending: THREE.NormalBlending,
    side: THREE.DoubleSide
  });

  grassMesh = new THREE.Mesh(grassGeometry, grassMaterial);
  grassMesh.frustumCulled = false;
  grassMesh.renderOrder = 2;

  scene.add(grassMesh);

  applyGrassParamsToUniforms();
}




// /* Rebuilds grass instances and shader material; only needed for enabled/count/seed changes. */
//     function rebuildGrass() {
//       disposeGrass();

//       const countRaw = params.grassCount | 0;
//       if (!params.grassEnabled || countRaw <= 0) {
//         grassLastCount = countRaw;
//         return;
//       }

//       const count = clamp(countRaw | 0, 1, 120000);
//       grassLastCount = count;

//       if (!scene) return;

//       if (!grassBladeBaseGeo) {
//         const g = new THREE.PlaneGeometry(1, 1, 1, 4);
//         g.translate(0, 0.5, 0);
//         grassBladeBaseGeo = g;
//       }

//       const rng = makeSeededRandom((params.grassSeed | 0) || 1);

//       const disk = new Float32Array(count * 2);
//       const yaw = new Float32Array(count);
//       const rand = new Float32Array(count * 2);
//       const phase = new Float32Array(count);

//       for (let i = 0; i < count; i++) {
//         const a = rng() * Math.PI * 2.0;
//         const r = Math.sqrt(rng());
//         disk[i * 2 + 0] = Math.cos(a) * r;
//         disk[i * 2 + 1] = Math.sin(a) * r;

//         yaw[i] = rng() * Math.PI * 2.0;

//         rand[i * 2 + 0] = rng();
//         rand[i * 2 + 1] = rng();

//         phase[i] = rng() * 10.0;
//       }

//       grassGeometry = new THREE.InstancedBufferGeometry();
//       grassGeometry.index = grassBladeBaseGeo.index;
//       grassGeometry.setAttribute("position", grassBladeBaseGeo.getAttribute("position"));
//       grassGeometry.setAttribute("normal", grassBladeBaseGeo.getAttribute("normal"));
//       grassGeometry.setAttribute("uv", grassBladeBaseGeo.getAttribute("uv"));

//       grassGeometry.setAttribute("aDisk", new THREE.InstancedBufferAttribute(disk, 2));
//       grassGeometry.setAttribute("aYaw", new THREE.InstancedBufferAttribute(yaw, 1));
//       grassGeometry.setAttribute("aRand", new THREE.InstancedBufferAttribute(rand, 2));
//       grassGeometry.setAttribute("aPhase", new THREE.InstancedBufferAttribute(phase, 1));

//       grassGeometry.instanceCount = count;

//       grassUniforms = {
//         uTime: { value: 0.0 },
//         uBaseWind: { value: new THREE.Vector2(0.0, 0.0) },

//         uCenter: { value: new THREE.Vector2(params.grassCenterX, params.grassCenterZ) },
//         uRadius: { value: params.grassRadius },
//         uBaseY: { value: params.grassBaseY },

//         uBladeHeight: { value: params.grassBladeHeight },
//         uBladeWidth: { value: params.grassBladeWidth },
//         uHeightJitter: { value: params.grassHeightJitter },
//         uWidthJitter: { value: params.grassWidthJitter },

//         uBend: { value: params.grassBend },
//         uWindSpeed: { value: params.grassWindSpeed },
//         uWindStrength: { value: params.grassWindStrength },
//         uStiffness: { value: params.grassStiffness },

//         uNoiseScale: { value: params.grassNoiseScale },
//         uNoiseStrength: { value: params.grassNoiseStrength },
//         uNoiseSpeed: { value: params.grassNoiseSpeed },
//         uColorVar: { value: params.grassColorVariation },

//         uColorBottom: { value: new THREE.Color(params.grassColorBottom || "#1f5f2e") },
//         uColorTop: { value: new THREE.Color(params.grassColorTop || "#7ee36c") },
//         uOpacity: { value: params.grassOpacity },
//         uAlphaCutoff: { value: params.grassAlphaCutoff }
//       };





//   const VERT = /* glsl */`
//     precision mediump float;

//     attribute vec2 aDisk;
//     attribute float aYaw;
//     attribute vec2 aRand;
//     attribute float aPhase;

//     uniform float uTime;
//     uniform vec2  uBaseWind;

//     uniform vec2  uCenter;
//     uniform float uRadius;
//     uniform float uBaseY;

//     uniform float uBladeHeight;
//     uniform float uBladeWidth;
//     uniform float uHeightJitter;
//     uniform float uWidthJitter;

//     uniform float uBend;
//     uniform float uWindSpeed;
//     uniform float uWindStrength;
//     uniform float uStiffness;

//     uniform float uNoiseScale;
//     uniform float uNoiseStrength;
//     uniform float uNoiseSpeed;

//     varying float vY;
//     varying float vEdge;
//     varying float vRand;
//     varying float vPatch;

//     float hash12(vec2 p) {
//       vec3 p3 = fract(vec3(p.xyx) * 0.1031);
//       p3 += dot(p3, p3.yzx + 33.33);
//       return fract((p3.x + p3.y) * p3.z);
//     }

//     float valueNoise(vec2 p) {
//       vec2 i = floor(p);
//       vec2 f = fract(p);
//       f = f * f * (3.0 - 2.0 * f);

//       float a = hash12(i);
//       float b = hash12(i + vec2(1.0, 0.0));
//       float c = hash12(i + vec2(0.0, 1.0));
//       float d = hash12(i + vec2(1.0, 1.0));

//       return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
//     }

//     void main() {
//       vec3 pos = position;

//       float y01 = clamp(pos.y, 0.0, 1.0);

//       float r = uRadius * aDisk.x;
//       vec2 base = uCenter + aDisk * uRadius;

//       float jitA = (aRand.x - 0.5) * 2.0;
//       float jitB = (aRand.y - 0.5) * 2.0;

//       float bh = max(0.01, uBladeHeight * (1.0 + jitA * uHeightJitter));
//       float bw = max(0.001, uBladeWidth  * (1.0 + jitB * uWidthJitter));

//       float s = sin(aYaw);
//       float c = cos(aYaw);

//       float localX = (pos.x) * bw;
//       float localY = (pos.y) * bh;

//       vec2 pr = vec2(localX * c, localX * s);

//       vec2 w = uBaseWind * uWindStrength;
//       float wl = length(w);
//       vec2 wdir = (wl > 0.0001) ? (w / wl) : normalize(vec2(0.7, 0.2));
//       vec2 wperp = vec2(-wdir.y, wdir.x);

//       float tt = uTime * uWindSpeed + aPhase + aDisk.x * 3.1 + aDisk.y * 3.3;
//       float swayN = sin(tt) * 0.55 + sin(tt * 1.7 + 1.2) * 0.35;
//       float swayP = cos(tt * 1.31 + 0.4) * 0.25;

//       float wgt = pow(y01, max(0.25, uStiffness));
//       vec2 bend = (wdir * swayN + wperp * swayP) * (uBend * wgt);

//       vec2 np = (base * max(0.01, uNoiseScale)) +
//                 vec2(aPhase * 0.07, aRand.y * 7.31) +
//                 vec2(0.0, uTime * uNoiseSpeed);

//       float nA = valueNoise(np);
//       float nB = valueNoise(np * 2.13 + 17.7);

//       float n1 = (nA - 0.5) * 2.0;
//       float n2 = (nB - 0.5) * 2.0;

//       vec2 gust = (wdir * n1 + wperp * n2) * (uBend * wgt * 0.55 * uNoiseStrength);
//       bend += gust;

//       vec3 worldPos = vec3(base.x, uBaseY + localY, base.y) + vec3(pr.x, 0.0, pr.y);
//       worldPos.x += bend.x;
//       worldPos.z += bend.y;

//       vec4 mv = modelViewMatrix * vec4(worldPos, 1.0);
//       gl_Position = projectionMatrix * mv;

//       vY = y01;
//       vEdge = abs(pos.x);
//       vRand = aRand.x * 2.0 - 1.0;
//       vPatch = nA;
//     }
//   `;

//   const FRAG = /* glsl */`
//     precision mediump float;

//     uniform vec3  uColorBottom;
//     uniform vec3  uColorTop;
//     uniform float uOpacity;
//     uniform float uAlphaCutoff;
//     uniform float uColorVar;

//     varying float vY;
//     varying float vEdge;
//     varying float vRand;
//     varying float vPatch;

//     void main() {
//       float taper = mix(1.0, 0.10, vY);
//       float x = vEdge / max(0.001, taper);

//       float edgeA = smoothstep(1.0, 0.82, x);
//       float tipA  = 1.0 - smoothstep(0.92, 1.0, vY);

//       float micro = 0.92 + 0.08 * sin(vY * 35.0 + vRand * 6.0);

//       float a = edgeA * tipA * micro * uOpacity;
//       if (a < uAlphaCutoff) discard;

//       float patchMul = 1.0 + ((vPatch - 0.5) * 2.0) * uColorVar;

//       vec3 col = mix(uColorBottom, uColorTop, pow(vY, 0.65));
//       col *= patchMul;

//       gl_FragColor = vec4(col, a);
//     }
//   `;







//   grassMaterial = new THREE.ShaderMaterial({
//     uniforms: grassUniforms,
//     vertexShader: VERT,
//     fragmentShader: FRAG,
//     transparent: true,
//     depthTest: true,
//     depthWrite: false,
//     blending: THREE.NormalBlending,
//     side: THREE.DoubleSide
//   });

//   grassMesh = new THREE.Mesh(grassGeometry, grassMaterial);
//   grassMesh.frustumCulled = false;
//   grassMesh.renderOrder = 2;

//   scene.add(grassMesh);

//   applyGrassParamsToUniforms();
// }




    /* Advances grass time and feeds base wind into shader. */
function updateGrass(dt, baseWindX, baseWindZ) {
  if (!grassUniforms) return;
  grassUniforms.uTime.value += dt;
  grassUniforms.uBaseWind.value.set(baseWindX, baseWindZ);
}









    // Visual flakes
let snowGeo = null;
let snowMat = null;
let snowPoints = null;

    // Sticking decals
let stuck = null;
let stuckGeo = null;
let stuckMat = null;
let stuckCount = 0;
let stuckWrite = 0;

    // Settlers
let SETTLER_COUNT = 0;
let settlerPos = null;
let settlerPrev = null;
let settlerVel = null;
let depositTokens = 0;


    // Colliders
let colliderObjects = [];
let colliderBounds = [];

    // Model-only colliders (cars etc): simplified oriented boxes built once at load-time
let avatarModelColliderObjects = [];
let avatarModelColliderBounds = [];
let avatarModelColliderOBBs = [];

    // Vehicle interaction + driving state (POC)
const vehicleInteractables = [];
const vehiclePromptState = {
  open: false,
  nearby: null
};

const vehicleDriveState = {
  enabled: false,
  vehicle: null,
  speed: 0.0,
  yaw: 0.0,
  pitch: 0.0,
  roll: 0.0,

  steerAngle: 0.0,

      // Plane lift state (used when vehicle meta.type/profile indicates an airplane/plane).
  liftY: 0.0,
  groundOffsetY: 0.0,

  lastTrackValid: false,
  lastTrackX: 0.0,
  lastTrackZ: 0.0,
  trackAcc: 0.0
};








const vehicleChaseCamState = {
  enabled: false,

      // OrbitControls target height above the vehicle origin.
  lookHeight: 1.1,

      // How quickly OrbitControls target follows the vehicle (lower = more inertia).
  targetStiffness: 7.0,

      // How quickly the camera azimuth eases behind the vehicle (lower = more inertia).
  yawStiffness: 1.75,

      // Clamp on per-frame yaw blending to prevent “stiff” snaps on low FPS frames.
  maxYawAlpha: 0.05,

      // Seconds since last OrbitControls interaction before auto-behind easing resumes (when not driving).
  recenterIdleSeconds: 0.45,

      // Internal state
  has: false,
  userOverride: false,
  pendingRecenter: false,
  userInteracting: false,
  hooksInstalled: false
};

const vehicleChasePrevControlsState = {
  has: false,
  enableRotate: true,
  enablePan: true,
  enableZoom: true,
  enableDamping: true
};

const vehicleChaseWorldPos = new THREE.Vector3();
const vehicleChaseForward = new THREE.Vector3();
const vehicleChaseDesiredTarget = new THREE.Vector3();

const vehicleChaseOldTarget = new THREE.Vector3();
const vehicleChaseNewTarget = new THREE.Vector3();
const vehicleChaseDelta = new THREE.Vector3();

const vehicleChaseOffset = new THREE.Vector3();
const vehicleChaseSpherical = new THREE.Spherical();

    /**
     * Marks a user-driven OrbitControls interaction for chase mode.
     * A manual orbit sets an override that blocks auto-behind until driving input resumes.
     */
function onVehicleChaseOrbitStart() {
  if (!vehicleChaseCamState.enabled) return;
  vehicleChaseCamState.userInteracting = true;
  vehicleChaseCamState.userOverride = true;
  vehicleChaseCamState.pendingRecenter = false;
  lastInteractionTime = performance.now() * 0.001;
}

    /**
     * Marks the end of a user-driven OrbitControls interaction for chase mode.
     */
function onVehicleChaseOrbitEnd() {
  if (!vehicleChaseCamState.enabled) return;
  vehicleChaseCamState.userInteracting = false;
  lastInteractionTime = performance.now() * 0.001;
}

    /**
     * Installs OrbitControls hooks used by chase mode exactly once.
     */
function ensureVehicleChaseOrbitHooks() {
  if (vehicleChaseCamState.hooksInstalled || !controls) return;
  controls.addEventListener("start", onVehicleChaseOrbitStart);
  controls.addEventListener("end", onVehicleChaseOrbitEnd);
  vehicleChaseCamState.hooksInstalled = true;
}

    /**
     * Determines whether the currently driven vehicle should be treated as an aircraft
     * for follow vector computation.
     */
function isVehiclePlane(v) {
  if (!v || !v.meta) return false;
  const prof = v.meta.profile || {};
  const driveMode = (typeof prof.driveMode === "string") ? prof.driveMode : "";
  return driveMode === "plane" || /airplane|plane/i.test((v.meta.type || ""));
}

    /**
     * Enables/disables chase camera mode for the driven vehicle while keeping OrbitControls usable:
     * rotate/zoom/damping remain enabled; pan is disabled so the target stays locked to the vehicle.
     */
function setVehicleChaseCameraEnabled(enabled) {
  const next = !!enabled;
  if (vehicleChaseCamState.enabled === next) return;

  vehicleChaseCamState.enabled = next;
  vehicleChaseCamState.has = false;
  vehicleChaseCamState.userOverride = false;
  vehicleChaseCamState.pendingRecenter = false;
  vehicleChaseCamState.userInteracting = false;
  avatarHasLastPos = false;

  if (!controls) return;

  if (next) {
    ensureVehicleChaseOrbitHooks();

    if (!vehicleChasePrevControlsState.has) {
      vehicleChasePrevControlsState.has = true;
      vehicleChasePrevControlsState.enableRotate = !!controls.enableRotate;
      vehicleChasePrevControlsState.enablePan = !!controls.enablePan;
      vehicleChasePrevControlsState.enableZoom = !!controls.enableZoom;
      vehicleChasePrevControlsState.enableDamping = !!controls.enableDamping;
    }

    controls.enableRotate = true;
    controls.enableZoom = true;
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.autoRotate = false;
  } else {
    controls.enableRotate = vehicleChasePrevControlsState.has ? vehicleChasePrevControlsState.enableRotate : true;
    controls.enablePan = vehicleChasePrevControlsState.has ? vehicleChasePrevControlsState.enablePan : true;
    controls.enableZoom = vehicleChasePrevControlsState.has ? vehicleChasePrevControlsState.enableZoom : true;
    controls.enableDamping = vehicleChasePrevControlsState.has ? vehicleChasePrevControlsState.enableDamping : true;
    controls.update();
  }
}

    /**
     * Updates the chase camera:
     * - OrbitControls target is smoothly moved to the vehicle (camera translates with it, preserving orbit)
     * - Auto-behind yaw easing runs when the user is not actively orbiting and no manual override is active
     * - Manual override is set by orbiting and is cleared only after driving input resumes
     */
function updateVehicleChaseCamera(dt) {
  if (!vehicleChaseCamState.enabled || !controls) return;

  const v = vehicleDriveState.vehicle;
  if (!vehicleDriveState.enabled || !v || !v.object) return;

  v.object.getWorldPosition(vehicleChaseWorldPos);

  vehicleChaseDesiredTarget
  .copy(vehicleChaseWorldPos)
  .addScaledVector(worldUp, vehicleChaseCamState.lookHeight);

  const targetAlpha =
  1 - Math.pow(0.001, vehicleChaseCamState.targetStiffness * Math.max(0.0, dt));

  if (!vehicleChaseCamState.has) {
    vehicleChaseOldTarget.copy(controls.target);
    controls.target.copy(vehicleChaseDesiredTarget);
    vehicleChaseDelta.subVectors(controls.target, vehicleChaseOldTarget);
    camera.position.add(vehicleChaseDelta);

    vehicleChaseCamState.has = true;
    controls.autoRotate = false;
    controls.update();
    return;
  }

  vehicleChaseOldTarget.copy(controls.target);
  vehicleChaseNewTarget.copy(controls.target).lerp(vehicleChaseDesiredTarget, targetAlpha);

  vehicleChaseDelta.subVectors(vehicleChaseNewTarget, vehicleChaseOldTarget);
  controls.target.copy(vehicleChaseNewTarget);
  camera.position.add(vehicleChaseDelta);

  const nowSeconds = performance.now() * 0.001;
  const idleSeconds = nowSeconds - lastInteractionTime;

  const driveKeyActive =
  !!(avatarKeys.forward || avatarKeys.back || avatarKeys.left || avatarKeys.right);

  const driveJoyActive =
  !!(joystickState.active && (Math.abs(joystickState.valueX) > 0.18 || Math.abs(joystickState.valueY) > 0.18));

  const driveInputActive = driveKeyActive || driveJoyActive;

  if (vehicleChaseCamState.userOverride) {
    if (driveInputActive) vehicleChaseCamState.pendingRecenter = true;
    if (vehicleChaseCamState.pendingRecenter && !vehicleChaseCamState.userInteracting) {
      vehicleChaseCamState.userOverride = false;
      vehicleChaseCamState.pendingRecenter = false;
    }
  } else {
    vehicleChaseCamState.pendingRecenter = false;
  }

  const allowAutoBehind =
  !vehicleChaseCamState.userOverride &&
  !vehicleChaseCamState.userInteracting &&
  (driveInputActive || idleSeconds >= vehicleChaseCamState.recenterIdleSeconds);

  if (allowAutoBehind) {
    vehicleChaseForward.set(0, 0, 1).applyQuaternion(v.object.quaternion);

    if (!isVehiclePlane(v)) vehicleChaseForward.y = 0;

    if (vehicleChaseForward.lengthSq() < 1e-8) vehicleChaseForward.set(0, 0, 1);
    vehicleChaseForward.normalize();

    const desiredTheta = Math.atan2(-vehicleChaseForward.x, -vehicleChaseForward.z);

    vehicleChaseOffset.copy(camera.position).sub(controls.target);

    if (vehicleChaseOffset.lengthSq() > 1e-10) {
      vehicleChaseSpherical.setFromVector3(vehicleChaseOffset);

      let yawAlpha =
      1 - Math.pow(0.001, vehicleChaseCamState.yawStiffness * Math.max(0.0, dt));

      yawAlpha = Math.min(vehicleChaseCamState.maxYawAlpha, Math.max(0.0, yawAlpha));

      vehicleChaseSpherical.theta = lerpYaw(vehicleChaseSpherical.theta, desiredTheta, yawAlpha);

      if (Number.isFinite(controls.minPolarAngle)) {
        vehicleChaseSpherical.phi = Math.max(vehicleChaseSpherical.phi, controls.minPolarAngle);
      }
      if (Number.isFinite(controls.maxPolarAngle)) {
        vehicleChaseSpherical.phi = Math.min(vehicleChaseSpherical.phi, controls.maxPolarAngle);
      }
      if (Number.isFinite(controls.minDistance)) {
        vehicleChaseSpherical.radius = Math.max(vehicleChaseSpherical.radius, controls.minDistance);
      }
      if (Number.isFinite(controls.maxDistance)) {
        vehicleChaseSpherical.radius = Math.min(vehicleChaseSpherical.radius, controls.maxDistance);
      }

      vehicleChaseOffset.setFromSpherical(vehicleChaseSpherical);
      camera.position.copy(controls.target).add(vehicleChaseOffset);
    }
  }

  controls.autoRotate = false;
  controls.update();
}





const vehicleTmpBox = new THREE.Box3();
const vehicleTmpCenter = new THREE.Vector3();
const vehicleTmpSize = new THREE.Vector3();
const vehicleTmpPos = new THREE.Vector3();
const vehicleTmpVel = new THREE.Vector3();
const vehicleTmpMove = new THREE.Vector3();
const vehicleSeatLocal = new THREE.Vector3();
const vehicleSeatWorld = new THREE.Vector3();

const vehicleGroundUp = new THREE.Vector3();
const vehicleGroundFwd = new THREE.Vector3();
const vehicleGroundRight = new THREE.Vector3();
const vehicleGroundMat = new THREE.Matrix4();


const vehicleOutlineBox = new THREE.Box3();
let vehicleOutlineHelper = null;


/**
 * Attaches a non-window debug bridge for vehicle inspection/manipulation to the renderer canvas element.
 * Access from DevTools: document.querySelector("#app canvas").vehicleDebug
 */
function installVehicleDebugBridge(canvasEl) {
  if (!canvasEl) return;

  const api = {
    /**
     * Lists loaded vehicles with ids and types.
     */
    list() {
      return vehicleInteractables.map((v) => ({
        id: v.id || "",
        type: (v.meta && v.meta.type) || "Vehicle"
      }));
    },

    /**
     * Returns the per-vehicle debug handle (same shape as the one logged at load-time).
     */
    get(id) {
      const key = String(id || "");
      for (let i = 0; i < vehicleInteractables.length; i++) {
        const v = vehicleInteractables[i];
        if (!v) continue;
        if (String(v.id || "") !== key) continue;
        const h = v.object && v.object.userData ? v.object.userData.vehicleDebug : null;
        return h || null;
      }
      return null;
    },

    /**
     * Returns the vehicle root Object3D for a given id.
     */
    root(id) {
      const h = api.get(id);
      return h ? h.object : null;
    },

    /**
     * Returns detected parts for a given id.
     */
    parts(id) {
      const h = api.get(id);
      return h ? h.parts : null;
    },

    /**
     * Sets an internal selection for quicker console iteration.
     */
    select(id) {
      const h = api.get(id);
      canvasEl.vehicleSelectedId = h ? h.id : "";
      return h;
    },

    /**
     * Gets current selection debug handle.
     */
    selected() {
      const id = String(canvasEl.vehicleSelectedId || "");
      return id ? api.get(id) : null;
    }
  };

  canvasEl.vehicleDebug = api;
  if (!canvasEl.vehicleSelectedId) canvasEl.vehicleSelectedId = "";
}


    /**
     * Shows/hides the vehicle prompt panel and refreshes the current selection.
     */
function setVehiclePrompt(open, v) {
  vehiclePromptState.open = !!open;
  vehiclePromptState.nearby = open ? (v || null) : null;

  syncVehicleTuningSelection();

  const panel = document.getElementById("vehiclePrompt");
  const title = document.getElementById("vehiclePromptTitle");
  const desc = document.getElementById("vehiclePromptDesc");
  const enterBtn = document.getElementById("vehicleEnterBtn");
  const exitBtn = document.getElementById("vehicleExitBtn");

  if (!panel || !title || !desc || !enterBtn || !exitBtn) return;

  if (uiHidden) {
    panel.style.display = "none";
    panel.setAttribute("aria-hidden", "true");
    return;
  }

  if (!vehiclePromptState.open || !vehiclePromptState.nearby) {
    panel.style.display = "none";
    panel.setAttribute("aria-hidden", "true");
    title.textContent = "";
    desc.textContent = "";
    enterBtn.style.display = "";
    exitBtn.style.display = "none";
    return;
  }

  const meta = vehiclePromptState.nearby.meta;
  title.textContent = meta.type || "Vehicle";
  desc.textContent = meta.description || "";

  if (vehicleDriveState.enabled) {
    enterBtn.style.display = "none";
    exitBtn.style.display = "";
  } else {
    enterBtn.style.display = "";
    exitBtn.style.display = "none";
  }

  panel.style.display = "block";
  panel.setAttribute("aria-hidden", "false");
}


    /**
     * Builds and caches per-vehicle mesh edge outlines under the given vehicle root.
     * Outlines are attached to each mesh so they inherit transforms and can be toggled efficiently.
     */
function ensureVehicleMeshOutlines(root) {
  if (!root) return;
  if (root.userData.vehicleMeshOutlineLines) return;

  const mat = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.25,
    depthTest: false
  });

  const lines = [];

  root.traverse((o) => {
    if (!o || !o.isMesh || !o.geometry) return;

    const edges = new THREE.EdgesGeometry(o.geometry, 15);
    const l = new THREE.LineSegments(edges, mat);
    l.frustumCulled = false;
    l.renderOrder = 1000;
    l.visible = false;

    o.add(l);
    lines.push(l);
  });

  root.userData.vehicleMeshOutlineLines = lines;
}

    /**
     * Toggles cached mesh edge outlines for a vehicle root (no-op if none exist).
     */
function setVehicleMeshOutlineVisible(root, visible) {
  if (!root) return;

  const lines = root.userData.vehicleMeshOutlineLines;
  if (!lines || lines.length === 0) return;

  const v = !!visible;
  for (let i = 0; i < lines.length; i++) {
    lines[i].visible = v;
  }
}

    /**
     * Builds and caches a per-vehicle silhouette outline using the inverted-hull technique:
     * a BackSide MeshBasicMaterial clone slightly scaled up, producing a clean contour
     * without wireframe/X-ray artifacts. Uses a two-pass approach to avoid traverse
     * recursion when adding children during traversal.
     */
function ensureVehicleSilhouetteOutline(root) {
  if (!root) return;
  if (root.userData.vehicleSilhouetteOutlines) return;

  const mat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    side: THREE.BackSide,
    depthTest: true,
    depthWrite: false,
    transparent: true,
    opacity: 0.50,
    polygonOffset: true,
    polygonOffsetFactor: 1,
    polygonOffsetUnits: 1
  });

  const meshes = [];
  root.traverse((o) => {
    if (!o || !o.isMesh || !o.geometry) return;
    if (o.isSkinnedMesh) return;
    if (o.userData && o.userData.isVehicleSilhouetteOutline) return;
    meshes.push(o);
  });

  const outlines = [];

  for (let i = 0; i < meshes.length; i++) {
    const m = meshes[i];
    if (!m) continue;

    const existing = m.userData && m.userData.vehicleSilhouetteOutlineMesh;
    if (existing && existing.isMesh) {
      outlines.push(existing);
      continue;
    }

    const outline = new THREE.Mesh(m.geometry, mat);
    outline.userData.isVehicleSilhouetteOutline = true;
    outline.frustumCulled = false;
    outline.renderOrder = -1;
    outline.visible = false;

    outline.scale.set(1.01, 1.01, 1.01);

    m.add(outline);

    if (!m.userData) m.userData = {};
    m.userData.vehicleSilhouetteOutlineMesh = outline;

    outlines.push(outline);
  }

  root.userData.vehicleSilhouetteOutlines = outlines;
}


    /**
     * Toggles cached silhouette outline visibility for a vehicle root.
     */
function setVehicleSilhouetteOutlineVisible(root, visible) {
  if (!root) return;
  const outlines = root.userData.vehicleSilhouetteOutlines;
  if (!outlines || outlines.length === 0) return;

  const v = !!visible;
  for (let i = 0; i < outlines.length; i++) {
    outlines[i].visible = v;
  }
}






    /**
     * Shows a green oriented bounding cuboid around the nearest vehicle and
     * a green silhouette outline on the vehicle meshes (inverted-hull). Bounds are
     * computed once per vehicle in the vehicle root's local space using a PCA fit
     * on mesh bounding-box corner samples (XZ), then cached. Outline is hidden while
     * driving and when UI is hidden.
     */
function updateVehicleOutlineFor(v) {
  if (!v || !v.object || uiHidden || vehicleDriveState.enabled) {
    if (vehicleOutlineHelper && vehicleOutlineHelper.parent) {
      setVehicleSilhouetteOutlineVisible(vehicleOutlineHelper.parent, false);
      vehicleOutlineHelper.parent.remove(vehicleOutlineHelper);
    }
    if (vehicleOutlineHelper) vehicleOutlineHelper.visible = false;
    return;
  }

  const root = v.object;

  if (vehicleOutlineHelper && vehicleOutlineHelper.parent && vehicleOutlineHelper.parent !== root) {
    setVehicleSilhouetteOutlineVisible(vehicleOutlineHelper.parent, false);
  }

  if (!root.userData.vehicleOutlineLocalOBB) {
    const invRoot = new THREE.Matrix4();
    const m = new THREE.Matrix4();
    const p = new THREE.Vector3();

    const pts = [];
    let yMin = Infinity;
    let yMax = -Infinity;

    root.updateWorldMatrix(true, true);
    invRoot.copy(root.matrixWorld).invert();

    root.traverse((o) => {
      if (!o || !o.isMesh || !o.geometry) return;
      if (o.userData && o.userData.isVehicleSilhouetteOutline) return;

      const g = o.geometry;
      if (!g.boundingBox) g.computeBoundingBox();
      if (!g.boundingBox) return;

      o.updateWorldMatrix(true, false);
      m.multiplyMatrices(invRoot, o.matrixWorld);

      const bb = g.boundingBox;

      const x0 = bb.min.x, y0 = bb.min.y, z0 = bb.min.z;
      const x1 = bb.max.x, y1 = bb.max.y, z1 = bb.max.z;

      const corners = [
        [x0, y0, z0], [x1, y0, z0], [x0, y0, z1], [x1, y0, z1],
        [x0, y1, z0], [x1, y1, z0], [x0, y1, z1], [x1, y1, z1]
      ];

      for (let i = 0; i < 8; i++) {
        const c = corners[i];
        p.set(c[0], c[1], c[2]).applyMatrix4(m);

        pts.push(p.x, p.z);

        if (p.y < yMin) yMin = p.y;
        if (p.y > yMax) yMax = p.y;
      }
    });

    if (!Number.isFinite(yMin) || !Number.isFinite(yMax) || pts.length < 8) {
      vehicleOutlineBox.setFromObject(root);
      const size = vehicleOutlineBox.getSize(new THREE.Vector3());
      const center = vehicleOutlineBox.getCenter(new THREE.Vector3());

      root.updateWorldMatrix(true, true);
      const inv = new THREE.Matrix4().copy(root.matrixWorld).invert();
      const cLocal = center.clone().applyMatrix4(inv);

      root.userData.vehicleOutlineLocalOBB = {
        centerLocal: cLocal,
        sizeLocal: new THREE.Vector3(
          Math.max(0.001, size.x),
          Math.max(0.001, size.y),
          Math.max(0.001, size.z)
          ),
        yawLocal: 0.0
      };
    } else {
      let meanX = 0.0;
      let meanZ = 0.0;

      for (let i = 0; i < pts.length; i += 2) {
        meanX += pts[i];
        meanZ += pts[i + 1];
      }

      const n = pts.length * 0.5;
      meanX /= n;
      meanZ /= n;

      let cXX = 0.0;
      let cXZ = 0.0;
      let cZZ = 0.0;

      for (let i = 0; i < pts.length; i += 2) {
        const dx = pts[i] - meanX;
        const dz = pts[i + 1] - meanZ;
        cXX += dx * dx;
        cXZ += dx * dz;
        cZZ += dz * dz;
      }

      cXX /= n;
      cXZ /= n;
      cZZ /= n;

      const yaw = 0.5 * Math.atan2(2.0 * cXZ, (cXX - cZZ));

      const c = Math.cos(yaw);
      const s = Math.sin(yaw);

      let minXr = Infinity, maxXr = -Infinity;
      let minZr = Infinity, maxZr = -Infinity;

      for (let i = 0; i < pts.length; i += 2) {
        const dx = pts[i] - meanX;
        const dz = pts[i + 1] - meanZ;

        const xr = dx * c + dz * s;
        const zr = -dx * s + dz * c;

        if (xr < minXr) minXr = xr;
        if (xr > maxXr) maxXr = xr;
        if (zr < minZr) minZr = zr;
        if (zr > maxZr) maxZr = zr;
      }

      const cxr = 0.5 * (minXr + maxXr);
      const czr = 0.5 * (minZr + maxZr);

      const centerX = meanX + (cxr * c - czr * s);
      const centerZ = meanZ + (cxr * s + czr * c);

      const sizeX = Math.max(0.001, maxXr - minXr);
      const sizeZ = Math.max(0.001, maxZr - minZr);
      const sizeY = Math.max(0.001, yMax - yMin);
      const centerY = 0.5 * (yMin + yMax);

      root.userData.vehicleOutlineLocalOBB = {
        centerLocal: new THREE.Vector3(centerX, centerY, centerZ),
        sizeLocal: new THREE.Vector3(sizeX, sizeY, sizeZ),
        yawLocal: yaw
      };
    }
  }

  ensureVehicleSilhouetteOutline(root);

  if (!vehicleOutlineHelper) {
    const geom = new THREE.EdgesGeometry(new THREE.BoxGeometry(1, 1, 1));
    const mat = new THREE.LineBasicMaterial({ color: 0xffffff });
    vehicleOutlineHelper = new THREE.LineSegments(geom, mat);
    vehicleOutlineHelper.frustumCulled = false;
    vehicleOutlineHelper.renderOrder = 999;
  }

  if (vehicleOutlineHelper.parent !== root) {
    if (vehicleOutlineHelper.parent) vehicleOutlineHelper.parent.remove(vehicleOutlineHelper);
    root.add(vehicleOutlineHelper);
  }

  const obb = root.userData.vehicleOutlineLocalOBB;

  vehicleOutlineHelper.visible = true;
  vehicleOutlineHelper.position.copy(obb.centerLocal);
  vehicleOutlineHelper.rotation.set(0, obb.yawLocal, 0);
  vehicleOutlineHelper.scale.set(obb.sizeLocal.x, obb.sizeLocal.y, obb.sizeLocal.z);

  setVehicleSilhouetteOutlineVisible(root, true);
}








    /**
     * Registers a vehicle instance for proximity interaction and driving.
     */
function registerVehicleInstance(inst, instCfg) {
  /**
   * Collects named sub-parts for vehicles (wheels/propellers/etc.) for debugging and future animation hooks.
   * Returns stable references to Object3D nodes found by name heuristics and a full name index.
   */
  function scanVehicleNamedParts(root) {
    const wheels = [];
    const propellers = [];
    const named = Object.create(null);
    const allNames = [];

    root.traverse((obj) => {
      const raw = typeof obj.name === "string" ? obj.name.trim() : "";
      if (!raw) return;

      named[raw] = obj;
      allNames.push(raw);

      const n = raw.toLowerCase();

      if (n.includes("wheel") || n.startsWith("whl") || n.includes("tyre") || n.includes("tire")) {
        wheels.push(obj);
        return;
      }

      if (
        n.includes("propeller") ||
        n === "prop" ||
        n.startsWith("prop_") ||
        n.includes("rotor") ||
        n.includes("fan")
        ) {
        propellers.push(obj);
    }
  });

    wheels.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
    propellers.sort((a, b) => (a.name || "").localeCompare(b.name || ""));

    return { wheels, propellers, named, allNames };
  }

  /**
   * Builds a lightweight debug handle that can be stored from the console for manual traversal.
   * No globals are created; the handle is only emitted via console logging.
   */
  function makeVehicleDebugHandle(id, meta, root, parts) {
    return {
      id,
      type: (meta && meta.type) || "Vehicle",
      object: root,
      parts: {
        wheels: parts.wheels,
        propellers: parts.propellers,
        named: parts.named
      },
      listNames() {
        return parts.allNames.slice();
      },
      getByName(name) {
        if (!name) return null;
        return parts.named[name] || null;
      },
      findBySubstring(substr) {
        const q = (substr || "").toLowerCase();
        if (!q) return [];
        const out = [];
        for (let i = 0; i < parts.allNames.length; i++) {
          const nm = parts.allNames[i];
          if (nm.toLowerCase().includes(q)) out.push(nm);
        }
        return out;
      }
    };
  }

  if (!instCfg || !instCfg.vehicle) return;

  inst.updateWorldMatrix(true, true);
  vehicleTmpBox.setFromObject(inst);

  if (!Number.isFinite(vehicleTmpBox.min.x) || !Number.isFinite(vehicleTmpBox.max.x)) return;

  vehicleTmpBox.getCenter(vehicleTmpCenter);
  vehicleTmpBox.getSize(vehicleTmpSize);

  const radius = Math.max(0.35, 0.5 * Math.max(vehicleTmpSize.x, vehicleTmpSize.z));
  const meta = instCfg.vehicle;

  const parts = scanVehicleNamedParts(inst);
  inst.userData.vehicleParts = parts;

  const v = {
    id: instCfg.id || "",
    object: inst,
    meta,
    radius,
    parts
  };

  vehicleInteractables.push(v);

  const debugHandle = makeVehicleDebugHandle(v.id, meta, inst, parts);
  inst.userData.vehicleDebug = debugHandle;

  console.groupCollapsed(
`[vehicle] loaded "${v.id || "(no-id)"}" (${(meta && meta.type) || "Vehicle"})`
);
  console.log("root:", inst);
  console.log("meta:", meta);
  console.log("detected:", {
    wheels: parts.wheels.map((o) => o.name),
    propellers: parts.propellers.map((o) => o.name),
    namedCount: parts.allNames.length
  });
  console.log("debug-handle:", debugHandle);
  console.groupEnd();
}


    /**
     * Finds the nearest vehicle within interaction range.
     */
function findNearbyVehicle() {
  if (!avatar) return null;

  const pos = avatar.position;
  let best = null;
  let bestD2 = Infinity;

  for (let i = 0; i < vehicleInteractables.length; i++) {
    const v = vehicleInteractables[i];
    if (!v || !v.object) continue;

    v.object.getWorldPosition(vehicleTmpPos);

    const dx = pos.x - vehicleTmpPos.x;
    const dz = pos.z - vehicleTmpPos.z;

    const reach = (avatarCollision.radius + v.radius + 0.65);
    const d2 = dx * dx + dz * dz;

    if (d2 <= reach * reach && d2 < bestD2) {
      bestD2 = d2;
      best = v;
    }
  }

  return best;
}


/**
 * Enters vehicle mode: locks controls to the vehicle and seats the avatar.
 * Vehicle chase camera is enabled on entry so camera always follows while driving.
 */
function enterVehicle(v) {
  if (!v || !v.object || !v.meta) return;
  if (!avatar || !avatarState.enabled) return;

  const carryChase = !!avatarChaseCamState.enabled;

  setAvatarChaseCameraEnabled(false);

  vehicleDriveState.enabled = true;
  vehicleDriveState.vehicle = v;
  vehicleDriveState.speed = 0.0;
  vehicleDriveState.yaw = v.object.rotation.y + (v.meta.yawOffset || 0.0);
  vehicleDriveState.steerAngle = 0.0;
  vehicleDriveState.pitch = 0.0;
  vehicleDriveState.roll = 0.0;
  vehicleDriveState.pitchVel = 0.0;
  vehicleDriveState.rollVel = 0.0;

  vehicleDriveState.liftY = 0.0;
  vehicleDriveState.groundOffsetY = v.object.position.y - getWorldSurfaceY(v.object.position.x, v.object.position.z);

  vehicleDriveState.lastTrackValid = false;
  vehicleDriveState.trackAcc = 0.0;

  if (avatarMixer && avatarActions.sit) {
    switchAvatarAction("sit");
  } else if (avatarMixer && avatarActions.idle) {
    switchAvatarAction("idle");
  }

  setVehiclePrompt(true, v);

  setVehicleChaseCameraEnabled(true);

  if (carryChase) {
    vehicleChaseCamState.userOverride = true;
    vehicleChaseCamState.pendingRecenter = false;
    vehicleChaseCamState.userInteracting = false;
    lastInteractionTime = performance.now() * 0.001;
  } else {
    vehicleChaseCamState.userOverride = false;
    vehicleChaseCamState.pendingRecenter = false;
    vehicleChaseCamState.userInteracting = false;
    lastInteractionTime = performance.now() * 0.001;
  }

  resetJoystick();
}







/**
 * Exits vehicle mode: restores avatar walking controls and places avatar beside the vehicle on the surface.
 * Uses vehicleDriveState yaw (not vehicle Euler) so slope-tilt does not break exit placement.
 */
function exitVehicle() {
  const v = vehicleDriveState.vehicle;
  if (!vehicleDriveState.enabled || !v || !v.object) return;

  setVehicleChaseCameraEnabled(false);

  v.object.getWorldPosition(vehicleTmpPos);

  const side = 1.1 + (v.radius || 0.8);
  const yaw = vehicleDriveState.yaw;

  const outX = vehicleTmpPos.x + Math.sin(yaw + Math.PI * 0.5) * side;
  const outZ = vehicleTmpPos.z + Math.cos(yaw + Math.PI * 0.5) * side;
  const outY = getWorldSurfaceY(outX, outZ);

  avatar.position.set(outX, outY, outZ);

  avatar.quaternion.identity();
  avatar.rotation.set(0, yaw, 0);

  vehicleDriveState.enabled = false;
  vehicleDriveState.vehicle = null;

  vehicleDriveState.speed = 0.0;
  vehicleDriveState.yaw = 0.0;
  vehicleDriveState.steerAngle = 0.0;
  vehicleDriveState.pitch = 0.0;
  vehicleDriveState.roll = 0.0;
  vehicleDriveState.pitchVel = 0.0;
  vehicleDriveState.rollVel = 0.0;

  vehicleDriveState.liftY = 0.0;
  vehicleDriveState.groundOffsetY = 0.0;

  vehicleDriveState.lastTrackValid = false;
  vehicleDriveState.trackAcc = 0.0;

  if (avatarVelocity) {
    avatarVelocity.set(0, 0, 0);
  }

  if (avatarMixer && avatarActions.idle) {
    switchAvatarAction("idle");
  }

  setVehiclePrompt(false, null);
  updateVehicleOutlineFor(null);
  resetJoystick();
}






    /**
     * Vehicle profile tuning state for lil-gui, bound to the currently selected vehicle:
     * - while driving: the driven vehicle
     * - otherwise: the currently nearby (prompt) vehicle
     */
const vehicleTuningState = {
  available: false,
  id: "",
  type: "",
  description: "",

      // Seat offset for avatar while riding (vehicle-local space)
  seatX: 0.0,
  seatY: 0.6,
  seatZ: 0.0,

  maxSpeed: 10.0,
  maxReverse: 4.0,
  accel: 10.0,
  brake: 14.0,
  coastDecel: 3.0,
  turnRate: 2.4,
  radius: 0.9,

  wheelBase: 2.5,
  minTurnRadius: 3.0,
  minSteerSpeed: 0.35,
  steerResponse: 8.0,
  steerReturn: 6.0,
  lateralGrip: 8.0,

      // Plane lift and attitude tuning (used when driveMode/profile indicates a plane).
  minFlySpeed: 14.0,
  maxLift: 10.0,
  liftResponse: 5.0,

  airTurnScale: 0.35,
  airRollMax: 0.35,
  airRollResponse: 8.0,
  airRollReturn: 5.0,

  climbPitchMax: 0.22,
  climbPitchSpeed: 4.0,
  pitchResponse: 4.0,
  pitchReturn: 3.0,
  turnPitchMax: 0.10,

      // Wet trail mark dimensions (vehicle-local override; defaults to wetTrailConfig.*)
  wetWidth: wetTrailConfig.vehicleWidth,
  wetLength: wetTrailConfig.vehicleLength,

      // Vehicle snow track half-width (vehicle-local override; used by snow deformation).
  trackHalfWidth: 1.0
};




let vehicleTuningLastId = "";
let vehicleTuningFolder = null;

    /**
     * Resolves the current tuning target vehicle based on interaction/drive state.
     */
function getVehicleTuningTarget() {
  if (vehicleDriveState.enabled && vehicleDriveState.vehicle) return vehicleDriveState.vehicle;
  if (vehiclePromptState.open && vehiclePromptState.nearby) return vehiclePromptState.nearby;
  return null;
}

    /**
     * Copies vehicle profile values into the tuning state (used for GUI display/listen).
     */
function readVehicleProfileIntoTuningState(v) {
  if (!v || !v.meta) return;

  const prof = v.meta.profile || {};
  vehicleTuningState.available = true;

  vehicleTuningState.id = v.id || "";
  vehicleTuningState.type = v.meta.type || "Vehicle";
  vehicleTuningState.description = v.meta.description || "";

  const seat = Array.isArray(v.meta.seatLocal) ? v.meta.seatLocal : [0, 0.6, 0];
  vehicleTuningState.seatX = Number.isFinite(seat[0]) ? seat[0] : 0.0;
  vehicleTuningState.seatY = Number.isFinite(seat[1]) ? seat[1] : 0.6;
  vehicleTuningState.seatZ = Number.isFinite(seat[2]) ? seat[2] : 0.0;

  vehicleTuningState.maxSpeed = Math.max(0.1, prof.maxSpeed ?? 10.0);
  vehicleTuningState.maxReverse = Math.max(0.1, prof.maxReverse ?? 4.0);
  vehicleTuningState.accel = Math.max(0.1, prof.accel ?? 10.0);
  vehicleTuningState.brake = Math.max(0.1, prof.brake ?? 14.0);
  vehicleTuningState.coastDecel = Math.max(0.1, prof.coastDecel ?? 3.0);
  vehicleTuningState.turnRate = Math.max(0.1, prof.turnRate ?? 2.4);

  vehicleTuningState.radius = Math.max(0.35, prof.radius ?? 0.9);

  vehicleTuningState.wheelBase = Math.max(0.5, prof.wheelBase ?? 2.5);
  vehicleTuningState.minTurnRadius = Math.max(1.0, prof.minTurnRadius ?? 3.0);
  vehicleTuningState.minSteerSpeed = Math.max(0.0, prof.minSteerSpeed ?? 0.35);
  vehicleTuningState.steerResponse = Math.max(0.1, prof.steerResponse ?? 8.0);
  vehicleTuningState.steerReturn = Math.max(0.1, prof.steerReturn ?? 6.0);
  vehicleTuningState.lateralGrip = Math.max(0.0, prof.lateralGrip ?? 8.0);

  vehicleTuningState.minFlySpeed = Math.max(0.0, prof.minFlySpeed ?? 14.0);
  vehicleTuningState.maxLift = Math.max(0.0, prof.maxLift ?? 10.0);
  vehicleTuningState.liftResponse = Math.max(0.1, prof.liftResponse ?? 5.0);

  vehicleTuningState.airTurnScale = clamp(Number.isFinite(prof.airTurnScale) ? prof.airTurnScale : 0.35, 0.0, 1.0);
  vehicleTuningState.airRollMax = Math.max(0.0, prof.airRollMax ?? 0.35);
  vehicleTuningState.airRollResponse = Math.max(0.1, prof.airRollResponse ?? 8.0);
  vehicleTuningState.airRollReturn = Math.max(0.1, prof.airRollReturn ?? 5.0);

  vehicleTuningState.climbPitchMax = Math.max(0.0, prof.climbPitchMax ?? 0.22);
  vehicleTuningState.climbPitchSpeed = Math.max(0.1, prof.climbPitchSpeed ?? 4.0);
  vehicleTuningState.pitchResponse = Math.max(0.1, prof.pitchResponse ?? 4.0);
  vehicleTuningState.pitchReturn = Math.max(0.1, prof.pitchReturn ?? 3.0);
  vehicleTuningState.turnPitchMax = Math.max(0.0, prof.turnPitchMax ?? 0.10);

  const ww = Number.isFinite(prof.wetWidth) ? prof.wetWidth : wetTrailConfig.vehicleWidth;
  const wl = Number.isFinite(prof.wetLength) ? prof.wetLength : wetTrailConfig.vehicleLength;
  vehicleTuningState.wetWidth = Math.max(0.05, ww);
  vehicleTuningState.wetLength = Math.max(0.05, wl);

  const r = Math.max(0.35,
    Number.isFinite(prof.radius) ? prof.radius : (Number.isFinite(v.radius) ? v.radius : 0.9)
    );
  const thw = Number.isFinite(prof.trackHalfWidth) ? prof.trackHalfWidth : (r * 0.55);
  vehicleTuningState.trackHalfWidth = Math.min(4.0, Math.max(0.22, thw));
}




    /**
     * Writes the tuning state back to the target vehicle profile (live steering changes).
     */
function writeTuningStateIntoVehicleProfile(v) {
  if (!v || !v.meta) return;

  v.meta.seatLocal = [
    Number.isFinite(vehicleTuningState.seatX) ? vehicleTuningState.seatX : 0.0,
    Number.isFinite(vehicleTuningState.seatY) ? vehicleTuningState.seatY : 0.6,
    Number.isFinite(vehicleTuningState.seatZ) ? vehicleTuningState.seatZ : 0.0
  ];

  if (!v.meta.profile || typeof v.meta.profile != "object") v.meta.profile = {};
  const prof = v.meta.profile;

  prof.maxSpeed = Math.max(0.1, vehicleTuningState.maxSpeed);
  prof.maxReverse = Math.max(0.1, vehicleTuningState.maxReverse);
  prof.accel = Math.max(0.1, vehicleTuningState.accel);
  prof.brake = Math.max(0.1, vehicleTuningState.brake);
  prof.coastDecel = Math.max(0.1, vehicleTuningState.coastDecel);
  prof.turnRate = Math.max(0.1, vehicleTuningState.turnRate);

  prof.radius = Math.max(0.35, vehicleTuningState.radius);
  v.radius = prof.radius;

  prof.wheelBase = Math.max(0.5, vehicleTuningState.wheelBase);
  prof.minTurnRadius = Math.max(1.0, vehicleTuningState.minTurnRadius);
  prof.minSteerSpeed = Math.max(0.0, vehicleTuningState.minSteerSpeed);
  prof.steerResponse = Math.max(0.1, vehicleTuningState.steerResponse);
  prof.steerReturn = Math.max(0.1, vehicleTuningState.steerReturn);
  prof.lateralGrip = Math.max(0.0, vehicleTuningState.lateralGrip);

  prof.minFlySpeed = Math.max(0.0, vehicleTuningState.minFlySpeed);
  prof.maxLift = Math.max(0.0, vehicleTuningState.maxLift);
  prof.liftResponse = Math.max(0.1, vehicleTuningState.liftResponse);

  prof.airTurnScale = clamp(Number.isFinite(vehicleTuningState.airTurnScale) ? vehicleTuningState.airTurnScale : 0.35, 0.0, 1.0);
  prof.airRollMax = Math.max(0.0, vehicleTuningState.airRollMax);
  prof.airRollResponse = Math.max(0.1, vehicleTuningState.airRollResponse);
  prof.airRollReturn = Math.max(0.1, vehicleTuningState.airRollReturn);

  prof.climbPitchMax = Math.max(0.0, vehicleTuningState.climbPitchMax);
  prof.climbPitchSpeed = Math.max(0.1, vehicleTuningState.climbPitchSpeed);
  prof.pitchResponse = Math.max(0.1, vehicleTuningState.pitchResponse);
  prof.pitchReturn = Math.max(0.1, vehicleTuningState.pitchReturn);
  prof.turnPitchMax = Math.max(0.0, vehicleTuningState.turnPitchMax);

  prof.trackHalfWidth = Math.min(4.0, Math.max(0.22, vehicleTuningState.trackHalfWidth));

  prof.wetWidth = Math.max(0.05, vehicleTuningState.wetWidth);
  prof.wetLength = Math.max(0.05, vehicleTuningState.wetLength);
}




    /**
     * Keeps the tuning state aligned with the current selection (no polling/traversal hacks).
     */
function syncVehicleTuningSelection() {
  if (!vehicleTuningFolder) return;

  const v = getVehicleTuningTarget();
  const id = v ? (v.id || "") : "";

  if (!v) {
    vehicleTuningState.available = false;
    vehicleTuningState.id = "";
    vehicleTuningState.type = "";
    vehicleTuningState.description = "";
    vehicleTuningLastId = "";
    return;
  }

  if (id === vehicleTuningLastId) return;

  vehicleTuningLastId = id;
  readVehicleProfileIntoTuningState(v);
}

    /**
     * Sets up lil-gui controls for the selected vehicle profile and provides an export action.
     */
function setupVehicleTuningGui(folder) {
  vehicleTuningFolder = folder;

  const info = folder.addFolder("Selection");
  info.add(vehicleTuningState, "available").name("Available").listen();
  info.add(vehicleTuningState, "id").name("Id").listen();
  info.add(vehicleTuningState, "type").name("Type").listen();
  info.add(vehicleTuningState, "description").name("Description").listen();
  info.close();


  const seat = folder.addFolder("Seat");

  seat.add(vehicleTuningState, "seatX", -2.0, 2.0, 0.01).name("Seat X").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  seat.add(vehicleTuningState, "seatY", -1.0, 3.0, 0.01).name("Seat Y").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  seat.add(vehicleTuningState, "seatZ", -2.0, 2.0, 0.01).name("Seat Z").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  seat.close();


  const wet = folder.addFolder("Wet Trail");

  wet.add(vehicleTuningState, "wetWidth", 0.05, 3.0, 0.01).name("Mark width").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  wet.add(vehicleTuningState, "wetLength", 0.05, 4.0, 0.01).name("Mark length").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  wet.add(vehicleTuningState, "trackHalfWidth", 0.22, 4.0, 0.01).name("Track half width").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  wet.close();



  const profile = folder.addFolder("Profile");

  profile.add(vehicleTuningState, "maxSpeed", 0.5, 120.0, 0.1).name("Max speed").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "maxReverse", 0.5, 40.0, 0.1).name("Max reverse").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "accel", 0.1, 60.0, 0.1).name("Accel").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "brake", 0.1, 80.0, 0.1).name("Brake").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "coastDecel", 0.1, 40.0, 0.1).name("Coast").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "turnRate", 0.1, 12.0, 0.05).name("Turn rate").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "radius", 0.35, 4.0, 0.01).name("Radius").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "wheelBase", 0.2, 8.0, 0.01).name("Wheelbase").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "minTurnRadius", 0.5, 20.0, 0.1).name("Min radius").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "minSteerSpeed", 0.0, 3.0, 0.01).name("Min steer").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "steerResponse", 0.1, 30.0, 0.1).name("Steer resp").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "steerReturn", 0.1, 30.0, 0.1).name("Steer return").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "lateralGrip", 0.0, 30.0, 0.1).name("Grip").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.close();


  const flight = folder.addFolder("Flight");

  flight.add(vehicleTuningState, "minFlySpeed", 0.0, 60.0, 0.1).name("Min fly speed").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "maxLift", 0.0, 1000.0, 1).name("Max lift").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "liftResponse", 0.1, 20.0, 0.1).name("Lift resp").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "airTurnScale", 0.0, 1.0, 0.01).name("Air turn").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "airRollMax", 0.0, 1.2, 0.01).name("Roll max").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "airRollResponse", 0.1, 30.0, 0.1).name("Roll resp").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "airRollReturn", 0.1, 30.0, 0.1).name("Roll return").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "climbPitchMax", 0.0, 0.8, 0.01).name("Pitch max").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "climbPitchSpeed", 0.1, 20.0, 0.1).name("Pitch spd").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "pitchResponse", 0.1, 30.0, 0.1).name("Pitch resp").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "pitchReturn", 0.1, 30.0, 0.1).name("Pitch return").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "turnPitchMax", 0.0, 0.5, 0.01).name("Turn pitch").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.close();





  const actions = {
    exportProfile: async () => {
      const v = getVehicleTuningTarget();
      if (!v || !v.meta) return;

      writeTuningStateIntoVehicleProfile(v);

      function fmtNum(n, digits = 3) {
        const x = Number(n);
        if (!Number.isFinite(x)) return null;
        const p = Math.pow(10, digits);
        const r = Math.round(x * p) / p;
        let s = r.toFixed(digits).replace(/0+$/, "").replace(/\.$/, "");
        if (!s.includes(".")) s += ".0";
        return s;
      }

      function fmtStr(s) {
        return JSON.stringify(String(s ?? ""));
      }

      function fmtBool(b) {
        return b ? "true" : "false";
      }

      function fmtArr3(a, dx, dy, dz) {
        const x = Array.isArray(a) ? a : [dx, dy, dz];
        const sx = fmtNum(x[0]) ?? "0.0";
        const sy = fmtNum(x[1]) ?? "0.0";
        const sz = fmtNum(x[2]) ?? "0.0";
        return `[${sx}, ${sy}, ${sz}]`;
      }

      const type = v.meta.type || "Vehicle";
      const description = v.meta.description || "";
      const seatLocal = v.meta.seatLocal || [0, 0.6, 0];
      const yawOffset = Number.isFinite(v.meta.yawOffset) ? v.meta.yawOffset : 0.0;

      const prof = (v.meta.profile && typeof v.meta.profile === "object") ? v.meta.profile : {};
      const used = new Set();
      const lines = [];

      lines.push("vehicle: {");
      lines.push(`  type: ${fmtStr(type)},`);
      lines.push(`  description: ${fmtStr(description)},`);
      lines.push(`  seatLocal: ${fmtArr3(seatLocal, 0, 0.6, 0)},`);
      lines.push(`  yawOffset: ${fmtNum(yawOffset) ?? "0.0"},`);
      lines.push("  profile: {");

      function pushNum(key) {
        used.add(key);
        const val = prof[key];
        const s = fmtNum(val);
        if (s == null) return;
        lines.push(`    ${key}: ${s},`);
      }

      function pushStrKey(key) {
        used.add(key);
        const val = prof[key];
        if (typeof val !== "string") return;
        lines.push(`    ${key}: ${fmtStr(val)},`);
      }

      function pushBoolKey(key) {
        used.add(key);
        const val = prof[key];
        if (typeof val !== "boolean") return;
        lines.push(`    ${key}: ${fmtBool(val)},`);
      }

      pushNum("maxSpeed");
      pushNum("maxReverse");
      pushNum("accel");
      pushNum("brake");
      pushNum("coastDecel");
      pushNum("turnRate");
      pushNum("radius");
      pushNum("wheelBase");
      pushNum("minTurnRadius");
      pushNum("minSteerSpeed");
      pushNum("steerResponse");
      pushNum("steerReturn");
      pushNum("lateralGrip");

      pushNum("wetWidth");
      pushNum("wetLength");
      pushNum("trackHalfWidth");

      pushNum("propSpinIdle");
      pushNum("propSpinMax");
      pushNum("propSpinMul");

      pushNum("liftOffSpeed");
      pushNum("liftOffRise");
      pushNum("liftOffFall");

      pushNum("airYawRate");
      pushNum("airRollRate");
      pushNum("airRollResponse");
      pushNum("airRollReturn");

      pushNum("climbPitchMax");
      pushNum("climbPitchSpeed");
      pushNum("pitchResponse");
      pushNum("pitchReturn");
      pushNum("turnPitchMax");

      pushStrKey("driveMode");
      pushStrKey("propAxis");
      pushBoolKey("propInvert");

      const extraKeys = Object.keys(prof).filter((k) => !used.has(k)).sort();
      for (let i = 0; i < extraKeys.length; i++) {
        const k = extraKeys[i];
        const val = prof[k];

        if (typeof val === "number") {
          const s = fmtNum(val);
          if (s != null) lines.push(`    ${k}: ${s},`);
          continue;
        }
        if (typeof val === "string" && val.length) {
          lines.push(`    ${k}: ${fmtStr(val)},`);
          continue;
        }
        if (typeof val === "boolean") {
          lines.push(`    ${k}: ${fmtBool(val)},`);
          continue;
        }
      }

      if (lines[lines.length - 1].endsWith(",")) {
        lines[lines.length - 1] = lines[lines.length - 1].slice(0, -1);
      }

      lines.push("  }");
      lines.push("}");

      const out = `// MODEL_CONFIG -> instance ${JSON.stringify(v.id)} (${type})\n${lines.join("\n")}`;

      console.log(out);

      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(out);
        }
      } catch (e) {
      }

      return out;
    }
  };






  folder.add(actions, "exportProfile").name("Copy MODEL_CONFIG").listen();
}






    /**
     * Resolves simplified XZ collisions for a moving vehicle using prebuilt sphere bounds and model OBBs.
     */
function resolveVehicleXZCollisions(pos, vel, radius, ignoreObject) {
  const limX = Math.max(0.5, visualBounds.x - (radius + 0.25));
  const limZ = Math.max(0.5, visualBounds.z - (radius + 0.25));

  pos.x = clamp(pos.x, -limX, limX);
  pos.z = clamp(pos.z, -limZ, limZ);

  if (ignoreObject === true) return;

  const skin = avatarCollision.skin;

  for (let iter = 0; iter < avatarCollision.iterations; iter++) {
    let pushed = false;

    const candidates = getAvatarCollisionCandidatesXZ(pos);
    if (candidates && candidates.length) {
      for (let c = 0; c < candidates.length; c++) {
        const b = colliderBounds[candidates[c]];
        if (!b) continue;

        const sumR = radius + b.radius + skin;
        const dx = pos.x - b.center.x;
        const dz = pos.z - b.center.z;
        const d2 = dx * dx + dz * dz;

        if (d2 >= sumR * sumR) continue;

        const d = Math.sqrt(d2) || 1e-6;
        const push = sumR - d;

        const nx = dx / d;
        const nz = dz / d;

        pos.x += nx * push;
        pos.z += nz * push;

        const velDot = vel.x * nx + vel.z * nz;
        if (velDot < 0) {
          vel.x -= velDot * nx;
          vel.z -= velDot * nz;
        }

        pushed = true;
      }
    }

    if (avatarModelColliderOBBs && avatarModelColliderOBBs.length) {
      for (let i = 0; i < avatarModelColliderOBBs.length; i++) {
        const obb = avatarModelColliderOBBs[i];
        if (!obb) continue;
        if (ignoreObject && obb.object === ignoreObject) continue;

        const dxw = pos.x - obb.center.x;
        const dzw = pos.z - obb.center.z;

        const c = Math.cos(obb.yaw);
        const s = Math.sin(obb.yaw);

        const lx = dxw * c + dzw * s;
        const lz = -dxw * s + dzw * c;

        const cx = clamp(lx, -obb.halfX, obb.halfX);
        const cz = clamp(lz, -obb.halfZ, obb.halfZ);

        const dxl = lx - cx;
        const dzl = lz - cz;

        const d2 = dxl * dxl + dzl * dzl;
        const sumR = radius + skin;

        if (d2 >= sumR * sumR) continue;

        const d = Math.sqrt(d2) || 1e-6;
        const push = sumR - d;

        let nlx = dxl / d;
        let nlz = dzl / d;

        if (!Number.isFinite(nlx) || !Number.isFinite(nlz)) {
          const px = obb.halfX - Math.abs(lx);
          const pz = obb.halfZ - Math.abs(lz);
          if (px < pz) {
            nlx = lx >= 0 ? 1 : -1;
            nlz = 0;
          } else {
            nlx = 0;
            nlz = lz >= 0 ? 1 : -1;
          }
        }

        const nx = nlx * c - nlz * s;
        const nz = nlx * s + nlz * c;

        pos.x += nx * push;
        pos.z += nz * push;

        const velDot = vel.x * nx + vel.z * nz;
        if (velDot < 0) {
          vel.x -= velDot * nx;
          vel.z -= velDot * nz;
        }

        pushed = true;
      }
    }

    pos.x = clamp(pos.x, -limX, limX);
    pos.z = clamp(pos.z, -limZ, limZ);

    if (!pushed) break;
  }
}










/**
 * Advances the currently-driven vehicle simulation (ground or aircraft), applying steering, speed, movement,
 * collision resolution (XZ), then surface-follow for ground vehicles and lift/attitude for aircraft.
 * Aircraft keep taxi terrain-follow, but once airborne they no longer inherit terrain height variation.
 */
function tickVehicle(dt) {
  const v = vehicleDriveState.vehicle;
  if (!vehicleDriveState.enabled || !v || !v.object || !v.meta) return;

  const prof = v.meta.profile || {};

  const driveMode = (typeof prof.driveMode === "string") ? prof.driveMode : "";
  const isPlane = driveMode === "plane" || /airplane|plane/i.test((v.meta.type || ""));

  const maxSpeed = Math.max(0.1, prof.maxSpeed ?? 10.0);
  const maxReverse = Math.max(0.1, prof.maxReverse ?? 4.0);
  const accel = Math.max(0.1, prof.accel ?? 10.0);
  const brake = Math.max(0.1, prof.brake ?? 14.0);
  const coastDecel = Math.max(0.1, prof.coastDecel ?? 3.0);
  const turnRate = Math.max(0.1, prof.turnRate ?? 2.4);

  const radius = Math.max(0.35, (prof.radius ?? v.radius ?? 0.9));
  const wheelBase = Math.max(0.1, prof.wheelBase ?? 2.0);
  const minTurnRadius = Math.max(0.5, prof.minTurnRadius ?? 6.0);
  const lateralGrip = Math.max(0.1, prof.lateralGrip ?? 8.0);

  let forwardAmount = 0.0;
  let steerAmount = 0.0;

  const joyForward = -joystickState.valueY;
  const joySteer = joystickState.valueX;

  if (joystickState.active) {
    forwardAmount = clamp(joyForward, -1, 1);
    steerAmount = clamp(joySteer, -1, 1);
  } else {
    const f = avatarKeys.forward ? 1 : 0;
    const b = avatarKeys.back ? -1 : 0;
    forwardAmount = f + b;

    const l = avatarKeys.left ? -1 : 0;
    const r = avatarKeys.right ? 1 : 0;
    steerAmount = l + r;
  }

  forwardAmount = clamp(forwardAmount, -1, 1);
  steerAmount = clamp(steerAmount, -1, 1);

  const speedNow = vehicleDriveState.speed;
  const speedAbsPrev = Math.abs(speedNow);

  const targetSpeed =
  forwardAmount > 0
  ? forwardAmount * maxSpeed
  : forwardAmount < 0
  ? forwardAmount * maxReverse
  : 0.0;

  const speedDiff = targetSpeed - speedNow;

  if (Math.abs(forwardAmount) > 1e-3) {
    const rate = (Math.sign(targetSpeed) === Math.sign(speedNow) || speedNow === 0) ? accel : brake;
    const step = clamp(speedDiff, -rate * dt, rate * dt);
    vehicleDriveState.speed = speedNow + step;
  } else {
    const decelStep = coastDecel * dt;
    if (Math.abs(speedNow) <= decelStep) vehicleDriveState.speed = 0.0;
    else vehicleDriveState.speed = speedNow - Math.sign(speedNow) * decelStep;
  }

  const speedAbs = Math.abs(vehicleDriveState.speed);

  const minSteerSpeed = Math.max(0.0, prof.minSteerSpeed ?? 0.35);
  const steerGate = (speedAbs > minSteerSpeed) ? 1 : 0;

  const steerResponse = Math.max(0.1, prof.steerResponse ?? 8.0);
  const steerReturn = Math.max(0.1, prof.steerReturn ?? 6.0);

  const desiredSteer = steerAmount * (Math.PI * 0.5) * clamp(turnRate, 0.05, 10.0);
  const steerNow = Number.isFinite(vehicleDriveState.steerAngle) ? vehicleDriveState.steerAngle : 0.0;

  const steerK = (Math.abs(steerAmount) > 1e-3) ? steerResponse : steerReturn;
  const steerAlpha = 1 - Math.pow(0.001, steerK * dt);
  const steerAngle = steerNow + (desiredSteer - steerNow) * steerAlpha;

  vehicleDriveState.steerAngle = steerAngle;

  if (isPlane) {
    if (typeof vehicleDriveState.planeAirborne !== "boolean") vehicleDriveState.planeAirborne = false;
    if (!Number.isFinite(vehicleDriveState.planeBaseGroundY)) vehicleDriveState.planeBaseGroundY = 0.0;
  }

  if (steerGate > 0 && Math.abs(steerAngle) > 1e-5 && speedAbs > 1e-5) {
    const base = (wheelBase / Math.max(1e-6, Math.tan(Math.abs(steerAngle))));
    const turnRadius = Math.max(minTurnRadius, base);

    if (Number.isFinite(turnRadius) && turnRadius > 1e-6) {
      const steerSign = steerAngle > 0 ? 1 : -1;
      const yawRate = speedAbs / turnRadius;

      let yawDelta = (-steerSign) * yawRate * dt;

      if (isPlane && vehicleDriveState.planeAirborne) {
        const airTurnScale = clamp(Number.isFinite(prof.airTurnScale) ? prof.airTurnScale : 0.35, 0.0, 1.0);
        yawDelta *= airTurnScale;
      }

      vehicleDriveState.yaw += yawDelta;
    }
  }

  const yawAdj = vehicleDriveState.yaw - (v.meta.yawOffset || 0.0);

  if (isPlane) {
    v.object.rotation.y = yawAdj;
  }

  const fx = Math.sin(vehicleDriveState.yaw);
  const fz = Math.cos(vehicleDriveState.yaw);

  vehicleTmpVel.set(fx * vehicleDriveState.speed, 0, fz * vehicleDriveState.speed);

  vehicleTmpMove.copy(vehicleTmpVel).multiplyScalar(dt);
  v.object.position.add(vehicleTmpMove);

  resolveVehicleXZCollisions(
    v.object.position,
    vehicleTmpVel,
    radius,
    (isPlane && vehicleDriveState.planeAirborne) ? true : v.object
    );

  if (isPlane) {
    const maxLift = Math.max(0.0, prof.maxLift ?? 10.0);
    const minFlySpeed = Math.max(0.0, prof.minFlySpeed ?? 14.0);
    const liftResponse = Math.max(0.1, prof.liftResponse ?? 5.0);

    const airRollMax = Math.max(0.0, prof.airRollMax ?? 0.35);
    const airRollResponse = Math.max(0.1, prof.airRollResponse ?? 8.0);
    const airRollReturn = Math.max(0.1, prof.airRollReturn ?? 5.0);

    const climbPitchMax = Math.max(0.0, prof.climbPitchMax ?? 0.22);
    const climbPitchSpeed = Math.max(0.1, prof.climbPitchSpeed ?? 4.0);
    const pitchResponse = Math.max(0.1, prof.pitchResponse ?? 4.0);
    const pitchReturn = Math.max(0.1, prof.pitchReturn ?? 3.0);
    const turnPitchMax = Math.max(0.0, prof.turnPitchMax ?? 0.10);

    const pos = v.object.position;
    const base = Number.isFinite(vehicleDriveState.groundOffsetY) ? vehicleDriveState.groundOffsetY : 0.0;
    const groundYNow = getWorldSurfaceY(pos.x, pos.z) + base;

    const denom = Math.max(1e-6, (maxSpeed - minFlySpeed));
    const t = clamp((speedAbs - minFlySpeed) / denom, 0.0, 1.0);
    const targetLift = maxLift * t;

    const liftPrev = Number.isFinite(vehicleDriveState.liftY) ? vehicleDriveState.liftY : 0.0;
    const liftAlpha = 1 - Math.pow(0.001, liftResponse * dt);
    let liftY = liftPrev + (targetLift - liftPrev) * liftAlpha;

    vehicleDriveState.liftY = liftY;

    let airborne = !!vehicleDriveState.planeAirborne;

    if (!airborne && liftY > 0.15) {
      airborne = true;
      vehicleDriveState.planeAirborne = true;
      vehicleDriveState.planeBaseGroundY = groundYNow;
    }



    if (airborne) {
      const refPrev = Number.isFinite(vehicleDriveState.planeBaseGroundY) ? vehicleDriveState.planeBaseGroundY : groundYNow;

      /* Keeps plane altitude decoupled from terrain while airborne; relaxes the reference floor near landing so touchdown uses local ground height. */
      const landBlend = clamp(1.0 - (liftY / Math.max(1e-3, maxLift * 0.35)), 0.0, 1.0);
      const baseAlpha = 1 - Math.pow(0.001, 2.5 * dt);

      let refY = refPrev + (groundYNow - refPrev) * (baseAlpha * landBlend);

      const clearBase = clamp(Number.isFinite(prof.minAirClearance) ? prof.minAirClearance : 0.25, 0.0, 5.0);
      const clearT = clamp(liftY / Math.max(1e-3, maxLift * 0.25), 0.0, 1.0);
      const minAirClear = clearBase * clearT;

      let y = refY + liftY;

      const minY = groundYNow + minAirClear;
      if (y < minY) {
        y = minY;
        refY = y - liftY;
      }

      vehicleDriveState.planeBaseGroundY = refY;
      pos.y = y;

      if (liftY <= 0.12 && pos.y <= groundYNow + 0.03) {
        airborne = false;
        vehicleDriveState.planeAirborne = false;
        vehicleDriveState.planeBaseGroundY = groundYNow;
        vehicleDriveState.liftY = 0.0;
        liftY = 0.0;
        pos.y = groundYNow;
      }
    } else {
      vehicleDriveState.planeBaseGroundY = groundYNow;
      pos.y = groundYNow + liftY;
    }
    

    const rollNow = Number.isFinite(vehicleDriveState.roll) ? vehicleDriveState.roll : 0.0;
    const rollVelNow = Number.isFinite(vehicleDriveState.rollVel) ? vehicleDriveState.rollVel : 0.0;

    const rollTarget = airborne ? clamp(steerAmount * airRollMax, -airRollMax, airRollMax) : 0.0;

    const rollK = (Math.abs(steerAmount) > 1e-3) ? airRollResponse : airRollReturn;
    const rollDamp = Math.max(0.1, prof.airRollDamp ?? (rollK * 1.25));
    const rollVelMax = Math.max(0.25, airRollMax * 8.0);

    let rollVel = rollVelNow + (rollTarget - rollNow) * rollK * dt;
    rollVel *= Math.exp(-rollDamp * dt);
    rollVel = clamp(rollVel, -rollVelMax, rollVelMax);

    let roll = rollNow + rollVel * dt;
    roll = clamp(roll, -airRollMax, airRollMax);

    vehicleDriveState.rollVel = rollVel;
    vehicleDriveState.roll = roll;



    const pitchNow = Number.isFinite(vehicleDriveState.pitch) ? vehicleDriveState.pitch : 0.0;
    const pitchVelNow = Number.isFinite(vehicleDriveState.pitchVel) ? vehicleDriveState.pitchVel : 0.0;

    const speedAbsRate = (speedAbs - speedAbsPrev) / Math.max(1e-6, dt);
    const accelNorm = clamp(speedAbsRate / Math.max(1e-6, climbPitchSpeed), -1.0, 1.0);

    const pitchFromAccel = -accelNorm * climbPitchMax;
    const pitchFromTurn = -(Math.abs(steerAmount) * turnPitchMax);

    const pitchTarget = (Math.max(speedAbs, speedAbsPrev) > 0.2)
    ? clamp(
      pitchFromAccel + pitchFromTurn,
      -Math.max(climbPitchMax, turnPitchMax),
      Math.max(climbPitchMax, turnPitchMax)
      )
    : 0.0;

    const pitchK = (Math.abs(pitchTarget) > 1e-4) ? pitchResponse : pitchReturn;
    const pitchDamp = Math.max(0.1, prof.pitchDamp ?? (pitchK * 1.25));
    const pitchVelMax = Math.max(0.25, Math.max(climbPitchMax, turnPitchMax) * 8.0);

    let pitchVel = pitchVelNow + (pitchTarget - pitchNow) * pitchK * dt;
    pitchVel *= Math.exp(-pitchDamp * dt);
    pitchVel = clamp(pitchVel, -pitchVelMax, pitchVelMax);

    let pitch = pitchNow + pitchVel * dt;
    pitch = clamp(
      pitch,
      -Math.max(climbPitchMax, turnPitchMax),
      Math.max(climbPitchMax, turnPitchMax)
      );

    vehicleDriveState.pitchVel = pitchVel;
    vehicleDriveState.pitch = pitch;

    v.object.rotation.set(pitch, yawAdj, roll, "YXZ");
  } else {
    vehicleDriveState.pitch = 0.0;
    vehicleDriveState.roll = 0.0;
    vehicleDriveState.pitchVel = 0.0;
    vehicleDriveState.rollVel = 0.0;

    const pos = v.object.position;
    const base = Number.isFinite(vehicleDriveState.groundOffsetY) ? vehicleDriveState.groundOffsetY : 0.0;

    pos.y = getWorldSurfaceY(pos.x, pos.z) + base;

    const nEps = clamp((prof.groundNormalEps ?? 0.85), 0.15, 3.0);
    getWorldSurfaceNormal(pos.x, pos.z, nEps, vehicleGroundUp);

    vehicleGroundFwd.set(Math.sin(yawAdj), 0, Math.cos(yawAdj));
    vehicleGroundFwd.addScaledVector(vehicleGroundUp, -vehicleGroundFwd.dot(vehicleGroundUp));

    if (vehicleGroundFwd.lengthSq() < 1e-10) {
      vehicleGroundFwd.set(0, 0, 1);
      vehicleGroundFwd.addScaledVector(vehicleGroundUp, -vehicleGroundFwd.dot(vehicleGroundUp));
      if (vehicleGroundFwd.lengthSq() < 1e-10) {
        vehicleGroundFwd.set(1, 0, 0);
        vehicleGroundFwd.addScaledVector(vehicleGroundUp, -vehicleGroundFwd.dot(vehicleGroundUp));
      }
    }

    vehicleGroundFwd.normalize();
    vehicleGroundRight.crossVectors(vehicleGroundUp, vehicleGroundFwd).normalize();
    vehicleGroundFwd.crossVectors(vehicleGroundRight, vehicleGroundUp).normalize();

    vehicleGroundMat.makeBasis(vehicleGroundRight, vehicleGroundUp, vehicleGroundFwd);
    v.object.quaternion.setFromRotationMatrix(vehicleGroundMat);
  }

  const long = vehicleTmpVel.x * fx + vehicleTmpVel.z * fz;
  const latX = vehicleTmpVel.x - fx * long;
  const latZ = vehicleTmpVel.z - fz * long;

  const latDamp = Math.exp(-lateralGrip * dt);
  vehicleTmpVel.x = fx * long + latX * latDamp;
  vehicleTmpVel.z = fz * long + latZ * latDamp;

  if (!isPlane || !vehicleDriveState.planeAirborne) {
    stampSnowFromVehicle(v, speedAbs, maxSpeed);
  }

  if (v.parts && v.parts.propellers && v.parts.propellers.length) {
    const axis = (prof.propAxis || "y");
    const idle = Math.max(0.0, prof.propIdle ?? 6.0);
    const max = Math.max(idle, prof.propMax ?? 38.0);
    const mul = Math.max(0.0, prof.propMul ?? 1.0);
    const invert = !!prof.propInvert;

    const signed =
    Math.abs(vehicleDriveState.speed) > 1e-3
    ? Math.sign(vehicleDriveState.speed)
    : Math.abs(targetSpeed) > 1e-3
    ? Math.sign(targetSpeed)
    : 0;

    const sign = invert ? -signed : signed;

    const spin = idle + (max - idle) * clamp((speedAbs / Math.max(1e-6, maxSpeed)) * mul, 0.0, 1.0);
    const d = spin * dt * sign;

    for (let i = 0; i < v.parts.propellers.length; i++) {
      const p = v.parts.propellers[i];
      if (!p) continue;

      if (axis === "x") p.rotation.x += d;
      else if (axis === "z") p.rotation.z += d;
      else p.rotation.y += d;
    }
  }

  vehicleSeatLocal.set(
    (v.meta.seatLocal && v.meta.seatLocal[0]) || 0,
    (v.meta.seatLocal && v.meta.seatLocal[1]) || 0.6,
    (v.meta.seatLocal && v.meta.seatLocal[2]) || 0
    );

  vehicleSeatWorld.copy(vehicleSeatLocal);
  v.object.localToWorld(vehicleSeatWorld);

  avatar.position.copy(vehicleSeatWorld);

  if (isVehiclePlane(v)) {
    avatar.quaternion.copy(v.object.quaternion);
  } else {
    avatar.rotation.set(0, vehicleDriveState.yaw, 0);
  }

  if (vehiclePromptState.open) {
    const titleEl = document.getElementById("vehiclePromptTitle");
    const descEl = document.getElementById("vehiclePromptDesc");
    const enterBtn = document.getElementById("vehicleEnterBtn");
    const exitBtn = document.getElementById("vehicleExitBtn");

    if (titleEl) titleEl.textContent = v.meta.type || "Vehicle";
    if (descEl) descEl.textContent = v.meta.description || "";
    if (enterBtn) enterBtn.style.display = "none";
    if (exitBtn) exitBtn.style.display = "";
  }

  updateVehicleOutlineFor(v);
  setVehiclePrompt(true, v);
}







    /**
     * Updates prompt state based on avatar proximity (transaction state before entering).
     */
function tickVehicleProximity() {
  if (!avatarState.enabled || vehicleDriveState.enabled) {
    if (vehiclePromptState.open) setVehiclePrompt(false, null);
    updateVehicleOutlineFor(null);
    return;
  }

  const near = findNearbyVehicle();
  if (!near) {
    if (vehiclePromptState.open) setVehiclePrompt(false, null);
    updateVehicleOutlineFor(null);
    return;
  }

  setVehiclePrompt(true, near);
  updateVehicleOutlineFor(near);
}


const boundCenter = new THREE.Vector3();
const raycaster = new THREE.Raycaster();
const segDir = new THREE.Vector3();
const segDelta = new THREE.Vector3();
const hitFrom = new THREE.Vector3();
const tmpNormal = new THREE.Vector3();
const tmpMatrix3 = new THREE.Matrix3();

const obbTmpBox = new THREE.Box3();
const obbTmpCenter = new THREE.Vector3();
const obbTmpSize = new THREE.Vector3();
const obbTmpQuat = new THREE.Quaternion();
const obbTmpEuler = new THREE.Euler(0, 0, 0, "YXZ");



    // Decal helpers
const tmpM = new THREE.Matrix4();
const tmpQ = new THREE.Quaternion();
const tmpS = new THREE.Vector3();
const tmpP = new THREE.Vector3();
const zAxis = new THREE.Vector3(0, 0, 1);

    // extra helpers for object sticking burst
const tmpMatrix = new THREE.Matrix4();
const tmpDir = new THREE.Vector3();


    // Rock builder ------------------------------------------------------------
    // Builds a deterministic scattered rock field (annulus distribution) and updates collision bounds.

function rebuildRocks() {
  if (!scene) return;

  for (const r of rocks) {
    if (r && r.parent === scene) scene.remove(r);
  }
  rocks.length = 0;

  colliderObjects = colliderObjects.filter((obj) => !obj.__isRock);

  if (!rockGeo) {
    rockGeo = new THREE.IcosahedronGeometry(1.1, 0);
    rockGeo.computeBoundingBox();
    if (rockGeo.boundingBox) {
      rockGeoMidY = (rockGeo.boundingBox.min.y + rockGeo.boundingBox.max.y) * 0.5;
    } else {
      rockGeoMidY = 0.0;
    }
  }
  if (!rockMat) {
    rockMat = new THREE.MeshStandardMaterial({
      color: normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442"),
      roughness: 1.0
    });
  } else if (rockMat.color) {
    rockMat.color.set(normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442"));
  }

  const rng = makeSeededRandom((params.rockSeed * 1000003) | 0);

  const count = clamp(params.rockCount | 0, 0, 800);
  const maxR = clamp(params.rockRadius, 1.0, HALF_GROUND - 1.0);
  const minR = clamp(params.rockInnerRadius, 0.0, Math.max(maxR - 1.0, 0.0));
  const minS = Math.max(0.2, params.rockMinScale);
  const maxS = Math.max(minS, params.rockMaxScale);
  const jitter = clamp(params.rockJitter, 0.0, 3.0);

  for (let i = 0; i < count; i++) {
    const t = rng();
    const rBase = Math.sqrt(t);
    const r = minR + (maxR - minR) * rBase;

    let ang = rng() * Math.PI * 2.0;
    ang += (rng() - 0.5) * jitter * 0.4;

    let x = Math.cos(ang) * r;
    let z = Math.sin(ang) * r;

    x += (rng() - 0.5) * jitter;
    z += (rng() - 0.5) * jitter;

    const rock = new THREE.Mesh(rockGeo, rockMat);

    const s = minS + (maxS - minS) * rng();
    rock.scale.setScalar(s);

    const groundY = sampleSnowHeight(x, z);
    rock.position.set(x, groundY - rockGeoMidY * s, z);

    rock.rotation.set(
      rng() * Math.PI * 2.0,
      rng() * Math.PI * 2.0,
      rng() * Math.PI * 2.0
      );

    rock.castShadow = true;
    rock.receiveShadow = true;
    rock.__isRock = true;

    scene.add(rock);
    rocks.push(rock);
    colliderObjects.push(rock);
  }

  colliderBounds = buildColliderBounds(colliderObjects);
  rebuildAvatarCollisionGrid();
}




    // Forest builder ----------------------------------------------------------

function rebuildForest() {
  if (!scene) return;

  // Remove old forest trees from scene and colliders
  for (const t of cones) {
    if (t && t.parent === scene) scene.remove(t);
  }
  cones.length = 0;

  colliderObjects = colliderObjects.filter((obj) => !obj.__isForestTree);

  if (!forestConeGeo) {
    forestConeGeo = new THREE.ConeGeometry(0.9, 3.3, 24, 1);
  }
  if (!forestConeMat) {
    forestConeMat = new THREE.MeshStandardMaterial({
      color: normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b"),
      roughness: 1.0,
      metalness: 0.0
    });
  } else if (forestConeMat.color) {
    forestConeMat.color.set(normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b"));
  }

  const rng = makeSeededRandom((params.forestSeed * 1000003) | 0);

  const count = clamp(params.forestCount | 0, 0, 400);
  const maxR = clamp(params.forestRadius, 1.0, HALF_GROUND - 1.0);
  const minR = clamp(
    params.forestInnerRadius,
    0.0,
    Math.max(maxR - 1.0, 0.0)
    );
  const minS = Math.max(0.2, params.forestMinScale);
  const maxS = Math.max(minS, params.forestMaxScale);
  const jitter = clamp(params.forestJitter, 0.0, 3.0);

  for (let i = 0; i < count; i++) {
    const t = rng();
    const rBase = Math.sqrt(t);
    const r = minR + (maxR - minR) * rBase;

    let ang = rng() * Math.PI * 2.0;
    ang += (rng() - 0.5) * jitter * 0.4;

    let x = Math.cos(ang) * r;
    let z = Math.sin(ang) * r;

    x += (rng() - 0.5) * jitter;
    z += (rng() - 0.5) * jitter;

    const tree = new THREE.Mesh(forestConeGeo, forestConeMat);

    const scale = minS + (maxS - minS) * rng();
    tree.scale.set(scale, scale, scale);

    const y = 1.65 * scale;
    tree.position.set(x, y, z);

    tree.rotation.y = rng() * Math.PI * 2.0;
    tree.castShadow = true;
    tree.receiveShadow = true;
    tree.__isForestTree = true;

    scene.add(tree);
    cones.push(tree);
    colliderObjects.push(tree);
  }

  colliderBounds = buildColliderBounds(colliderObjects);
  rebuildAvatarCollisionGrid();
}







    // Gust system -------------------------------------------------------------

class Gust {
  constructor() {
    this.x = 0;
    this.z = 0;
    this.radius = 1;
    this.strength = 0;
    this.swirl = 0;
    this.updraft = 0;
    this.ttl = 0;
    this.life = 0;
  }
  reset(x, z, radius, strength, swirl, updraft, ttl) {
    this.x = x;
    this.z = z;
    this.radius = radius;
    this.strength = strength;
    this.swirl = swirl;
    this.updraft = updraft;
    this.ttl = ttl;
    this.life = ttl;
  }
  step(dt) {
    this.life = Math.max(0, this.life - dt);
  }
  get active() {
    return this.life > 0;
  }
  get fade() {
    if (this.ttl <= 1e-6) return 0;
    const t = this.life / this.ttl;
    return t * t;
  }
}

const GUST_MAX = 6;
const gusts = Array.from({ length: GUST_MAX }, () => new Gust());
let gustSpawnTimer = 0;

const gustTmp = new THREE.Vector3();
const gustPosRad = new Float32Array(GUST_MAX * 3);
const gustParams = new Float32Array(GUST_MAX * 3);


function spawnGusts(dt) {
  gustSpawnTimer -= dt;
  if (gustSpawnTimer > 0) return;

  const minI = clamp(params.gustMinInterval, 0.2, 20.0);
  const maxI = clamp(params.gustMaxInterval, minI + 0.1, 40.0);
  gustSpawnTimer = minI + Math.random() * (maxI - minI);

  if (!cones.length) return;
  const tpos = cones[(Math.random() * cones.length) | 0].position;
  const gx = tpos.x + (Math.random() * 2 - 1) * 2.2;
  const gz = tpos.z + (Math.random() * 2 - 1) * 2.2;

  const tornadoChance = clamp(params.gustTornadoChance, 0.0, 1.0);
  const isTornado = Math.random() < tornadoChance;

  const radius = isTornado ? (1.8 + Math.random() * 1.2) : (3.4 + Math.random() * 3.2);
  const strength =
  (isTornado ? (2.4 + Math.random() * 2.2) : (0.9 + Math.random() * 1.2)) *
  clamp(params.gustStrengthMul, 0.0, 4.0);
  const swirlSign = Math.random() < 0.5 ? -1 : 1;
  const swirl =
  swirlSign *
  (isTornado ? 4.4 : 2.2) *
  clamp(params.gustSwirlMul, 0.0, 4.0);
  const updraft =
  (isTornado ? (2.2 + Math.random() * 2.0) : (0.20 + Math.random() * 0.55)) *
  clamp(params.gustUpdraftMul, 0.0, 4.0);
  const ttl = isTornado ? (1.5 + Math.random() * 1.8) : (1.1 + Math.random() * 1.8);

      // find slot
  let slot = 0;
  for (let i = 0; i < gusts.length; i++) {
    if (!gusts[i].active) {
      slot = i;
      break;
    }
  }

  gusts[slot].reset(gx, gz, radius, strength, swirl, updraft, ttl);

    // audio whoosh tied to gust strength
    //playGustFx(strength);

}


function gustWindAt(x, z, heightAboveSnow, out) {
  out.set(0, 0, 0);
  for (let i = 0; i < gusts.length; i++) {
    const g = gusts[i];
    if (!g.active) continue;

    const dx = x - g.x;
    const dz = z - g.z;
    const r2 = dx * dx + dz * dz;
    const r = g.radius;
    if (r2 > r * r) continue;

    const rr = Math.max(1e-6, Math.sqrt(r2));
    const npx = dx / rr;
    const npz = dz / rr;

    const heightK = 1.0 / (1.0 + Math.max(0, heightAboveSnow) * 1.15);
    const radial = 1.0 - rr / r;
    const k = g.fade * g.strength * radial * radial * heightK;

    const tx = -npz;
    const tz = npx;

    out.x += tx * (g.swirl * k) + (-npx) * (0.18 * k);
    out.z += tz * (g.swirl * k) + (-npz) * (0.18 * k);
    out.y += g.updraft * k * (radial * radial);
  }
  return out;
}

function applyGustScour(baseWindX, baseWindZ) {
  const scourBase = clamp(params.gustScour, 0.0, 0.10);
  const redepBase = clamp(params.gustRedeposit, 0.0, 0.10);
  if (scourBase === 0 && redepBase === 0) return;

  for (let i = 0; i < gusts.length; i++) {
    const g = gusts[i];
    if (!g.active) continue;

    const fade = g.fade;
    const scour = -scourBase * fade;
    const redeposit = redepBase * fade;

        // scour around gust center, redeposit downwind
    depositHeightAtWorld(g.x, g.z, scour, 0, 0);
    depositHeightAtWorld(g.x, g.z, scour * 0.7, 0, 0);
    depositHeightAtWorld(g.x, g.z, redeposit, baseWindX, baseWindZ);
  }
}

    // GUI / presets -----------------------------------------------------------

let gui = null;
const guiControllers = [];




const presetState = {
  presetName: "",
  selected: "<none>"
};
let presetSelectCtrl = null;



    // JSON file presets (edit / extend this list)
const FILE_PRESET_URLS = [
  "presets/snow-Hello.json",
  "presets/snow-Forrest.json",
  "presets/snow-Moist-1.json",
  "presets/snow-More-Snow.json",
  "presets/snow-Delicate.json",
  "presets/snow-heavy.json"
];

function getBuiltinPresets() {
  return FILE_PRESET_URLS.map((url) => {
    const parts = url.split("/");
    const file = parts[parts.length - 1] || url;
    const withoutExt = file.replace(/\.json$/i, "");
    const spaced = withoutExt
    .replace(/^snow-/, "")
    .replace(/[-_]+/g, " ");
    const name = sanitizePresetName(spaced);
    return { name: name || withoutExt, url };
  });
}



    // Drift deposition kernel -------------------------------------------------

const KERNEL_RADIUS = 3;
const KERNEL_SIGMA = 1.05;
const driftKernel = [];

(function buildKernel() {
  let sum = 0;
  for (let dz = -KERNEL_RADIUS; dz <= KERNEL_RADIUS; dz++) {
    for (let dx = -KERNEL_RADIUS; dx <= KERNEL_RADIUS; dx++) {
      const r2 = dx * dx + dz * dz;
      const w = Math.exp(-r2 / (2 * KERNEL_SIGMA * KERNEL_SIGMA));
      driftKernel.push({ dx, dz, w });
      sum += w;
    }
  }
  for (const k of driftKernel) k.w /= sum || 1;
})();






// -------------------------------------------------------------------------
// Apply settings (clamps)
// -------------------------------------------------------------------------

function applySettings(
  obj,
  { rebuild = false, updateGui = true, persist = true } = {}
  ) {
  const prevPersistBlocked = persistBlocked;

  const prevSnowEnabled = !!params.snowEnabled;

  const prevDustEnabled = !!params.dustEnabled;
  const prevDustCount = params.dustCount | 0;

  const prevRainEnabled = !!params.rainEnabled;
  const prevRainCount = params.rainCount | 0;

  const prevGrassEnabled = !!params.grassEnabled;
  const prevGrassCount = params.grassCount | 0;
  const prevGrassSeed = params.grassSeed | 0;

  persistBlocked = persistBlocked || !persist;

  try {
    if (!obj || typeof obj !== "object") return;

    for (const k in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      params[k] = obj[k];
    }

    // core sim
    params.timeScale = clamp(params.timeScale, 0.05, 5.0);
    params.dtMax = clamp(params.dtMax, 0.005, 0.25);

    params.pixelRatio = clamp(params.pixelRatio, 0.5, 2.5);

    // performance (shadows)
    params.shadowsEnabled = !!params.shadowsEnabled;
    params.shadowsAutoUpdate = !!params.shadowsAutoUpdate;
    params.shadowType = sanitizeShadowType(params.shadowType);
    params.shadowMapSize = sanitizeShadowMapSize(params.shadowMapSize | 0);

    applyShadowSettingsFromParams(false);

    // snow master enable
    params.snowEnabled = !!params.snowEnabled;

    params.visualCount = clamp(params.visualCount | 0, 1000, 150000);

    params.windStrength = clamp(params.windStrength, 0.0, 0.6);
    params.windSpeed = clamp(params.windSpeed, 0.01, 2.0);
    params.fallSpeed = clamp(params.fallSpeed, 0.2, 10.0);
    params.fallJitter = clamp(params.fallJitter, 0.0, 1.0);

    params.flakeSize = clamp(params.flakeSize, 0.1, 4.0);
    params.flakeSizeJitter = clamp(params.flakeSizeJitter, 0.0, 1.0);

    params.gustMinInterval = clamp(params.gustMinInterval, 0.2, 20.0);
    params.gustMaxInterval = clamp(params.gustMaxInterval, params.gustMinInterval, 40.0);
    params.gustTornadoChance = clamp(params.gustTornadoChance, 0.0, 1.0);

    params.gustStrengthMul = clamp(params.gustStrengthMul, 0.0, 4.0);
    params.gustSwirlMul = clamp(params.gustSwirlMul, 0.0, 4.0);
    params.gustUpdraftMul = clamp(params.gustUpdraftMul, 0.0, 4.0);
    params.gustScour = clamp(params.gustScour, 0.0, 0.08);
    params.gustRedeposit = clamp(params.gustRedeposit, 0.0, 0.08);

    params.driftGrid = clamp(params.driftGrid | 0, 64, 512);
    params.driftMaxHeight = clamp(params.driftMaxHeight, 0.0, 8.0);

    params.coverBase = clamp(params.coverBase, 0.0, 2.0);
    params.coverMacroAmp = clamp(params.coverMacroAmp, 0.0, 2.0);
    params.coverMacroFreq = clamp(params.coverMacroFreq, 0.0, 30.0);
    params.coverMicroAmp = clamp(params.coverMicroAmp, 0.0, 2.0);
    params.coverMicroFreq = clamp(params.coverMicroFreq, 0.0, 80.0);

    params.driftDiffusion = clamp(params.driftDiffusion, 0.0, 0.2);
    params.driftAdvection = clamp(params.driftAdvection, 0.0, 0.05);

    params.obstacleShapeInterval = clamp(params.obstacleShapeInterval | 0, 1, 600);
    params.driftWriteInterval = clamp(params.driftWriteInterval | 0, 1, 600);
    params.normalUpdateInterval = clamp(params.normalUpdateInterval | 0, 1, 1200);

    params.settlerCount = clamp(params.settlerCount | 0, 0, 60000);

    params.groundDepositBudget = clamp(params.groundDepositBudget, 0.0, 2000.0);
    params.depositUnit = clamp(params.depositUnit, 0.00001, 0.01);

    params.objectTestsPerFrame = clamp(params.objectTestsPerFrame | 0, 0, 5000);
    params.objectDeposit = clamp(params.objectDeposit, 0.0, 0.02);

    params.stuckMax = clamp(params.stuckMax | 0, 0, 80000);
    params.decalSize = clamp(params.decalSize, 0.02, 1.5);

    // fog
    params.fogNear = clamp(params.fogNear, 0.1, 400.0);
    params.fogFar = clamp(params.fogFar, 1.0, 2000.0);

    // surface colors
    params.groundColor = normalizeHexColor(params.groundColor, DEFAULTS.groundColor || "#ffffff");
    params.rockColor = normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442");
    params.forestColor = normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b");
    params.cubeColor = normalizeHexColor(params.cubeColor, DEFAULTS.cubeColor || "#4e9cff");

    // snowman
    params.snowmanMoveEnabled = !!params.snowmanMoveEnabled;
    params.snowmanPathRadius = clamp(params.snowmanPathRadius, 0.0, 50.0);
    params.snowmanSpeed = clamp(params.snowmanSpeed, 0.0, 2.0);

    // forest
    params.forestCount = clamp(params.forestCount | 0, 0, 4000);
    params.forestRadius = clamp(params.forestRadius, 2.0, 2000.0);
    params.forestInnerRadius = clamp(params.forestInnerRadius, 0.0, 2000.0);
    params.forestMinScale = clamp(params.forestMinScale, 0.1, 20.0);
    params.forestMaxScale = clamp(params.forestMaxScale, params.forestMinScale, 30.0);
    params.forestSeed = clamp(params.forestSeed | 0, 0, 999999);
    params.forestJitter = clamp(params.forestJitter, 0.0, 3.0);

    // rocks
    params.rockCount = clamp(params.rockCount | 0, 0, 800);
    params.rockRadius = clamp(params.rockRadius, 2.0, 2000.0);
    params.rockInnerRadius = clamp(params.rockInnerRadius, 0.0, 2000.0);
    params.rockMinScale = clamp(params.rockMinScale, 0.1, 50.0);
    params.rockMaxScale = clamp(params.rockMaxScale, params.rockMinScale, 80.0);
    params.rockSeed = clamp(params.rockSeed | 0, 0, 999999);
    params.rockJitter = clamp(params.rockJitter, 0.0, 3.0);

    // clouds
    params.cloudEnabled = !!params.cloudEnabled;
    params.cloudHeightBase = clamp(params.cloudHeightBase, 0.0, 200.0);
    params.cloudHeightRange = clamp(params.cloudHeightRange, 0.0, 200.0);
    params.cloudRadius = clamp(params.cloudRadius, 5.0, 400.0);
    params.cloudSliceCount = clamp(params.cloudSliceCount | 0, 32, 1024);
    params.cloudSpeed = clamp(params.cloudSpeed, 0.0, 2.0);
    params.cloudDensity = clamp(params.cloudDensity, 0.0, 2.0);
    params.cloudSoftness = clamp(params.cloudSoftness, 0.0, 4.0);
    params.cloudOpacity = clamp(params.cloudOpacity, 0.0, 1.0);

    // dust
    params.dustEnabled = !!params.dustEnabled;
    params.dustRadius = clamp(params.dustRadius, 0.1, 200.0);
    params.dustFloorY = clamp(params.dustFloorY, -50.0, 500.0);
    params.dustCeilY = clamp(params.dustCeilY, params.dustFloorY + 0.01, 1000.0);
    params.dustSpeed = clamp(params.dustSpeed, 0.0, 20.0);
    params.dustCount = clamp(params.dustCount | 0, 1, 20000);
    params.dustSize = clamp(params.dustSize, 0.001, 10.0);
    params.dustNoise = clamp(params.dustNoise, 0.0, 10.0);
    params.dustCenterX = clamp(params.dustCenterX, -HALF_GROUND, HALF_GROUND);
    params.dustCenterZ = clamp(params.dustCenterZ, -HALF_GROUND, HALF_GROUND);

    // rain
    params.rainEnabled = !!params.rainEnabled;
    params.rainRadius = clamp(params.rainRadius, 0.1, 2000.0);
    params.rainTopY = clamp(params.rainTopY, -50.0, 1000.0);
    params.rainBottomY = clamp(params.rainBottomY, -200.0, 1000.0);
    if (params.rainBottomY > params.rainTopY - 0.01) params.rainBottomY = params.rainTopY - 0.01;
    params.rainSpeed = clamp(params.rainSpeed, 0.0, 30.0);
    params.rainCount = clamp(params.rainCount | 0, 1, 40000);
    params.rainSize = clamp(params.rainSize, 0.001, 20.0);
    params.rainThickness = clamp(params.rainThickness, 0.001, 0.5);
    params.rainStreak = clamp(params.rainStreak, 0.05, 0.98);
    params.rainWindX = clamp(params.rainWindX, -20.0, 20.0);
    params.rainWindZ = clamp(params.rainWindZ, -20.0, 20.0);
    params.rainCenterX = clamp(params.rainCenterX, -HALF_GROUND, HALF_GROUND);
    params.rainCenterZ = clamp(params.rainCenterZ, -HALF_GROUND, HALF_GROUND);
    params.rainOpacity = clamp(params.rainOpacity, 0.0, 1.0);

    // grass
    params.grassEnabled = !!params.grassEnabled;
    params.grassCount = clamp(params.grassCount | 0, 0, 120000);
    params.grassRadius = clamp(params.grassRadius, 0.1, 2000.0);
    params.grassCenterX = clamp(params.grassCenterX, -HALF_GROUND, HALF_GROUND);
    params.grassCenterZ = clamp(params.grassCenterZ, -HALF_GROUND, HALF_GROUND);
    params.grassBaseY = clamp(params.grassBaseY, -5.0, 25.0);

    params.grassBladeHeight = clamp(params.grassBladeHeight, 0.01, 4.0);
    params.grassBladeWidth = clamp(params.grassBladeWidth, 0.001, 2.0);
    params.grassHeightJitter = clamp(params.grassHeightJitter, 0.0, 1.0);
    params.grassWidthJitter = clamp(params.grassWidthJitter, 0.0, 1.0);

    params.grassBend = clamp(params.grassBend, 0.0, 6.0);
    params.grassWindSpeed = clamp(params.grassWindSpeed, 0.0, 20.0);
    params.grassWindStrength = clamp(params.grassWindStrength, 0.0, 6.0);
    params.grassStiffness = clamp(params.grassStiffness, 0.25, 4.0);

    params.grassNoiseScale = clamp(params.grassNoiseScale, 0.01, 4.0);
    params.grassNoiseStrength = clamp(params.grassNoiseStrength, 0.0, 2.0);
    params.grassNoiseSpeed = clamp(params.grassNoiseSpeed, 0.0, 10.0);
    params.grassColorVariation = clamp(params.grassColorVariation, 0.0, 0.5);

    params.grassColorBottom = normalizeHexColor(params.grassColorBottom, DEFAULTS.grassColorBottom || "#1f5f2e");
    params.grassColorTop = normalizeHexColor(params.grassColorTop, DEFAULTS.grassColorTop || "#7ee36c");
    params.grassOpacity = clamp(params.grassOpacity, 0.0, 1.0);
    params.grassAlphaCutoff = clamp(params.grassAlphaCutoff, 0.0, 0.95);
    params.grassSeed = clamp(params.grassSeed | 0, 0, 999999);

    const snowEnabledChanged = (!!params.snowEnabled !== prevSnowEnabled);

    const dustNeedsRebuild =
    rebuild ||
    (!!params.dustEnabled !== prevDustEnabled) ||
    ((params.dustCount | 0) !== (prevDustCount | 0)) ||
    (dustLastCount !== (params.dustCount | 0));

    const rainNeedsRebuild =
    rebuild ||
    (!!params.rainEnabled !== prevRainEnabled) ||
    ((params.rainCount | 0) !== (prevRainCount | 0)) ||
    (rainLastCount !== (params.rainCount | 0));

    const grassNeedsRebuild =
    rebuild ||
    (!!params.grassEnabled !== prevGrassEnabled) ||
    ((params.grassCount | 0) !== (prevGrassCount | 0)) ||
    ((params.grassSeed | 0) !== (prevGrassSeed | 0)) ||
    (grassLastCount !== (params.grassCount | 0));

    if (rebuild) {
      rebuildWorld();
      rebuildForest();
      rebuildRocks();
      rebuildClouds();
    } else {
      applyCloudParamsToUniforms();
      if (snowEnabledChanged) {
        rebuildWorld();
      }
    }

    if (dustNeedsRebuild) {
      rebuildDust();
    } else {
      if (!params.dustEnabled) {
        disposeDust();
      } else if (!dustUniforms) {
        rebuildDust();
      } else {
        applyDustParamsToUniforms();
      }
    }

    if (rainNeedsRebuild) {
      rebuildRain();
    } else {
      if (!params.rainEnabled) {
        disposeRain();
      } else if (!rainUniforms) {
        rebuildRain();
      } else {
        applyRainParamsToUniforms();
      }
    }

    if (grassNeedsRebuild) {
      rebuildGrass();
    } else {
      if (!params.grassEnabled) {
        disposeGrass();
      } else if (!grassUniforms) {
        rebuildGrass();
      } else {
        applyGrassParamsToUniforms();
      }
    }

    applySurfaceColorsFromParams();

    if (updateGui && gui) {
      refreshGuiDisplays();
    }

    if (persist && !persistBlocked) {
      saveLastDebounced(params);
    }
  } finally {
    persistBlocked = prevPersistBlocked;
  }
}




    // -------------------------------------------------------------------------
    // Snow texture (point sprite)
    // -------------------------------------------------------------------------

function makeRadialTexture(size = 96) {
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const g = c.getContext("2d");

  const grad = g.createRadialGradient(
    size / 2, size / 2, 0,
    size / 2, size / 2, size / 2
    );
  grad.addColorStop(0.00, "rgba(254,254,254,1.00)");
  grad.addColorStop(0.42, "rgba(255,255,255,0.92)");
  grad.addColorStop(0.78, "rgba(255,255,255,0.22)");
  grad.addColorStop(1.00, "rgba(255,255,255,0.00)");

  g.clearRect(0, 0, size, size);
  g.fillStyle = grad;
  g.beginPath();
  g.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
  g.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.anisotropy = 4;
  tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
  return tex;
}

    // -------------------------------------------------------------------------
    // Drifts: heightfield
    // -------------------------------------------------------------------------

function gridIndex(i, j) {
  return j * DRIFT_STRIDE + i;
}


/* Deterministic 2D value-noise + fBm helpers for procedural terrain. */
function _hash2D(ix, iz, seed) {
  let n = (ix * 374761393 + iz * 668265263 + (seed | 0) * 1442695041) | 0;
  n = (n ^ (n >>> 13)) >>> 0;
  n = (n * 1274126177) >>> 0;
  n = (n ^ (n >>> 16)) >>> 0;
  return n / 4294967295;
}

function _fade01(t) {
  t = clamp(t, 0, 1);
  return t * t * (3 - 2 * t);
}

function _valueNoise2D(x, z, seed) {
  const ix = Math.floor(x);
  const iz = Math.floor(z);
  const fx = x - ix;
  const fz = z - iz;

  const a = _hash2D(ix, iz, seed);
  const b = _hash2D(ix + 1, iz, seed);
  const c = _hash2D(ix, iz + 1, seed);
  const d = _hash2D(ix + 1, iz + 1, seed);

  const ux = _fade01(fx);
  const uz = _fade01(fz);

  const ab = a + (b - a) * ux;
  const cd = c + (d - c) * ux;
  return ab + (cd - ab) * uz;
}

function _fbm2D(x, z, seed, octaves, lacunarity, gain) {
  let sum = 0;
  let amp = 1;
  let freq = 1;

  const o = clamp(octaves | 0, 1, 10);
  const lac = Math.max(1.0, lacunarity);
  const g = clamp(gain, 0.0, 1.0);

  for (let i = 0; i < o; i++) {
    const n = _valueNoise2D(x * freq, z * freq, seed + i * 1013);
    sum += (n * 2 - 1) * amp;
    amp *= g;
    freq *= lac;
  }
  return sum;
}

function _smoothstep(edge0, edge1, x) {
  const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
  return t * t * (3 - 2 * t);
}

function _terrainMaskAt(x, z) {
  const outer = Math.max(0, params.terrainRadius);
  const inner = clamp(params.terrainInnerRadius, 0, outer);
  const fade = Math.max(0.0, params.terrainEdgeFade);

  if (outer <= 0.0001) return 0;

  const r = Math.sqrt(x * x + z * z);

  const edgeFreq = Math.max(0.0001, params.terrainEdgeNoiseFreq);
  const edgeAmp = clamp(params.terrainEdgeNoiseAmp, 0.0, 0.9);
  const edgeN = (_valueNoise2D(x * edgeFreq, z * edgeFreq, (params.terrainSeed | 0) + 9001) * 2 - 1) * edgeAmp;

  const effectiveOuter = Math.max(0.0, outer * (1.0 + edgeN));
  const outerMask = 1.0 - _smoothstep(Math.max(0.0, effectiveOuter - fade), effectiveOuter, r);
  const innerMask = inner <= 0.0001 ? 1.0 : _smoothstep(inner, inner + fade, r);

  return clamp(outerMask * innerMask, 0, 1);
}

function _terrainHeightAt(x, z) {
  if (!params.terrainEnabled) return 0;

  const mask = _terrainMaskAt(x, z);
  if (mask <= 0.00001) return 0;

  const amp = Math.max(0, params.terrainAmp);
  if (amp <= 0.00001) return 0;

  const freq = Math.max(0.0001, params.terrainFreq);
  const seed = params.terrainSeed | 0;

  const warpFreq = Math.max(0.0001, params.terrainWarpFreq);
  const warpAmp = Math.max(0.0, params.terrainWarpAmp);

  const wx = (_valueNoise2D(x * warpFreq, z * warpFreq, seed + 30011) * 2 - 1) * warpAmp;
  const wz = (_valueNoise2D(x * warpFreq, z * warpFreq, seed + 30071) * 2 - 1) * warpAmp;

  const n = _fbm2D(
    (x + wx) * freq,
    (z + wz) * freq,
    seed + 701,
    params.terrainOctaves | 0,
    params.terrainLacunarity,
    params.terrainGain
    );

  let t = n * 0.5 + 0.5;
  t = clamp(t, 0, 1);

  if (params.terrainRidge) {
    const r = 1.0 - Math.abs(n);
    t = clamp(r, 0, 1);
  }

  const exp = Math.max(0.25, params.terrainExponent);
  t = Math.pow(t, exp);

  return t * amp * mask;
}

/* Re-initializes terrain base + cover without rebuilding the full world. */
function rebuildTerrainBase() {
  if (!params.snowEnabled || !snowSurface || !driftGeo || !driftHeights) return;
  initSnowCover();
  applyHeightsToGeometry();
  driftGeo.computeVertexNormals();
  driftGeo.attributes.normal.needsUpdate = true;
}


function initSnowCover() {
  if (!driftHeights) return;

  const base = Math.max(0, params.coverBase);
  const macroAmp = Math.max(0, params.coverMacroAmp);
  const macroFreq = Math.max(0.1, params.coverMacroFreq);
  const microAmp = Math.max(0, params.coverMicroAmp);
  const microFreq = Math.max(0.1, params.coverMicroFreq);
  const TAU = Math.PI * 2;

  const maxH = Math.max(0.5, params.driftMaxHeight);
  const colStrength = clamp(params.terrainColorStrength || 0, 0, 1);

  let lowR = 1, lowG = 1, lowB = 1, highR = 1, highG = 1, highB = 1;
  if (driftColorArray && colStrength > 0.00001) {
    const lo = new THREE.Color(normalizeHexColor(params.terrainColorLow, "#ffffff"));
    const hi = new THREE.Color(normalizeHexColor(params.terrainColorHigh, "#ffffff"));
    lowR = lo.r; lowG = lo.g; lowB = lo.b;
    highR = hi.r; highG = hi.g; highB = hi.b;
  }

  for (let j = 0; j <= DRIFT_GRID; j++) {
    for (let i = 0; i <= DRIFT_GRID; i++) {
      const u = i / DRIFT_GRID;
      const v = j / DRIFT_GRID;

      const sin1 = Math.sin((u * macroFreq + 0.11) * TAU);
      const cos1 = Math.cos((v * macroFreq - 0.27) * TAU);
      const macro = (sin1 + cos1) * 0.5;

      const sin3 = Math.sin(((u * microFreq + v * (microFreq * 0.70)) + 0.19) * TAU);
      const cos2 = Math.cos(((v * microFreq - u * (microFreq * 0.80)) - 0.23) * TAU);
      const micro = (sin3 + cos2) * 0.5;

      const x = (u - 0.5) * GROUND_SIZE;
      const z = (v - 0.5) * GROUND_SIZE;

      const terrain = _terrainHeightAt(x, z);

      const h = base + macro * macroAmp + micro * microAmp + terrain;
      const idx = gridIndex(i, j);

      const hc = clamp(h, 0, maxH);
      driftHeights[idx] = hc;

      if (driftColorArray) {
        let t = hc / maxH;
        t = clamp(t, 0, 1);
        t = Math.pow(t, 0.65);

        const cr = lowR + (highR - lowR) * t;
        const cg = lowG + (highG - lowG) * t;
        const cb = lowB + (highB - lowB) * t;

        const outR = 1 + (cr - 1) * colStrength;
        const outG = 1 + (cg - 1) * colStrength;
        const outB = 1 + (cb - 1) * colStrength;

        const o = idx * 3;
        driftColorArray[o + 0] = outR;
        driftColorArray[o + 1] = outG;
        driftColorArray[o + 2] = outB;
      }
    }
  }

  if (driftDeform) driftDeform.fill(0);

  if (driftColorAttr) driftColorAttr.needsUpdate = true;
}



function applyHeightsToGeometry() {
  if (!driftHeights || !driftPosArray) return;

  const d = driftDeform && driftDeform.length === DRIFT_VERTS ? driftDeform : null;

  for (let v = 0; v < DRIFT_VERTS; v++) {
    const y = driftHeights[v] + (d ? d[v] : 0);
    driftPosArray[v * 3 + 1] = y;
  }

  driftPosAttr.needsUpdate = true;
}


function sampleSnowHeight(x, z) {
  if (!driftHeights) return 0;

  const d = driftDeform && driftDeform.length === DRIFT_VERTS ? driftDeform : null;

  let u = (x + HALF_GROUND) / GROUND_SIZE;
  let v = (z + HALF_GROUND) / GROUND_SIZE;
  u = clamp(u, 0, 0.999999);
  v = clamp(v, 0, 0.999999);

  const fx = u * DRIFT_GRID;
  const fz = v * DRIFT_GRID;

  const i0 = fx | 0;
  const j0 = fz | 0;
  const i1 = Math.min(DRIFT_GRID, i0 + 1);
  const j1 = Math.min(DRIFT_GRID, j0 + 1);

  const tx = fx - i0;
  const tz = fz - j0;

  const idx00 = gridIndex(i0, j0);
  const idx10 = gridIndex(i1, j0);
  const idx01 = gridIndex(i0, j1);
  const idx11 = gridIndex(i1, j1);

  const h00 = driftHeights[idx00] + (d ? d[idx00] : 0);
  const h10 = driftHeights[idx10] + (d ? d[idx10] : 0);
  const h01 = driftHeights[idx01] + (d ? d[idx01] : 0);
  const h11 = driftHeights[idx11] + (d ? d[idx11] : 0);

  const hx0 = h00 + (h10 - h00) * tx;
  const hx1 = h01 + (h11 - h01) * tx;
  return hx0 + (hx1 - hx0) * tz;
}


function ensureWetTrailTex() {
  /* Creates the radial alpha texture used by wet decals (soft edge, no harsh squares). */
  if (wetTrailTex) return wetTrailTex;
  wetTrailTex = makeRadialTexture(128);
  wetTrailTex.wrapS = THREE.ClampToEdgeWrapping;
  wetTrailTex.wrapT = THREE.ClampToEdgeWrapping;
  wetTrailTex.needsUpdate = true;
  return wetTrailTex;
}

function makeFootprintTexture(size, cfg) {
  /* Creates an alpha texture shaped like a footprint: heel + toe ovals connected by a soft bridge. */
  const s = Math.max(32, size | 0);
  const canvas = document.createElement("canvas");
  canvas.width = s;
  canvas.height = s;

  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, s, s);

  const softness = clamp(cfg.footSoftness ?? 0.55, 0.05, 0.95);
  const toeScale = clamp(cfg.footToeScale ?? 0.62, 0.1, 1.0);
  const heelScale = clamp(cfg.footHeelScale ?? 0.52, 0.1, 1.0);
  const bridge = clamp(cfg.footBridge ?? 0.22, 0.0, 0.9);

  function drawSoftOval(cx, cy, rx, ry) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(rx, ry);

    const g = ctx.createRadialGradient(0, 0, 0, 0, 0, 1);
    g.addColorStop(0.0, "rgba(255,255,255,1.0)");
    g.addColorStop(Math.max(0.01, 1.0 - softness), "rgba(255,255,255,1.0)");
    g.addColorStop(1.0, "rgba(255,255,255,0.0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(0, 0, 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  const cx = s * 0.5;

  const toeCy = s * 0.34;
  const heelCy = s * 0.68;

  const baseRx = s * 0.22;
  const baseRy = s * 0.28;

  drawSoftOval(cx, toeCy, baseRx * toeScale, baseRy * toeScale);
  drawSoftOval(cx, heelCy, baseRx * heelScale, baseRy * heelScale);

  // Bridge: soft vertical capsule between toe and heel
  if (bridge > 0.001) {
    const bridgeW = baseRx * (0.9 * bridge + 0.1);
    const topY = toeCy + baseRy * toeScale * 0.45;
    const botY = heelCy - baseRy * heelScale * 0.55;
    const h = Math.max(1, botY - topY);

    ctx.save();
    ctx.translate(cx, topY);

    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0.0, "rgba(255,255,255,0.0)");
    g.addColorStop(0.25, "rgba(255,255,255,1.0)");
    g.addColorStop(0.75, "rgba(255,255,255,1.0)");
    g.addColorStop(1.0, "rgba(255,255,255,0.0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.moveTo(-bridgeW, 0);
    ctx.lineTo(bridgeW, 0);
    ctx.lineTo(bridgeW, h);
    ctx.lineTo(-bridgeW, h);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  const tex = new THREE.CanvasTexture(canvas);
  tex.wrapS = THREE.ClampToEdgeWrapping;
  tex.wrapT = THREE.ClampToEdgeWrapping;
  tex.needsUpdate = true;
  return tex;
}

function ensureWetFootTex() {
  /* Creates/caches the footprint alpha texture; re-creates when footprint params change. */
  const sig =
  String(wetTrailConfig.footTexSize | 0) + "|" +
  String(wetTrailConfig.footToeScale) + "|" +
  String(wetTrailConfig.footHeelScale) + "|" +
  String(wetTrailConfig.footBridge) + "|" +
  String(wetTrailConfig.footSoftness);

  if (wetFootTex && wetFootSig === sig) return wetFootTex;

  if (wetFootTex && wetFootTex.dispose) wetFootTex.dispose();

  wetFootSig = sig;
  wetFootTex = makeFootprintTexture(wetTrailConfig.footTexSize, wetTrailConfig);
  return wetFootTex;
}


function getSnowSurfaceY(x, z) {
  /* Returns world-space snow surface Y (snowSurface offset + sampled drift height). */
  const baseY = snowSurface ? snowSurface.position.y : 0.0;
  return baseY + sampleSnowHeight(x, z);
}

/**
 * Returns the current traversable surface Y at XZ.
 * Today this is the snow surface; future surfaces (water/dunes/etc.) can be routed here.
 */
function getWorldSurfaceY(x, z) {
  return getSnowSurfaceY(x, z);
}

/**
 * Approximates the current traversable surface normal at XZ using central differences.
 */
function getWorldSurfaceNormal(x, z, eps, out) {
  const e = Math.max(1e-3, Number.isFinite(eps) ? eps : 0.75);

  const hL = getWorldSurfaceY(x - e, z);
  const hR = getWorldSurfaceY(x + e, z);
  const hD = getWorldSurfaceY(x, z - e);
  const hU = getWorldSurfaceY(x, z + e);

  out.set(hL - hR, 2.0 * e, hD - hU);

  if (!Number.isFinite(out.x) || !Number.isFinite(out.y) || !Number.isFinite(out.z) || out.lengthSq() < 1e-12) {
    out.set(0, 1, 0);
    return out;
  }

  out.normalize();
  return out;
}


function setupWetTrailSystem() {
  /* Builds a pooled decal system for short-lived wet marks behind avatar/vehicles. */
  if (!scene) return;

  if (!wetTrailGroup) {
    wetTrailGroup = new THREE.Group();
    wetTrailGroup.renderOrder = 6;
    scene.add(wetTrailGroup);
  }

  if (!wetTrailGeo) {
    wetTrailGeo = new THREE.PlaneGeometry(1, 1, 1, 1);
    wetTrailGeo.rotateX(-Math.PI / 2);
  }

  rebuildWetTrailPool();
}

function rebuildWetTrailPool() {
  /* Resizes the decal pool to wetTrailConfig.maxMarks and keeps old ones hidden. */
  if (!wetTrailGroup || !wetTrailGeo) return;

  const target = clamp(wetTrailConfig.maxMarks | 0, 0, 3000);

  while (wetTrailPool.length > target) {
    const m = wetTrailPool.pop();
    if (m) {
      wetTrailGroup.remove(m);
      if (m.material) m.material.dispose();
    }
  }

  while (wetTrailPool.length < target) {
    const tex = ensureWetTrailTex();
    const mat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(wetTrailConfig.color),
      transparent: true,
      opacity: 0.0,
      alphaMap: tex,
      depthWrite: false,
      depthTest: true
    });
    mat.polygonOffset = true;
    mat.polygonOffsetFactor = -2;
    mat.polygonOffsetUnits = -2;

    const m = new THREE.Mesh(wetTrailGeo, mat);
    m.visible = false;
    m.frustumCulled = true;
    m.userData.age = 0.0;
    m.userData.life = 0.0;
    m.userData.baseOpacity = 0.0;

    wetTrailGroup.add(m);
    wetTrailPool.push(m);
  }

  wetTrailCursor = 0;
}

function clearWetTrails() {
  /* Hides all decals immediately. */
  for (let i = 0; i < wetTrailPool.length; i++) {
    const m = wetTrailPool[i];
    if (!m) continue;
    m.visible = false;
    m.userData.age = 0.0;
    m.userData.life = 0.0;
    m.userData.baseOpacity = 0.0;
    if (m.material) m.material.opacity = 0.0;
  }
}

function spawnWetTrailMark(x, z, yaw, sx, sz, baseOpacity, life, opts) {
  /* Spawns a single fading decal at world XZ, aligned to yaw, sitting on the snow surface. */
  if (!wetTrailConfig.enabled) return;
  if (!wetTrailPool || wetTrailPool.length === 0) return;

  const m = wetTrailPool[wetTrailCursor];
  wetTrailCursor = (wetTrailCursor + 1) % wetTrailPool.length;

  const y = getSnowSurfaceY(x, z) + wetTrailConfig.lift;

  m.position.set(x, y, z);
  m.rotation.set(0, yaw, 0);
  m.scale.set(Math.max(0.01, sx), 1.0, Math.max(0.01, sz));

  m.userData.age = 0.0;
  m.userData.life = Math.max(0.05, life);
  m.userData.baseOpacity = clamp(baseOpacity, 0.0, 1.0);

  const col =
  (opts && opts.color) ||
  wetTrailConfig.color ||
  "#1a1a1a";

  const alpha =
  (opts && opts.alphaMap) ||
  ensureWetTrailTex();

  if (m.material) {
    if (m.material.alphaMap !== alpha) {
      m.material.alphaMap = alpha;
      m.material.needsUpdate = true;
    }
    m.material.color.set(col);
    m.material.opacity = m.userData.baseOpacity;
  }

  m.visible = true;
}


function updateWetTrails(dt) {
  /* Advances decal fade-outs and hides expired marks. */
  if (!wetTrailConfig.enabled) return;
  if (!(dt > 0)) return;

  for (let i = 0; i < wetTrailPool.length; i++) {
    const m = wetTrailPool[i];
    if (!m || !m.visible) continue;

    const life = m.userData.life || 0.0;
    if (!(life > 0)) {
      m.visible = false;
      continue;
    }

    m.userData.age += dt;
    const a = clamp(1.0 - (m.userData.age / life), 0.0, 1.0);

    const fade = a * a;
    if (m.material) m.material.opacity = (m.userData.baseOpacity || 0.0) * fade;

    if (a <= 0.0) {
      m.visible = false;
      if (m.material) m.material.opacity = 0.0;
    }
  }
}



function depositHeightAtWorld(x, z, amount, windX = 0, windZ = 0) {
  if (!driftHeights || amount === 0) return;

      // push deposits slightly downwind (turbulence bias)
  const drift = 0.35;
  const nx = x + windX * drift;
  const nz = z + windZ * drift;

  let u = (nx + HALF_GROUND) / GROUND_SIZE;
  let v = (nz + HALF_GROUND) / GROUND_SIZE;
  u = clamp(u, 0, 1);
  v = clamp(v, 0, 1);

  const ci = clamp((u * DRIFT_GRID) | 0, 0, DRIFT_GRID);
  const cj = clamp((v * DRIFT_GRID) | 0, 0, DRIFT_GRID);

  const maxH = Math.max(0.5, params.driftMaxHeight);
  const baseAmount = amount;

  for (const k of driftKernel) {
    const i = ci + k.dx;
    const j = cj + k.dz;
    if (i < 0 || i > DRIFT_GRID || j < 0 || j > DRIFT_GRID) continue;
    const idx = gridIndex(i, j);
    const h = driftHeights[idx];
    const shelter = clamp(1.0 - h / maxH, 0.1, 1.0);
    const delta = baseAmount * k.w * shelter;
    driftHeights[idx] = clamp(h + delta, 0, maxH);
  }
}

/**
 * Requests an immediate drift height write to geometry (and normals refresh) on the next simulation tick.
 * Used by local deformation (footprints/tracks) so marks appear immediately without lowering global intervals.
 */
function requestDriftWrite() {
  forceDriftWrite = true;
  forceDriftNormals = true;
}




/**
 * Carves a smooth circular depression into the snow surface.
 * Size is stable across driftGrid values (no "cell-sized" craters).
 * Writes into driftDeform so drifting (driftHeights) can continue evolving independently.
 */
function carveHeightAtWorld(x, z, depth) {
  if (!snowDeformConfig.enabled) return false;
  if (!driftHeights || !driftDeform) return false;
  if (!(depth > 0)) return false;

  const grid = DRIFT_GRID;
  const cell = GROUND_SIZE / grid;

  const depthMin = Math.max(0, snowDeformConfig.carveDepthMin);
  const depthMax = Math.max(depthMin + 1e-6, snowDeformConfig.carveDepthMax);
  const d = clamp(depth, depthMin, depthMax);

  let radiusWorld = snowDeformConfig.carveRadiusBase + d * snowDeformConfig.carveRadiusFromDepth;
  radiusWorld = clamp(radiusWorld, snowDeformConfig.carveRadiusMin, snowDeformConfig.carveRadiusMax);
  radiusWorld = Math.max(radiusWorld, cell * Math.max(0, snowDeformConfig.carveMinCellFrac));

  const maxCells = Math.max(1, (snowDeformConfig.carveMaxCells | 0));
  const rCells = Math.min(maxCells, Math.max(1, Math.ceil(radiusWorld / cell)));
  const r2 = radiusWorld * radiusWorld;

  const sigma = Math.max(1e-4, radiusWorld * Math.max(0.05, snowDeformConfig.carveSigmaFrac));
  const invTwoSigma2 = 1.0 / (2.0 * sigma * sigma);

  const maxCarve = Math.max(0.001, snowDeformConfig.carveMaxCarve);
  const minDeform = -maxCarve;

  let u = (x + HALF_GROUND) / GROUND_SIZE;
  let v = (z + HALF_GROUND) / GROUND_SIZE;
  u = clamp(u, 0, 1);
  v = clamp(v, 0, 1);

  const ci = clamp((u * grid) | 0, 0, grid);
  const cj = clamp((v * grid) | 0, 0, grid);

  let changed = false;

  for (let dj = -rCells; dj <= rCells; dj++) {
    const j = cj + dj;
    if (j < 0 || j > grid) continue;

    const wz = -HALF_GROUND + j * cell;
    const dz = wz - z;
    const dz2 = dz * dz;
    if (dz2 > r2) continue;

    for (let di = -rCells; di <= rCells; di++) {
      const i = ci + di;
      if (i < 0 || i > grid) continue;

      const wx = -HALF_GROUND + i * cell;
      const dx = wx - x;

      const dist2 = dx * dx + dz2;
      if (dist2 > r2) continue;

      const w = Math.exp(-dist2 * invTwoSigma2);
      if (w < 1e-4) continue;

      const idx = gridIndex(i, j);

      const baseAmount = d * w;
      const next = driftDeform[idx] - baseAmount;

      driftDeform[idx] = next < minDeform ? minDeform : next;
      changed = true;
    }
  }

  return changed;
}





const snowDeformConfig = {
  enabled: true,

  avatarFootRadius: 0.22,
  avatarStepDistance: 0.55,
  avatarDepthWalk: 0.010,
  avatarDepthRun: 0.016,

  vehicleTrackDepth: 0.050,
  vehicleHalfWidthFallback: 0.42,
  vehicleTrackSpacing: 0.70,

  carveDepthMin: 0.005,
  carveDepthMax: 0.080,

  carveRadiusBase: 0.18,
  carveRadiusFromDepth: 9.0,
  carveRadiusMin: 0.22,
  carveRadiusMax: 1.35,

  carveMinCellFrac: 0.25,
  carveMaxCells: 12,

  carveSigmaFrac: 0.55,
  carveMaxCarve: 0.18
};




const avatarFootprintState = {
  has: false,
  lastX: 0,
  lastZ: 0,
  acc: 0,
  phase: 0
};

/**
 * Stamps alternating left/right footprints into the deformation field and optionally spawns wet footprint decals.
 * Step spacing uses snowDeformConfig.avatarStepDistance; depth uses avatarDepthWalk/avatarDepthRun.
 */
function stampSnowFromAvatar(speedAbs) {
  if (!snowDeformConfig.enabled || !avatar || !driftHeights || !driftDeform) return;

  const minSpeed = 0.15;
  if (!(speedAbs >= minSpeed)) {
    avatarFootprintState.has = false;
    avatarFootprintState.acc = 0;
    return;
  }

  const x = avatar.position.x;
  const z = avatar.position.z;

  if (!avatarFootprintState.has) {
    avatarFootprintState.has = true;
    avatarFootprintState.lastX = x;
    avatarFootprintState.lastZ = z;
    avatarFootprintState.acc = 0;
    avatarFootprintState.phase = 0;
    return;
  }

  const dx = x - avatarFootprintState.lastX;
  const dz = z - avatarFootprintState.lastZ;
  const dist = Math.sqrt(dx * dx + dz * dz);

  avatarFootprintState.lastX = x;
  avatarFootprintState.lastZ = z;

  if (!(dist > 1e-6)) return;

  avatarFootprintState.acc += dist;

  const step = Math.max(0.10, snowDeformConfig.avatarStepDistance);
  const yaw = avatar.rotation.y;

  const fx = Math.sin(yaw);
  const fz = Math.cos(yaw);
  const rx = Math.sin(yaw + Math.PI * 0.5);
  const rz = Math.cos(yaw + Math.PI * 0.5);

  const runThreshold = (AVATAR_WALK_SPEED + AVATAR_RUN_SPEED) * 0.5;
  const depth = speedAbs >= runThreshold ? snowDeformConfig.avatarDepthRun : snowDeformConfig.avatarDepthWalk;

  const lateral = Math.max(0.06, snowDeformConfig.avatarFootRadius * 0.65);

  const markSize = Math.max(0.05, wetTrailConfig.avatarSize);
  const markOpacity = wetTrailConfig.opacity;
  const markLife = wetTrailConfig.life;

  const footColor = wetTrailConfig.avatarColor || wetTrailConfig.color || "#1a1a1a";
  const footAlpha = wetTrailConfig.avatarUseFootprint ? ensureWetFootTex() : ensureWetTrailTex();

  let didCarve = false;

  while (avatarFootprintState.acc >= step) {
    avatarFootprintState.acc -= step;

    const side = (avatarFootprintState.phase & 1) ? -1 : 1;
    const px = x + rx * lateral * side - fx * (step * 0.15);
    const pz = z + rz * lateral * side - fz * (step * 0.15);

    if (carveHeightAtWorld(px, pz, depth)) didCarve = true;

    spawnWetTrailMark(px, pz, yaw, markSize, markSize, markOpacity, markLife, {
      color: footColor,
      alphaMap: footAlpha
    });

    avatarFootprintState.phase++;
  }

  if (didCarve) requestDriftWrite();
}






/**
 * Stamps simple dual tracks (left/right) into the deformation field for the active vehicle.
 * Uses vehicleTrackDepth/vehicleTrackSpacing from snowDeformConfig.
 */
/**
 * Stamps simple dual tracks (left/right) into the deformation field for the active vehicle.
 * Uses vehicleTrackDepth/vehicleTrackSpacing from snowDeformConfig.
 */
function stampSnowFromVehicle(v, speedAbs, maxSpeed) {
  if (!snowDeformConfig.enabled || !v || !v.object || !v.meta || !driftHeights || !driftDeform) return;

  const ms = Math.max(1e-6, maxSpeed || 1);
  const minSpeed = Math.max(0.15, ms * 0.05);
  if (!(speedAbs >= minSpeed)) {
    vehicleDriveState.lastTrackValid = false;
    vehicleDriveState.trackAcc = 0;
    return;
  }

  const x = v.object.position.x;
  const z = v.object.position.z;

  if (!vehicleDriveState.lastTrackValid) {
    vehicleDriveState.lastTrackValid = true;
    vehicleDriveState.lastTrackX = x;
    vehicleDriveState.lastTrackZ = z;
    vehicleDriveState.trackAcc = 0;
    return;
  }

  const dx = x - vehicleDriveState.lastTrackX;
  const dz = z - vehicleDriveState.lastTrackZ;
  const dist = Math.sqrt(dx * dx + dz * dz);

  vehicleDriveState.lastTrackX = x;
  vehicleDriveState.lastTrackZ = z;

  if (!(dist > 1e-6)) return;

  vehicleDriveState.trackAcc += dist;

  const prof = (v.meta && v.meta.profile) ? v.meta.profile : {};
  const radius = Math.max(0.35, (prof.radius ?? v.radius ?? 0.9));

  const halfWidth = Math.max(
    0.22,
    (prof.trackHalfWidth != null ? prof.trackHalfWidth : (radius * 0.55)) ||
    snowDeformConfig.vehicleHalfWidthFallback
    );

  const wheelBase = Math.max(0.6, prof.wheelBase ?? (radius * 2.2));
  const fore = wheelBase * 0.35;

  const yaw = vehicleDriveState.yaw;
  const fx = Math.sin(yaw);
  const fz = Math.cos(yaw);
  const rx = Math.sin(yaw + Math.PI * 0.5);
  const rz = Math.cos(yaw + Math.PI * 0.5);

  const depthScale = clamp(speedAbs / ms, 0.25, 1.0);
  const depth = snowDeformConfig.vehicleTrackDepth * depthScale;

  const spacing = Math.max(0.15, snowDeformConfig.vehicleTrackSpacing);

  const sx = Math.max(
    0.05,
    Number.isFinite(prof.wetWidth) ? prof.wetWidth : wetTrailConfig.vehicleWidth
    );

  const sz = Math.max(
    0.05,
    Number.isFinite(prof.wetLength) ? prof.wetLength : wetTrailConfig.vehicleLength
    );

  const trailColor = wetTrailConfig.vehicleColor || wetTrailConfig.color || "#1a1a1a";
  const trailAlpha = ensureWetTrailTex();
  const trailOpts = { color: trailColor, alphaMap: trailAlpha };

  let didCarve = false;

  while (vehicleDriveState.trackAcc >= spacing) {
    vehicleDriveState.trackAcc -= spacing;

    const p1x = x - rx * halfWidth + fx * fore;
    const p1z = z - rz * halfWidth + fz * fore;
    const p2x = x - rx * halfWidth - fx * fore;
    const p2z = z - rz * halfWidth - fz * fore;

    const p3x = x + rx * halfWidth + fx * fore;
    const p3z = z + rz * halfWidth + fz * fore;
    const p4x = x + rx * halfWidth - fx * fore;
    const p4z = z + rz * halfWidth - fz * fore;

    if (carveHeightAtWorld(p1x, p1z, depth)) didCarve = true;
    if (carveHeightAtWorld(p2x, p2z, depth)) didCarve = true;
    if (carveHeightAtWorld(p3x, p3z, depth)) didCarve = true;
    if (carveHeightAtWorld(p4x, p4z, depth)) didCarve = true;

    spawnWetTrailMark(p1x, p1z, yaw, sx, sz, wetTrailConfig.opacity, wetTrailConfig.life, trailOpts);
    spawnWetTrailMark(p2x, p2z, yaw, sx, sz, wetTrailConfig.opacity, wetTrailConfig.life, trailOpts);
    spawnWetTrailMark(p3x, p3z, yaw, sx, sz, wetTrailConfig.opacity, wetTrailConfig.life, trailOpts);
    spawnWetTrailMark(p4x, p4z, yaw, sx, sz, wetTrailConfig.opacity, wetTrailConfig.life, trailOpts);
  }

  if (didCarve) requestDriftWrite();
}










function evolveDrifts(windX, windZ) {
  if (!driftHeights || !driftHeightsTmp) return;

  const diff = clamp(params.driftDiffusion, 0.0, 0.25);
  const adv = clamp(params.driftAdvection, 0.0, 0.30);
  if (diff <= 0 && adv <= 0) return;

  const wx = clamp(windX, -1, 1);
  const wz = clamp(windZ, -1, 1);

  for (let j = 0; j <= DRIFT_GRID; j++) {
    const jb = j > 0 ? j - 1 : j;
    const jf = j < DRIFT_GRID ? j + 1 : j;
    for (let i = 0; i <= DRIFT_GRID; i++) {
      const ib = i > 0 ? i - 1 : i;
      const ifw = i < DRIFT_GRID ? i + 1 : i;

      const idx = gridIndex(i, j);
      const h = driftHeights[idx];

      const hL = driftHeights[gridIndex(ib, j)];
      const hR = driftHeights[gridIndex(ifw, j)];
      const hD = driftHeights[gridIndex(i, jb)];
      const hU = driftHeights[gridIndex(i, jf)];
      const avg = (hL + hR + hD + hU) * 0.25;

          // simple upwind sample
      const upI = clamp(i - Math.round(wx), 0, DRIFT_GRID);
      const upJ = clamp(j - Math.round(wz), 0, DRIFT_GRID);
      const upH = driftHeights[gridIndex(upI, upJ)];

      let nh = h + diff * (avg - h) + adv * (upH - h);
      nh = Math.max(0, nh * 0.99982);
      driftHeightsTmp[idx] = nh;
    }
  }

  const tmp = driftHeights;
  driftHeights = driftHeightsTmp;
  driftHeightsTmp = tmp;
}

function shapeDriftsAroundObstacles(windX, windZ) {
  if (!driftHeights || !colliderBounds.length) return;
  const wx = windX;
  const wz = windZ;
  const len = Math.sqrt(wx * wx + wz * wz);
  if (len < 1e-4) return;

  const nx = wx / len;
  const nz = wz / len;

  for (const cb of colliderBounds) {
    const ox = cb.center.x;
    const oz = cb.center.z;

    const scourX = ox - nx * (cb.radius * 1.20);
    const scourZ = oz - nz * (cb.radius * 1.20);

    const driftX = ox + nx * (cb.radius * 1.55);
    const driftZ = oz + nz * (cb.radius * 1.55);

    depositHeightAtWorld(scourX, scourZ, -0.0016, 0, 0);
    depositHeightAtWorld(driftX, driftZ, 0.0030, wx, wz);
  }
}



/* Removes the snow surface mesh and clears drift buffers so snow can be fully disabled. */

/* Removes the snow surface mesh and clears drift buffers so snow can be fully disabled. */
function disposeSnowSurface() {
  if (snowSurface) {
    scene.remove(snowSurface);
    snowSurface.geometry.dispose();
    snowSurface.material.dispose();
    snowSurface = null;
  } else if (driftGeo) {
    driftGeo.dispose();
  }

  driftGeo = null;
  driftPosAttr = null;
  driftPosArray = null;
  driftColorAttr = null;
  driftColorArray = null;

  driftHeights = null;
  driftHeightsTmp = null;
  driftDeform = null;
}



function buildSnowSurface() {
  disposeSnowSurface();
  if (!params.snowEnabled) return;

  DRIFT_GRID = clamp(params.driftGrid | 0, 32, 256);
  DRIFT_STRIDE = DRIFT_GRID + 1;
  DRIFT_VERTS = DRIFT_STRIDE * DRIFT_STRIDE;

  driftHeights = new Float32Array(DRIFT_VERTS);
  driftHeightsTmp = new Float32Array(DRIFT_VERTS);
  driftDeform = new Float32Array(DRIFT_VERTS);

  driftGeo = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE, DRIFT_GRID, DRIFT_GRID);
  driftGeo.rotateX(-Math.PI / 2);

  const colors = new Float32Array(DRIFT_VERTS * 3);
  colors.fill(1);
  driftGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  const mat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    vertexColors: true,
    roughness: 0.995,
    metalness: 0.0,
    polygonOffset: true,
    polygonOffsetFactor: -2,
    polygonOffsetUnits: -2
  });

  snowSurface = new THREE.Mesh(driftGeo, mat);
  snowSurface.position.y = 0.02;
  snowSurface.receiveShadow = true;
  scene.add(snowSurface);

  driftPosAttr = driftGeo.attributes.position;
  driftPosArray = driftPosAttr.array;

  driftColorAttr = driftGeo.attributes.color;
  driftColorArray = driftColorAttr.array;

  initSnowCover();
  applyHeightsToGeometry();
  driftGeo.computeVertexNormals();
  driftGeo.attributes.normal.needsUpdate = true;
}




    // Clouds Shaders
const CLOUD_VERTEX_SHADER = /* glsl */ `
  attribute float aLayer;
  uniform float uRadius;
  uniform float uHeightBase;
  uniform float uHeightRange;

  varying vec3 vWorldPos;
  varying float vLayer;

  void main() {
    vec3 pos = position;

    float layerT = aLayer;
    float ang = layerT * 6.2831853;
    float h = uHeightBase + (layerT - 0.5) * uHeightRange;

    pos.x += cos(ang) * uRadius * 0.4;
    pos.z += sin(ang) * uRadius * 0.4;
    pos.y = h;

    vec4 world = modelMatrix * vec4(pos, 1.0);
    vWorldPos = world.xyz;
    vLayer = layerT;

    gl_Position = projectionMatrix * viewMatrix * world;
  }
`;





const CLOUD_FRAGMENT_SHADER = /* glsl */ `
  precision highp float;

  varying vec3 vWorldPos;
  varying float vLayer;

  uniform float uTime;
  uniform float uRadius;
  uniform float uHeightBase;
  uniform float uHeightRange;
  uniform float uDensity;
  uniform float uSoftness;
  uniform float uSpeed;
  uniform vec3 uCloudColor;
  uniform vec3 uSkyColor;
  // NEW: overall opacity mul, driven from params.cloudOpacity
  uniform float uOpacity;

  float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
  }

  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
  }

  float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    float f = 1.0;
    for (int i = 0; i < 4; i++) {
      v += a * noise(p * f);
      f *= 2.0;
      a *= 0.5;
    }
    return v;
  }

  void main() {
    vec2 uv = vWorldPos.xz / uRadius;

    float scroll = uTime * uSpeed;
    vec2 p = uv * 1.2 + vec2(scroll, vLayer * 0.27);

    float n = fbm(p);

    // center of the cloud band in noise space
    float center = 1.0 - uDensity;

    // softness controls *band width* around that center
    float halfWidth = max(0.001, uSoftness * 0.5);

    // alpha = 0 below center - halfWidth
    // alpha = 1 above center + halfWidth
    // smooth fade in between → nice white → transparent gradient
    float alpha = smoothstep(center - halfWidth, center + halfWidth, n);

    float dist = length(vWorldPos.xz) / uRadius;
    float edgeFade = smoothstep(1.0, 0.6, dist);
    alpha *= edgeFade;

    float hFade = smoothstep(0.0, 0.4, vLayer) * smoothstep(1.0, 0.5, vLayer);
    alpha *= hFade;

    // NEW: use uniform instead of hard-coded 1.35
    alpha = clamp(alpha * uOpacity, 0.0, 1.0);

    if (alpha < 0.02) discard;

    // color is still a blend between sky and cloud colors
    vec3 rgb = mix(uSkyColor, uCloudColor, alpha);
    gl_FragColor = vec4(rgb, alpha);
  }
`;




function setupClouds() {
  if (!params.cloudEnabled) return;

  const sliceCount = Math.max(1, params.cloudSliceCount | 0);

  const geo = new THREE.PlaneGeometry(
    params.cloudRadius * 2.0,
    params.cloudRadius * 1.4,
    1,
    1
    );
  geo.rotateX(-Math.PI / 2);

  const layerAttr = new Float32Array(sliceCount);
  const denom = sliceCount > 1 ? sliceCount - 1 : 1;
  for (let i = 0; i < sliceCount; i++) {
    layerAttr[i] = i / denom;
  }
  geo.setAttribute(
    "aLayer",
    new THREE.InstancedBufferAttribute(layerAttr, 1)
    );

  cloudMaterial = new THREE.ShaderMaterial({
    vertexShader: CLOUD_VERTEX_SHADER,
    fragmentShader: CLOUD_FRAGMENT_SHADER,
    transparent: true,
    depthWrite: false,
    depthTest: true,
    side: THREE.DoubleSide
  });

  cloudMaterial.uniforms = {
    uTime: { value: 0 },
    uRadius: { value: params.cloudRadius },
    uHeightBase: { value: params.cloudHeightBase },
    uHeightRange: { value: params.cloudHeightRange },
    uDensity: { value: params.cloudDensity },
    uSoftness: { value: params.cloudSoftness },
    uSpeed: { value: params.cloudSpeed },
    // NEW: driven from params so presets/files carry it
    uCloudColor: { value: new THREE.Color(params.cloudColor || "#f5f7ff") },
    uSkyColor: { value: new THREE.Color(params.cloudSkyColor || "#0a1220") },
    uOpacity: { value: params.cloudOpacity }
  };

  cloudLayer = new THREE.InstancedMesh(geo, cloudMaterial, sliceCount);
  // draw clouds after snow points (2) and stuck decals (3)
  cloudLayer.renderOrder = 4;

  const dummy = new THREE.Object3D();
  for (let i = 0; i < sliceCount; i++) {
    dummy.position.set(0, 0, 0);
    dummy.rotation.set(0, 0, 0);
    dummy.scale.set(1, 1, 1);
    dummy.updateMatrix();
    cloudLayer.setMatrixAt(i, dummy.matrix);
  }

  cloudLayer.instanceMatrix.needsUpdate = true;
  scene.add(cloudLayer);
}






function updateClouds(dt) {
  if (!cloudMaterial) return;
  cloudMaterial.uniforms.uTime.value += dt;
}

function applyCloudParamsToUniforms() {
  if (!cloudMaterial) return;
  const u = cloudMaterial.uniforms;

  u.uRadius.value = params.cloudRadius;
  u.uHeightBase.value = params.cloudHeightBase;
  u.uHeightRange.value = params.cloudHeightRange;
  u.uDensity.value = params.cloudDensity;
  u.uSoftness.value = params.cloudSoftness;
  u.uSpeed.value = params.cloudSpeed;

  // NEW:
  if (params.cloudColor) {
    u.uCloudColor.value.set(params.cloudColor);
  }
  if (params.cloudSkyColor) {
    u.uSkyColor.value.set(params.cloudSkyColor);
  }
  u.uOpacity.value = params.cloudOpacity;
}


function disposeClouds() {
  if (cloudLayer) {
    scene.remove(cloudLayer);
    cloudLayer.geometry.dispose();
    cloudLayer.material.dispose();
    cloudLayer = null;
    cloudMaterial = null;
  }
}

function rebuildClouds() {
  disposeClouds();
  if (!params.cloudEnabled) return;
  setupClouds();
  applyCloudParamsToUniforms();
}







    // -------------------------------------------------------------------------
    // Visual flakes (GPU point sprites + gust uniforms)
    // -------------------------------------------------------------------------

/* Disposes the visual snow point-sprite system and releases GPU resources. */
function disposeSnowField() {
  if (snowPoints) {
    scene.remove(snowPoints);
    snowPoints = null;
  }
  if (snowGeo) {
    snowGeo.dispose();
    snowGeo = null;
  }
  if (snowMat) {
    snowMat.dispose();
    snowMat = null;
  }
}

function buildSnowField() {
  disposeSnowField();
  if (!params.snowEnabled) return;

  const count = clamp(params.visualCount | 0, 20000, 600000);
  const pos = new Float32Array(count * 3);
  const seeds = new Float32Array(count);

  for (let i = 0; i < count; i++) {
    const p = i * 3;
    pos[p + 0] = (Math.random() * 2 - 1) * visualBounds.x;
    pos[p + 1] = visualBounds.yMin + Math.random() * (visualBounds.yMax - visualBounds.yMin);
    pos[p + 2] = (Math.random() * 2 - 1) * visualBounds.z;
    seeds[i] = Math.random();
  }

  snowGeo = new THREE.BufferGeometry();
  snowGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  snowGeo.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));

  snowMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    uniforms: {
      uTime: { value: 0 },
      uTex: { value: snowTex },
      uWind: { value: new THREE.Vector2(0, 0) },
      uBounds: { value: new THREE.Vector2(visualBounds.x, visualBounds.z) },
      uYTop: { value: visualBounds.yMax },
      uYBot: { value: visualBounds.yMin },
      uGroundY: { value: 0.06 },
      uFallSpeed: { value: params.fallSpeed },
      uFallJitter: { value: params.fallJitter },
      uFlakeSize: { value: params.flakeSize },
      uFlakeSizeJitter: { value: params.flakeSizeJitter },
      uGustPosRad: { value: gustPosRad },
      uGustParams: { value: gustParams }
    },
    vertexShader: `
          uniform float uTime;
          uniform vec2 uWind;
          uniform vec2 uBounds;
          uniform float uYTop;
          uniform float uYBot;
          uniform float uGroundY;

          uniform float uFallSpeed;
          uniform float uFallJitter;
          uniform float uFlakeSize;
          uniform float uFlakeSizeJitter;

          uniform float uGustPosRad[${GUST_MAX * 3}];
          uniform float uGustParams[${GUST_MAX * 3}];

          attribute float aSeed;

          varying float vAlpha;

          float wrapCoord(float x, float halfSpan) {
            float span = halfSpan * 2.0;
            return -halfSpan + mod(x + halfSpan + span * 1000.0, span);
          }

          float jitter01(float x) {
            return fract(sin(x) * 43758.5453123);
          }

          void main() {
            vec3 p = position;

            float spanY = (uYTop - uYBot);

            float jf = jitter01(aSeed * 91.7 + 3.1);
            float fallMul = mix(1.0 - uFallJitter, 1.0 + uFallJitter, jf);
            float speed = max(0.001, uFallSpeed) * fallMul;

            float phase = aSeed * 37.0;
            float y = uYTop - mod(uTime * speed + phase, spanY);

            float nearGround = clamp(1.0 - (y - uYBot) / 6.0, 0.0, 1.0);

            float flutter =
              sin(uTime * 1.15 + aSeed * 83.0) * 0.10 +
              sin(uTime * 1.85 + aSeed * 19.0) * 0.05;

            vec2 drift =
              uWind * (0.22 + 0.16 * sin(aSeed * 11.0)) +
              vec2(flutter * 0.18,
                   cos(uTime * 0.9 + aSeed * 41.0) * 0.03);

            vec2 gustVec = vec2(0.0);
            float lift = 0.0;

            for (int gi = 0; gi < ${GUST_MAX}; gi++) {
              float gx = uGustPosRad[gi * 3 + 0];
              float gz = uGustPosRad[gi * 3 + 1];
              float gr = uGustPosRad[gi * 3 + 2];

              float gs  = uGustParams[gi * 3 + 0];
              float gsw = uGustParams[gi * 3 + 1];
              float gup = uGustParams[gi * 3 + 2];

              vec2 d = vec2(p.x - gx, p.z - gz);
              float r2 = dot(d, d);
              float rr = sqrt(max(r2, 1e-6));
              if (rr > gr) continue;

              float radial = 1.0 - rr / gr;
              float k = radial * radial * nearGround * gs;

              vec2 n = d / rr;
              vec2 t = vec2(-n.y, n.x);

              gustVec += t * (gsw * k) + (-n) * (0.12 * k);
              lift += gup * k * (radial * radial);
            }

            float gustLen = length(gustVec);
            float gustMax = 3.0;
            if (gustLen > gustMax) {
              gustVec *= gustMax / max(gustLen, 1e-5);
            }
            lift = clamp(lift, -3.0, 3.0);

            y += lift * 0.12;

            float x = p.x + drift.x * uTime + gustVec.x;
            float z = p.z + drift.y * uTime + gustVec.y;

            x = wrapCoord(x, uBounds.x);
            z = wrapCoord(z, uBounds.y);

            vec3 worldPos = vec3(x, y, z);
            vec4 mvPosition = modelViewMatrix * vec4(worldPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float js = jitter01(aSeed * 13.9 + 7.7);
            float sizeMul = mix(1.0 - uFlakeSizeJitter, 1.0 + uFlakeSizeJitter, js);
            float size = max(0.05, uFlakeSize) * sizeMul;

            gl_PointSize = size * (300.0 / -mvPosition.z);

            float groundFade = clamp((y - uGroundY) / 0.9, 0.0, 1.0);
            vAlpha = (mix(0.55, 0.95, fract(aSeed * 4.77))
                     * (0.65 + 0.35 * nearGround)) * groundFade;
          }
      `,

      fragmentShader: `
          uniform sampler2D uTex;
          varying float vAlpha;

          void main() {
            vec4 tex = texture2D(uTex, gl_PointCoord);
            float a = tex.a * vAlpha * 0.65;
            if (a < 0.01) discard;
            gl_FragColor = vec4(1.0, 1.0, 1.0, a);
          }
        `
      });

snowPoints = new THREE.Points(snowGeo, snowMat);
snowPoints.frustumCulled = false;
snowPoints.renderOrder = 2;
scene.add(snowPoints);
}


    // -------------------------------------------------------------------------
    // Decals (sticking snow)
    // -------------------------------------------------------------------------

/* Disposes the sticking snow decal instancing system. */
function disposeStuckSystem() {
  if (stuck) {
    scene.remove(stuck);
    stuck.geometry.dispose();
    stuck.material.dispose();
    stuck = null;
  }
  stuckGeo = null;
  stuckMat = null;
  stuckCount = 0;
  stuckWrite = 0;
}

function buildStuckSystem() {
  disposeStuckSystem();
  if (!params.snowEnabled) return;

  const max = Math.max(1000, params.stuckMax | 0);
  stuckGeo = new THREE.CircleGeometry(Math.max(0.05, params.decalSize), 20);
  stuckMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.97,
    metalness: 0.0,
    map: snowTex,
    transparent: true,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1,
    emissive: new THREE.Color(0x202020),
    emissiveIntensity: 0.65
  });

  stuck = new THREE.InstancedMesh(stuckGeo, stuckMat, max);
  stuck.frustumCulled = false;
  stuck.renderOrder = 3;
  scene.add(stuck);

  stuckCount = 0;
  stuckWrite = 0;
  stuck.count = 0;
  stuck.instanceMatrix.needsUpdate = true;
}

function addStuckSnow(point, normal) {
  if (!stuck) return;
  if (!Number.isFinite(point.x + point.y + point.z)) return;

  tmpNormal.set(0, 1, 0);
  if (normal && Number.isFinite(normal.x + normal.y + normal.z)) {
    tmpNormal.copy(normal);
  }

  const len = tmpNormal.length();
  if (len < 1e-6) tmpNormal.set(0, 1, 0);
  else tmpNormal.multiplyScalar(1.0 / len);

  const max = stuck.instanceMatrix.count;
  const idx = stuckWrite % max;

  const up01 = clamp((tmpNormal.y + 1.0) * 0.5, 0.0, 1.0);

  const lift = 0.008 + Math.random() * 0.012;
  tmpP.copy(point).addScaledVector(tmpNormal, lift);

  const baseSize = Math.max(0.05, params.decalSize);
  const slopeMul = 0.25 + 0.75 * up01;
  const base = baseSize * (0.55 + Math.random() * 1.05) * slopeMul;

  const anis = 0.70 + Math.random() * 0.85;
  const steep = 1.0 - up01;
  const sx = base * (1.0 - 0.15 * steep);
  const sy = base * anis * (1.0 + 0.35 * steep);
  tmpS.set(sx, sy, 1);

  tmpQ.setFromUnitVectors(zAxis, tmpNormal);
  tmpQ.multiply(new THREE.Quaternion().setFromAxisAngle(tmpNormal, Math.random() * Math.PI * 2));

  tmpM.compose(tmpP, tmpQ, tmpS);
  stuck.setMatrixAt(idx, tmpM);

  stuckWrite++;
  stuckCount = Math.min(stuckCount + 1, max);
  stuck.count = stuckCount;
  stuck.instanceMatrix.needsUpdate = true;
}

    // -------------------------------------------------------------------------
    // Settlers (CPU flakes building drifts + decals)
    // -------------------------------------------------------------------------

/* Clears the CPU snow-settler buffers so drift/deposit simulation can be fully disabled. */
function disposeSettlers() {
  SETTLER_COUNT = 0;
  settlerPos = null;
  settlerPrev = null;
  settlerVel = null;
  depositTokens = 0;
}

function buildSettlers() {
  disposeSettlers();
  if (!params.snowEnabled) return;

  SETTLER_COUNT = clamp(params.settlerCount | 0, 1000, 300000);
  settlerPos = new Float32Array(SETTLER_COUNT * 3);
  settlerPrev = new Float32Array(SETTLER_COUNT * 3);
  settlerVel = new Float32Array(SETTLER_COUNT * 3);
  for (let i = 0; i < SETTLER_COUNT; i++) respawnSettler(i);
    depositTokens = 0;
}

function respawnSettler(i) {
  const p = i * 3;
  const x = (Math.random() * 2 - 1) * settleBounds.x;
  const y = settleBounds.yMax * (0.72 + Math.random() * 0.28);
  const z = (Math.random() * 2 - 1) * settleBounds.z;

  settlerPos[p + 0] = x;
  settlerPos[p + 1] = y;
  settlerPos[p + 2] = z;

  settlerPrev[p + 0] = x;
  settlerPrev[p + 1] = y;
  settlerPrev[p + 2] = z;

  settlerVel[p + 0] = (Math.random() * 2 - 1) * 0.02;
  settlerVel[p + 1] = -(0.35 + Math.random() * 0.35);
  settlerVel[p + 2] = (Math.random() * 2 - 1) * 0.02;
}









/**
 * Builds simple sphere bounds for collision broadphase.
 * - Meshes: uses geometry.boundingSphere (fast).
 * - Non-mesh roots (e.g., GLTF instance roots): uses Box3.setFromObject once (built-time only).
 * - Forest cone trees: uses cone base radius in XZ to avoid oversized bounding-sphere radii.
 */
function buildColliderBounds(objs) {
  const out = [];

  const box = new THREE.Box3();
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();

  for (const obj of objs) {
    if (!obj) continue;

    obj.updateWorldMatrix(true, false);

    if (obj.isMesh && obj.geometry) {
      if (!obj.geometry.boundingSphere) obj.geometry.computeBoundingSphere();
      const bs = obj.geometry.boundingSphere;
      if (!bs) continue;

      boundCenter.copy(bs.center);
      obj.localToWorld(boundCenter);

      tmpS.set(1, 1, 1);
      obj.getWorldScale(tmpS);

      const sx = Math.abs(tmpS.x);
      const sy = Math.abs(tmpS.y);
      const sz = Math.abs(tmpS.z);

      const maxS = Math.max(sx, sy, sz);
      const maxXZ = Math.max(sx, sz);

      let radius;

      if (
        obj.__isForestTree &&
        obj.geometry &&
        obj.geometry.parameters &&
        Number.isFinite(obj.geometry.parameters.radius)
        ) {
        radius = obj.geometry.parameters.radius * maxXZ;
    } else {
      radius = bs.radius * (Number.isFinite(maxS) ? maxS : 1);
    }

    out.push({
      obj,
      center: boundCenter.clone(),
      radius: Number.isFinite(radius) ? radius : bs.radius
    });

    continue;
  }

  box.setFromObject(obj);
  if (!Number.isFinite(box.min.x) || !Number.isFinite(box.max.x)) continue;

  box.getCenter(center);
  box.getSize(size);

  const radius = 0.5 * Math.sqrt(
    size.x * size.x +
    size.y * size.y +
    size.z * size.z
    );

  out.push({
    obj,
    center: center.clone(),
    radius: Number.isFinite(radius) ? radius : 0.0
  });
}

return out;
}





const gustVec = new THREE.Vector3();

function updateSettlers(dt, baseWindX, baseWindZ) {
  if (!settlerPos || dt <= 0) return;

  depositTokens += params.groundDepositBudget * dt;
  let depositsRemaining = Math.max(0, Math.floor(depositTokens));
  if (depositsRemaining > 0) {
    depositTokens -= depositsRemaining;
  }

  const depositUnit = params.depositUnit;
  const objectDepositAmount = params.objectDeposit;
  const maxObjectTests = clamp(params.objectTestsPerFrame | 0, 0, 20000);
  let objectTests = 0;

  const gravity = 1.5;

  for (let i = 0; i < SETTLER_COUNT; i++) {
    const p = i * 3;

    const px = settlerPos[p + 0];
    const py = settlerPos[p + 1];
    const pz = settlerPos[p + 2];

    let vx = settlerVel[p + 0];
    let vy = settlerVel[p + 1];
    let vz = settlerVel[p + 2];

    settlerPrev[p + 0] = px;
    settlerPrev[p + 1] = py;
    settlerPrev[p + 2] = pz;

        // base wobble
    vx += (Math.random() * 2 - 1) * 0.25 * dt;
    vz += (Math.random() * 2 - 1) * 0.25 * dt;

        // global wind
    vx += baseWindX * dt * 0.5;
    vz += baseWindZ * dt * 0.5;

        // gust field (local turbulence + updraft)
    const snowY = sampleSnowHeight(px, pz);
    gustWindAt(px, pz, py - snowY, gustVec);
    vx += gustVec.x * dt;
    vy += gustVec.y * dt;
    vz += gustVec.z * dt;

    vy -= gravity * dt;

    let nx = px + vx * dt;
    let ny = py + vy * dt;
    let nz = pz + vz * dt;

        // wrap in XZ
    if (nx < -settleBounds.x) nx += settleBounds.x * 2;
    if (nx > settleBounds.x) nx -= settleBounds.x * 2;
    if (nz < -settleBounds.z) nz += settleBounds.z * 2;
    if (nz > settleBounds.z) nz -= settleBounds.z * 2;

    const groundY = sampleSnowHeight(nx, nz);

        // Hit ground -> deposit and respawn
    if (ny <= groundY + 0.02) {
      if (depositsRemaining > 0 && depositUnit > 0) {
        depositHeightAtWorld(nx, nz, depositUnit, baseWindX, baseWindZ);
        depositsRemaining--;
      }
      respawnSettler(i);
      continue;
    }

    settlerPos[p + 0] = nx;
    settlerPos[p + 1] = ny;
    settlerPos[p + 2] = nz;

    settlerVel[p + 0] = vx;
    settlerVel[p + 1] = vy;
    settlerVel[p + 2] = vz;




    // Object collisions (trees, rocks, cube)
    if (!colliderBounds.length || objectTests >= maxObjectTests) continue;

    const prevX = settlerPrev[p + 0];
    const prevY = settlerPrev[p + 1];
    const prevZ = settlerPrev[p + 2];

    // segment from previous to current position
    segDelta.set(nx - prevX, ny - prevY, nz - prevZ);
    const segLen = segDelta.length();
    if (segLen < 1e-4) continue;
    segDir.copy(segDelta).multiplyScalar(1.0 / segLen);

    hitFrom.set(prevX, prevY, prevZ);
    raycaster.set(hitFrom, segDir);
    raycaster.far = segLen;

    let hitSomething = false;

    for (const cb of colliderBounds) {
      if (objectTests >= maxObjectTests) break;

      // looser bounding-sphere cull so more flakes can hit
      const dx = cb.center.x - nx;
      const dy = cb.center.y - ny;
      const dz = cb.center.z - nz;
      const dist2 = dx * dx + dy * dy + dz * dz;
      const extraRadius = 1.5;
      const r = cb.radius + extraRadius;
      if (dist2 > r * r) continue;

      const intersections = raycaster.intersectObject(cb.obj, false);
      objectTests++;
      if (!intersections.length) continue;

      const hit = intersections[0];

      tmpNormal.set(0, 1, 0);
      if (hit.face) {
        tmpNormal.copy(hit.face.normal);
        tmpMatrix3.getNormalMatrix(hit.object.matrixWorld);
        tmpNormal.applyMatrix3(tmpMatrix3).normalize();
      }

      // more sticking: many decals per hit, scaled by objectDeposit
      const baseBurst = Math.floor(objectDepositAmount * 900); // 0.02 -> ~18
      const burst = clamp(baseBurst, 6, 40);

      for (let b = 0; b < burst; b++) {
        // jitter along normal
        const jitterN = (Math.random() - 0.5) * 0.05;

        // small tangent jitter so they spread over the surface
        const jitterT = 0.08;
        tmpP.copy(hit.point);
        tmpP.addScaledVector(tmpNormal, jitterN);

        tmpMatrix.makeRotationAxis(tmpNormal, Math.random() * Math.PI * 2.0);
        tmpDir.set(1, 0, 0).applyMatrix4(tmpMatrix);
        tmpP.addScaledVector(tmpDir, (Math.random() - 0.5) * jitterT);

        addStuckSnow(tmpP, tmpNormal);
      }

      if (objectDepositAmount > 0 && depositsRemaining > 0) {
        depositHeightAtWorld(
          hit.point.x,
          hit.point.z,
          objectDepositAmount,
          baseWindX,
          baseWindZ
          );
        depositsRemaining--;
      }

      respawnSettler(i);
      hitSomething = true;
      break;
    }

    if (hitSomething) continue;


  }


      depositTokens += depositsRemaining; // put back unused
    }


    // -------------------------------------------------------------------------
    // Camera idle auto-rotate (desktop only, not in XR)
    // -------------------------------------------------------------------------
    const AUTO_ROTATE_IDLE_SECONDS = 1.5;   // how long to wait
    const AUTO_ROTATE_SPEED = 0.35;        // OrbitControls autoRotateSpeed
    let lastInteractionTime = performance.now() * 0.001; // seconds
    let autoRotateEnabled = true;

    function markUserInteraction() {
      lastInteractionTime = performance.now() * 0.001;
      if (controls) {
        // disable auto-rotate immediately when the user touches the controls
        controls.autoRotate = false;
      }
    }







    // -------------------------------------------------------------------------
    // Scene / world setup
    // -------------------------------------------------------------------------


    /* Normalizes shadow type strings to a supported set. */
    function sanitizeShadowType(v) {
      const s = String(v || "").trim();
      if (s === "PCFSoft" || s === "PCF" || s === "Basic") return s;
      return "PCFSoft";
    }

    /* Snaps shadow map size to a supported power-of-two set. */
    function sanitizeShadowMapSize(v) {
      const n = (v | 0) || 0;
      const allowed = [256, 512, 1024, 2048, 4096];
      let best = allowed[0];
      let bestD = Math.abs(n - best);
      for (let i = 1; i < allowed.length; i++) {
        const d = Math.abs(n - allowed[i]);
        if (d < bestD) {
          bestD = d;
          best = allowed[i];
        }
      }
      return best;
    }

    /* Applies shadow performance settings to renderer and main directional light. */
    function applyShadowSettingsFromParams(force = false) {
      if (!renderer || !dirLight) return;

      const enabled = !!params.shadowsEnabled;
      const autoUpdate = !!params.shadowsAutoUpdate;
      const typeKey = sanitizeShadowType(params.shadowType);
      const mapSize = sanitizeShadowMapSize(params.shadowMapSize | 0);

      if (
        !force &&
        shadowApplied.enabled === enabled &&
        shadowApplied.autoUpdate === autoUpdate &&
        shadowApplied.typeKey === typeKey &&
        shadowApplied.mapSize === mapSize
        ) {
        return;
    }

    shadowApplied.enabled = enabled;
    shadowApplied.autoUpdate = autoUpdate;
    shadowApplied.typeKey = typeKey;
    shadowApplied.mapSize = mapSize;

    renderer.shadowMap.enabled = enabled;
    renderer.shadowMap.autoUpdate = enabled && autoUpdate;
    renderer.shadowMap.needsUpdate = true;

    if (typeKey === "Basic") renderer.shadowMap.type = THREE.BasicShadowMap;
    else if (typeKey === "PCF") renderer.shadowMap.type = THREE.PCFShadowMap;
    else renderer.shadowMap.type = THREE.PCFSoftShadowMap;

    dirLight.castShadow = enabled;

    if (!enabled) {
      if (dirLight.shadow && dirLight.shadow.map) {
        dirLight.shadow.map.dispose();
        dirLight.shadow.map = null;
      }
      return;
    }

    const ms = dirLight.shadow.mapSize;
    if (ms.x !== mapSize || ms.y !== mapSize) {
      ms.set(mapSize, mapSize);

      if (dirLight.shadow.map) {
        dirLight.shadow.map.dispose();
        dirLight.shadow.map = null;
      }

      dirLight.shadow.needsUpdate = true;
      renderer.shadowMap.needsUpdate = true;
    }
  }





  function setupScene() {

    const container = document.getElementById("app");

    scene = new THREE.Scene();
    updateFogFromParams();

    camera = new THREE.PerspectiveCamera(
      60,
      window.innerWidth / window.innerHeight,
      0.1,
      params.fogFar
      );
    camera.position.set(-2, 7, -10);


    renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.xr.enabled = true; // WebXR ON

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, params.pixelRatio));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      //renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      container.appendChild(renderer.domElement);

      // temp to debug vehicles
      installVehicleDebugBridge(renderer.domElement);




      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 0.3;
      controls.maxDistance = 30;
      controls.target.set(0, 0.5, 0);

      // If your ground is at y = 0:
      const groundY = 0;
      const margin = 0.2; // “always slightly above”

      // Keep the orbit in the upper hemisphere (above the ground)
      controls.maxPolarAngle = Math.PI / 2 - 0.001; // never go below horizon

      // Optional: keep the orbit from going perfectly top-down / perfectly flat
      controls.minPolarAngle = 0.05;

      // Optional: keep target a bit above the surface (helps a lot)
      // controls.target.y = groundY + margin;

      // Auto-rotate is controlled per-frame based on idle time
      controls.autoRotate = false;
      controls.autoRotateSpeed = AUTO_ROTATE_SPEED;

      // Any pointer/touch/wheel interaction on the canvas resets idle timer
      const orbitInteractionEvents = [
        "pointerdown",
        "pointermove",
        "wheel",
        "touchstart",
        "touchmove"
      ];

      for (const ev of orbitInteractionEvents) {
        renderer.domElement.addEventListener(ev, markUserInteraction, {
          passive: true
        });
      }

      controls.update();

      // TransformControls setup block
      transformControls = new TransformControls(camera, renderer.domElement);
      transformControls.setSpace("world");
      transformControls.setMode("translate");

      transformControlsHelper = transformControls.getHelper();
      transformControlsHelper.visible = false;
      scene.add(transformControlsHelper);

      transformControls.addEventListener("dragging-changed", (event) => {
        if (controls) controls.enabled = !event.value;
        markUserInteraction();

        if (event.value) {
          if (worldEditState.enabled && worldEditState.selected && !worldEditHistory.applying && !worldEditHistory.dragPushed) {
            pushWorldEditUndoSnapshot();
            worldEditHistory.dragPushed = true;
          }
          return;
        }

        worldEditHistory.dragPushed = false;

        if (worldEditState.enabled && worldEditState.selected) {
          const found = findWorldEditConfigForRoot(worldEditState.selected);
          if (found && found.instCfg) {
            syncInstanceTransformToInstCfg(worldEditState.selected, found.instCfg);
          }
        }

        commitWorldEditTransform();
      });

      renderer.domElement.addEventListener("pointerdown", (event) => {
        onWorldEditPointerDown(event);
      });



      // WebXR “Enter VR” button (Quest 3 etc.)
      // Hides the non-actionable “WebXR NOT Available” UI on phone browsers while keeping it on XR browsers (Quest/Pico/etc.).
      const sessionInit = {
        optionalFeatures: ["local-floor", "bounded-floor"]
      };

      const hideVrButtonOnPhone = (() => {
        const coarse = !!(window.matchMedia && window.matchMedia("(pointer: coarse)").matches);
        if (!coarse) return false;

        const ua = navigator.userAgent || "";
        const isXrBrowser = /OculusBrowser|Quest|PicoBrowser|ViveBrowser/i.test(ua);

        return !isXrBrowser;
      })();

      if (!hideVrButtonOnPhone) {
        const vrButton = VRButton.createButton(renderer, sessionInit);
        document.body.appendChild(vrButton);
      }


      // Disable desktop OrbitControls while in XR so they don't fight head pose
      renderer.xr.addEventListener("sessionstart", () => {
        if (controls) controls.enabled = false;
      });
      renderer.xr.addEventListener("sessionend", () => {
        if (controls) controls.enabled = true;
      });


      // Enhanced Lights
      // Lights (with better control + shadow quality)
      hemiLight = new THREE.HemisphereLight(0xdce7ff, 0x0b0f18, 1.0);
      scene.add(hemiLight);

      dirLight = new THREE.DirectionalLight(0xffffff, 1.35);
      dirLight.position.set(8, 14, 6);

      // Shadow quality defaults (final enable/type/size controlled by params)
      dirLight.castShadow = true;

      // Shadow map size is applied by applyShadowSettingsFromParams (params.shadowMapSize)
      const shadowSize = 1024;
      dirLight.shadow.mapSize.set(shadowSize, shadowSize);

      // Tighten shadow camera frustum (reduces banding/striping)
      dirLight.shadow.camera.left = -18;
      dirLight.shadow.camera.right = 18;
      dirLight.shadow.camera.top = 18;
      dirLight.shadow.camera.bottom = -18;
      dirLight.shadow.camera.near = 2;
      dirLight.shadow.camera.far = 60;

      // Bias tuning (reduce acne / stripe artifacts)
      dirLight.shadow.normalBias = 0.03; // try 0.01–0.08
      dirLight.shadow.bias = -0.00015;   // try -0.00005 to -0.0003

      scene.add(dirLight);

      // Renderer shadow settings (performance tuning via params)
      applyShadowSettingsFromParams(true);



      // Renderer (ensure these are set once in your setup)
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // Debug helpers (toggle on when tuning)
      const LIGHT_DEBUG = false;
      if (LIGHT_DEBUG) {
        scene.add(new THREE.HemisphereLightHelper(hemiLight, 2));
        scene.add(new THREE.DirectionalLightHelper(dirLight, 2));
        scene.add(new THREE.CameraHelper(dirLight.shadow.camera));
      }

      // // Lights
      // scene.add(new THREE.HemisphereLight(0xdce7ff, 0x0b0f18, 1));

      // const dir = new THREE.DirectionalLight(0xffffff, 1.35);
      // dir.position.set(8, 14, 6);
      // dir.castShadow = true;
      // dir.shadow.mapSize.set(2048, 2048);
      // dir.shadow.camera.left = -26;
      // dir.shadow.camera.right = 26;
      // dir.shadow.camera.top = 26;
      // dir.shadow.camera.bottom = -26;
      // dir.shadow.camera.near = 0.1;
      // dir.shadow.camera.far = 120;
      // scene.add(dir);




      setupWetTrailSystem();


      // Ground
      const groundMat = new THREE.MeshStandardMaterial({
        color: normalizeHexColor(params.groundColor, DEFAULTS.groundColor || "#ffffff"),
        roughness: 1.0,
        metalness: 0.0
      });
      ground = new THREE.Mesh(
        new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE),
        groundMat
        );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);


      // Axes helper at origin
      const axes = new THREE.AxesHelper(5);
      scene.add(axes);


      // Cube centered at origin (sitting on ground)
      const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
      const cubeMat = new THREE.MeshStandardMaterial({
        color: normalizeHexColor(params.cubeColor, DEFAULTS.cubeColor || "#4e9cff"),
        roughness: 0.4,
        metalness: 0.2
      });
      cube = new THREE.Mesh(cubeGeo, cubeMat);
      cube.position.set(0, 0.5, 0);
      cube.castShadow = true;
      //scene.add(cube);


      // Rocks
      const rockGeo = new THREE.IcosahedronGeometry(1.1, 0);
      const rockMat = new THREE.MeshStandardMaterial({
        color: normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442"),
        roughness: 1.0
      });


      const rockPos = [
        [-9, 1.0,  6],
        [-7, 0.8, -8],
        [ 8, 1.0, -6]
      ];

      for (let i = 0; i < rockPos.length; i++) {
        const [x, _y, z] = rockPos[i];

        const r = new THREE.Mesh(rockGeo, rockMat);
        r.scale.setScalar(1.0 + i * 0.25);

        r.position.set(x, 0.0, z);

        r.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
        r.castShadow = true;
        r.receiveShadow = true;

        scene.add(r);
        rocks.push(r);
      }



      // Base colliders: rocks + cube, forest trees added in rebuildForest()
      colliderObjects = [...rocks, cube];

      // Build forest according to params (fills cones[] and colliderObjects)
      rebuildForest();


      //loadModel1();
      //loadAllModels();

      setupClouds();
      rebuildDust();
      rebuildRain();
      rebuildGrass();

      initAudio();

    }

    /**
     * Repositions all rock meshes so the snow surface cuts through the middle of each rock,
     * keeping them half-buried even when snow height changes.
     */
    function updateRocksGrounding() {
      for (const r of rocks) {
        if (!r) continue;
        const s = r.scale.y || 1.0;
        const groundY = sampleSnowHeight(r.position.x, r.position.z);
        r.position.y = groundY - rockGeoMidY * s;
      }
    }



    function rebuildWorld() {
      if (params.snowEnabled) {
        buildSnowSurface();
        buildSnowField();
      } else {
        disposeSnowField();
        disposeSnowSurface();
      }

      updateRocksGrounding();

      if (params.snowEnabled) {
        buildStuckSystem();
        buildSettlers();
      } else {
        disposeStuckSystem();
        disposeSettlers();
      }

      colliderBounds = buildColliderBounds(colliderObjects);
      rebuildAvatarCollisionGrid();
    }




    // -------------------------------------------------------------------------
    // GUI (with gust controls + preset dropdown)
    // -------------------------------------------------------------------------

    function trackController(ctrl, { rebuild = false, instant = true } = {}) {
      guiControllers.push(ctrl);
      const needsFinish = typeof ctrl.onFinishChange === "function";

      if (needsFinish && !instant) {
        ctrl.onChange(() => {
          saveLastDebounced(params);
        });
        ctrl.onFinishChange(() => {
          if (rebuild) rebuildWorld();
          saveLastDebounced(params);
        });
      } else {
        ctrl.onChange(() => {
          if (rebuild) rebuildWorld();
          saveLastDebounced(params);
        });
      }
      return ctrl;
    }

    function refreshGuiDisplays() {
      for (const c of guiControllers) {
        c.updateDisplay();
      }
    }

    async function refreshPresetList() {
      try {
        const builtin = getBuiltinPresets();
        const builtinNames = builtin.map((p) => p.name);

        const savedNames = await idbListPresetNames();

        const seen = new Set();
        const mergedNames = [];

        function pushName(raw) {
          const key = sanitizePresetName(raw);
          if (!key || key === "<none>") return;
          if (seen.has(key)) return;
          seen.add(key);
          mergedNames.push(raw);
        }

        for (const n of builtinNames) pushName(n);
          for (const n of savedNames) pushName(n);

            const names = mergedNames;
          const opts = names.length ? names : ["<none>"];

          presetSelectCtrl.options(opts);

          if (!names.includes(presetState.selected)) {
            presetState.selected = names[0] || "<none>";
          }

          presetSelectCtrl.updateDisplay();
        } catch (e) {
          console.error("[snow] refresh presets failed", e);
        }
      }



      async function savePreset() {
        const name = sanitizePresetName(presetState.presetName || `preset-${nowStamp()}`);
        if (!name) return;
        presetState.presetName = name;
        const settings = safeCloneSettings(params);
        try {
          await idbPutPreset(name, settings);
          presetState.selected = name;
          await refreshPresetList();
          saveLastDebounced(params);
        } catch (e) {
          console.error("[snow] preset save failed", e);
        }
      }



      async function loadPreset() {
        const selectedRaw = presetState.selected;
        const key = sanitizePresetName(selectedRaw);
        if (!key || key === "<none>") return;

        const builtin = getBuiltinPresets().find(
          (p) => sanitizePresetName(p.name) === key
          );

        try {
          if (builtin) {
            const response = await fetch(builtin.url, {
              cache: "no-store"
            });

            if (!response.ok) {
              console.warn(
                "[snow] builtin preset fetch failed:",
                builtin.url,
                response.status,
                response.statusText
                );
              return;
            }

            const json = await response.json();

            const srcSettings =
            json &&
            typeof json === "object" &&
            json.settings &&
            typeof json.settings === "object"
            ? json.settings
            : json;

            if (!srcSettings || typeof srcSettings !== "object") {
              console.warn("[snow] builtin preset JSON has no settings object");
              return;
            }

            const merged = Object.assign({}, DEFAULTS, srcSettings);

            applySettings(merged, {
              rebuild: true,
              updateGui: true,
              persist: true
            });

            presetState.presetName = builtin.name;
            return;
          }

          const row = await idbGetPreset(key);
          if (!row || !row.settings) {
            console.warn("[snow] preset not found:", key);
            return;
          }

          applySettings(row.settings, {
            rebuild: true,
            updateGui: true,
            persist: true
          });
          presetState.presetName = key;
        } catch (e) {
          console.error("[snow] preset load failed", e);
        }
      }



      async function deletePreset() {
        const name = sanitizePresetName(presetState.selected);
        if (!name || name === "<none>") return;
        try {
          await idbDeletePreset(name);
          presetState.selected = "<none>";
          await refreshPresetList();
        } catch (e) {
          console.error("[snow] preset delete failed", e);
        }
      }

      function exportSettings() {
        const hasSelection =
        presetState.selected && presetState.selected !== "<none>";

        const baseName = hasSelection
        ? presetState.selected
        : (presetState.presetName || `preset-${nowStamp()}`);

        const name = sanitizePresetName(baseName);

        const payload = {
          v: 1,
          kind: "snow-preset",
          exportedAt: Date.now(),
          name,
          settings: safeCloneSettings(params)
        };

        const safeName = name
        ? name.replace(/\s+/g, "-")
        : `preset-${nowStamp()}`;

        const filename = `snow-${safeName}.json`;
        downloadJson(payload, filename);
      }

      function importSettings() {
        const input = ensureImportInput();

        input.onchange = async () => {
          const file = input.files && input.files[0];
          input.value = "";
          if (!file) return;

          try {
            const text = await file.text();
            const json = JSON.parse(text);

            if (!json || typeof json !== "object") {
              throw new Error("Invalid JSON root");
            }

          // Accept both:
          //   { v: 1, kind, name, settings: { ... } }
          //   { ...paramsDirectly }
            const srcSettings =
            json.settings && typeof json.settings === "object"
            ? json.settings
            : json;

            if (!srcSettings || typeof srcSettings !== "object") {
              throw new Error("No settings object found");
            }

          // Merge onto DEFAULTS so missing keys get sane values
            const merged = { ...DEFAULTS, ...srcSettings };

            applySettings(merged, {
              rebuild: true,
              updateGui: true,
              persist: true
            });

          // Update preset name in GUI if present in file
            let importedName = null;
            if (typeof json.name === "string" && json.name.trim()) {
              importedName = sanitizePresetName(json.name);
            } else if (
              typeof json.presetName === "string" &&
              json.presetName.trim()
              ) {
              importedName = sanitizePresetName(json.presetName);
            }

            if (importedName) {
              presetState.presetName = importedName;
              presetState.selected = importedName;
              if (presetSelectCtrl) {
                await refreshPresetList();
              }
            }
          } catch (e) {
            console.error("[snow] import failed", e);
          }
        };

        input.click();
      }




      function setupGui() {
        gui = new GUI({ width: 380 });

        trackController(gui.add(params, "paused").name("Paused"), { instant: true });
        trackController(gui.add(params, "debug").name("Debug logs"), { instant: true });

        const sim = gui.addFolder("Simulation");
        trackController(sim.add(params, "timeScale", 0.05, 2.0, 0.01).name("Time scale"));
        trackController(sim.add(params, "dtMax", 0.008, 0.050, 0.001).name("dt max (clamp)"));
        trackController(sim.add(params, "pixelRatio", 0.5, 2.5, 0.01).name("Pixel ratio"), {
          rebuild: false
        });

        const perf = gui.addFolder("Performance");

        trackController(perf.add(params, "shadowsEnabled").name("Shadows").listen(), { instant: true });

        trackController(
          perf.add(params, "shadowsAutoUpdate").name("Shadow auto update").listen(),
          { instant: true }
          );

        trackController(
          perf.add(params, "shadowType", ["PCFSoft", "PCF", "Basic"]).name("Shadow type").listen(),
          { instant: true }
          );

        trackController(
          perf.add(params, "shadowMapSize", [256, 512, 1024, 2048, 4096]).name("Shadow map size").listen(),
          { instant: true }
          );

        perf.close();


      //sim.open();

        const wind = gui.addFolder("Wind");
        trackController(wind.add(params, "windStrength", 0.0, 2.0, 0.01).name("Strength"));
        trackController(wind.add(params, "windSpeed", 0.0, 5, 0.01).name("Speed"));
        //wind.open();


        const rocksFolder = gui.addFolder("Rocks");

        const rockCountCtrl = rocksFolder.add(params, "rockCount", 0, 800, 1).name("Rock count");
        const rockRadiusCtrl = rocksFolder.add(params, "rockRadius", 2.0, 1500.0, 0.5).name("Radius");
        const rockInnerCtrl = rocksFolder.add(params, "rockInnerRadius", 0.0, 200.0, 0.5).name("Inner radius");
        const rockMinScaleCtrl = rocksFolder.add(params, "rockMinScale", 0.01, 5.0, 0.01).name("Min scale");
        const rockMaxScaleCtrl = rocksFolder.add(params, "rockMaxScale", 0.2, 100.0, 0.05).name("Max scale");
        const rockSeedCtrl = rocksFolder.add(params, "rockSeed", 0, 9999, 1).name("Seed");
        const rockJitterCtrl = rocksFolder.add(params, "rockJitter", 0.0, 2.0, 0.05).name("Randomness");

        const rockCtrls = [
          rockCountCtrl,
          rockRadiusCtrl,
          rockInnerCtrl,
          rockMinScaleCtrl,
          rockMaxScaleCtrl,
          rockSeedCtrl,
          rockJitterCtrl
        ];

        rockCtrls.forEach((ctrl) => {
          trackController(ctrl, { rebuild: false, instant: true });
          if (typeof ctrl.onFinishChange === "function") {
            ctrl.onFinishChange(() => {
              applySettings(params, { rebuild: false, updateGui: false });
              rebuildRocks();
              saveLastDebounced(params);
            });
          }
        });

        rocksFolder
        .add(
        {
          rebuildRocks: () => {
            applySettings(params, { rebuild: false, updateGui: false });
            rebuildRocks();
            saveLastDebounced(params);
          }
        },
        "rebuildRocks"
        )
        .name("Rebuild rocks");

        rocksFolder.close();


        const forest = gui.addFolder("Forest");

        const forestCountCtrl = forest
        .add(params, "forestCount", 0, 4000, 1)
        .name("Tree count");
        const forestRadiusCtrl = forest
        .add(params, "forestRadius", 2.0, 1500.0, 0.5)
        .name("Radius");
        const forestInnerCtrl = forest
        .add(params, "forestInnerRadius", 0.0, 16.0, 0.5)
        .name("Inner radius");
        const forestMinScaleCtrl = forest
        .add(params, "forestMinScale", 0.3, 2.5, 0.05)
        .name("Min scale");
        const forestMaxScaleCtrl = forest
        .add(params, "forestMaxScale", 0.3, 3.0, 0.05)
        .name("Max scale");
        const forestSeedCtrl = forest
        .add(params, "forestSeed", 0, 9999, 1)
        .name("Seed");
        const forestJitterCtrl = forest
        .add(params, "forestJitter", 0.0, 2.0, 0.05)
        .name("Randomness");

        const forestCtrls = [
          forestCountCtrl,
          forestRadiusCtrl,
          forestInnerCtrl,
          forestMinScaleCtrl,
          forestMaxScaleCtrl,
          forestSeedCtrl,
          forestJitterCtrl
        ];

        forestCtrls.forEach((ctrl) => {
          trackController(ctrl, { rebuild: false, instant: true });
          if (typeof ctrl.onFinishChange === "function") {
            ctrl.onFinishChange(() => {
              applySettings(params, { rebuild: false, updateGui: false });
              rebuildForest();
              saveLastDebounced(params);
            });
          }
        });

        forest
        .add(
        {
          rebuildForest: () => {
            applySettings(params, { rebuild: false, updateGui: false });
            rebuildForest();
            saveLastDebounced(params);
          }
        },
        "rebuildForest"
        )
        .name("Rebuild forest");

        //wind.open();



        const surfaces = gui.addFolder("Surfaces");

        const surfaceUpdate = () => {
          params.groundColor = normalizeHexColor(params.groundColor, DEFAULTS.groundColor || "#ffffff");
          params.rockColor = normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442");
          params.forestColor = normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b");
          params.cubeColor = normalizeHexColor(params.cubeColor, DEFAULTS.cubeColor || "#4e9cff");
          applySurfaceColorsFromParams();
          saveLastDebounced(params);
        };

        const groundColorCtrl = surfaces.addColor(params, "groundColor").name("Ground").listen();
        const rockColorCtrl = surfaces.addColor(params, "rockColor").name("Rocks").listen();
        const forestColorCtrl = surfaces.addColor(params, "forestColor").name("Forest").listen();
        const cubeColorCtrl = surfaces.addColor(params, "cubeColor").name("Cube").listen();

        guiControllers.push(groundColorCtrl, rockColorCtrl, forestColorCtrl, cubeColorCtrl);

        groundColorCtrl.onChange(surfaceUpdate);
        rockColorCtrl.onChange(surfaceUpdate);
        forestColorCtrl.onChange(surfaceUpdate);
        cubeColorCtrl.onChange(surfaceUpdate);

        surfaces.close();

        const fogFolder = gui.addFolder("Fog");
        const fogUpdate = () => {
          updateFogFromParams();
          saveLastDebounced(params);
        };

        const fogNearCtrl = fogFolder
        .add(params, "fogNear", 0.1, 200.0, 0.5)
        .name("Near");
        const fogFarCtrl = fogFolder
        .add(params, "fogFar", 1.0, 400.0, 0.5)
        .name("Far");
        const fogColorCtrl = fogFolder
        .addColor(params, "fogColor")
        .name("Color");

        fogNearCtrl.onChange(fogUpdate);
        fogFarCtrl.onChange(fogUpdate);
        fogColorCtrl.onChange(fogUpdate);
        //fogFolder.open();

        const gustFolder = gui.addFolder("Gusts");



        trackController(
          gustFolder.add(params, "gustMinInterval", 0.2, 6.0, 0.1).name("Min interval")
          );
        trackController(
          gustFolder.add(params, "gustMaxInterval", 0.4, 12.0, 0.1).name("Max interval")
          );
        trackController(
          gustFolder.add(params, "gustTornadoChance", 0.0, 0.6, 0.01).name("Tornado chance")
          );
        trackController(
          gustFolder.add(params, "gustStrengthMul", 0.3, 2.0, 0.01).name("Strength mul")
          );
        trackController(
          gustFolder.add(params, "gustSwirlMul", 0.3, 2.0, 0.01).name("Swirl mul")
          );
        trackController(
          gustFolder.add(params, "gustUpdraftMul", 0.0, 2.0, 0.01).name("Updraft mul")
          );
        trackController(
          gustFolder.add(params, "gustScour", 0.0, 0.03, 0.0005).name("Scour")
          );
        trackController(
          gustFolder.add(params, "gustRedeposit", 0.0, 0.03, 0.0005).name("Redeposit")
          );
      //gustFolder.open();



        const cloudFolder = gui.addFolder("Clouds");

        cloudFolder
        .add(params, "cloudEnabled")
        .name("Enabled")
        .onChange((v) => {
          params.cloudEnabled = !!v;

          if (!params.cloudEnabled) {
            if (cloudLayer) cloudLayer.visible = false;
          } else {
            if (!cloudLayer) {
              rebuildClouds();
            } else {
              cloudLayer.visible = true;
              applyCloudParamsToUniforms();
            }
          }
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudHeightBase", 0.0, 200.0, 1)
        .name("Base height")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudHeightRange", 0.0, 150.0, 1)
        .name("Height range")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudRadius", 1.0, 300.0, 1.0)
        .name("Radius")
        .onChange(() => {
          rebuildClouds();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudSliceCount", 1, 256, 1)
        .name("Slices")
        .onChange(() => {
          rebuildClouds();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudDensity", 0.0, 1.0, 0.01)
        .name("Density")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudSoftness", 0.001, 1, 0.001)
        .name("Softness")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudSpeed", -0.05, 0.05, 0.001)
        .name("Scroll speed")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        // NEW: color + opacity controls

        const cloudColorCtrl = cloudFolder
        .addColor(params, "cloudColor")
        .name("Cloud color");

        const skyColorCtrl = cloudFolder
        .addColor(params, "cloudSkyColor")
        .name("Sky color");

        const cloudOpacityCtrl = cloudFolder
        .add(params, "cloudOpacity", 0.0, 3.0, 0.05)
        .name("Opacity");

        const updateCloudAppearance = () => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        };

        cloudColorCtrl.onChange(updateCloudAppearance);
        skyColorCtrl.onChange(updateCloudAppearance);
        cloudOpacityCtrl.onChange(updateCloudAppearance);


        cloudFolder.close();




        const dustFolder = gui.addFolder("Dust");

        dustFolder
        .add(params, "dustEnabled")
        .name("Enabled")
        .onChange(() => {
          rebuildDust();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustCount", 16, 100000, 1)
        .name("Particles")
        .onChange(() => {
          rebuildDust();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustRadius", 0.1, 400.0, 0.1)
        .name("Radius")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustFloorY", -2.0, 10.0, 0.01)
        .name("Floor Y")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustCeilY", 0.1, 500.0, 0.1)
        .name("Ceiling Y")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustSpeed", 0.0, 20.0, 0.01)
        .name("Speed (time)")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustSize", 0.01, 5.0, 0.01)
        .name("Point size")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustNoise", 0.0, 2.0, 0.01)
        .name("Wiggle")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustCenterX", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center X")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustCenterZ", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center Z")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        const dustInnerCtrl = dustFolder.addColor(params, "dustColorInner").name("Inner color");
        const dustOuterCtrl = dustFolder.addColor(params, "dustColorOuter").name("Outer color");

        const updateDustAppearance = () => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        };

        dustInnerCtrl.onChange(updateDustAppearance);
        dustOuterCtrl.onChange(updateDustAppearance);

        dustFolder.close();


        
        // Rain GUI

        const rainFolder = gui.addFolder("Rain");

        rainFolder
        .add(params, "rainEnabled")
        .name("Enabled")
        .onChange(() => {
          rebuildRain();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainCount", 16, 40000, 1)
        .name("Drops")
        .onChange(() => {
          rebuildRain();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainRadius", 0.1, 200.0, 0.1)
        .name("Radius")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainTopY", -10.0, 200.0, 0.1)
        .name("Top Y")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainBottomY", -50.0, 80.0, 0.1)
        .name("Bottom Y")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainSpeed", 0.0, 12.0, 0.01)
        .name("Speed (time)")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainWindX", -10.0, 10.0, 0.01)
        .name("Wind X")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainWindZ", -10.0, 10.0, 0.01)
        .name("Wind Z")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainSize", 0.01, 2.0, 0.01)
        .name("Point size")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainThickness", 0.01, 0.25, 0.005)
        .name("Thickness")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainStreak", 0.10, 0.98, 0.01)
        .name("Streak")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainCenterX", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center X")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainCenterZ", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center Z")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        const rainColorCtrl = rainFolder.addColor(params, "rainColor").name("Color");

        rainFolder
        .add(params, "rainOpacity", 0.0, 1.0, 0.01)
        .name("Opacity");

        const updateRainAppearance = () => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        };

        rainColorCtrl.onChange(updateRainAppearance);

        rainFolder.close();





        // Grass GUI

        const grassFolder = gui.addFolder("Grass");

        grassFolder
        .add(params, "grassEnabled")
        .name("Enabled")
        .listen()
        .onChange(() => {
          rebuildGrass();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassCount", 0, 120000, 1)
        .name("Blades")
        .onChange(() => {
          rebuildGrass();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassSeed", 0, 999999, 1)
        .name("Seed")
        .onChange(() => {
          rebuildGrass();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassRadius", 0.1, 2000.0, 0.1)
        .name("Radius")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassCenterX", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center X")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassCenterZ", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center Z")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBaseY", -2.0, 5.0, 0.005)
        .name("Base Y")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBladeHeight", 0.01, 50, 0.005)
        .name("Height")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBladeWidth", 0.001, 5, 0.001)
        .name("Width")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassHeightJitter", 0.0, 1.0, 0.01)
        .name("Height jitter")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassWidthJitter", 0.0, 1.0, 0.01)
        .name("Width jitter")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBend", 0.0, 12.0, 0.01)
        .name("Bend")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassWindSpeed", 0.0, 20.0, 0.01)
        .name("Wind speed")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassWindStrength", 0.0, 6.0, 0.01)
        .name("Wind strength")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassStiffness", 0.25, 4.0, 0.01)
        .name("Stiffness")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });


        grassFolder
        .add(params, "grassNoiseScale", 0.01, 20.0, 0.01)
        .name("Noise scale")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassNoiseStrength", 0.0, 2.0, 0.01)
        .name("Gust strength")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassNoiseSpeed", 0.0, 10.0, 0.01)
        .name("Gust speed")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassStaticHeightNoise", 0.0, 20.0, 0.01)
        .name("Height noise")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassStaticWidthNoise", 0.0, 10.0, 0.01)
        .name("Width noise")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBorderNoise", 0.0, 10.0, 0.01)
        .name("Border noise")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassColorVariation", 0.0, 0.5, 0.01)
        .name("Color var")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });





        const grassBottomCtrl = grassFolder.addColor(params, "grassColorBottom").name("Bottom").listen();
        const grassTopCtrl = grassFolder.addColor(params, "grassColorTop").name("Top").listen();




        grassFolder
        .add(params, "grassOpacity", 0.0, 1.0, 0.01)
        .name("Opacity")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassAlphaCutoff", 0.0, 0.95, 0.01)
        .name("Cutoff")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        const updateGrassAppearance = () => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        };

        grassBottomCtrl.onChange(updateGrassAppearance);
        grassTopCtrl.onChange(updateGrassAppearance);

        grassFolder.close();








        // Snowing

        const flakes = gui.addFolder("Flakes");
        trackController(flakes.add(params, "snowEnabled").name("Enabled"), { rebuild: true, instant: true });

        trackController(
          flakes.add(params, "visualCount", 20000, 600000, 5000).name("Visual flakes"),
          { rebuild: true, instant: false }
          );
        trackController(flakes.add(params, "fallSpeed", 0.001, 10.5, 0.001).name("Fall speed"));
        trackController(flakes.add(params, "fallJitter", 0.0, 0.9, 0.01).name("Fall jitter"));
        trackController(flakes.add(params, "flakeSize", 0.01, 10.0, 0.01).name("Flake size"));
        trackController(
          flakes.add(params, "flakeSizeJitter", 0.0, 0.9, 0.01).name("Size jitter")
          );
        
        //flakes.open();

        const drifts = gui.addFolder("Drifts");

        trackController(drifts.add(params, "driftGrid", 32, 4096, 1).name("Grid"), {
          rebuild: true,
          instant: false
        });
        trackController(
          drifts.add(params, "driftMaxHeight", 0.5, 8.0, 0.1).name("Max height")
          );
        trackController(drifts.add(params, "coverBase", 0.0, 0.30, 0.005).name("Base cover"));
        trackController(
          drifts.add(params, "coverMacroAmp", 0.0, 0.30, 0.005).name("Macro amp")
          );
        trackController(
          drifts.add(params, "coverMacroFreq", 0.5, 6.0, 0.1).name("Macro freq")
          );
        trackController(
          drifts.add(params, "coverMicroAmp", 0.0, 0.20, 0.005).name("Micro amp")
          );
        trackController(
          drifts.add(params, "coverMicroFreq", 2.0, 16.0, 0.1).name("Micro freq")
          );
        trackController(
          drifts.add(params, "depositUnit", 0.00005, 0.0015, 0.00001).name("Deposit unit")
          );
        trackController(
          drifts.add(params, "driftDiffusion", 0.0, 0.25, 0.001).name("Diffusion")
          );
        trackController(
          drifts.add(params, "driftAdvection", 0.0, 0.30, 0.001).name("Advection")
          );
        trackController(
          drifts.add(params, "obstacleShapeInterval", 1, 60, 1).name("Obstacle shape N")
          );
        trackController(
          drifts.add(params, "driftWriteInterval", 1, 60, 1).name("Write mesh N")
          );
        trackController(
          drifts.add(params, "normalUpdateInterval", 4, 180, 1).name("Normals N")
          );
      //drifts.open();




        const terrain = gui.addFolder("Terrain");

        const terrainSanitize = () => {
          params.terrainColorLow = normalizeHexColor(params.terrainColorLow, DEFAULTS.terrainColorLow || "#ffffff");
          params.terrainColorHigh = normalizeHexColor(params.terrainColorHigh, DEFAULTS.terrainColorHigh || "#ffffff");
          params.terrainOctaves = clamp(params.terrainOctaves | 0, 1, 10);
          params.terrainLacunarity = Math.max(1.0, params.terrainLacunarity);
          params.terrainGain = clamp(params.terrainGain, 0.0, 1.0);
          params.terrainEdgeNoiseAmp = clamp(params.terrainEdgeNoiseAmp, 0.0, 0.9);
          params.terrainColorStrength = clamp(params.terrainColorStrength, 0.0, 1.0);
        };

        const terrainCtrls = [
          terrain.add(params, "terrainEnabled").name("Enabled").listen(),
          terrain.add(params, "terrainAmp", 0.0, 25.0, 0.05).name("Height amp").listen(),
          terrain.add(params, "terrainFreq", 0.001, 0.12, 0.001).name("Frequency").listen(),
          terrain.add(params, "terrainOctaves", 1, 10, 1).name("Octaves").listen(),
          terrain.add(params, "terrainLacunarity", 1.0, 3.5, 0.05).name("Lacunarity").listen(),
          terrain.add(params, "terrainGain", 0.0, 0.95, 0.01).name("Gain").listen(),
          terrain.add(params, "terrainWarpAmp", 0.0, 40.0, 0.25).name("Warp amp").listen(),
          terrain.add(params, "terrainWarpFreq", 0.001, 0.06, 0.001).name("Warp freq").listen(),
          terrain.add(params, "terrainRidge").name("Ridged").listen(),
          terrain.add(params, "terrainExponent", 0.5, 3.0, 0.05).name("Shape").listen(),

          terrain.add(params, "terrainRadius", 0.0, 200.0, 0.5).name("Radius").listen(),
          terrain.add(params, "terrainInnerRadius", 0.0, 200.0, 0.5).name("Inner radius").listen(),
          terrain.add(params, "terrainEdgeFade", 0.0, 40.0, 0.5).name("Edge fade").listen(),
          terrain.add(params, "terrainEdgeNoiseAmp", 0.0, 0.9, 0.01).name("Border noise").listen(),
          terrain.add(params, "terrainEdgeNoiseFreq", 0.001, 0.10, 0.001).name("Border freq").listen(),

          terrain.add(params, "terrainSeed", 0, 9999, 1).name("Seed").listen(),
          terrain.addColor(params, "terrainColorLow").name("Color low").listen(),
          terrain.addColor(params, "terrainColorHigh").name("Color high").listen(),
          terrain.add(params, "terrainColorStrength", 0.0, 1.0, 0.01).name("Color mix").listen()
        ];

        terrainCtrls.forEach((ctrl) => {
          trackController(ctrl, { rebuild: false, instant: true });
          if (typeof ctrl.onFinishChange === "function") {
            ctrl.onFinishChange(() => {
              terrainSanitize();
              applySettings(params, { rebuild: false, updateGui: false });
              rebuildTerrainBase();
              saveLastDebounced(params);
            });
          } else if (typeof ctrl.onChange === "function") {
            ctrl.onChange(() => {
              terrainSanitize();
              applySettings(params, { rebuild: false, updateGui: false });
              rebuildTerrainBase();
              saveLastDebounced(params);
            });
          }
        });

        terrain
        .add(
        {
          rebuildTerrain: () => {
            terrainSanitize();
            applySettings(params, { rebuild: false, updateGui: false });
            rebuildTerrainBase();
            saveLastDebounced(params);
          }
        },
        "rebuildTerrain"
        )
        .name("Rebuild terrain");



        const sticking = gui.addFolder("Sticking");



        trackController(
          sticking.add(params, "settlerCount", 1000, 300000, 500).name("Settlers"),
          { rebuild: true, instant: false }
          );
        trackController(
          sticking.add(params, "groundDepositBudget", 20, 10200, 10).name("Deposit budget")
          );
        trackController(
          sticking.add(params, "objectTestsPerFrame", 0, 50000, 50).name("Ray tests/frame")
          );
        trackController(
          sticking.add(params, "objectDeposit", 0.0, 1, 0.0005).name("Object deposit")
          );
        trackController(
          sticking.add(params, "stuckMax", 1000, 600000, 500).name("Max decals"),
          { rebuild: true, instant: false }
          );
        trackController(
          sticking.add(params, "decalSize", 0.06, 0.50, 0.01).name("Decal size"),
          { rebuild: true, instant: false }
          );
      //ticking.open();

        const deformation = gui.addFolder("Deformation");

        const deformActions = {
          clear: () => {
            if (driftDeform && driftDeform.length) {
              driftDeform.fill(0);
              requestDriftWrite();
            }
          }
        };

        const deformControllers = [];

        deformControllers.push(
          deformation.add(snowDeformConfig, "enabled").name("Enabled").listen()
          );
        deformation.add(deformActions, "clear").name("Clear");

        const deformAvatar = deformation.addFolder("Avatar");
        deformControllers.push(
          deformAvatar.add(snowDeformConfig, "avatarFootRadius", 0.08, 0.80, 0.01).name("Foot radius").listen()
          );
        deformControllers.push(
          deformAvatar.add(snowDeformConfig, "avatarStepDistance", 0.15, 1.50, 0.01).name("Step distance").listen()
          );
        deformControllers.push(
          deformAvatar.add(snowDeformConfig, "avatarDepthWalk", 0.001, 0.080, 0.001).name("Depth walk").listen()
          );
        deformControllers.push(
          deformAvatar.add(snowDeformConfig, "avatarDepthRun", 0.001, 0.120, 0.001).name("Depth run").listen()
          );

        const deformVehicle = deformation.addFolder("Vehicle");
        deformControllers.push(
          deformVehicle.add(snowDeformConfig, "vehicleTrackDepth", 0.001, 1, 0.001).name("Track depth").listen()
          );
        deformControllers.push(
          deformVehicle.add(snowDeformConfig, "vehicleHalfWidthFallback", 0.10, 2.50, 0.01).name("Half width").listen()
          );
        deformControllers.push(
          deformVehicle.add(snowDeformConfig, "vehicleTrackSpacing", 0.10, 3.00, 0.01).name("Track spacing").listen()
          );

        const deformCarve = deformation.addFolder("Carve");
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveDepthMin", 0.000, 0.120, 0.001).name("Depth min").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveDepthMax", 0.001, 0.300, 0.001).name("Depth max").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveRadiusBase", 0.00, 2.50, 0.01).name("Radius base").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveRadiusFromDepth", 0.00, 40.0, 0.1).name("Radius / depth").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveRadiusMin", 0.00, 4.00, 0.01).name("Radius min").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveRadiusMax", 0.05, 8.00, 0.01).name("Radius max").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveMinCellFrac", 0.00, 2.00, 0.01).name("Min cell frac").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveMaxCells", 1, 48, 1).name("Max cells").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveSigmaFrac", 0.10, 1.50, 0.01).name("Sigma frac").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveMaxCarve", 0.005, 0.50, 0.005).name("Max carve").listen()
          );


        const wet = deformation.addFolder("Wet marks");

        wet.add(wetTrailConfig, "enabled").name("Enabled").listen();
        wet.add(wetTrailConfig, "maxMarks", 0, 1200, 10).name("Max marks").listen().onFinishChange(() => {
          setupWetTrailSystem();
          rebuildWetTrailPool();
        });
        wet.add(wetTrailConfig, "life", 0.5, 12.0, 0.1).name("Life").listen();
        wet.add(wetTrailConfig, "opacity", 0.01, 1.0, 0.01).name("Opacity").listen();
        wet.add(wetTrailConfig, "lift", 0.0, 0.20, 0.001).name("Lift").listen();

        wet.add(wetTrailConfig, "avatarSize", 0.05, 2.0, 0.01).name("Avatar size").listen();
        wet.add(wetTrailConfig, "vehicleWidth", 0.05, 3.0, 0.01).name("Vehicle width").listen();
        wet.add(wetTrailConfig, "vehicleLength", 0.05, 4.0, 0.01).name("Vehicle length").listen();

        wet.addColor(wetTrailConfig, "avatarColor").name("Avatar color").listen();
        wet.addColor(wetTrailConfig, "vehicleColor").name("Vehicle color").listen();

        wet.add(wetTrailConfig, "avatarUseFootprint").name("Avatar footprint").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });

        wet.add(wetTrailConfig, "footToeScale", 0.10, 1.00, 0.01).name("Foot toe").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });
        wet.add(wetTrailConfig, "footHeelScale", 0.10, 1.00, 0.01).name("Foot heel").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });
        wet.add(wetTrailConfig, "footBridge", 0.00, 0.60, 0.01).name("Foot bridge").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });
        wet.add(wetTrailConfig, "footSoftness", 0.05, 0.95, 0.01).name("Foot softness").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });

        wet.add({ clear: () => clearWetTrails() }, "clear").name("Clear");

        for (let i = 0; i < deformControllers.length; i++) {
          const c = deformControllers[i];
          if (c && c.onFinishChange) c.onFinishChange(() => requestDriftWrite());
        }

        deformation.close()

        const misc = {
          resetDefaults() {
            applySettings(DEFAULTS, { rebuild: true, updateGui: true, persist: true });
          }
        };


        gui.add(misc, "resetDefaults").name("Reset to defaults");

        const presets = gui.addFolder("Presets");
        presets.add(presetState, "presetName").name("Save as").listen();

        presetSelectCtrl = presets
        .add(presetState, "selected", ["<none>"])
        .name("Saved presets");

      // auto-load preset (file or DB) when selection changes
        presetSelectCtrl.onChange(async (value) => {
          const name = sanitizePresetName(value);
          presetState.selected = name || "<none>";
          if (name && name !== "<none>") {
            await loadPreset();
          }
        });

        presets.add({ savePreset }, "savePreset").name("Save");
      // no Load button – selection loads instantly
        presets.add({ deletePreset }, "deletePreset").name("Delete");
        presets.add({ exportJson: exportSettings }, "exportJson").name("Export JSON");
        presets.add({ importJson: importSettings }, "importJson").name("Import JSON");
      //presets.open();
      //presets.open();


        const worldModels = gui.addFolder("World Models");
        worldModels.add(worldModelsIoState, "source").name("Config source").listen();
        worldModels.add(worldModelsIoState, "openWorlds").name("Worlds...");
        worldModels.add(worldModelsIoState, "exportWorldModelsJson").name("Export world");
        worldModels.add(worldModelsIoState, "importWorldModelsJson").name("Import world");
        worldModels.close();




        const snowmanFolder = gui.addFolder("Snowman");        


        trackController(
          snowmanFolder.add(params, "snowmanMoveEnabled").name("Moving")
          );

        trackController(
          snowmanFolder
          .add(params, "snowmanSpeed", 0.002, 0.15, 0.001)
          .name("Path speed")
          );

        trackController(
          snowmanFolder
          .add(params, "snowmanPathRadius", 1.0, 8.0, 0.1)
          .name("Path radius")
          );

        // start folded to not spam the UI
        // snowmanFolder.open(); // enable if you prefer it open by default

        const vehiclesFolder = gui.addFolder("Vehicles");
        setupVehicleTuningGui(vehiclesFolder);
        vehiclesFolder.close();



        sim.close();
        wind.close();
        fogFolder.close();
        gustFolder.close();
        flakes.close();
        drifts.close();
        sticking.close();
        presets.close();
        snowmanFolder.close();
        forest.close();

        gui.close()

      }

    // -------------------------------------------------------------------------
    // Events / main loop
    // -------------------------------------------------------------------------

      function handleResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      const clock = new THREE.Clock();
      let frame = 0;
      let simTime = 0;






      function animate() {
        const rawDt = clamp(
          clock.getDelta(),
          0.0,
          Math.max(0.001, params.dtMax)
          );

        const timeScale = clamp(params.timeScale, 0.05, 5.0);

        const dtSim = params.paused ? 0.0 : rawDt * timeScale;
        const dtAvatar = params.paused ? 0.0 : rawDt;

        if (!params.paused) simTime += dtSim;
        const t = simTime;

        const wA =
        Math.sin(t * params.windSpeed) * 0.48 +
        Math.sin(t * (params.windSpeed * 2.4)) * 0.16;
        const wB =
        Math.cos(t * (params.windSpeed * 0.92)) * 0.44 +
        Math.sin(t * (params.windSpeed * 2.1)) * 0.14;
        const baseWindX = wA * params.windStrength;
        const baseWindZ = wB * params.windStrength;

        if (!params.paused) {
          spawnGusts(dtSim);
          for (let i = 0; i < gusts.length; i++) {
            gusts[i].step(dtSim);
          }
        }

        for (let i = 0; i < GUST_MAX; i++) {
          const g = gusts[i];
          const fade = g.active ? g.fade : 0.0;

          gustPosRad[i * 3 + 0] = g.x;
          gustPosRad[i * 3 + 1] = g.z;
          gustPosRad[i * 3 + 2] = g.radius;

          gustParams[i * 3 + 0] = g.strength * fade;
          gustParams[i * 3 + 1] = g.swirl * fade;
          gustParams[i * 3 + 2] = g.updraft * fade;
        }

        if (params.snowEnabled && snowMat) {
          snowMat.uniforms.uTime.value = t;
          snowMat.uniforms.uWind.value.set(baseWindX, baseWindZ);
          snowMat.uniforms.uFallSpeed.value = params.fallSpeed;
          snowMat.uniforms.uFallJitter.value = params.fallJitter;
          snowMat.uniforms.uFlakeSize.value = params.flakeSize;
          snowMat.uniforms.uFlakeSizeJitter.value = params.flakeSizeJitter;
        }

        if (!params.paused) {
          if (driftHeights) {
            applyGustScour(baseWindX, baseWindZ);

            if (frame % clamp(params.obstacleShapeInterval | 0, 1, 600) === 0) {
              shapeDriftsAroundObstacles(baseWindX, baseWindZ);
            }
            evolveDrifts(baseWindX, baseWindZ);

            const writeEvery = clamp(params.driftWriteInterval | 0, 1, 120);
            const normalEvery = clamp(params.normalUpdateInterval | 0, 1, 240);

            const shouldWrite = forceDriftWrite || (frame % writeEvery === 0);
            if (shouldWrite) {
              applyHeightsToGeometry();
              forceDriftWrite = false;
            }

            if (driftGeo && (forceDriftNormals || (frame % normalEvery === 0))) {
              driftGeo.computeVertexNormals();
              driftGeo.attributes.normal.needsUpdate = true;
              forceDriftNormals = false;

              updateWetTrails(dtAvatar);
            }
          }

          updateSettlers(dtSim, baseWindX, baseWindZ);
          updateSnowman(dtSim);
          updateClouds(dtSim);

          updateDust(dtSim);
          updateRain(dtSim);
          updateGrass(dtSim, baseWindX, baseWindZ);
        }

        tickAvatar(dtAvatar);

        const inXR = renderer.xr.isPresenting;

        if (!inXR && controls) {
          if (avatarState.enabled) {
            controls.autoRotate = false;
            controls.autoRotateSpeed = AUTO_ROTATE_SPEED;

            if (vehicleDriveState.enabled && vehicleChaseCamState.enabled) {
              updateVehicleChaseCamera(dtAvatar);
            } else if (!vehicleDriveState.enabled && avatarChaseCamState.enabled && avatarState.viewMode === "third") {
              updateAvatarChaseCamera(dtAvatar);
            } else {
              if (!joystickState.active) {
                controls.update();
              }

              updateAvatarCamera(dtAvatar);
            }
          } else {
            const nowSeconds = performance.now() * 0.001;
            const idleSeconds = nowSeconds - lastInteractionTime;

            const shouldAutoRotate =
            autoRotateEnabled &&
            idleSeconds >= AUTO_ROTATE_IDLE_SECONDS;

            controls.autoRotate = shouldAutoRotate;
            controls.autoRotateSpeed = AUTO_ROTATE_SPEED;

            controls.update();
          }
        }

        applyShadowSettingsFromParams(false);
        renderer.render(scene, camera);

        frame++;

      }






// -------------------------------------------------------------------------
// Keyboard: fullscreen (F) and UI toggle (ESC)
// -------------------------------------------------------------------------

      let uiHidden = false;

/**
 * Toggle visibility of GUI and HUD without destroying state.
 */
      function setUIHidden(hidden) {
        uiHidden = hidden;

        if (gui && gui.domElement) {
          gui.domElement.style.display = hidden ? "none" : "";
        }

        const hud = document.querySelector(".hud");
        if (hud) {
          hud.style.display = hidden ? "none" : "";
        }

        const avatarUi = document.querySelector(".avatar-ui");
        if (avatarUi) {
          avatarUi.style.display = hidden ? "none" : "";
        }

        const joystickEl = document.getElementById("joystick");
        if (joystickEl) {
          joystickEl.style.display = hidden ? "none" : "";
        }

        const vehiclePanel = document.getElementById("vehiclePrompt");
        if (vehiclePanel) {
          if (hidden) {
            vehiclePanel.style.display = "none";
            vehiclePanel.setAttribute("aria-hidden", "true");
          } else {
            const show = !!(vehiclePromptState.open && vehiclePromptState.nearby);
            vehiclePanel.style.display = show ? "block" : "none";
            vehiclePanel.setAttribute("aria-hidden", show ? "false" : "true");
          }
        }

        if (hidden) {
          updateVehicleOutlineFor(null);
        } else {
          if (vehiclePromptState.open && vehiclePromptState.nearby) {
            updateVehicleOutlineFor(vehiclePromptState.nearby);
          }
        }
      }



/**
 * Cross-browser fullscreen state check.
 */
      function isFullscreen() {
        return (
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
          );
      }

/**
 * Toggle fullscreen on the document root.
 */
      function toggleFullscreen() {
        const el = document.documentElement;

        if (!isFullscreen()) {
          if (el.requestFullscreen) el.requestFullscreen();
          else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
          else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
          else if (el.msRequestFullscreen) el.msRequestFullscreen();
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
          else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
          else if (document.msExitFullscreen) document.msExitFullscreen();
        }
      }



      const keyboardHelpState = { open: false };
      let keyboardHelpEl = null;
      let keyboardHelpCloseBtn = null;

      const playerProfileState = { open: false, wired: false };
      let playerProfileEl = null;
      let playerProfileCloseBtn = null;
      let playerProfileSaveBtn = null;
      let playerProfileResetBtn = null;
      let playerProfileIdEl = null;
      let playerNameInputEl = null;
      let playerColorInputEl = null;
      let playerBioInputEl = null;

      /**
       * Shows or hides the player profile overlay and keeps ARIA state in sync.
       */
      function setPlayerProfileOpen(open) {
        playerProfileState.open = !!open;

        if (!playerProfileEl) return;

        playerProfileEl.classList.toggle("is-open", playerProfileState.open);
        playerProfileEl.setAttribute("aria-hidden", playerProfileState.open ? "false" : "true");

        if (playerProfileState.open) {
          if (playerProfileIdEl) playerProfileIdEl.textContent = playerProfile.id;
          if (playerNameInputEl) playerNameInputEl.value = playerProfile.name;
          if (playerColorInputEl) playerColorInputEl.value = playerProfile.color;
          if (playerBioInputEl) playerBioInputEl.value = String(playerProfile?.meta?.about ?? "");
          if (playerNameInputEl) playerNameInputEl.focus({ preventScroll: true });
        }
      }

      /**
       * Wires the profile overlay UI once and binds it to the persisted profile state.
       */
      function ensurePlayerProfileOverlayWired() {
        if (playerProfileState.wired) return;

        playerProfileEl = document.getElementById("playerProfile");
        playerProfileCloseBtn = document.getElementById("playerProfileClose");
        playerProfileSaveBtn = document.getElementById("playerProfileSave");
        playerProfileResetBtn = document.getElementById("playerProfileReset");
        playerProfileIdEl = document.getElementById("playerProfileId");
        playerNameInputEl = document.getElementById("playerNameInput");
        playerColorInputEl = document.getElementById("playerColorInput");
        playerBioInputEl = document.getElementById("playerBioInput");

        if (playerProfileCloseBtn) {
          playerProfileCloseBtn.addEventListener("click", (event) => {
            event.preventDefault();
            setPlayerProfileOpen(false);
          });
        }

        if (playerProfileEl) {
          playerProfileEl.addEventListener("pointerdown", (event) => {
            if (event.target === playerProfileEl) setPlayerProfileOpen(false);
          });
        }

        if (playerProfileSaveBtn) {
          playerProfileSaveBtn.addEventListener("click", (event) => {
            event.preventDefault();

            const next = {
              id: playerProfile.id,
              name: sanitizePlayerName(playerNameInputEl ? playerNameInputEl.value : playerProfile.name),
              color: playerColorInputEl ? String(playerColorInputEl.value) : playerProfile.color,
              meta: { about: playerBioInputEl ? String(playerBioInputEl.value ?? "").slice(0, 256) : "" }
            };

            setPlayerProfile(next, { persist: true });
            setPlayerProfileOpen(false);
          });
        }

        if (playerProfileResetBtn) {
          playerProfileResetBtn.addEventListener("click", (event) => {
            event.preventDefault();

            setPlayerProfile(
            {
              id: playerProfile.id,
              name: "Anonymous",
              color: "#22c55e",
              meta: { about: "" }
            },
            { persist: true }
            );

            setPlayerProfileOpen(true);
          });
        }

        playerProfileState.wired = true;
      }



      const actionToastState = { timer: 0 };
      let actionToastEl = null;

      /**
       * Displays a short-lived, centered status toast for editor actions (undo/redo/clone/delete).
       */
      function showActionToast(message) {
        if (!message) return;

        if (!actionToastEl) actionToastEl = document.getElementById("actionToast");
        if (!actionToastEl) return;

        actionToastEl.textContent = String(message);
        actionToastEl.classList.add("is-open");
        actionToastEl.setAttribute("aria-hidden", "false");

        if (actionToastState.timer) {
          clearTimeout(actionToastState.timer);
          actionToastState.timer = 0;
        }

        actionToastState.timer = setTimeout(() => {
          actionToastEl.classList.remove("is-open");
          actionToastEl.setAttribute("aria-hidden", "true");
          actionToastState.timer = 0;
        }, 900);
      }


      /**
       * Shows or hides the keyboard help overlay and keeps ARIA state in sync.
       */
      function setKeyboardHelpOpen(open) {
        keyboardHelpState.open = !!open;

        if (!keyboardHelpEl) return;

        keyboardHelpEl.classList.toggle("is-open", keyboardHelpState.open);
        keyboardHelpEl.setAttribute("aria-hidden", keyboardHelpState.open ? "false" : "true");

        if (keyboardHelpState.open && keyboardHelpCloseBtn) {
          keyboardHelpCloseBtn.focus({ preventScroll: true });
        }
      }




      /**
       * Unified key handler.
       */
      function onKeyDown(event) {
        const tag = event.target && event.target.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA") return;

        const isHelpToggle = event.code === "Slash" && (event.metaKey || event.ctrlKey);
        if (isHelpToggle) {
          event.preventDefault();
          setKeyboardHelpOpen(!keyboardHelpState.open);
          return;
        }

        if (keyboardHelpState.open) {
          if (event.code === "Escape") {
            event.preventDefault();
            setKeyboardHelpOpen(false);
          }
          return;
        }

        const isWorldSave = event.code === "KeyS" && (event.metaKey || event.ctrlKey);
        if (isWorldSave) {
          event.preventDefault();
          if (!event.repeat) saveActiveWorld();
          return;
        }

        /**
         * World editor hotkeys: undo/redo, duplicate/delete, and TransformControls mode switching.
         */
        if (worldEditState.enabled) {
          const mod = event.metaKey || event.ctrlKey;

          if (mod) {
            if (event.code === "KeyZ") {
              event.preventDefault();
              if (event.shiftKey) worldEditRedo();
              else worldEditUndo();
              return;
            }

            if (event.code === "KeyY") {
              event.preventDefault();
              worldEditRedo();
              return;
            }
          }

          if (event.shiftKey && event.code === "KeyD") {
            event.preventDefault();
            if (!event.repeat) duplicateSelectedWorldModel();
            return;
          }

          if (event.code === "KeyX") {
            event.preventDefault();
            if (!event.repeat) deleteSelectedWorldModel();
            return;
          }

          if (worldEditState.selected && transformControls) {
            switch (event.code) {
            case "KeyW":
              event.preventDefault();
              transformControls.setMode("translate");
              return;

            case "KeyE":
              event.preventDefault();
              transformControls.setMode("rotate");
              return;

            case "KeyR":
              event.preventDefault();
              transformControls.setMode("scale");
              return;

            case "KeyQ":
              event.preventDefault();
              transformControls.setSpace(transformControls.space === "local" ? "world" : "local");
              return;

            default:
              break;
            }
          }
        }

        if (event.code === "KeyP") {
          if (event.repeat) return;
          event.preventDefault();
          params.paused = !params.paused;
          return;
        }

        if (event.code === "KeyB") {
          if (event.repeat) return;
          event.preventDefault();

          if (vehicleDriveState.enabled) {
            setVehicleChaseCameraEnabled(!vehicleChaseCamState.enabled);
            return;
          }

          if (avatarState.enabled && !vehicleDriveState.enabled) {
            if (avatarState.viewMode !== "third") {
              setAvatarViewMode("third", true);
              updateAvatarButtons();
            }

            setAvatarChaseCameraEnabled(!avatarChaseCamState.enabled);
            return;
          }

          return;
        }

        if (event.code === "KeyF") {
          event.preventDefault();
          toggleFullscreen();
          return;
        }

        if (event.code === "Escape") {
          if (isFullscreen()) {
            if (document.exitFullscreen) document.exitFullscreen();
            else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
            else if (document.msExitFullscreen) document.msExitFullscreen();
          }

          setUIHidden(!uiHidden);
          return;
        }

        if (event.code === "KeyE") {
          event.preventDefault();

          if (vehicleDriveState.enabled) {
            exitVehicle();
            return;
          }

          if (vehiclePromptState.nearby && avatarState.enabled) {
            enterVehicle(vehiclePromptState.nearby);
            return;
          }

          return;
        }

        if (event.code === "KeyO") {
          event.preventDefault();

          if (vehicleDriveState.enabled) {
            exitVehicle();
          }
          return;
        }

        if (event.code === "KeyA" && !vehicleDriveState.enabled && !avatarState.enabled && avatar) {
          event.preventDefault();
          enableAvatarControl(avatarState.viewMode);
          return;
        }

        switch (event.code) {
        case "ShiftLeft":
        case "ShiftRight":
          avatarKeys.run = true;
          break;

        case "KeyW":
        case "ArrowUp":
          avatarKeys.forward = true;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyS":
        case "ArrowDown":
          avatarKeys.back = true;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyA":
        case "ArrowLeft":
          avatarKeys.left = true;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyD":
        case "ArrowRight":
          avatarKeys.right = true;
          recomputeAvatarMoveFromKeys();
          break;

        case "Space":
          event.preventDefault();
          avatarKeys.jump = true;
          if (!event.repeat) requestAvatarJump();
          break;

        case "KeyV":
          event.preventDefault();
          if (avatarState.enabled) {
            disableAvatarControl();
          } else {
            enableAvatarControl(avatarState.viewMode);
          }
          updateAvatarButtons();
          break;

        case "KeyC":
          event.preventDefault();
          if (avatarState.enabled) {
            const next = avatarState.viewMode === "third" ? "first" : "third";
            setAvatarViewMode(next, true);
            updateAvatarButtons();
          } else {
            avatarState.viewMode = avatarState.viewMode === "third" ? "first" : "third";
            updateAvatarButtons();
          }
          break;

        default:
          break;
        }
      }


      function onKeyUp(event) {
        const tag = event.target && event.target.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA") return;

        switch (event.code) {
        case "ShiftLeft":
        case "ShiftRight":
          avatarKeys.run = false;
          break;

        case "KeyW":
        case "ArrowUp":
          avatarKeys.forward = false;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyS":
        case "ArrowDown":
          avatarKeys.back = false;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyA":
        case "ArrowLeft":
          avatarKeys.left = false;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyD":
        case "ArrowRight":
          avatarKeys.right = false;
          recomputeAvatarMoveFromKeys();
          break;

        case "Space":
          avatarKeys.jump = false;
          break;

        default:
          break;
        }
      }







    // -------------------------------------------------------------------------
    // Boot
    // -------------------------------------------------------------------------

// Loads a default preset JSON file and applies it on top of DEFAULTS.
// This is used for bootstrapping a consistent “Default” scene state without persisting it.
      async function loadDefaultPresetFromFile(url) {
        const presetUrl = typeof url === "string" && url.trim() ? url.trim() : "presets/snow-Hello.json";

        try {
          const response = await fetch(presetUrl, { cache: "no-store" });

          if (!response.ok) {
            console.warn(
              "[snow] default preset fetch failed:",
              presetUrl,
              response.status,
              response.statusText
              );
            return;
          }

          const json = await response.json();

    // Accept both formats:
    // 1) { "v": 1, "settings": { ... } }
    // 2) { ...paramsDirectly }
          const srcSettings =
          json &&
          typeof json === "object" &&
          json.settings &&
          typeof json.settings === "object"
          ? json.settings
          : json;

          if (!srcSettings || typeof srcSettings !== "object") {
            console.warn("[snow] default preset JSON has no settings object");
            return;
          }

    // Merge onto DEFAULTS so missing keys get sane values
          const merged = Object.assign({}, DEFAULTS, srcSettings);

    // Apply with rebuild so procedural systems (including rocks) regenerate from preset values.
    // Do not persist boot defaults over user storage.
          applySettings(merged, {
            rebuild: true,
            updateGui: true,
            persist: false
          });
        } catch (e) {
          console.warn("[snow] default preset load failed", e);
        }
      }




      async function init() {
        loadLastSettings(params);

        const bootActiveWorldId = getActiveWorldId();
        let bootWorldSettings = null;

        if (bootActiveWorldId) {
          try {
            const rec = await idbGetWorld(bootActiveWorldId);
            if (rec && rec.settings && typeof rec.settings === "object") {
              bootWorldSettings = Object.assign({}, DEFAULTS, rec.settings);
            }
          } catch (e) {
            bootWorldSettings = null;
          }
        }

        setupScene();

        snowTex = makeRadialTexture(96);

        if (bootWorldSettings) {
          applySettings(bootWorldSettings, { rebuild: true, updateGui: false, persist: false });
          updateFogFromParams();
        } else {
          rebuildWorld();
        }

        setupGui();
        refreshGuiDisplays();
        refreshPresetList();

        handleResize();
        window.addEventListener("resize", handleResize, { passive: true });

        window.addEventListener("keydown", onKeyDown);
        window.addEventListener("keyup", onKeyUp);

        addEventListener("pagehide", () => saveLastNow(params), { capture: true });
        addEventListener("beforeunload", () => saveLastNow(params), { capture: true });
        addEventListener(
          "visibilitychange",
          () => {
            if (document.visibilityState === "hidden") saveLastNow(params);
          },
          { capture: true }
          );

        loadAllModels(() => {
          console.log("model ready");
        });

        loadAvatar();
        setupAvatarUI();

        bootWorldPickerOverlay();

        if (!bootActiveWorldId) {
          try {
            await loadDefaultPresetFromFile("presets/snow-Hello.json");
            updateFogFromParams();
          } catch (e) {
            console.warn("[snow] default preset load failed", e);
          }
        }

        renderer.setAnimationLoop(animate);
      }






      init();





    </script>
  </body>
  </html>
  