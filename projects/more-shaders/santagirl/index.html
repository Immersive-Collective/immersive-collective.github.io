<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Yolo - Nano</title>
  <link rel="icon" href="data:,">

  <meta name="viewport" content="width=device-width, minimal-ui, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"
  />

  <link rel="preload" href="fonts/minimalo-font/Minimalo-LVzzy.ttf" as="font" type="font/ttf" crossorigin>

  <script>
        // Conditional analytics loader: Skips on localhost/local dev, handles errors gracefully
    (function() {
            // Skip in local dev environments
      if (location.hostname === 'localhost' || location.hostname === '127.0.0.1' || location.hostname === '192.168.1.90' || location.protocol === 'file:') {
        return;
      }

            // Create script element dynamically
      const script = document.createElement('script');
      script.defer = true;
      script.src = 'https://analytics.mielniczuk.com/script.js';
      script.setAttribute('data-website-id', 'ff22cca0-067d-440f-98ba-2e4c176300ef');
      
            // Error handling: Log but don't block
      script.onerror = function() {
        console.warn('Analytics script failed to loadâ€”continuing without tracking.');
      };
      
            // Append to head (or body end) for async loading
      document.head.appendChild(script);
    })();
  </script>


  <style>


/* Target the game UI element or body for full coverage */
body {
  /* Core: Disables text selection across browsers */
  -webkit-user-select: none;  /* iOS Safari & Chrome */
  -moz-user-select: none;     /* Firefox */
  -ms-user-select: none;      /* IE/Edge */
  user-select: none;          /* Standard */

  /* iOS-specific: Hides the long-press callout menu */
  -webkit-touch-callout: none;

  /* Optional: Reduces tap highlight (blue glow) on interactive elements */
  -webkit-tap-highlight-color: transparent;

  /* For canvas-heavy games: Prevent accidental drag selection */
  -webkit-user-drag: none;
}


@font-face {
  font-family: "Minimalo";
  src: url("fonts/minimalo-font/Minimalo-LVzzy.ttf") format("truetype");
  font-weight: 400;
  font-style: normal;
  font-display: swap;
}

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #0a1220;
  font-family: "Minimalo", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}

button {
  font-family: "Minimalo", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  border-radius: 14px;
  border: 0px solid rgba(255, 255, 255, 0.18);
  background: rgba(0, 0, 0, 0.28);
  color: #fff;
  padding: 12px 14px;

}

.profile-btn {
  font-size: 14px;
  text-transform: uppercase;
}


#app {
  position: fixed;
  inset: 0;
}
.hud {
  position: fixed;
  left: 12px;
  top: 12px;
  font: 12px/1.4 "Minimalo", ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
  color: rgba(255,255,255,0.92);
  background: rgba(0,0,0,0.28);
  border: 1px solid rgba(255,255,255,0.14);
  border-radius: 12px;
  padding: 10px 12px;
  backdrop-filter: blur(8px);
  user-select: none;
  pointer-events: none;
  max-width: 380px;
}
.hud b {
  color: rgba(255,255,255,0.98);
}

.avatar-btn {
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.24);
  background: rgba(0,0,0,0.55);
  color: #f5f5f5;
  font-size: 12px;;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  cursor: pointer;
  backdrop-filter: blur(10px);

  pointer-events: auto;
}

.avatar-btn {
  padding: 4px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.24);
  background: rgba(0,0,0,0.55);
  color: #f5f5f5;
  font-size: 12px;;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  cursor: pointer;
  backdrop-filter: blur(10px);
}

.avatar-btn:hover {
  background: rgba(0,0,0,0.8);
}

.avatar-btn:active {
  background: rgba(0,0,0,0.95);
}

.avatar-btn__icon {
  width: 18px;
  height: 18px;
  display: inline-block;
  vertical-align: middle;
  margin-right: 8px;
  pointer-events: none;
  user-select: none;
}

.avatar-btn__text {
  display: inline-block;
  vertical-align: middle;
  white-space: nowrap;
}

.avatar-ui[data-layout="icons"] .avatar-btn__text {
  display: none;
}

.avatar-ui[data-layout="text"] .avatar-btn__icon {
  display: none;
}

.avatar-ui[data-layout="icons"] .avatar-btn__icon {
  margin-right: 0;
}

.avatar-ui[data-layout="icons"] .avatar-btn {
  width: 40px;
  height: 40px;
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

@media (max-width: 720px) {
  .avatar-ui {
    right: 0px;
    bottom: 0px;
    gap: 6px;
    flex-wrap: wrap;
    justify-content: flex-end;
    max-width: calc(100vw - 16px);
  }

  .avatar-btn {
    padding: 10px 12px;
    font-size: 12px;
  }
}






.border-stick-b {
  border-radius: 0.75rem 0.75rem 0 0;  
}


.joystick {
  position: fixed;
  left: 16px;
  bottom: 50px;
  width: 140px;
  height: 140px;
  border-radius: 999px;
  background: rgba(255,255,255,0.10);
  border: 1px solid rgba(255,255,255,0.18);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);

  z-index: 40;
  pointer-events: auto;

  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}

.joystick-inner {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 52px;
  height: 52px;
  margin-left: -26px;
  margin-top: -26px;
  border-radius: 999px;
  background: rgba(255,255,255,0.22);
  border: 1px solid rgba(255,255,255,0.22);

  pointer-events: none;

  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
}

.joystick--right {
  left: auto;
  right: 16px;
}


.vehicle-ui {
  position: fixed;
  bottom: 150px;
  left: 50%;
  transform: translate(-50%, -50%);
  max-width: 520px;
  width: auto;
  margin: 0;
  padding: 10px 12px;
  border-radius: 12px;
  color: #fff;
  background: rgba(0, 0, 0, 0.58);
  backdrop-filter: blur(10px);
  z-index: 25;
  display: none;
  pointer-events: auto;
}

.vehicle-ui__title {
  font-weight: 700;
  margin-bottom: 4px;
  line-height: 1.2;
  color: yellow;
}

.vehicle-ui__desc {
  opacity: 0.92;
  font-size: 14px;
  line-height: 1.25;
  margin-bottom: 10px;
}

.vehicle-ui__row {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  align-items: center;
}

.vehicle-quick-action {
  position: fixed;
  left: 50%;
  bottom: 76px;
  transform: translateX(-50%);
  z-index: 55;
  pointer-events: auto;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  -webkit-tap-highlight-color: transparent;
  min-width: 120px;
}



.kbd-help {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 60;
  background: rgba(0, 0, 0, 0.55);
  pointer-events: auto;
}

.kbd-help.is-open {
  display: flex;
}

.kbd-help__panel {
  width: min(520px, calc(100vw - 24px));
  background: rgba(18, 18, 18, 0.92);
  border: 1px solid rgba(255, 255, 255, 0.18);
  border-radius: 14px;
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
  padding: 14px 14px 12px 14px;
  color: rgba(255, 255, 255, 0.95);
}

.kbd-help__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 10px;
}

.kbd-help__title {
  font-weight: 700;
  font-size: 24px;;
  letter-spacing: 0.2px;
}

.kbd-help__grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 8px;
}

.kbd-help__row {
  display: flex;
  align-items: center;
  gap: 10px;
}

.kbd {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  min-width: 34px;
  padding: 4px 8px;
  border-radius: 8px;
  border: 1px solid rgba(255, 255, 255, 0.22);
  background: rgba(255, 255, 255, 0.08);
  font-size: 14px;;
  font-weight: 700;
  font-family: "Minimalo", ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  user-select: none;
}

.kbd--wide {
  min-width: 90px;
}

.kbd-help__text {
  font-size: 14px;;
  line-height: 1.25;
  color: rgba(255, 255, 255, 0.88);
}

.kbd-help__note {
  margin-top: 10px;
  font-size: 14px;;
  color: rgba(255, 255, 255, 0.75);
}





.edit-stack {
  position: fixed;
  right: 12px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 8px;
  z-index: 22;
  pointer-events: auto;
}

@media (max-width: 540px) {
  .edit-stack {
    right: 10px;
    top: calc(50% - 16px);
  }
}

.edit-transform-mode-btn {
  width: 44px;
  height: 44px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.24);
  background: rgba(0,0,0,0.55);
  color: #f5f5f5;
  font-size: 14px;
  font-weight: 800;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  display: none;
  align-items: center;
  justify-content: center;
  pointer-events: auto;
  cursor: pointer;
  backdrop-filter: blur(10px);
}

.edit-transform-mode-btn:hover {
  background: rgba(0,0,0,0.8);
}

.edit-transform-mode-btn:active {
  background: rgba(0,0,0,0.95);
}

.edit-transform-mode-btn[disabled] {
  opacity: 0.35;
  cursor: default;
}





.action-toast {
  position: fixed;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%) scale(0.98);
  padding: 10px 14px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.22);
  background: rgba(0,0,0,0.68);
  color: #f5f5f5;
  font-size: 14px;;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  opacity: 0;
  pointer-events: none;
  z-index: 25;
  backdrop-filter: blur(10px);
  transition: opacity 180ms ease, transform 180ms ease;
}

.action-toast.is-open {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
}


.edit-transform-mode-btn[disabled] {
  opacity: 0.35;
  cursor: default;
}

.profile-help {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 65;
  background: rgba(0, 0, 0, 0.55);
  pointer-events: auto;
}

.profile-help.is-open {
  display: flex;
}

.profile-help__panel {
  width: min(520px, calc(100vw - 24px));
  background: rgba(18, 18, 18, 0.92);
  border: 1px solid rgba(255, 255, 255, 0.18);
  border-radius: 14px;
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
  padding: 1.5rem;
  color: rgba(255, 255, 255, 0.95);
}

.profile-form {
  display: grid;
  grid-template-columns: 1fr;
  gap: 4px;
  margin-top: 6px;
}

.profile-field {
  display: grid;
  grid-template-columns: 1fr;
  gap: 4px;
}

.profile-label {
  font-size: 14px;;
  color: rgba(255, 255, 255, 0.78);
  letter-spacing: 0.2px;
}

.profile-input,
.profile-textarea {
  width: 100%;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.18);
  background: rgba(0, 0, 0, 0.35);
  color: rgba(255, 255, 255, 0.92);
  padding: 10px 10px;
  outline: none;
  font-size: 14px;;
  line-height: 1.2;
}

.profile-textarea {
  resize: none;
  min-height: 74px;
}

.profile-input:focus,
.profile-textarea:focus {
  border-color: rgba(255, 255, 255, 0.32);
  background: rgba(0, 0, 0, 0.45);
}

.profile-readonly {
  width: 100%;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.14);
  background: rgba(255, 255, 255, 0.06);
  color: rgba(255, 255, 255, 0.88);
  padding: 10px 10px;
  font-size: 14px;;
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  user-select: text;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.profile-color {
  height: 44px;
  padding: 4px 6px;
}

.profile-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 2px;
}


.world-picker {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 70;
  background: rgba(0, 0, 0, 0.62);
  pointer-events: auto;
  padding: 12px;
}

.world-picker.is-open {
  display: flex;
}

@media (max-width: 540px) {
  .world-picker {
    align-items: flex-end;
    padding: 0;
  }
}

.world-picker__panel {
  width: min(920px, calc(100vw - 24px));
  max-height: min(760px, calc(100vh - 24px));
  overflow: hidden;
  display: flex;
  flex-direction: column;
  background: rgba(18, 18, 18, 0.92);
  border: 1px solid rgba(255, 255, 255, 0.18);
  border-radius: 14px;
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
  padding: 14px 14px 12px 14px;
  color: rgba(255, 255, 255, 0.95);
}

@media (max-width: 540px) {
  .world-picker__panel {
    width: 100vw;
    max-height: calc(100vh - env(safe-area-inset-top));
    border-radius: 16px 16px 0 0;
    padding: 12px 12px calc(12px + env(safe-area-inset-bottom)) 12px;
  }
}

.world-picker__save {
  display: none;
  gap: 10px;
  margin-bottom: 12px;
}

.world-picker.is-editing .world-picker__save {
  display: grid;
}

.world-picker__save-row {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 2px;
}




.world-picker__list {
  display: flex;
  flex-direction: column;
  gap: 14px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  flex: 1 1 auto;
  min-height: 0;
  padding: 2px;

  scrollbar-width: none;
  -ms-overflow-style: none;
}

.world-picker__section {
  display: flex;
  flex-direction: column;
  gap: 10px;
  padding: 2px 2px 10px;
  border-bottom: 1px solid rgba(255, 255, 255, 0.10);
}

.world-picker__section:last-child {
  border-bottom: none;
  padding-bottom: 2px;
}

.world-picker__sectionHead {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 10px;
}

.world-picker__sectionTitle {
  font-size: 12px;
  font-weight: 850;
  letter-spacing: 0.14em;
  text-transform: uppercase;
  color: rgba(255, 255, 255, 0.90);
}

.world-picker__sectionMeta {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.62);
  white-space: nowrap;
}

.world-picker__sectionGrid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 10px;
}

@media (min-width: 720px) {
  .world-picker__sectionGrid {
    grid-template-columns: 1fr 1fr;
  }
}

@media (min-width: 1040px) {
  .world-picker__sectionGrid {
    grid-template-columns: 1fr 1fr 1fr;
  }
}

.world-picker__empty {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.62);
  padding: 6px 2px 0;
}

.world-picker__footer {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 8px;
}


.world-card {
  border: 2px solid rgba(255, 255, 255, 0.16);
  border-radius: 12px;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.35);
  position: relative;
  height: clamp(220px, 32vw, 290px);
  display: block;
  isolation: isolate;
}

.world-card.is-active {
  border-color: rgba(34, 197, 94, 0.60);
}

.world-card__thumb {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  background: rgba(255, 255, 255, 0.06);
  display: block;
  transform: scale(1.01);
  filter: saturate(1.02) contrast(1.02);
}

.world-card__body {
  position: absolute;
  inset: 0;
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: linear-gradient(
    to bottom,
    rgba(0, 0, 0, 0.74),
    rgba(0, 0, 0, 0.22) 48%,
    rgba(0, 0, 0, 0.84)
  );
  color: rgba(255, 255, 255, 0.95);
  z-index: 2;
}


.world-card__titleRow {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  min-width: 0;
}

.world-card__title {
  font-weight: 700;
  font-size: 22px;;
  letter-spacing: 0.2px;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.85);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  min-width: 0;
  flex: 1 1 auto;
}

.world-card__meta {
  font-size: 12px;
  opacity: 0.85;
  white-space: nowrap;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.85);
  flex: 0 0 auto;
}

.world-card__desc {
  font-size: 12px;
  opacity: 0.92;
  line-height: 1.25;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.85);
  overflow: hidden;
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: 3;
  max-height: 3.75em;
}

.world-card__actions {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  justify-content: flex-end;
  align-items: center;
  margin-top: auto;
}

.world-card .avatar-btn {
  padding: 6px 10px;
  font-size: 12px;;
  touch-action: manipulation;
}

@media (max-width: 420px) {
  .world-card {
    height: 230px;
  }

  .world-card__body {
    padding: 10px 10px 12px 10px;
    gap: 8px;
  }

  .world-card__title {
    font-size: 14px;;
  }

  .world-card__desc {
    font-size: 12px;
    -webkit-line-clamp: 2;
    max-height: 2.5em;
  }

  .world-card__actions {
    gap: 6px;
  }
}

.world-name {
  position: fixed;
  left: 50%;
  top: calc(30px + env(safe-area-inset-top));
  transform: translateX(-50%);
  padding: 6px 10px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgb(192 192 192 / 42%);
  color: rgb(50 50 50 / 92%);
  font-size: 22px;;
  font-weight: 800;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  z-index: 23;
  pointer-events: none;
  backdrop-filter: blur(10px);
  max-width: min(84vw, 520px);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.world-name[aria-hidden="true"] {
  display: none;
}

.world-name.is-edit {
  background: rgba(15, 255, 0, 0.22);
  border-color: rgba(15, 255, 0, 0.95);
  color: white;
}

.inventory-picker {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 70;
  background: rgba(0, 0, 0, 0.62);
  pointer-events: auto;
  padding: 12px;
}

.inventory-picker.is-open {
  display: flex;
}

@media (max-width: 540px) {
  .inventory-picker {
    align-items: flex-end;
    padding: 0;
  }
}

.inventory-picker__panel {
  width: min(760px, calc(100vw - 24px));
  max-height: min(720px, calc(100vh - 24px));
  overflow: hidden;
  display: flex;
  flex-direction: column;
  background: rgba(18, 18, 18, 0.92);
  border: 1px solid rgba(255, 255, 255, 0.18);
  border-radius: 14px;
  box-shadow: 0 14px 40px rgba(0, 0, 0, 0.55);
  padding: 14px 14px 12px 14px;
  color: rgba(255, 255, 255, 0.95);
}

@media (max-width: 540px) {
  .inventory-picker__panel {
    width: 100vw;
    max-height: calc(100vh - env(safe-area-inset-top));
    border-radius: 16px 16px 0 0;
    padding: 12px 12px calc(12px + env(safe-area-inset-bottom)) 12px;
  }
}

.inventory-picker__list {
  display: grid;
  grid-template-columns: repeat(2, minmax(0, 1fr));
  gap: 10px;
  overflow: auto;
  -webkit-overflow-scrolling: touch;
  flex: 1 1 auto;
  min-height: 0;
  padding: 2px;
  scrollbar-width: none;
}

.inventory-picker__list::-webkit-scrollbar {
  width: 0;
  height: 0;
}

@media (min-width: 720px) {
  .inventory-picker__list {
    grid-template-columns: repeat(4, minmax(0, 1fr));
  }
}

.inv-slot {
  border: 1px solid rgba(255, 255, 255, 0.16);
  border-radius: 12px;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.35);
  display: flex;
  flex-direction: column;
  min-height: 168px;
}

.inv-slot--empty {
  background: rgba(255, 255, 255, 0.04);
  border-style: dashed;
}

.inv-slot__empty {
  margin: auto;
  font-size: 12px;
  opacity: 0.75;
  letter-spacing: 0.06em;
  text-transform: uppercase;
}

.inv-item__thumb {
  width: 100%;
  height: 92px;
  object-fit: cover;
  background: rgba(255, 255, 255, 0.06);
  display: block;
}

.inv-item__body {
  padding: 10px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  color: white;
}

.inv-item__name {
  font-weight: 800;
  font-size: 13px;
  letter-spacing: 0.2px;
  line-height: 1.2;
}

.inv-item__desc {
  font-size: 12px;
  opacity: 0.86;
  line-height: 1.25;
  min-height: 2.5em;
}






.avatar-picker {
  display: grid;
  grid-template-columns: 52px 1fr 52px;
  gap: 0px;
  align-items: center;
  width: 100%;
  margin-top: 6px;
}

.avatar-picker__nav {
  height: 52px;
  width: 52px;
  border-radius: 14px;
  border: 0px solid rgba(255,255,255,0.18);
  background: rgba(0,0,0,0.28);
  color: #ffeb3b;
  font-weight: 900;
  font-size: 22px;
  display: grid;
  place-items: center;
  cursor: pointer;
  touch-action: manipulation;
}

.avatar-picker__nav:active {
  transform: translateY(1px);
}

.avatar-picker__card {
  position: relative;
  border-radius: 16px;
  border: 0px solid rgba(255,255,255,0.18);
  background: rgba(0,0,0,0);
  overflow: hidden;
  padding: 2px;
  display: flex;
  flex-direction: column;
  gap: 2px;
  min-height: clamp(280px, 38vh, 420px);
}

.avatar-picker__thumb {
  width: 100%;
  height: clamp(190px, 26vh, 360px);
  border-radius: 14px;
  object-fit: contain;
  object-position: center center;
  background: radial-gradient(circle, rgba(255, 255, 255, 0.25) 0%, rgba(255, 255, 255, 0) 66%);
  border: 0px solid rgba(255,255,255,0.10);
  cursor: pointer;
  touch-action: manipulation;
}

.avatar-picker__meta {
  display: grid;
  gap: 4px;
  align-content: start;
  min-width: 0;
  padding: 0 2px;
}

.avatar-picker__title {
  font-weight: 900;
  font-size: 18px;
  line-height: 1.2;
  letter-spacing: 0.2px;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}

.avatar-picker__desc {
  font-size: 13px;
  line-height: 1.25;
  opacity: 0.88;
  overflow: hidden;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.avatar-picker__badge {
  position: absolute;
  top: 20px;
  right: 0px;
  font-size: 12px;
  padding: 6px 10px;
  border-radius: 999px;
  border: 0px solid rgba(255,255,255,0.18);
  background: rgba(0,0,0,0.32);
}

.avatar-picker__actions {
  display: flex;
  justify-content: flex-end;
  gap: 10px;
  margin-top: 8px;
}

.avatar-picker__select {
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(0,0,0,0.28);
  color: #fff;
  padding: 12px 14px;
  font-weight: 900;
  cursor: pointer;
  touch-action: manipulation;
}

.avatar-picker__select[disabled] {
  opacity: 0.45;
  cursor: default;
}

@media (max-width: 520px) {
  .avatar-picker {
    grid-template-columns: 44px 1fr 44px;
    gap: 1px;
  }

  .avatar-picker__nav {
    height: 44px;
    width: 44px;
    border-radius: 14px;
    font-size: 20px;
  }

  .avatar-picker__card {
    padding: 10px;
    min-height: clamp(260px, 36vh, 380px);
  }

  .avatar-picker__thumb {
    height: clamp(180px, 24vh, 280px);
  }

  .avatar-picker__title {
    font-size: 16px;
  }

  .avatar-picker__desc {
    font-size: 12px;
  }
}



.minimap {
  position: fixed;
  left: calc(8px + env(safe-area-inset-left));
  top: calc(8px + env(safe-area-inset-top));
  width: var(--minimap-size, 160px);
  height: var(--minimap-size, 160px);
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(0,0,0,0.35);
  box-shadow: 0 10px 30px rgba(0,0,0,0.35);
  padding: 0;
  overflow: hidden;
  z-index: 22;
  pointer-events: auto;
  cursor: pointer;
  backdrop-filter: blur(10px);
  -webkit-tap-highlight-color: transparent;
}

.minimap:active {
  transform: translateY(1px);
}

.minimap.is-medium {
  --minimap-size: 320px;
  border-radius: 18px;
}

.minimap__canvas {
  display: block;
  width: 100%;
  height: 100%;
}

.map-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  padding: calc(16px + env(safe-area-inset-top))
  calc(16px + env(safe-area-inset-right))
  calc(16px + env(safe-area-inset-bottom))
  calc(16px + env(safe-area-inset-left));
  background: rgba(0,0,0,0.45);
  z-index: 60;
  pointer-events: auto;
  backdrop-filter: blur(10px);
}

.map-overlay.is-open {
  display: flex;
}

.map-overlay__panel {
  width: min(96vw, 980px);
  height: min(90vh, 980px);
  border-radius: 22px;
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(12,12,12,0.65);
  box-shadow: 0 18px 60px rgba(0,0,0,0.55);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.map-overlay__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
}

.map-overlay__title {
  font-size: 14px;
  font-weight: 800;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(255,255,255,0.92);
}

.map-overlay__canvas {
  width: 100%;
  height: 100%;
  display: block;
  flex: 1 1 auto;
}

@media (max-width: 520px) {
  .minimap { --minimap-size: 132px; border-radius: 14px; }
  .minimap.is-medium { --minimap-size: 240px; border-radius: 16px; }
  .map-overlay__panel { width: 96vw; height: 86vh; border-radius: 18px; }
}



/* Minimal reset only for title container */
.doggerland-wrapper {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 9999;
}

.doggerland-title {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: clamp(4rem, 10vw, 12rem);
  background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #feca57, #ff9ff3, #54a0ff);
  background-size: 400% 400%;
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: doggerlandGradientShift 30s ease-in-out infinite;
  text-align: center;
  letter-spacing: 0.1em;
  text-shadow: 0 0 20px rgba(255, 255, 255, 0.3);
  text-transform: uppercase;
  white-space: nowrap;
  pointer-events: none;
  font-family: "Minimalo";
}

@keyframes doggerlandGradientShift {
  0% {
    background-position: 0% 50%;
  }
  50% {
    background-position: 100% 50%;
  }
  100% {
    background-position: 0% 50%;
  }
}

@media (max-width: 480px) {
  .doggerland-title {
    font-size: clamp(3rem, 8vw, 8rem);
    letter-spacing: 0.05em;
  }
}

.snapshots-overlay {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  padding: calc(16px + env(safe-area-inset-top))
  calc(16px + env(safe-area-inset-right))
  calc(16px + env(safe-area-inset-bottom))
  calc(16px + env(safe-area-inset-left));
  background: rgba(0,0,0,0.45);
  z-index: 65;
  pointer-events: auto;
  backdrop-filter: blur(10px);
}

.snapshots-overlay.is-open {
  display: flex;
}

.snapshots-overlay__panel {
  width: min(96vw, 760px);
  height: min(90vh, 860px);
  border-radius: 22px;
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(12,12,12,0.65);
  box-shadow: 0 18px 60px rgba(0,0,0,0.55);
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.snapshots-overlay__header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
  padding: 12px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.10);
}

.snapshots-overlay__title {
  font-size: 14px;
  font-weight: 800;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: rgba(255,255,255,0.92);
}

.snapshots-overlay__meta {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 10px;
  padding: 10px 12px;
  border-bottom: 1px solid rgba(255,255,255,0.08);
}

.snapshots-overlay__world {
  font-size: 13px;
  font-weight: 700;
  color: rgba(255,255,255,0.86);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.snapshots-overlay__hint {
  font-size: 12px;
  color: rgba(255,255,255,0.62);
  white-space: nowrap;
}

.snapshots-list {
  flex: 1 1 auto;
  overflow: auto;
  padding: 12px;
  display: grid;
  grid-template-columns: 1fr;
  gap: 10px;
}

.snapshot-item {
  width: 100%;
  display: grid;
  grid-template-columns: 160px 1fr;
  gap: 12px;
  align-items: center;
  border-radius: 16px;
  border: 1px solid rgba(255,255,255,0.12);
  background: rgba(0,0,0,0.22);
  padding: 10px;
  color: rgba(255,255,255,0.92);
  cursor: pointer;
  text-align: left;
}

.snapshot-item:hover {
  border-color: rgba(255,255,255,0.20);
  background: rgba(0,0,0,0.28);
}

.snapshot-item:active {
  transform: translateY(1px);
}

.snapshot-item__thumb {
  width: 160px;
  height: 90px;
  border-radius: 12px;
  object-fit: cover;
  background: rgba(255,255,255,0.06);
  border: 1px solid rgba(255,255,255,0.10);
}

.snapshot-item__meta {
  min-width: 0;
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.snapshot-item__world {
  font-size: 13px;
  font-weight: 800;
  color: rgba(255,255,255,0.92);
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.snapshot-item__time {
  font-size: 12px;
  color: rgba(255,255,255,0.66);
}

.snapshots-empty {
  display: none;
  padding: 18px 12px 22px;
  text-align: center;
  color: rgba(255,255,255,0.66);
  font-size: 13px;
}

.snapshots-empty.is-open {
  display: block;
}

@media (max-width: 520px) {
  .snapshots-overlay__panel { width: 96vw; height: 86vh; border-radius: 18px; }
  .snapshot-item { grid-template-columns: 120px 1fr; }
  .snapshot-item__thumb { width: 120px; height: 68px; border-radius: 10px; }
}


.hud-tile {
  position: fixed;
  left: calc(8px + env(safe-area-inset-left));
  top: calc(8px + env(safe-area-inset-top) + var(--minimap-size, 160px) + 10px);
  width: var(--minimap-size, 160px);
  min-height: 64px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.16);
  background: rgba(0,0,0,0.35);
  box-shadow: 0 10px 30px rgba(0,0,0,0.30);
  backdrop-filter: blur(10px);
  padding: 10px 12px;
  z-index: 22;
  pointer-events: none;
  font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial, "Apple Color Emoji", "Segoe UI Emoji";
  color: rgba(255,255,255,0.92);
}

.hud-tile__row {
  display: flex;
  align-items: baseline;
  justify-content: space-between;
  gap: 10px;
}

.hud-tile__label {
  font-size: 0.6rem;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  opacity: 0.75;
}

.hud-tile__value {
  font-size: 12px;
  font-weight: 700;
}

.hud-tile__value_sm {
  font-size: 10px;
  font-weight: 700;
}


.hud-tile__meta {
  margin-top: 6px;
  font-size: 12px;
  opacity: 0.85;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
}


.hud-tile__bar { margin-top: 6px; }
.hud-tile__bar-top { display:flex; gap:6px; align-items:center; font-size: 12px; opacity: 0.9; }
.hud-tile__bar-track { height: 6px; border-radius: 6px; overflow: hidden; background: rgba(255,255,255,0.15); margin-top: 4px; }
.hud-tile__bar-fill { height: 100%; background: rgba(34,197,94,0.95); }
.hud-tile__bar-sep { opacity: 0.6; }


/* Edit World visual cue on main WebGL canvas */
canvas.world-edit-on {
  box-sizing: border-box;
  border: 0.25rem solid #0fff00;
  border-radius: 1rem;
}

/* Toggled button style (used by existing UI update code) */
.avatar-btn.is-on {
  background: rgba(15, 255, 0, 1);
  border-color: rgba(15, 255, 0, 1);
  color: black;
}


.now-playing {
  position: fixed;
  left: 50%;
  top: calc(75px + env(safe-area-inset-top));
  transform: translateX(-50%);
  width: min(50vw, 520px);
  z-index: 23;
  pointer-events: auto;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgb(0 0 0 / 28%);
  backdrop-filter: blur(10px);
  color: rgba(255,255,255,0.92);
}

.now-playing[aria-hidden="true"] {
  display: none;
}

.now-playing__row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  margin-bottom: 8px;
}

.now-playing__title {
  font-size: 12px;
  font-weight: 700;
  letter-spacing: 0.04em;
  text-transform: uppercase;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
  max-width: 70%;
}

.now-playing__time {
  font-size: 12px;
  opacity: 0.9;
  flex: 0 0 auto;
}

.now-playing__seek {
  width: 100%;
  margin: 0 0 8px 0;
}

.now-playing__controls {
  display: flex;
  gap: 8px;
  justify-content: center;
}

.now-playing__btn {
  padding: 6px 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.18);
  background: rgba(255,255,255,0.08);
  color: rgba(255,255,255,0.92);
  font-weight: 700;
  cursor: pointer;
}

.now-playing__btn--primary {
  background: rgba(255,255,255,0.18);
}


.now-playing.now-playing--disabled {
  opacity: 0.65;
  filter: grayscale(0.2);
}


.avatar-btn__icon {
  width: 18px;
  height: 18px;
  display: inline-block;
  vertical-align: middle;
  margin-right: 8px;
  pointer-events: none;
  user-select: none;
}

.avatar-btn__text {
  display: inline-block;
  vertical-align: middle;
  white-space: nowrap;
}

.avatar-ui.avatar-ui--icons .avatar-btn__text {
  display: none;
}

.avatar-ui.avatar-ui--icons .avatar-btn__icon {
  margin-right: 0;
}

.avatar-ui.avatar-ui--icons .avatar-btn {
  width: 40px;
  height: 40px;
  padding: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

@media (max-width: 720px) {
  .avatar-ui {
    right: 8px;
    bottom: 0px;
    gap: 6px;
    flex-wrap: wrap;
    justify-content: center;
    max-width: calc(100vw - 16px);
    width: 100%;
  }

  .avatar-btn {
    padding: 10px 12px;
    font-size: 12px;
  }
}




</style>



<!-- Import map for Three.js -->
<script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.182.0/build/three.module.js",
      "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.182.0/examples/jsm/"
    }
  }
</script>


</head>


<body>


  <div id="app"></div>


<!--   <div class="doggerland-wrapper" id="doggerland-root">
    <div class="doggerland-title" id="doggerland-title">Doggerland</div>
  </div>
  -->  

  <div id="worldName" class="world-name" aria-hidden="true" aria-live="polite"></div>


  <div id="nowPlaying" class="now-playing" aria-hidden="true">
    <div class="now-playing__row">
      <div id="nowPlayingTitle" class="now-playing__title">â€”</div>
      <div id="nowPlayingTime" class="now-playing__time">0:00 / 0:00</div>
    </div>

    <input id="nowPlayingSeek" class="now-playing__seek" type="range" min="0" max="1" step="0.001" value="0" aria-label="Seek" />

    <div class="now-playing__controls">
      <button id="nowPlayingPrev" class="now-playing__btn" type="button">Prev</button>
      <button id="nowPlayingPlay" class="now-playing__btn now-playing__btn--primary" type="button">Play</button>
      <button id="nowPlayingNext" class="now-playing__btn" type="button">Next</button>
    </div>
  </div>




  <button id="miniMap" class="minimap" type="button" aria-label="Open map">
    <canvas id="miniMapCanvas" class="minimap__canvas"></canvas>
  </button>

  

  <div id="hudTile" class="hud-tile" aria-hidden="false">
    <div class="hud-tile__row">
      <span class="hud-tile__label">ALT</span>
      <span id="hudAltValue" class="hud-tile__value">0.0m</span>
    </div>

    <div class="hud-tile__row">
      <span class="hud-tile__label">DIST</span>
      <span id="hudDistValue" class="hud-tile__value">0m</span>
    </div>

    <div class="hud-tile__row">
      <span class="hud-tile__label">TIME</span>
      <span id="hudTimeValue" class="hud-tile__value">0:00</span>
    </div>

    <div class="hud-tile__row">
      <span class="hud-tile__label">STEPS</span>
      <span id="hudStepsValue" class="hud-tile__value">0</span>
    </div>

    <div class="hud-tile__row">
      <span class="hud-tile__label">E</span>
      <span id="hudKcalValue" class="hud-tile__value_sm">0kcal (0kJ)</span>
    </div>

    <div class="hud-tile__bar">
      <div class="hud-tile__bar-top">
        <span class="hud-tile__label">HEALTH</span>
        <span id="hudHealthValue" class="hud-tile__bar-value">100%</span>
        <span class="hud-tile__bar-sep">â€¢</span>
        <span class="hud-tile__bar-label">ðŸ©·</span>
        <span id="hudLivesValue" class="hud-tile__bar-value"></span>
      </div>
      <div class="hud-tile__bar-track" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="100">
        <div id="hudHealthFill" class="hud-tile__bar-fill" style="width:100%"></div>
      </div>
    </div>

    <div id="hudProfileMeta" class="hud-tile__meta">Anonymous â€¢ 0 badges</div>
  </div>







  <div id="mapOverlay" class="map-overlay" aria-hidden="true">
    <div class="map-overlay__panel" role="dialog" aria-modal="true" aria-label="Map">
      <div class="map-overlay__header">
        <div class="map-overlay__title">Map</div>
        <button id="mapOverlayClose" class="avatar-btn" type="button">Close</button>
      </div>
      <canvas id="mapOverlayCanvas" class="map-overlay__canvas"></canvas>
    </div>
  </div>






  <div class="avatar-ui avatar-ui--text" data-layout="text">
    <button id="avatarToggle" class="avatar-btn border-stick-b" type="button" aria-label="Avatar">
      <img class="avatar-btn__icon" src="assets/images/icons/white/human.svg" alt="" aria-hidden="true">
      <span class="avatar-btn__text">Avatar: OFF</span>
    </button>

    <button id="avatarViewToggle" class="avatar-btn border-stick-b" type="button" aria-label="View">
      <img class="avatar-btn__icon" src="assets/images/icons/white/eye.svg" alt="" aria-hidden="true">
      <span class="avatar-btn__text">V: Behind</span>
    </button>

    <button id="worldEditToggle" class="avatar-btn border-stick-b" type="button" aria-label="Edit World">
      <img class="avatar-btn__icon" src="assets/images/icons/white/edit.svg" alt="" aria-hidden="true">
      <span class="avatar-btn__text">Edit: OFF</span>
    </button>

    <button id="worldsBtn" class="avatar-btn border-stick-b" type="button" aria-label="Worlds">
      <img class="avatar-btn__icon" src="assets/images/icons/white/globe.svg" alt="" aria-hidden="true">
      <span class="avatar-btn__text">Worlds</span>
    </button>

    <button id="saveWorldBtn" class="avatar-btn border-stick-b" type="button" aria-label="Save World">
      <img class="avatar-btn__icon" src="assets/images/icons/white/save.svg" alt="" aria-hidden="true">
      <span class="avatar-btn__text">Save</span>
    </button>

    <button id="inventoryBtn" class="avatar-btn border-stick-b" type="button" aria-label="Inventory">
      <img class="avatar-btn__icon" src="assets/images/icons/white/inventory.svg" alt="" aria-hidden="true">
      <span class="avatar-btn__text">Inventory</span>
    </button>

    <button id="playerProfileBtn" class="avatar-btn border-stick-b" type="button" aria-label="Profile">
      <img class="avatar-btn__icon" src="assets/images/icons/white/profile.svg" alt="" aria-hidden="true">
      <span class="avatar-btn__text">Profile</span>
    </button>

    <button id="avatarUiModeToggle" class="avatar-btn border-stick-b" type="button" aria-label="UI layout">
      <img class="avatar-btn__icon" src="assets/images/icons/white/change.svg" alt="" aria-hidden="true">
      <span class="avatar-btn__text">UI: TEXT</span>
    </button>
  </div>







  <div id="worldEditStack" class="edit-stack" aria-hidden="true">
    <button id="worldEditUndoBtn" class="edit-transform-mode-btn" type="button" aria-label="Undo edit action" aria-hidden="true">â†¶</button>
    <button id="worldEditRedoBtn" class="edit-transform-mode-btn" type="button" aria-label="Redo edit action" aria-hidden="true">â†·</button>
    <button id="worldEditTransformMode" class="edit-transform-mode-btn" type="button" aria-label="Edit transform mode" aria-hidden="true">P</button>
    <button id="worldEditAddBtn" class="edit-transform-mode-btn" type="button" aria-label="Add object to world" aria-hidden="true">+</button>
    <button id="worldEditDuplicateBtn" class="edit-transform-mode-btn" type="button" aria-label="Duplicate selected model" aria-hidden="true">D</button>
    <button id="worldEditDeleteBtn" class="edit-transform-mode-btn" type="button" aria-label="Delete selected model" aria-hidden="true">X</button>
  </div>



  <div id="actionToast" class="action-toast" aria-hidden="true"></div>




  <div id="joystick" class="joystick">
    <div id="joystickInner" class="joystick-inner"></div>
  </div> 

  <div id="joystickRight" class="joystick joystick--right">
    <div id="joystickRightInner" class="joystick-inner"></div>
  </div>

  <button id="vehicleQuickActionBtn" class="avatar-btn vehicle-quick-action" type="button" aria-hidden="true" style="display:none;"></button>

  <div id="vehiclePrompt" class="vehicle-ui" aria-hidden="false">
    <div id="vehiclePromptTitle" class="vehicle-ui__title">Small Plane</div>
    <div id="vehiclePromptDesc" class="vehicle-ui__desc">Wearable backpack 1</div>
    <div class="vehicle-ui__row">
      <button id="vehicleEnterBtn" class="avatar-btn">Equip</button>
      <button id="vehicleExitBtn" class="avatar-btn" style="display:none;">Unequip</button>
      <button id="vehicleCloseBtn" class="avatar-btn">Close</button>
    </div>
  </div>



<!-- Updated keyboard help to match current keybinds -->
<div id="keyboardHelp" class="kbd-help" aria-hidden="true">
  <div class="kbd-help__panel" role="dialog" aria-modal="true" aria-label="Keyboard controls">
    <div class="kbd-help__header">
      <div class="kbd-help__title">Keyboard</div>
      <button id="keyboardHelpClose" class="avatar-btn">Close</button>
    </div>

    <div class="kbd-help__grid">
      <div class="kbd-help__row"><span class="kbd">V</span><span class="kbd-help__text">Toggle avatar control on/off</span></div>
      <div class="kbd-help__row"><span class="kbd">C</span><span class="kbd-help__text">Toggle camera view (third â†” first) when avatar is enabled</span></div>
      <div class="kbd-help__row"><span class="kbd">B</span><span class="kbd-help__text">Toggle chase camera behind avatar/vehicle</span></div>

      <div class="kbd-help__row"><span class="kbd">P</span><span class="kbd-help__text">Pause / resume simulation</span></div>
      <div class="kbd-help__row"><span class="kbd kbd--wide">Ctrl/Cmd+S</span><span class="kbd-help__text">Save current world</span></div>

      <div class="kbd-help__row"><span class="kbd kbd--wide">WASD / Arrows</span><span class="kbd-help__text">Move avatar (and drive vehicles when mounted)</span></div>
      <div class="kbd-help__row"><span class="kbd kbd--wide">Shift</span><span class="kbd-help__text">Run (avatar)</span></div>
      <div class="kbd-help__row"><span class="kbd kbd--wide">Space</span><span class="kbd-help__text">Jump (avatar) / Jetpack ascend (when equipped)</span></div>
      <div class="kbd-help__row"><span class="kbd">Q</span><span class="kbd-help__text">Jetpack descend (when equipped) / Edit mode: local â†” world space</span></div>

      <div class="kbd-help__row"><span class="kbd">E</span><span class="kbd-help__text">Interact: enter nearest vehicle / equip nearby item</span></div>
      <div class="kbd-help__row"><span class="kbd">O</span><span class="kbd-help__text">Exit vehicle / unequip item</span></div>

      <div class="kbd-help__row"><span class="kbd kbd--wide">Ctrl/Cmd+E</span><span class="kbd-help__text">Toggle Edit World mode</span></div>
      <div class="kbd-help__row"><span class="kbd">W</span><span class="kbd-help__text">Edit mode: Translate</span></div>
      <div class="kbd-help__row"><span class="kbd">T</span><span class="kbd-help__text">Edit mode: Rotate</span></div>
      <div class="kbd-help__row"><span class="kbd">R</span><span class="kbd-help__text">Edit mode: Scale</span></div>
      <div class="kbd-help__row"><span class="kbd kbd--wide">Shift+D</span><span class="kbd-help__text">Edit mode: Duplicate selection</span></div>
      <div class="kbd-help__row"><span class="kbd">X</span><span class="kbd-help__text">Edit mode: Delete selection</span></div>
      <div class="kbd-help__row"><span class="kbd kbd--wide">Ctrl/Cmd+Z</span><span class="kbd-help__text">Edit mode: Undo</span></div>
      <div class="kbd-help__row"><span class="kbd kbd--wide">Ctrl/Cmd+Shift+Z</span><span class="kbd-help__text">Edit mode: Redo</span></div>
      <div class="kbd-help__row"><span class="kbd kbd--wide">Ctrl/Cmd+Y</span><span class="kbd-help__text">Edit mode: Redo</span></div>

      <div class="kbd-help__row"><span class="kbd">F</span><span class="kbd-help__text">Toggle fullscreen</span></div>
      <div class="kbd-help__row"><span class="kbd kbd--wide">Esc</span><span class="kbd-help__text">Close overlays / toggle UI; exit fullscreen (if active)</span></div>
    </div>

    <div class="kbd-help__note">Toggle with Cmd+/ (Mac) or Ctrl+/ (Windows/Linux).</div>
  </div>
</div>

<div id="snapshotsOverlay" class="snapshots-overlay" aria-hidden="true">
  <div class="snapshots-overlay__panel" role="dialog" aria-modal="true" aria-label="Snapshots">
    <div class="snapshots-overlay__header">
      <div class="snapshots-overlay__title">Snapshots</div>
      <button id="snapshotsOverlayClose" class="avatar-btn" type="button">Close</button>
    </div>

    <div class="snapshots-overlay__meta">
      <div id="snapshotsOverlayWorld" class="snapshots-overlay__world"></div>
      <div class="snapshots-overlay__hint">F5 Save Â· F6 Load latest Â· F7 Toggle</div>
    </div>

    <div id="snapshotsList" class="snapshots-list" role="list"></div>
    <div id="snapshotsEmpty" class="snapshots-empty" aria-hidden="true">No snapshots yet.</div>
  </div>
</div>





<div id="playerProfile" class="profile-help" aria-hidden="true">
  <div class="profile-help__panel" role="dialog" aria-modal="true" aria-label="Player profile">
    <div class="kbd-help__header">
      <div class="kbd-help__title">Profile</div>
      <button id="playerProfileClose" class="avatar-btn">Close</button>
    </div>



    <div class="profile-form">
      <div class="profile-field">
        <label class="profile-label">Avatar</label>

        <div class="avatar-picker">
          <button class="avatar-picker__nav" id="avatarPrevBtn" type="button" aria-label="Previous avatar">â€¹</button>

          <div class="avatar-picker__card">
            <img class="avatar-picker__thumb" id="avatarPreviewImg" alt="" />
            <div class="avatar-picker__meta">
              <div class="avatar-picker__title" id="avatarPreviewName"></div>
              <div class="avatar-picker__desc" id="avatarPreviewDesc"></div>
            </div>
            <div class="avatar-picker__badge" id="avatarPreviewCounter"></div>
          </div>

          <button class="avatar-picker__nav" id="avatarNextBtn" type="button" aria-label="Next avatar">â€º</button>
        </div>

        <div class="avatar-picker__actions">
          <button class="avatar-picker__select" id="avatarSelectBtn" type="button">Select</button>
        </div>
      </div>

      <div class="profile-field" style="display:none;">
        <label class="profile-label">Player ID</label>
        <div class="profile-readonly" id="playerProfileId"></div>
      </div>

      <div class="profile-field">
        <label class="profile-label" for="playerNameInput">Display name</label>
        <input class="profile-input" id="playerNameInput" type="text" maxlength="32" autocomplete="nickname" />
      </div>

      <div class="profile-field" style="display:none;">
        <label class="profile-label" for="playerColorInput">Accent color</label>
        <input class="profile-input profile-input--color" id="playerColorInput" type="color" />
      </div>

      <div class="profile-field">
        <label class="profile-label" for="playerBioInput">About</label>
        <textarea class="profile-textarea" id="playerBioInput" maxlength="256" rows="3" placeholder="Optional short bio"></textarea>
        <div class="profile-help">Visible to other clients once networking is enabled.</div>
      </div>

      <div class="profile-actions">
        <button class="profile-btn profile-btn--secondary" id="playerProfileReset" type="button">Reset</button>
        <button class="profile-btn profile-btn--primary" id="playerProfileSave" type="button">Save</button>
      </div>
    </div>




  </div>
</div>

<div id="worldPicker" class="world-picker" aria-hidden="true">
  <div class="world-picker__panel" role="dialog" aria-modal="true" aria-label="Worlds">
    <div class="kbd-help__header">
      <div class="kbd-help__title">Worlds</div>
      <button id="worldPickerClose" class="kbd-help__close" type="button" aria-label="Close">âœ•</button>
    </div>

    <div class="world-picker__save">
      <div class="profile-field">
        <label class="profile-label" for="worldTitleInput">Title</label>
        <input id="worldTitleInput" class="profile-input" type="text" placeholder="Untitled" autocomplete="off" />
      </div>

      <div class="profile-field">
        <label class="profile-label" for="worldDescInput">Description</label>
        <textarea id="worldDescInput" class="profile-input" rows="2" placeholder="Short description"></textarea>
      </div>

      <div class="profile-actions">
        <button id="worldSaveBtn" class="avatar-btn" type="button">Save Current</button>
      </div>
    </div>

    <div id="worldPickerList" class="world-picker__list">
      <div class="world-picker__section">
        <div class="world-picker__sectionHead">
          <div class="world-picker__sectionTitle">Local Worlds</div>
          <div id="worldPickerLocalMeta" class="world-picker__sectionMeta"></div>
        </div>
        <div id="worldPickerListLocal" class="world-picker__sectionGrid"></div>
      </div>

      <div class="world-picker__section">
        <div class="world-picker__sectionHead">
          <div class="world-picker__sectionTitle">Private Cloud Worlds</div>
          <div id="worldPickerPrivateMeta" class="world-picker__sectionMeta"></div>
        </div>
        <div id="worldPickerListPrivate" class="world-picker__sectionGrid"></div>
      </div>

      <div class="world-picker__section">
        <div class="world-picker__sectionHead">
          <div class="world-picker__sectionTitle">Global Worlds</div>
          <div id="worldPickerGlobalMeta" class="world-picker__sectionMeta"></div>
        </div>
        <div id="worldPickerListGlobal" class="world-picker__sectionGrid"></div>
      </div>
    </div>

    <div class="world-picker__footer">
      <button id="worldImportBtn" class="avatar-btn" type="button">Import World</button>
    </div>

    <div class="kbd-help__note">Selecting a world reloads the page to fully swap loaded models.</div>
  </div>
</div>


<div id="inventoryPicker" class="inventory-picker" aria-hidden="true">
  <div class="inventory-picker__panel" role="dialog" aria-modal="true" aria-label="Inventory">
    <div class="kbd-help__header">
      <div class="kbd-help__title">Inventory</div>
      <button id="inventoryPickerClose" class="avatar-btn">Close</button>
    </div>

    <div id="inventoryPickerList" class="inventory-picker__list"></div>

    <div class="kbd-help__note">Mock inventory (items + empty slots). Thumbnails are placeholders for now.</div>
  </div>
</div>

<div id="worldObjectPicker" class="inventory-picker" aria-hidden="true">
  <div class="inventory-picker__panel" role="dialog" aria-modal="true" aria-label="World objects">
    <div class="kbd-help__header">
      <div class="kbd-help__title">Objects</div>
      <button id="worldObjectPickerClose" class="avatar-btn">Close</button>
    </div>

    <div id="worldObjectPickerList" class="inventory-picker__list"></div>

    <div class="kbd-help__note">Available world objects (Edit World only). Click an item to add it in front of the avatar.</div>
  </div>
</div>





<div class="hud" style="visibility: hidden;">
  <b>Snowdrifts + gusts + sticking snow + presets</b><br />
  Drag: orbit Â· Wheel: zoom Â· Right-drag: pan<br />
  Gust parameters, sticking, drifts, and presets are all controlled from the GUI.
</div>

<script type="module">


// Optional JS: Add subtle entrance animation on load
    // window.addEventListener('load', () => {
    //   const title = document.querySelector('.title');
    //   title.style.opacity = '0';
    //   title.style.transform = 'scale(0.8) translateY(20px)';

    //   title.animate([
    //     { opacity: 0, transform: 'scale(0.8) translateY(20px)' },
    //     { opacity: 1, transform: 'scale(1) translateY(0)' }
    //   ], {
    //     duration: 1000,
    //     easing: 'ease-out',
    //     fill: 'forwards'
    //   });
    // });



  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";
  import { TransformControls } from "three/addons/controls/TransformControls.js";
  import { VRButton } from "three/addons/webxr/VRButton.js";
  import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
  import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";    
  import GUI from "https://cdn.jsdelivr.net/npm/lil-gui@0.20/+esm";

    // -------------------------------------------------------------------------
    // Helpers / persistence utilities
    // -------------------------------------------------------------------------

  const PLAYER_PROFILE_STORAGE_KEY = "snow:playerProfile:v1";


  const DEFAULT_AVATAR_ID = "robots/optimus";

    /* Static avatar catalog for the Profile carousel (thumb + GLB share the same basename). */
  const AVATAR_CATALOG = [


    { id: "dolls/slashboy1", name: "Slash Boy", desc: "Slash Boy 1", url: "models/ready/dolls/slashboy3-anims.glb", thumb: "models/ready/dolls/slashboy3-anims.png" },

    { id: "dolls/masonboy1", name: "Mason Boy", desc: "Mason Boy 1", url: "models/ready/dolls/masonboy5-anims.glb", thumb: "models/ready/dolls/masonboy5-anims.png" },


    { id: "dolls/barbie1", name: "Pink Barbie", desc: "Barbie Pink 1", url: "models/ready/dolls/barbie1-anims.glb", thumb: "models/ready/dolls/barbie1-anims.png" },


    { id: "dolls/deluxe", name: "Barbie Deluxe", desc: "Barbie Deluxe 1", url: "models/ready/dolls/deluxe-anims.glb", thumb: "models/ready/dolls/deluxe-anims.png" },


    { id: "robots/optimus", name: "Optimus 1", desc: "Optimus 2026", url: "models/ready/robots/optimus-anims.glb", thumb: "models/ready/robots/optimus-anims.png" },


    { id: "astro/coco1", name: "Coco 1", desc: "Coco in Space 1", url: "models/ready/astro/coco-anims.glb", thumb: "models/ready/astro/coco-anims.png" },


    { id: "astro/cat1", name: "Astrocat 1", desc: "Cats in Space 1", url: "models/ready/astro/catastro-anims.glb", thumb: "models/ready/astro/catastro-anims.png" },


    { id: "female/afro1", name: "Lola 1", desc: "Lola in space 1", url: "models/ready/female/afro/6-anims.glb", thumb: "models/ready/female/afro/6-anims.png" },

    { id: "female/afro2", name: "Lola 2", desc: "Lola in space 2", url: "models/ready/female/afro/afro4-anims.glb", thumb: "models/ready/female/afro/afro4-anims.png" },



    { id: "male/musil1", name: "Ahmob", desc: "Ahmob bobo.", url: "models/ready/male/musils/musils1-anims.glb", thumb: "models/ready/male/musils/musils1-anims.png" },

    { id: "male/musil2", name: "Ahmob", desc: "Ahmob bobo 2.", url: "models/ready/male/musils/musils2-anims.glb", thumb: "models/ready/male/musils/musils2-anims.png" },

    { id: "female/blondie-anims", name: "Blondie", desc: "Female avatar.", url: "models/ready/female/blondie-anims.glb", thumb: "models/ready/female/blondie-anims.png" },


    { id: "female/avad", name: "Ava D", desc: "Female avatar.", url: "models/ready/female/avad/avad1-anims.glb", thumb: "models/ready/female/avad/avad1-anims.png" },

    { id: "female/skate1", name: "Skate Girl 1", desc: "Female avatar.", url: "models/ready/female/skate/vans5-anims.glb", thumb: "models/ready/female/skate/vans5-anims.png" },

    { id: "female/skate2", name: "Skate Girl 2", desc: "Female avatar.", url: "models/ready/female/skate/vans6-anims.glb", thumb: "models/ready/female/skate/vans6-anims.png" },

    { id: "female/skate3", name: "Skate Girl 3", desc: "Female avatar.", url: "models/ready/female/skate/latin2-anims.glb", thumb: "models/ready/female/skate/latin2-anims.png" },

    { id: "female/skate4", name: "Skate Girl 5", desc: "Female avatar.", url: "models/ready/female/skate/nord-anims.glb", thumb: "models/ready/female/skate/nord-anims.png" },

    { id: "female/skate5", name: "Skate Girl 6", desc: "Female avatar.", url: "models/ready/female/skate/japa-anims.glb", thumb: "models/ready/female/skate/japa-anims.png" },

    { id: "female/skate6", name: "Skate Girl 7", desc: "Female avatar.", url: "models/ready/female/skate/flo-anims.glb", thumb: "models/ready/female/skate/flo-anims.png" },

    { id: "female/skate7", name: "Skate Girl 8", desc: "Female avatar.", url: "models/ready/female/skate/max-anims.glb", thumb: "models/ready/female/skate/max-anims.png" },


    { id: "female/camouflage1", name: "Camouflage", desc: "Female avatar.", url: "models/ready/female/camouflage1.glb", thumb: "models/ready/female/camouflage1.png" },

    { id: "female/computer", name: "Computer", desc: "Female avatar.", url: "models/ready/female/computer.glb", thumb: "models/ready/female/computer.png" },

    { id: "female/crocs_anims", name: "Crocs", desc: "Female avatar.", url: "models/ready/female/crocs_anims.glb", thumb: "models/ready/female/crocs_anims.png" },

      // { id: "female/elizabeth", name: "Elizabeth", desc: "Female avatar.", url: "models/ready/female/elizabeth.glb", thumb: "models/ready/female/elizabeth.png" },

    { id: "female/pinky1-anims", name: "Pinky", desc: "Female avatar.", url: "models/ready/female/pinky1-anims.glb", thumb: "models/ready/female/pinky1-anims.png" },

    { id: "female/redsa1", name: "Redsa", desc: "Female avatar.", url: "models/ready/female/redsa1.glb", thumb: "models/ready/female/redsa1.png" },

    { id: "female/santa5", name: "Santa 5", desc: "Holiday avatar.", url: "models/ready/female/santa5.glb", thumb: "models/ready/female/santa5.png" },

    { id: "female/santa6", name: "Santa 6", desc: "Holiday avatar.", url: "models/ready/female/santa6.glb", thumb: "models/ready/female/santa6.png" },

      // { id: "female/santagirl", name: "Santa Girl", desc: "Holiday avatar.", url: "models/ready/female/santagirl.glb", thumb: "models/ready/female/santagirl.png" },

    { id: "female/santagirl2", name: "Santa Girl 2", desc: "Holiday avatar.", url: "models/ready/female/santagirl2.glb", thumb: "models/ready/female/santagirl2.png" },

    { id: "female/santagirl21-eu", name: "Santa Girl EU", desc: "Holiday avatar.", url: "models/ready/female/santagirl21-eu.glb", thumb: "models/ready/female/santagirl21-eu.png" },

    { id: "female/santagirl3", name: "Santa Girl 3", desc: "Holiday avatar.", url: "models/ready/female/santagirl3.glb", thumb: "models/ready/female/santagirl3.png" },

    { id: "female/santax1", name: "Santa X1", desc: "Holiday avatar.", url: "models/ready/female/santax1.glb", thumb: "models/ready/female/santax1.png" },

    { id: "female/santax2-a2", name: "Santa X2", desc: "Holiday avatar.", url: "models/ready/female/santax2-a2.glb", thumb: "models/ready/female/santax2-a2.png" },

    { id: "female/sanya-a", name: "Sanya", desc: "Female avatar.", url: "models/ready/female/sanya-a.glb", thumb: "models/ready/female/sanya-a.png" },


    { id: "female/she/she1_anims-anims", name: "She 1", desc: "Female avatar.", url: "models/ready/female/she/she1_anims-anims.glb", thumb: "models/ready/female/she/she1_anims-anims.png" },


      // { id: "female/sophie", name: "Sophie", desc: "Female avatar.", url: "models/ready/female/sophie.glb", thumb: "models/ready/female/sophie.png" },

    { id: "male/tripo/tripo_anims", name: "Tripo 1", desc: "Male avatar.", url: "models/ready/male/tripo/tripo_anims.glb", thumb: "models/ready/male/tripo/tripo_anims.png" },

    { id: "male/tripo/prisoner_anims", name: "Tripo 1", desc: "Male avatar.", url: "models/ready/male/tripo/prisoner_anims.glb", thumb: "models/ready/male/tripo/prisoner_anims.png" },

    { id: "aliens/alien_face2-anims", name: "Alien 1", desc: "Alien avatar.", url: "models/ready/aliens/alien_face2-anims.glb", thumb: "models/ready/aliens/alien_face2-anims.png" },


      // { id: "male/josh", name: "Josh", desc: "Male avatar.", url: "models/ready/male/josh.glb", thumb: "models/ready/male/josh.png" },

      // { id: "male/lewis", name: "Lewis", desc: "Male avatar.", url: "models/ready/male/lewis.glb", thumb: "models/ready/male/lewis.png" },

    { id: "male/tata/tata1-anims", name: "Tata 1", desc: "Male avatar.", url: "models/ready/male/tata/tata1-anims.glb", thumb: "models/ready/male/tata/tata1-anims.png" },


    { id: "male/tata/tata2-anims", name: "Tata 2", desc: "Male avatar.", url: "models/ready/male/tata/tata2-anims.glb", thumb: "models/ready/male/tata/tata2-anims.png" },
    { id: "male/tata/tata4_1-anims", name: "Tata 4.1", desc: "Male avatar.", url: "models/ready/male/tata/tata4_1-anims.glb", thumb: "models/ready/male/tata/tata4_1-anims.png" },
    { id: "male/tata/tata4_1-rework", name: "Tata 4.1 Rework", desc: "Male avatar.", url: "models/ready/male/tata/tata4_1-rework.glb", thumb: "models/ready/male/tata/tata4_1-rework.png" },
    { id: "male/tata/tata5_anim-anims", name: "Tata 5", desc: "Male avatar.", url: "models/ready/male/tata/tata5_anim-anims.glb", thumb: "models/ready/male/tata/tata5_anim-anims.png" }
  ];

    /* Returns catalog entry by id. */
  function getAvatarById(id) {
    const key = String(id ?? "").trim();
    for (let i = 0; i < AVATAR_CATALOG.length; i++) {
      if (AVATAR_CATALOG[i].id === key) return AVATAR_CATALOG[i];
    }
    return null;
  }

    /* Ensures avatarId always resolves to a catalog item. */
  function sanitizeAvatarId(id, fallback = DEFAULT_AVATAR_ID) {
    const key = String(id ?? "").trim();
    if (key && getAvatarById(key)) return key;
    const fb = String(fallback ?? "").trim();
    if (fb && getAvatarById(fb)) return fb;
    return AVATAR_CATALOG.length ? AVATAR_CATALOG[0].id : DEFAULT_AVATAR_ID;
  }



    /**
     * Creates a stable per-player id for future multiuser transport.
     */
  function makePlayerId() {
    try {
      const bytes = new Uint8Array(8);
      crypto.getRandomValues(bytes);
      let out = "";
      for (let i = 0; i < bytes.length; i++) out += bytes[i].toString(16).padStart(2, "0");
        return out;
    } catch {
      return Math.random().toString(16).slice(2) + Math.random().toString(16).slice(2);
    }
  }

    /**
     * Normalizes a display name for UI and future networking.
     */
  function sanitizePlayerName(name) {
    const s = String(name ?? "").trim().replace(/\s+/g, " ");
    if (!s) return "Anonymous";
    return s.slice(0, 32);
  }

  /**
   * Generates a default local profile (anonymous by default).
   */
  function createDefaultPlayerProfile() {
    const id = makePlayerId();
    return {
      v: 1,
      id,
      name: "Anonymous",
      color: "#22c55e",
      avatarId: sanitizeAvatarId(DEFAULT_AVATAR_ID, DEFAULT_AVATAR_ID),
      meta: { about: "" },

      stats: {
        v: 1,

        // Bio + progression
        health: 100,
        damage: 0,
        lives: 3,
        powers: [],
        badges: [],

        // Totals (across all worlds)
        steps: 0,
        distWalkM: 0,
        distVehicleM: 0,

        // Internal accumulator for converting walk distance -> steps
        __stepCarryM: 0,

        // Per-world rollups keyed by worldUiState.id
        worlds: {}
      }
    };
  }


    /**
     * Loads the local player profile from storage, falling back to defaults.
     */
  function loadPlayerProfile() {
    try {
      const raw = localStorage.getItem(PLAYER_PROFILE_STORAGE_KEY);
      if (!raw) return createDefaultPlayerProfile();

      const json = JSON.parse(raw);
      if (!json || typeof json !== "object") return createDefaultPlayerProfile();

      const p = createDefaultPlayerProfile();
      p.id = typeof json.id === "string" && json.id.trim() ? json.id.trim() : p.id;
      p.name = sanitizePlayerName(json.name);
      p.color = typeof json.color === "string" && /^#([0-9a-fA-F]{6})$/.test(json.color) ? json.color : p.color;
      p.avatarId = sanitizeAvatarId(json.avatarId, p.avatarId);

      if (json.meta && typeof json.meta === "object") {
        p.meta.about = typeof json.meta.about === "string" ? json.meta.about.slice(0, 256) : "";
      }

      if (json.stats && typeof json.stats === "object") {
        const s = json.stats;

        p.stats.health = Number.isFinite(+s.health) ? Math.max(0, Math.min(1000, +s.health)) : p.stats.health;
        p.stats.damage = Number.isFinite(+s.damage) ? Math.max(0, Math.min(1000, +s.damage)) : p.stats.damage;
        p.stats.lives = Number.isFinite(+s.lives) ? Math.max(0, Math.min(99, Math.floor(+s.lives))) : p.stats.lives;

        p.stats.steps = Number.isFinite(+s.steps) ? Math.max(0, Math.floor(+s.steps)) : p.stats.steps;
        p.stats.distWalkM = Number.isFinite(+s.distWalkM) ? Math.max(0, +s.distWalkM) : p.stats.distWalkM;
        p.stats.distVehicleM = Number.isFinite(+s.distVehicleM) ? Math.max(0, +s.distVehicleM) : p.stats.distVehicleM;

        p.stats.__stepCarryM = Number.isFinite(+s.__stepCarryM) ? Math.max(0, +s.__stepCarryM) : p.stats.__stepCarryM;

        p.stats.powers = Array.isArray(s.powers) ? s.powers.filter((x) => typeof x === "string").slice(0, 64) : p.stats.powers;
        p.stats.badges = Array.isArray(s.badges) ? s.badges.filter((x) => typeof x === "string").slice(0, 128) : p.stats.badges;

        if (s.worlds && typeof s.worlds === "object") {
          p.stats.worlds = s.worlds;
        }
      }

      return p;
    } catch {
      return createDefaultPlayerProfile();
    }
  }


    /**
     * Persists the local player profile.
     */
  function savePlayerProfile(profile) {
    try {
      localStorage.setItem(PLAYER_PROFILE_STORAGE_KEY, JSON.stringify(profile));
    } catch {}
  }


  const PLAYER_VITALS_STORAGE_KEY = "snow:playerVitals:v1";

  /* Creates the default vitals model used by stamina/energy/health systems. */
  function createDefaultPlayerVitals() {
    return {
      v: 1,
      stamina: 1,        // 0..1 (fatigue buffer)
      energyKcal: 0,     // stored energy; food adds here first
      lastDeathMs: 0
    };
  }

  /* Loads persisted vitals, falling back to defaults. */
  function loadPlayerVitals() {
    try {
      const raw = localStorage.getItem(PLAYER_VITALS_STORAGE_KEY);
      if (!raw) return createDefaultPlayerVitals();
      const json = JSON.parse(raw);
      if (!json || typeof json !== "object") return createDefaultPlayerVitals();

      const v = createDefaultPlayerVitals();
      v.stamina = Number.isFinite(+json.stamina) ? Math.max(0, Math.min(1, +json.stamina)) : v.stamina;
      v.energyKcal = Number.isFinite(+json.energyKcal) ? Math.max(0, +json.energyKcal) : v.energyKcal;
      v.lastDeathMs = Number.isFinite(+json.lastDeathMs) ? Math.max(0, +json.lastDeathMs) : v.lastDeathMs;
      return v;
    } catch {
      return createDefaultPlayerVitals();
    }
  }

  /* Persists vitals to localStorage. */
  function savePlayerVitals() {
    try {
      localStorage.setItem(PLAYER_VITALS_STORAGE_KEY, JSON.stringify(playerVitals));
    } catch {}
  }

  let playerVitals = loadPlayerVitals();



/* Audio System */
  let envAudioState = null;






/* HUD variables and helpers */


  let hudTileEl = null;
  let hudAltValueEl = null;
  let hudProfileMetaEl = null;
  let hudTileNextUpdateMs = 0;


  let hudDistValueEl = null;
  let hudTimeValueEl = null;
  let hudStepsValueEl = null;
  let hudEnergyValueEl = null;

    /* Session */

  let sessionStartMs = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
  let sessionDistM = 0;

  let sessionSteps = 0;
  let sessionEnergyKcal = 0;

  let sessionPrevX = null;
  let sessionPrevZ = null;
  let sessionPrevVehX = null;
  let sessionPrevVehZ = null;

  let sessionPrevJumpActive = false;


/* HUD tile runtime state (wiring + session timers). */
  const hudTileState = {
    wired: false,
    sessionStartSeconds: 0,
    __warnedExhausted: false,
    __lastBurnKcal: 0
  };


  function formatClock(seconds) {
    const s = Number(seconds);
    if (!Number.isFinite(s) || s <= 0) return "0:00";

    const total = Math.floor(s);
    const m = Math.floor(total / 60);
    const r = total - m * 60;

    return `${m}:${String(r).padStart(2, "0")}`;
  }


/* Formats meters into m/km for HUD display. */
  function formatDistanceMeters(m) {
    const v = Number.isFinite(m) ? Math.max(0, m) : 0;
    if (v >= 1000) return `${(v / 1000).toFixed(2)}km`;
    return `${Math.round(v)}m`;
  }


  let hudHealthValueEl = null;
  let hudLivesValueEl = null;
  let hudHealthFillEl = null;

/* Wires the HUD tile elements once so updateHudTile() can push values every frame. */
  function ensureHudTileWired() {
    if (hudTileState.wired) return;

    hudTileEl = document.getElementById("hudTile");

    hudAltValueEl = document.getElementById("hudAltValue");
    hudDistValueEl = document.getElementById("hudDistValue");
    hudTimeValueEl = document.getElementById("hudTimeValue");

    hudStepsValueEl = document.getElementById("hudStepsValue");

  /* NOTE: HTML uses hudKcalValue for the energy line. */
    hudEnergyValueEl = document.getElementById("hudKcalValue");

    hudProfileMetaEl = document.getElementById("hudProfileMeta");

    hudHealthValueEl = document.getElementById("hudHealthValue");
    hudLivesValueEl = document.getElementById("hudLivesValue");
    hudHealthFillEl = document.getElementById("hudHealthFill");

    hudTileState.wired = true;
  }



/* Updates HUD tile values (ALT/DIST/TIME/STEPS/ENERGY + profile meta + health). */
  function updateHudTile() {
    ensureHudTileWired();
    if (!hudTileEl) return;

    const nowMs = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
    if (nowMs < hudTileNextUpdateMs) return;
    hudTileNextUpdateMs = nowMs + 120;

    const nowS = nowMs * 0.001;

  /* Session timer */
    if (!hudTileState.sessionStartSeconds) hudTileState.sessionStartSeconds = nowS;
    const sessionSeconds = Math.max(0, nowS - hudTileState.sessionStartSeconds);

    /* ALT: avatar altitude above original ground baseline (y=0). */
    let alt = 0.0;
    if (avatar && avatar.position) {
      alt = Number.isFinite(avatar.position.y) ? avatar.position.y : 0.0;
    }


  /* Session distance (walk or vehicle) */
    const driving = !!(vehicleDriveState && vehicleDriveState.enabled && vehicleDriveState.vehicle);
    if (driving) {
      const vWrap = vehicleDriveState.vehicle;
      const vObj = (vWrap && vWrap.object) ? vWrap.object : null;

      if (vObj) {
        const vx = vObj.position.x;
        const vz = vObj.position.z;

        if (sessionPrevVehX !== null && sessionPrevVehZ !== null) {
          const d = Math.hypot(vx - sessionPrevVehX, vz - sessionPrevVehZ);
          if (Number.isFinite(d) && d > 1e-6) sessionDistM += d;
        }

        sessionPrevVehX = vx;
        sessionPrevVehZ = vz;
      }

      sessionPrevX = null;
      sessionPrevZ = null;
    } else {
      if (avatar) {
        const ax = avatar.position.x;
        const az = avatar.position.z;

        if (sessionPrevX !== null && sessionPrevZ !== null) {
          const d = Math.hypot(ax - sessionPrevX, az - sessionPrevZ);
          if (Number.isFinite(d) && d > 1e-6) sessionDistM += d;
        }

        sessionPrevX = ax;
        sessionPrevZ = az;
      }

      sessionPrevVehX = null;
      sessionPrevVehZ = null;
    }

  /* Steps from distance */
    const stepLen = Number.isFinite(params.avatarStepLengthM) ? Math.max(0.2, params.avatarStepLengthM) : 0.78;
    const estSteps = Math.max(0, Math.floor(sessionDistM / stepLen));

    if (estSteps > sessionSteps) {
      const deltaSteps = estSteps - sessionSteps;
      sessionSteps = estSteps;

    /* KCAL burn from steps */
      const kcalPerStep = Number.isFinite(params.kcalPerStep) ? Math.max(0, params.kcalPerStep) : 0.05;
      sessionEnergyKcal += deltaSteps * kcalPerStep;
    }

  /* KCAL burn from jumps (rising edge) */
    const jumpActive = !!(avatarJumpState && avatarJumpState.active);
    if (jumpActive && !sessionPrevJumpActive) {
      const kcalPerJump = Number.isFinite(params.kcalPerJump) ? Math.max(0, params.kcalPerJump) : 0.2;
      sessionEnergyKcal += kcalPerJump;
    }
    sessionPrevJumpActive = jumpActive;

  /* TIME formatting */
    const mins = Math.floor(sessionSeconds / 60);
    const secs = Math.floor(sessionSeconds - mins * 60);
    const timeText = `${mins}:${String(secs).padStart(2, "0")}`;

  /* Intake shown as +kcal (set by pickupConsume) */
    if (typeof window.__sessionEnergyIntakeKcal !== "number") window.__sessionEnergyIntakeKcal = 0;
    const intakeKcal = window.__sessionEnergyIntakeKcal;

  /* DIST / STEPS / ENERGY (session accumulators) */
    const distM = Number.isFinite(sessionDistM) ? Math.max(0, sessionDistM) : 0;
    const steps = Number.isFinite(sessionSteps) ? Math.max(0, sessionSteps | 0) : 0;

    const burnedKcal = Number.isFinite(sessionEnergyKcal) ? Math.max(0, sessionEnergyKcal) : 0;
    const burnedKJ = burnedKcal * 4.184;

    if (hudAltValueEl) hudAltValueEl.textContent = `${alt.toFixed(1)}m`;
    if (hudDistValueEl) hudDistValueEl.textContent = formatDistanceMeters(distM);
    if (hudTimeValueEl) hudTimeValueEl.textContent = timeText;
    if (hudStepsValueEl) hudStepsValueEl.textContent = `${steps}`;

    if (hudEnergyValueEl) {
      const burnTxt = `${burnedKcal.toFixed(0)}kcal`;
      const kjTxt = `${burnedKJ.toFixed(0)}kJ`;
      const inTxt = intakeKcal > 0 ? ` +${intakeKcal.toFixed(0)}kcal` : "";
      hudEnergyValueEl.textContent = `${burnTxt} (${kjTxt})${inTxt}`;
    }

  /* Profile meta */
    let healthPct = 100;
    let lives = 3;

    if (typeof playerProfile !== "undefined" && playerProfile) {
      const nm = (typeof playerProfile.name === "string" && playerProfile.name.trim()) ? playerProfile.name.trim() : "Anonymous";
      const badges =
      (playerProfile && playerProfile.stats && Array.isArray(playerProfile.stats.badges)) ? playerProfile.stats.badges.length :
      (playerProfile && Array.isArray(playerProfile.badges)) ? playerProfile.badges.length :
      0;

      if (hudProfileMetaEl) hudProfileMetaEl.textContent = `${nm} â€¢ ${Math.max(0, badges | 0)} badges`;

      if (playerProfile.stats) {
        const h = Number.isFinite(+playerProfile.stats.health) ? +playerProfile.stats.health : 100;
        healthPct = Math.max(0, Math.min(100, h));
        lives = Number.isFinite(+playerProfile.stats.lives) ? Math.max(0, Math.floor(+playerProfile.stats.lives)) : lives;
      }
    }

  /* Energy -> stamina -> health drain (pipeline-ready) */
    if (typeof playerVitals !== "undefined" && playerVitals) {
      if (typeof hudTileState.__lastBurnKcal !== "number") hudTileState.__lastBurnKcal = burnedKcal;

      const deltaBurn = burnedKcal - hudTileState.__lastBurnKcal;
      hudTileState.__lastBurnKcal = burnedKcal;

      if (Number.isFinite(deltaBurn) && deltaBurn > 0) {
        playerVitals.energyKcal = Number.isFinite(playerVitals.energyKcal) ? playerVitals.energyKcal : 0;
        playerVitals.stamina = Number.isFinite(playerVitals.stamina) ? playerVitals.stamina : 1;

        if (playerVitals.energyKcal > 0) {
          playerVitals.energyKcal = Math.max(0, playerVitals.energyKcal - deltaBurn);
        } else {
          playerVitals.stamina = Math.max(0, playerVitals.stamina - (deltaBurn / 1400));
        }

        if (playerVitals.stamina <= 0.10 && !hudTileState.__warnedExhausted) {
          hudTileState.__warnedExhausted = true;
          if (typeof showActionToast === "function") showActionToast("EXHAUSTED â€¢ find food or rest");
        }

        if (playerVitals.stamina <= 0.001 && playerProfile && playerProfile.stats) {
          const drain = (deltaBurn / 10);
          const nextH = Math.max(0, (Number.isFinite(+playerProfile.stats.health) ? +playerProfile.stats.health : 100) - drain);
          playerProfile.stats.health = nextH;

          if (nextH <= 0) {
            const nowMs2 = Date.now();
            const since = nowMs2 - (Number.isFinite(playerVitals.lastDeathMs) ? playerVitals.lastDeathMs : 0);

            if (since > 1200) {
              playerVitals.lastDeathMs = nowMs2;

              const curLives = Number.isFinite(+playerProfile.stats.lives) ? Math.max(0, Math.floor(+playerProfile.stats.lives)) : 0;
              playerProfile.stats.lives = Math.max(0, curLives - 1);

              playerProfile.stats.health = 100;
              playerVitals.stamina = 1;
              playerVitals.energyKcal = 0;

              if (typeof showActionToast === "function") {
                if (playerProfile.stats.lives > 0) showActionToast(`DEAD â€¢ respawned (${playerProfile.stats.lives} lives left)`);
                else showActionToast("DEAD â€¢ no lives left");
              }

              savePlayerProfile(playerProfile);
              savePlayerVitals();
            }
          } else {
            savePlayerProfile(playerProfile);
          }
        }

        savePlayerVitals();
      }
    }

  /* Health UI */
    if (hudHealthValueEl) hudHealthValueEl.textContent = `${Math.round(healthPct)}%`;
    if (hudLivesValueEl) hudLivesValueEl.textContent = `${lives}`;

    if (hudHealthFillEl) {
      const w = `${Math.max(0, Math.min(100, healthPct))}%`;
      hudHealthFillEl.style.width = w;
      const track = hudHealthFillEl.parentElement;
      if (track && track.setAttribute) track.setAttribute("aria-valuenow", `${Math.round(Math.max(0, Math.min(100, healthPct)))}`);
    }
  }








  let playerProfile = loadPlayerProfile();

    /* Updates local player profile (validated), optionally persists, and applies it onto the avatar userData. */
/* Applies user edits onto the persisted profile without wiping accumulated stats. */
  function setPlayerProfile(next, { persist = true } = {}) {
    const base = createDefaultPlayerProfile();

    base.id = typeof next?.id === "string" && next.id.trim() ? next.id.trim() : playerProfile.id;
    base.name = sanitizePlayerName(next?.name);
    base.color = typeof next?.color === "string" && /^#([0-9a-fA-F]{6})$/.test(next.color) ? next.color : playerProfile.color;
    base.avatarId = sanitizeAvatarId(next?.avatarId, playerProfile.avatarId);

    if (next?.meta && typeof next.meta === "object") {
      base.meta.about = typeof next.meta.about === "string" ? next.meta.about.slice(0, 256) : "";
    } else {
      base.meta.about = typeof playerProfile?.meta?.about === "string" ? playerProfile.meta.about : "";
    }

  // Preserve stats unless caller explicitly supplies stats
    if (next?.stats && typeof next.stats === "object") {
      base.stats = next.stats;
    } else if (playerProfile?.stats && typeof playerProfile.stats === "object") {
      base.stats = playerProfile.stats;
    }

    playerProfile = base;
    if (persist) savePlayerProfile(playerProfile);

    applyLocalPlayerProfileToAvatar();
  }




    /**
     * Applies local profile metadata onto the avatar object for future multiuser sync.
     */
  function applyLocalPlayerProfileToAvatar() {
    if (!avatar) return;

    avatar.userData.playerProfile = {
      id: playerProfile.id,
      name: playerProfile.name,
      color: playerProfile.color,
      avatarId: playerProfile.avatarId,
      meta: { about: playerProfile.meta.about }
    };
  }






/**
 * Builds a compact state packet suitable for sending over a websocket.
 * Not transmitted by default; this is a stable schema for future multiuser work.
 */
  function buildLocalPlayerNetPacket() {
    const pose = avatar
    ? {
      p: [avatar.position.x, avatar.position.y, avatar.position.z],
      q: [avatar.quaternion.x, avatar.quaternion.y, avatar.quaternion.z, avatar.quaternion.w]
    }
    : null;

    const driving =
    vehicleDriveState &&
    vehicleDriveState.enabled &&
    vehicleDriveState.vehicle &&
    vehicleDriveState.vehicle.userData &&
    vehicleDriveState.vehicle.userData.vehicleId
    ? String(vehicleDriveState.vehicle.userData.vehicleId)
    : "";

    return {
      v: 1,
      t: "player",
      id: playerProfile.id,
      profile: {
        name: playerProfile.name,
        color: playerProfile.color,
        avatarId: playerProfile.avatarId,
        meta: { about: playerProfile.meta.about }
      },
      pose,
      driving
    };
  }







  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    /* Applies an axial dead-zone and rescales remaining range back to [-1..1]. */
  function applyDeadZone(v, deadZone) {
    const dz = Number.isFinite(deadZone) ? deadZone : 0;
    if (dz <= 0) return v;
    if (dz >= 1) return 0;

    const av = Math.abs(v);
    if (av <= dz) return 0;

    const sign = v < 0 ? -1 : 1;
    const scaled = (av - dz) / (1 - dz);
    return sign * clamp(scaled, 0, 1);
  }



    // Simple seedable RNG (LCG)
  function makeSeededRandom(seed) {
    let s = (seed | 0) || 1;
    return function () {
      s = (s * 1664525 + 1013904223) | 0;
      return (s >>> 0) / 4294967296;
    };
  }

  function nowStamp() {

    const d = new Date();
    const pad = (n) => String(n).padStart(2, "0");
    return (
      d.getFullYear() +
      pad(d.getMonth() + 1) +
      pad(d.getDate()) +
      "-" +
      pad(d.getHours()) +
      pad(d.getMinutes()) +
      pad(d.getSeconds())
      );
  }

  function safeCloneSettings(src) {
    const out = {};
    for (const k of Object.keys(src)) {
      const v = src[k];
      if (typeof v === "number" || typeof v === "boolean" || typeof v === "string") {
        out[k] = v;
      }
    }
    return out;
  }

  function downloadJson(obj, filename) {
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    a.rel = "noopener";
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

    // localStorage (last used settings)
  const STORAGE_LAST = "snow:lastSettings:v1";

  let persistTimer = 0;
  let persistBlocked = false;

  function saveLastNow(params) {
    if (persistBlocked) return;
    try {
      const payload = {
        v: 1,
        savedAt: Date.now(),
        settings: safeCloneSettings(params)
      };
      localStorage.setItem(STORAGE_LAST, JSON.stringify(payload));
    } catch (e) {
      console.warn("[snow] save last failed", e);
    }
  }

  function saveLastDebounced(params) {
    if (persistBlocked) return;
    if (persistTimer) clearTimeout(persistTimer);
    persistTimer = setTimeout(() => {
      persistTimer = 0;
      saveLastNow(params);
    }, 200);
  }

    /* Loads last-used settings; before scene init it only patches params (no rebuild calls). */
  function loadLastSettings(params) {
    try {
      const raw = localStorage.getItem(STORAGE_LAST);
      if (!raw) return;

      const parsed = JSON.parse(raw);
      if (!parsed || typeof parsed !== "object" || !parsed.settings || typeof parsed.settings !== "object") return;

        // If the scene is already ready, use the normal settings pipeline.
      if (typeof scene !== "undefined" && scene) {
        applySettings(parsed.settings, { rebuild: false, updateGui: false, persist: false });
        return;
      }

        // Early boot: copy only known primitive params (prevents calling rebuild* before scene exists).
      const s = parsed.settings;
      for (const k of Object.keys(s)) {
        if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
        const v = s[k];
        if (typeof v === "number" || typeof v === "boolean" || typeof v === "string") {
          params[k] = v;
        }
      }
    } catch (e) {
      console.warn("[snow] load last failed", e);
    }
  }






  // localStorage (quick save state + snapshot list)
  const QUICK_STATE_STORAGE_KEY = "snow:quickState:v1";
  const SNAPSHOTS_STORAGE_KEY = "snow:snapshots:v1";
  const SNAPSHOTS_MAX = 20;

  let quickStateCache = null;

  const snapshotsOverlayState = {
    wired: false,
    open: false,
    overlayEl: null,
    closeBtn: null,
    worldEl: null,
    listEl: null,
    emptyEl: null
  };

  /* Builds a per-player + per-world storage key (isolates snapshots by user and current world). */
  function makeScopedStorageKey(prefix) {
    const pid = playerProfile && typeof playerProfile.id === "string" && playerProfile.id.trim() ? playerProfile.id.trim() : "anon";
    const wid = typeof getActiveWorldId === "function" ? (getActiveWorldId() || "") : "";
    const w = wid && String(wid).trim() ? String(wid).trim() : "default";
    return `${prefix}:${pid}:${w}`;
  }

  /* Formats a snapshot timestamp for list display. */
  function formatSnapshotTime(ms) {
    const t = Number(ms) || 0;
    const d = new Date(t || Date.now());
    try {
      return d.toLocaleString(undefined, {
        year: "numeric",
        month: "short",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    } catch {
      return d.toString();
    }
  }

  /* Returns the current world title used in UI. */
  function getCurrentWorldTitle() {
    const t = (typeof worldUiState !== "undefined" && worldUiState && typeof worldUiState.title === "string") ? worldUiState.title : "";
    const s = String(t || "").trim();
    return s ? s : "Default";
  }

  /* Captures a serializable snapshot of avatar + camera pose for quick retry. */
  function buildQuickStateSnapshot() {
    const snap = {
      v: 1,
      savedAt: Date.now(),
      avatar: null,
      camera: null,
      meta: {
        avatarEnabled: !!(avatarState && avatarState.enabled),
        avatarViewMode: avatarState && typeof avatarState.viewMode === "string" ? avatarState.viewMode : "",
        avatarChase: !!(avatarChaseCamState && avatarChaseCamState.enabled),
        vehicleDriving: !!(vehicleDriveState && vehicleDriveState.enabled),
        vehicleChase: !!(vehicleChaseCamState && vehicleChaseCamState.enabled)
      }
    };

    if (avatar) {
      snap.avatar = {
        p: [avatar.position.x, avatar.position.y, avatar.position.z],
        q: [avatar.quaternion.x, avatar.quaternion.y, avatar.quaternion.z, avatar.quaternion.w]
      };
    }

    if (camera) {
      const target = controls && controls.target ? controls.target : null;
      snap.camera = {
        p: [camera.position.x, camera.position.y, camera.position.z],
        q: [camera.quaternion.x, camera.quaternion.y, camera.quaternion.z, camera.quaternion.w],
        t: target ? [target.x, target.y, target.z] : null
      };
    }

    return snap;
  }

  /* Persists the last quick snapshot to localStorage and caches it in memory (scoped by user+world, with legacy fallback). */
  function saveQuickStateSnapshot() {
    const snap = buildQuickStateSnapshot();
    quickStateCache = snap;

    const scopedKey = makeScopedStorageKey(QUICK_STATE_STORAGE_KEY);
    try {
      localStorage.setItem(scopedKey, JSON.stringify(snap));
    } catch (e) {
      try {
        localStorage.setItem(QUICK_STATE_STORAGE_KEY, JSON.stringify(snap));
      } catch (e2) {
        console.warn("[snow] quick save failed", e2);
      }
    }

    return snap;
  }

  /* Loads the last quick snapshot from localStorage (returns null when missing/invalid). */
  function loadQuickStateSnapshot() {
    if (quickStateCache && quickStateCache.v === 1) return quickStateCache;

    const scopedKey = makeScopedStorageKey(QUICK_STATE_STORAGE_KEY);
    const tryLoad = (k) => {
      try {
        const raw = localStorage.getItem(k);
        if (!raw) return null;
        const parsed = JSON.parse(raw);
        if (!parsed || parsed.v !== 1) return null;
        return parsed;
      } catch {
        return null;
      }
    };

    const scoped = tryLoad(scopedKey);
    if (scoped) {
      quickStateCache = scoped;
      return scoped;
    }

    const legacy = tryLoad(QUICK_STATE_STORAGE_KEY);
    if (legacy) {
      quickStateCache = legacy;
      return legacy;
    }

    return null;
  }

  /* Applies a quick snapshot to avatar + camera and resets follow smoothing to prevent jumps. */
  /* Applies a quick snapshot to avatar + camera and resets follow smoothing to prevent jumps. */
  function applyQuickStateSnapshot(snap) {
    if (!snap || snap.v !== 1) return false;

    if (avatar && snap.avatar && Array.isArray(snap.avatar.p) && snap.avatar.p.length === 3) {
      const p = snap.avatar.p;
      const q = snap.avatar.q;

      if (Number.isFinite(p[0]) && Number.isFinite(p[1]) && Number.isFinite(p[2])) {
        avatar.position.set(p[0], p[1], p[2]);
      }

      if (Array.isArray(q) && q.length === 4 && q.every((n) => Number.isFinite(n))) {
        const x = q[0], y = q[1], z = q[2], w = q[3];

        const sinyCosp = 2 * (w * y + x * z);
        const cosyCosp = 1 - 2 * (y * y + z * z);
        const yaw = Math.atan2(sinyCosp, cosyCosp);

        if (Number.isFinite(yaw)) {
          avatar.rotation.set(0, yaw, 0);
        } else {
          avatar.quaternion.set(x, y, z, w).normalize();
        }
      }

      if (typeof avatarVelocity !== "undefined" && avatarVelocity) avatarVelocity.set(0, 0, 0);
      if (typeof avatarMoveDir !== "undefined" && avatarMoveDir) avatarMoveDir.set(0, 0, 0);

      if (typeof avatarJumpState !== "undefined" && avatarJumpState) {
        avatarJumpState.active = false;
        avatarJumpState.grounded = true;
        avatarJumpState.vy = 0.0;
        avatarJumpState.groundY = avatar.position.y;
        if (avatarJumpState._lastGrounded) {
          const lg = avatarJumpState._lastGrounded;
          lg.x = avatar.position.x; lg.y = avatar.position.y; lg.z = avatar.position.z;
        }
      }

      if (typeof avatarKeys !== "undefined" && avatarKeys) {
        avatarKeys.forward = false;
        avatarKeys.back = false;
        avatarKeys.left = false;
        avatarKeys.right = false;
        avatarKeys.run = false;
        avatarKeys.jump = false;
        avatarKeys.jetDown = false;
      }

      if (typeof avatarState !== "undefined" && avatarState) {
        avatarState.moveX = 0;
        avatarState.moveZ = 0;
      }

      if (typeof recomputeAvatarMoveFromKeys === "function") recomputeAvatarMoveFromKeys();
      if (typeof resetJoystick === "function") resetJoystick();
      if (typeof resetRightJoystick === "function") resetRightJoystick();

      if (typeof avatarState !== "undefined" && avatarState && avatarState.enabled && avatar && controls) {
        if (typeof avatarHasLastPos !== "undefined") avatarHasLastPos = true;

        if (typeof avatarLastWorldPos !== "undefined" && avatarLastWorldPos) {
          avatarLastWorldPos.set(avatar.position.x, avatar.position.y, avatar.position.z);
        }

        if (typeof avatarCameraYFollowState !== "undefined" && avatarCameraYFollowState) {
          avatarCameraYFollowState.has = true;
          avatarCameraYFollowState.y = avatar.position.y;
        }

        if (typeof avatarCameraYFollowFirstState !== "undefined" && avatarCameraYFollowFirstState) {
          avatarCameraYFollowFirstState.has = true;
          const headY =
          typeof avatarViewConfig !== "undefined" && avatarViewConfig && Number.isFinite(avatarViewConfig.firstPersonHeight)
          ? (avatar.position.y + avatarViewConfig.firstPersonHeight)
          : avatar.position.y;
          avatarCameraYFollowFirstState.y = headY;
        }
      }
    }

    if (camera && snap.camera && Array.isArray(snap.camera.p) && snap.camera.p.length === 3) {
      const p = snap.camera.p;
      const q = snap.camera.q;
      const t = snap.camera.t;

      if (Number.isFinite(p[0]) && Number.isFinite(p[1]) && Number.isFinite(p[2])) {
        camera.position.set(p[0], p[1], p[2]);
      }

      if (Array.isArray(q) && q.length === 4 && q.every((n) => Number.isFinite(n))) {
        camera.quaternion.set(q[0], q[1], q[2], q[3]).normalize();
      }

      if (controls && controls.target && Array.isArray(t) && t.length === 3) {
        if (Number.isFinite(t[0]) && Number.isFinite(t[1]) && Number.isFinite(t[2])) {
          controls.target.set(t[0], t[1], t[2]);
        }
      }

      if (controls) controls.update();
    }

    return true;
  }





  /* Loads the snapshot list for current user+world. */
  function loadSnapshotsList() {
    const key = makeScopedStorageKey(SNAPSHOTS_STORAGE_KEY);
    try {
      const raw = localStorage.getItem(key);
      if (!raw) return [];
      const parsed = JSON.parse(raw);
      if (!Array.isArray(parsed)) return [];
      return parsed.filter((it) => it && typeof it === "object" && it.v === 1 && typeof it.id === "string");
    } catch {
      return [];
    }
  }

  /* Persists the snapshot list for current user+world (best-effort under quota). */
  function saveSnapshotsList(list) {
    const key = makeScopedStorageKey(SNAPSHOTS_STORAGE_KEY);
    const arr = Array.isArray(list) ? list.slice(0, SNAPSHOTS_MAX) : [];

    try {
      localStorage.setItem(key, JSON.stringify(arr));
      return true;
    } catch (e) {
      try {
        const trimmed = arr.slice(0, Math.max(0, Math.min(8, arr.length)));
        localStorage.setItem(key, JSON.stringify(trimmed));
        return true;
      } catch (e2) {
        try {
          const noThumb = arr.slice(0, Math.max(0, Math.min(10, arr.length))).map((it) => {
            const out = Object.assign({}, it);
            out.thumb = "";
            return out;
          });
          localStorage.setItem(key, JSON.stringify(noThumb));
          return true;
        } catch (e3) {
          console.warn("[snow] snapshots persist failed", e3);
          return false;
        }
      }
    }
  }

  /* Creates and appends a new snapshot entry (thumbnail + pose) into the per-world list. */
  function addSnapshotEntry() {
    const state = saveQuickStateSnapshot();
    const thumb = (typeof captureWorldThumbnail === "function") ? (captureWorldThumbnail() || "") : "";

    const entry = {
      v: 1,
      id: `s_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`,
      savedAt: Date.now(),
      worldTitle: getCurrentWorldTitle(),
      thumb: typeof thumb === "string" ? thumb : "",
      state
    };

    const list = loadSnapshotsList();
    list.unshift(entry);
    const dedup = [];
    const seen = new Set();
    for (let i = 0; i < list.length && dedup.length < SNAPSHOTS_MAX; i++) {
      const it = list[i];
      if (!it || typeof it !== "object" || typeof it.id !== "string") continue;
      if (seen.has(it.id)) continue;
      seen.add(it.id);
      dedup.push(it);
    }

    saveSnapshotsList(dedup);

    if (snapshotsOverlayState.open) {
      renderSnapshotsOverlayList(dedup);
      refreshSnapshotsOverlayMeta();
    }

    return entry;
  }

  /* Ensures snapshots overlay DOM is wired once. */
  function ensureSnapshotsOverlayWired() {
    if (snapshotsOverlayState.wired) return;

    snapshotsOverlayState.overlayEl = document.getElementById("snapshotsOverlay");
    snapshotsOverlayState.closeBtn = document.getElementById("snapshotsOverlayClose");
    snapshotsOverlayState.worldEl = document.getElementById("snapshotsOverlayWorld");
    snapshotsOverlayState.listEl = document.getElementById("snapshotsList");
    snapshotsOverlayState.emptyEl = document.getElementById("snapshotsEmpty");

    if (snapshotsOverlayState.closeBtn) {
      snapshotsOverlayState.closeBtn.addEventListener("click", (e) => {
        e.preventDefault();
        setSnapshotsOverlayOpen(false);
      });
    }

    if (snapshotsOverlayState.overlayEl) {
      snapshotsOverlayState.overlayEl.addEventListener("click", (e) => {
        if (e.target === snapshotsOverlayState.overlayEl) setSnapshotsOverlayOpen(false);
      }, { passive: true });
    }

    snapshotsOverlayState.wired = true;
  }

  /* Updates the overlay world label. */
  function refreshSnapshotsOverlayMeta() {
    if (!snapshotsOverlayState.worldEl) return;
    snapshotsOverlayState.worldEl.textContent = getCurrentWorldTitle();
  }

  /* Renders the snapshot list as clickable items that load that snapshot. */
  function renderSnapshotsOverlayList(items) {
    const listEl = snapshotsOverlayState.listEl;
    const emptyEl = snapshotsOverlayState.emptyEl;
    if (!listEl || !emptyEl) return;

    const list = Array.isArray(items) ? items : [];
    listEl.innerHTML = "";

    if (!list.length) {
      emptyEl.classList.add("is-open");
      emptyEl.setAttribute("aria-hidden", "false");
      return;
    }

    emptyEl.classList.remove("is-open");
    emptyEl.setAttribute("aria-hidden", "true");

    for (let i = 0; i < list.length; i++) {
      const it = list[i];
      if (!it || typeof it !== "object") continue;

      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "snapshot-item";
      btn.setAttribute("role", "listitem");

      const img = document.createElement("img");
      img.className = "snapshot-item__thumb";
      img.alt = "";
      img.decoding = "async";
      img.loading = "lazy";
      img.src = (typeof it.thumb === "string" && it.thumb) ? it.thumb : "";
      img.onerror = () => {
        img.onerror = null;
        img.src = "";
      };

      const meta = document.createElement("div");
      meta.className = "snapshot-item__meta";

      const world = document.createElement("div");
      world.className = "snapshot-item__world";
      world.textContent = (typeof it.worldTitle === "string" && it.worldTitle.trim()) ? it.worldTitle.trim() : getCurrentWorldTitle();

      const time = document.createElement("div");
      time.className = "snapshot-item__time";
      time.textContent = formatSnapshotTime(it.savedAt);

      meta.appendChild(world);
      meta.appendChild(time);

      btn.appendChild(img);
      btn.appendChild(meta);

      btn.addEventListener("click", (e) => {
        e.preventDefault();
        const snap = it && it.state ? it.state : null;
        const ok = applyQuickStateSnapshot(snap);
        if (typeof showActionToast === "function") showActionToast(ok ? "Snapshot loaded" : "Snapshot load failed");
        if (ok) setSnapshotsOverlayOpen(false);
      });

      listEl.appendChild(btn);
    }
  }

  /* Shows/hides the snapshots overlay and refreshes its contents. */
  function setSnapshotsOverlayOpen(open) {
    ensureSnapshotsOverlayWired();
    snapshotsOverlayState.open = !!open;

    const el = snapshotsOverlayState.overlayEl;
    if (!el) return;

    el.classList.toggle("is-open", snapshotsOverlayState.open);
    el.setAttribute("aria-hidden", snapshotsOverlayState.open ? "false" : "true");

    if (snapshotsOverlayState.open) {
      refreshSnapshotsOverlayMeta();
      const list = loadSnapshotsList();
      renderSnapshotsOverlayList(list);
      if (snapshotsOverlayState.closeBtn) snapshotsOverlayState.closeBtn.focus({ preventScroll: true });
    }
  }

  /* Toggles the snapshots overlay open/closed. */
  function toggleSnapshotsOverlay() {
    setSnapshotsOverlayOpen(!snapshotsOverlayState.open);
  }

  /* Returns the latest snapshot entry, or null when none exist. */
  function getLatestSnapshotEntry() {
    const list = loadSnapshotsList();
    return list.length ? list[0] : null;
  }

  /* Saves the current avatar + camera pose as a new snapshot (also updates quick state). */
  function quickSave() {
    addSnapshotEntry();
    if (typeof showActionToast === "function") showActionToast("Snapshot saved");
  }

  /* Loads the latest snapshot; falls back to legacy quick-save state when list is empty. */
  function quickReload() {
    const latest = getLatestSnapshotEntry();
    const snap = latest && latest.state ? latest.state : loadQuickStateSnapshot();

    if (!snap) {
      if (typeof showActionToast === "function") showActionToast("No snapshots");
      return;
    }

    const ok = applyQuickStateSnapshot(snap);
    if (typeof showActionToast === "function") showActionToast(ok ? "Snapshot loaded" : "Snapshot load failed");
  }






    // IndexedDB presets -------------------------------------------------------

  const IDB_NAME = "snow-presets";
  const IDB_STORE = "presets";
  const IDB_VERSION = 1;

  function idbOpen() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(IDB_NAME, IDB_VERSION);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(IDB_STORE)) {
          db.createObjectStore(IDB_STORE, { keyPath: "name" });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbPutPreset(name, settings) {
    const db = await idbOpen();
    try {
      await new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, "readwrite");
        tx.onerror = () => reject(tx.error);
        tx.objectStore(IDB_STORE).put({ name, savedAt: Date.now(), settings });
        tx.oncomplete = () => resolve();
      });
    } finally {
      db.close();
    }
  }

  async function idbGetPreset(name) {
    const db = await idbOpen();
    try {
      return await new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, "readonly");
        tx.onerror = () => reject(tx.error);
        const req = tx.objectStore(IDB_STORE).get(name);
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error);
      });
    } finally {
      db.close();
    }
  }

  async function idbDeletePreset(name) {
    const db = await idbOpen();
    try {
      await new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, "readwrite");
        tx.onerror = () => reject(tx.error);
        tx.objectStore(IDB_STORE).delete(name);
        tx.oncomplete = () => resolve();
      });
    } finally {
      db.close();
    }
  }

  async function idbListPresetNames() {
    const db = await idbOpen();
    try {
      return await new Promise((resolve, reject) => {
        const tx = db.transaction(IDB_STORE, "readonly");
        tx.onerror = () => reject(tx.error);
        const req = tx.objectStore(IDB_STORE).getAllKeys();
        req.onsuccess = () => {
          const list = (req.result || []).map(String).sort();
          resolve(list);
        };
        req.onerror = () => reject(req.error);
      });
    } finally {
      db.close();
    }
  }

  function sanitizePresetName(s) {
    const name = String(s ?? "").replace(/\.[a-z0-9]+$/i, "").trim();
    if (!name) return "";
    return name.replace(/\s+/g, " ").slice(0, 96);
  }

    // File input for JSON import ---------------------------------------------

  let importInput = null;
  function ensureImportInput() {
    if (importInput) return importInput;
    importInput = document.createElement("input");
    importInput.type = "file";
    importInput.accept = "application/json,.json";
    importInput.style.position = "fixed";
    importInput.style.left = "-9999px";
    importInput.style.top = "-9999px";
    document.body.appendChild(importInput);
    return importInput;
  }










    // Parameters (includes gust/turbulence)
    // -------------------------------------------------------------------------

  const DEFAULTS = {


    // Audio (music + SFX)
    musicEnabled: false,
    musicVolume: 0.35,
    sfxEnabled: true,
    sfxVolume: 0.85,    


    sfxPresets: {
      jump: {
        kind: "mix",
        oscType: "sine",
        freq: 220,
        freqEnd: 120,
        noise: 0.25,
        gain: 0.55,
        attack: 0.002,
        decay: 0.10,
        release: 0.06,
        duration: 0.20,
        filterType: "lowpass",
        filterFreq: 900,
        filterQ: 0.7,
        pan: 0.0,
        reverbMix: 0.08,
        irSeconds: 1.2
      },
      land: {
        kind: "mix",
        oscType: "sine",
        freq: 110,
        freqEnd: 60,
        noise: 0.35,
        gain: 0.75,
        attack: 0.001,
        decay: 0.14,
        release: 0.10,
        duration: 0.28,
        filterType: "lowpass",
        filterFreq: 420,
        filterQ: 0.9,
        pan: 0.0,
        reverbMix: 0.10,
        irSeconds: 1.4
      }
    },



  // Environmental Sounds
    envSoundEnabled: false,
    envSoundVolume: 0.18,
    envSoundPanDepth: 0.5,
    envSoundPanSpeed: 0.6,
    envSoundReverbMix: 0.35,
    envSoundIrSeconds: 1.5,
    envSoundToneHz: 0,

  // Avatar
    avatarId: DEFAULT_AVATAR_ID,
    avatarMaxStepUp: 0.37,
    avatarFallStart: 0.8,

  // Energy burn
    kcalPerStep: 0.05,
    kcalPerJump: 0.2,  


  // Performance
    shadowsEnabled: true,
    shadowsAutoUpdate: true,
      shadowType: "PCFSoft",   // "PCFSoft" | "PCF" | "Basic"
      shadowMapSize: 1024,     // 256 | 512 | 1024 | 2048 | 4096

  // Core
      paused: false,
      debug: false,
      timeScale: 1.0,
      dtMax: 0.020,
      pixelRatio: 1.75,

  // Flakes & base wind
      snowEnabled: true,
      visualCount: 180000,
      windStrength: 0,
      windSpeed: 0,
      fallSpeed: 0.42,
      fallJitter: 0.45,
      flakeSize: 3.0,
      flakeSizeJitter: 0.35,


  // Gusts / turbulence
      gustMinInterval: 1.4,
      gustMaxInterval: 3.2,
      gustTornadoChance: 0.22,
      gustStrengthMul: 1.0,
      gustSwirlMul: 1.0,
      gustUpdraftMul: 1.0,
      gustScour: 0.0100,
      gustRedeposit: 0.0080,

  // Drifts / cover
      driftGrid: 2048,
      driftMaxHeight: 3.6,
      coverBase: 0.06,
      coverMacroAmp: 0.09,
      coverMacroFreq: 2.4,
      coverMicroAmp: 0.05,
      coverMicroFreq: 8.5,


  // Terrain (procedural base heightfield; saved with worlds)
      terrainEnabled: false,
      terrainSeed: 1337,
      terrainRadius: 80.0,
      terrainInnerRadius: 0.0,
      terrainEdgeFade: 10.0,
      terrainEdgeNoiseAmp: 0.18,
      terrainEdgeNoiseFreq: 0.025,

      terrainAmp: 1.2,
      terrainFreq: 0.035,
      terrainOctaves: 5,
      terrainLacunarity: 2.0,
      terrainGain: 0.5,
      terrainWarpAmp: 12.0,
      terrainWarpFreq: 0.012,
      terrainRidge: false,
      terrainExponent: 1.35,

      terrainColorLow: "#e9f1ff",
      terrainColorHigh: "#ffffff",
      terrainColorStrength: 0.25,



      driftDiffusion: 0.07,
      driftAdvection: 0.125,
      obstacleShapeInterval: 10,
      driftWriteInterval: 8,
      normalUpdateInterval: 36,

  // Settlers & deposition
      settlerCount: 8000,
      groundDepositBudget: 420,
      depositUnit: 0.00035,
      objectTestsPerFrame: 900,
      objectDeposit: 0.002,

  // Sticking decals
      stuckMax: 24000,
      decalSize: 0.14,

  // Fog
      fogNear: 18,
      fogFar: 60,
      fogColor: "#0a1220",
      fadeEndOfWorldEnabled: false,
      fadeEndOfWorldDistance: 95,      

  // Surface colors
      groundColor: "#ffffff",
      rockColor: "#2b3442",
      forestColor: "#2b7a2b",
      cubeColor: "#4e9cff",      

  // Snowman path animation
      snowmanMoveEnabled: true,
      snowmanPathRadius: 4.0,  // approximate radius of his wander area
      snowmanSpeed: 0.03,       // loops per second (small = snail-slow)

      // Forest
      forestCount: 24,
      forestRadius: 14,
      forestInnerRadius: 3,
      forestMinScale: 0.7,
      forestMaxScale: 1.6,
      forestSeed: 1234,
      forestJitter: 1.0,

      // Rocks
      rockCount: 18,
      rockRadius: 16,
      rockInnerRadius: 2,
      rockMinScale: 0.65,
      rockMaxScale: 1.85,
      rockSeed: 2468,
      rockJitter: 1.0,

      rockDetail: 1,                 // 0..2 (Icosahedron subdivisions)
      rockVariantCount: 10,          // number of prebuilt rock shapes to reuse
      rockNoiseAmp: 0.28,            // shape displacement amount
      rockNoiseFreq: 1.75,           // noise frequency
      rockNoiseOctaves: 4,
      rockNoiseLacunarity: 2.0,
      rockNoiseGain: 0.50,
      rockNoiseRidge: 0.35,          // 0..1 blend towards ridged noise

      rockFlatten: 0.18,             // 0..1 random Y squash per rock
      rockAnisotropy: 0.25,          // 0..1 random X/Z scaling per rock
      rockEmbed: 0.12,               // pushes rocks down into snow/ground

      rockColorVar: 0.18,            // per-rock brightness variation
      rockRoughness: 1.0,
      rockMetalness: 0.0,


      // Clouds
      cloudEnabled: true,
      cloudHeightBase: 18.0,
      cloudHeightRange: 6.0,
      cloudRadius: 40.0,
      cloudSliceCount: 10,
      cloudSpeed: 0.010,
      cloudDensity: 0.85,
      cloudSoftness: 0.25,
      cloudColor: "#f5f7ff",
      cloudSkyColor: "#0a1220",
      cloudOpacity: 1.35,

      // Dust / fire column (atmospheric phenomenon; persisted in worlds/presets)
      dustEnabled: false,
      dustRadius: 5.0,
      dustFloorY: 0.10,
      dustCeilY: 4.0,
      dustSpeed: 2.3,
      dustCount: 600,
      dustSize: 0.10,
      dustNoise: 0.10,
      dustCenterX: 0.0,
      dustCenterZ: -3.5,
      dustColorInner: "#ffc57a",
      dustColorOuter: "#222222",


      // Rain (GPU point-sprite streaks; persisted in worlds/presets)
      rainEnabled: false,
      rainRadius: 28.0,
      rainTopY: 26.0,
      rainBottomY: 0.0,
      rainSpeed: 2.4,
      rainCount: 12000,
      rainSize: 0.12,
      rainThickness: 0.06,
      rainStreak: 0.85,
      rainWindX: 0.40,
      rainWindZ: 0.10,
      rainCenterX: 0.0,
      rainCenterZ: 0.0,
      rainColor: "#bcd7ff",
      rainOpacity: 0.30,


      // Grass (instanced blades + wind shader; persisted in worlds/presets)
      grassEnabled: false,
      grassCount: 9000,
      grassRadius: 26.0,
      grassCenterX: 0.0,
      grassCenterZ: 0.0,
      grassBaseY: 0.02,
      grassBladeHeight: 0.22,
      grassBladeWidth: 0.055,
      grassHeightJitter: 0.55,
      grassWidthJitter: 0.50,
      grassBend: 0.55,
      grassWindSpeed: 1.6,
      grassWindStrength: 1.0,
      grassStiffness: 1.7,

      grassNoiseScale: 0.35,
      grassNoiseStrength: 0.75,
      grassNoiseSpeed: 0.35,

      grassStaticHeightNoise: 0.35,
      grassStaticWidthNoise: 0.35,
      grassBorderNoise: 0.35,

      grassColorVariation: 0.12,

      grassColorBottom: "#1f5f2e",
      grassColorTop: "#7ee36c",
      grassOpacity: 0.95,
      grassAlphaCutoff: 0.03,
      grassSeed: 4242,




    };


    const params = { ...DEFAULTS };


    // Scene globals
    // -------------------------------------------------------------------------

    const GROUND_SIZE = 1050;
    const HALF_GROUND = GROUND_SIZE * 0.5;

    /**
     * Playable world bounds in X/Z. Defaults to the ground plane edge (HALF_GROUND).
     * Adjust this single value to expand/shrink the playable area without touching other systems.
     */
    const WORLD_BOUNDS_XZ = HALF_GROUND;

    const visualBounds = { x: WORLD_BOUNDS_XZ, z: WORLD_BOUNDS_XZ, yMin: -2.0, yMax: 22.0 };
    const settleBounds = { x: WORLD_BOUNDS_XZ, z: WORLD_BOUNDS_XZ, yMin: -2.0, yMax: 18.0 };


    let scene, camera, renderer, controls, hemiLight, dirLight;
    let ground, cube;
    const cones = [];
    const rocks = [];

    /* Tracks last-applied renderer/light shadow settings to avoid per-frame churn. */
    const shadowApplied = {
      enabled: null,
      autoUpdate: null,
      typeKey: null,
      mapSize: null
    };


    // Forest cone shared resources
    let forestConeGeo = null;
    let forestConeMat = null;

    // Rock shared resources
    let rockGeo = null;
    let rockMat = null;
    let rockGeoMidY = 0.0;

    let rockVariantGeos = [];
    let rockVariantMidY = [];
    let rockVariantKey = "";


    let snowTex;
    let wetTrailTex;
    let wetFootTex;
    let wetFootSig = ""; 


    function updateFogFromParams() {
      if (!scene) return;

      const color = new THREE.Color(params.fogColor || "#0a1220");
      scene.background = color;

      if (!scene.fog) {
        scene.fog = new THREE.Fog(color, params.fogNear, params.fogFar);
      } else {
        scene.fog.color.copy(color);
        scene.fog.near = params.fogNear;
        scene.fog.far = params.fogFar;
      }
    }

    /* Linear interpolation for scalar values. */
    function lerpNumber(a, b, t) {
      return a + (b - a) * t;
    }


    /* Tightens fog near the world edge to hide the seam when enabled. */
    function updateEdgeFadeFog(focusX, focusZ) {
      if (!scene || !scene.fog) return;

      const baseNear = params.fogNear;
      const baseFar = params.fogFar;

      if (!params.fadeEndOfWorldEnabled) {
        scene.fog.near = baseNear;
        scene.fog.far = baseFar;
        return;
      }

      const half = Math.max(1, WORLD_BOUNDS_XZ);
      const dx = half - Math.abs(focusX);
      const dz = half - Math.abs(focusZ);
      const distToEdge = Math.max(0.0, Math.min(dx, dz));

      const defaultDist = Math.max(12.0, Math.min(120.0, half * 0.18));
      const maxDist = Math.min(400.0, half);

      const edgeFadeDist = clamp(
        Number(params.fadeEndOfWorldDistance ?? defaultDist),
        12.0,
        maxDist
        );

      const t = clamp(1.0 - (distToEdge / edgeFadeDist), 0.0, 1.0);

      const edgeNear = 0.1;
      const edgeFar = Math.min(baseFar, 5.0);

      const nearNow = lerpNumber(baseNear, edgeNear, t);
      let farNow = lerpNumber(baseFar, edgeFar, t);
      farNow = Math.max(farNow, nearNow + 0.5);

      scene.fog.near = nearNow;
      scene.fog.far = farNow;
    }



    /* Normalizes color values to "#rrggbb" for persistence and GUI compatibility. */
    function normalizeHexColor(value, fallback = "#ffffff") {
      if (typeof fallback !== "string" || !fallback.trim()) fallback = "#ffffff";

      if (typeof value === "number" && Number.isFinite(value)) {
        const n = (value >>> 0) & 0xffffff;
        return `#${n.toString(16).padStart(6, "0")}`;
      }

      if (typeof value !== "string") return fallback;

      const s = value.trim();
      if (!s) return fallback;

      if (s[0] === "#") {
        const hex = s.slice(1);
        if (/^[0-9a-fA-F]{3}$/.test(hex)) {
          return `#${hex[0]}${hex[0]}${hex[1]}${hex[1]}${hex[2]}${hex[2]}`.toLowerCase();
        }
        if (/^[0-9a-fA-F]{6}$/.test(hex)) return `#${hex.toLowerCase()}`;
        return fallback;
      }

      if (/^0x[0-9a-fA-F]{6}$/.test(s)) return `#${s.slice(2).toLowerCase()}`;

      return fallback;
    }

    /* Applies persisted surface colors to existing materials (ground/rocks/forest/cube). */
    function applySurfaceColorsFromParams() {
      const g = normalizeHexColor(params.groundColor, DEFAULTS.groundColor || "#ffffff");
      const r = normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442");
      const f = normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b");
      const c = normalizeHexColor(params.cubeColor, DEFAULTS.cubeColor || "#4e9cff");

      if (ground && ground.material && ground.material.color) {
        ground.material.color.set(g);
      }

      if (cube && cube.material && cube.material.color) {
        cube.material.color.set(c);
      }

      if (rockMat && rockMat.color) {
        rockMat.color.set(r);
      }

      if (forestConeMat && forestConeMat.color) {
        forestConeMat.color.set(f);
      }
    }



    // Clouds runtime
    let cloudLayer = null;
    let cloudMaterial = null;

    // Dust runtime
    const dustCenterTmp = new THREE.Vector3();
    let dustGeometry = null;
    let dustMaterial = null;
    let dustPoints = null;
    let dustUniforms = null;
    let dustLastCount = -1;

    // Rain runtime
    const rainCenterTmp = new THREE.Vector3();
    let rainGeometry = null;
    let rainMaterial = null;
    let rainPoints = null;
    let rainUniforms = null;
    let rainLastCount = -1;



    // -------------------------------------------------------------------------
    // Minimal WebAudio: background mp3 + simple gust FX
    // -------------------------------------------------------------------------

// -------------------------------------------------------------------------
// Music Player (playlist folders + JSON)
// -------------------------------------------------------------------------

    const PLAYLISTS_SET_URL = "./audio/playlists_set.json";
    const PLAYLISTS_BASE_URL = "./audio/playlists";

    let musicElement = null;
    let musicElementSource = null;

    let musicState = {
      playlists: [],
      playlistOrder: [],
      playlistId: "starter",
      playlistFolder: "starter",

      tracks: [],
      trackIndex: 0,

      isPlaying: false,
      loopPlaylist: true,
      followPlaylistsOrder: false,

      uiWired: false,
      ui: {
        root: null,
        title: null,
        time: null,
        seek: null,
        btnPlay: null,
        btnPrev: null,
        btnNext: null
      },
      _seeking: false,
      _lastUiTs: 0
    };

/* Loads playlists_set.json once and normalizes it into musicState.playlists + order. */
    async function loadPlaylistsSetOnce() {
      if (musicState.playlists && musicState.playlists.length) return;

      const res = await fetch(PLAYLISTS_SET_URL, { cache: "no-cache" });
      const json = await res.json();

      let list = [];
      let order = [];

      if (Array.isArray(json)) {
        list = json;
      } else if (json && typeof json === "object") {
        if (Array.isArray(json.playlists)) list = json.playlists;
        if (Array.isArray(json.order)) order = json.order;
      }

      list = (list || []).filter(Boolean).map((p) => {
        const id = String(p.id || p.folder || "").trim();
        const folder = String(p.folder || p.id || "").trim();
        return {
          id: id || folder,
          folder: folder || id,
          title: String(p.title || id || folder || "").trim(),
          thumbnail: String(p.thumbnail || "").trim(),
          albumMeta: (p.albumMeta && typeof p.albumMeta === "object") ? p.albumMeta : null,
          order: Number.isFinite(Number(p.order)) ? Number(p.order) : null
        };
      }).filter((p) => p.id && p.folder);

      if (!order.length) {
        order = list
        .slice()
        .sort((a, b) => {
          const ao = Number.isFinite(a.order) ? a.order : 1e9;
          const bo = Number.isFinite(b.order) ? b.order : 1e9;
          if (ao !== bo) return ao - bo;
          return a.id.localeCompare(b.id);
        })
        .map((p) => p.id);
      }

      musicState.playlists = list;
      musicState.playlistOrder = order;

      if (!musicState.playlists.some((p) => p.id === musicState.playlistId)) {
        musicState.playlistId = (musicState.playlistOrder[0] || (musicState.playlists[0] && musicState.playlists[0].id) || "starter");
      }

      const pl = musicState.playlists.find((p) => p.id === musicState.playlistId);
      if (pl) musicState.playlistFolder = pl.folder;
    }

/* Loads trackList.json (or tracks.json fallback) for the current playlist folder. */
    async function loadTracksForCurrentPlaylist() {
      const folder = String(musicState.playlistFolder || "starter").trim() || "starter";
      const urlA = `${PLAYLISTS_BASE_URL}/${folder}/trackList.json`;
      const urlB = `${PLAYLISTS_BASE_URL}/${folder}/tracks.json`;

      let json = null;
      try {
        const resA = await fetch(urlA, { cache: "no-cache" });
        json = await resA.json();
      } catch (_) {
        const resB = await fetch(urlB, { cache: "no-cache" });
        json = await resB.json();
      }

      let tracks = [];
      if (Array.isArray(json)) tracks = json;
      else if (json && typeof json === "object" && Array.isArray(json.tracks)) tracks = json.tracks;

      tracks = (tracks || []).filter(Boolean).map((t, idx) => {
        const file = String(t.file || t.src || "").trim();
        return {
          file,
          title: String(t.title || `Track ${idx + 1}`).trim(),
          artist: String(t.artist || "").trim(),
          duration: Number.isFinite(Number(t.duration)) ? Number(t.duration) : null,
          trackNumber: Number.isFinite(Number(t.trackNumber)) ? Number(t.trackNumber) : (idx + 1)
        };
      }).filter((t) => t.file);

      musicState.tracks = tracks;
      if (musicState.trackIndex < 0) musicState.trackIndex = 0;
      if (musicState.trackIndex >= tracks.length) musicState.trackIndex = 0;
    }

/* Creates the HTMLAudioElement once and wires it to the shared AudioContext master gain. */
    function ensureMusicElement() {
      if (musicElement) return musicElement;

      if (!audioListener || !audioCtx || !audioMaster) initAudio();
      if (!audioCtx || !audioMaster) return null;

      musicElement = document.createElement("audio");
      musicElement.preload = "metadata";
      musicElement.crossOrigin = "anonymous";
      musicElement.loop = false;

      musicElement.addEventListener("ended", () => {
        handleMusicTrackEnded();
      });

      musicElementSource = audioCtx.createMediaElementSource(musicElement);
      musicElementSource.connect(musicGain);

      return musicElement;
    }

/* Updates the DOM strip and keeps it in sync with current playback. */
    function updateNowPlayingUi(tsMs) {
      if (!musicState.uiWired) ensureNowPlayingUiWired();
      if (!musicState.uiWired) return;

      const ts = Number(tsMs || 0);
      if (ts && (ts - musicState._lastUiTs) < 60) return;
      musicState._lastUiTs = ts;

      const hasPlaylist = !!(musicState.tracks && musicState.tracks.length);
      const track = hasPlaylist ? musicState.tracks[musicState.trackIndex] : null;

      const root = musicState.ui.root;
      if (!root) return;

      const enabled = !!(params && params.musicEnabled);

  // Always show the strip; disable controls when Music is OFF.
      root.setAttribute("aria-hidden", "false");
      root.classList.toggle("now-playing--disabled", !enabled);

      const titleEl = musicState.ui.title;
      const timeEl = musicState.ui.time;
      const seekEl = musicState.ui.seek;
      const btnPlay = musicState.ui.btnPlay;
      const btnPrev = musicState.ui.btnPrev;
      const btnNext = musicState.ui.btnNext;

      const el = musicElement;
      const cur = (el && Number.isFinite(el.currentTime)) ? el.currentTime : 0;
      const dur = (el && Number.isFinite(el.duration)) ? el.duration : (track && Number.isFinite(track.duration) ? track.duration : 0);

      if (titleEl) {
        if (!enabled) {
          titleEl.textContent = "Music: OFF";
        } else if (track) {
          titleEl.textContent = track.artist ? `${track.title} â€” ${track.artist}` : track.title;
        } else {
          titleEl.textContent = "Loading playlistâ€¦";
        }
      }

      if (timeEl) {
        if (!enabled) timeEl.textContent = "0:00 / 0:00";
        else timeEl.textContent = `${formatClock(cur)} / ${formatClock(dur)}`;
      }

      if (seekEl) {
        seekEl.disabled = !enabled || !track;
        if (!musicState._seeking) {
          const frac = (enabled && dur > 0.0001) ? clamp(cur / dur, 0.0, 1.0) : 0.0;
          seekEl.value = String(frac);
        }
      }

      if (btnPlay) {
        btnPlay.disabled = !enabled || !track;
        btnPlay.textContent = musicState.isPlaying ? "Pause" : "Play";
      }

      if (btnPrev) btnPrev.disabled = !enabled || !track;
      if (btnNext) btnNext.disabled = !enabled || !track;
    }




/* Wires the Now Playing DOM strip once (buttons, seek). */
    function ensureNowPlayingUiWired() {
      if (musicState.uiWired) return;

      const root = document.getElementById("nowPlaying");
      const title = document.getElementById("nowPlayingTitle");
      const time = document.getElementById("nowPlayingTime");
      const seek = document.getElementById("nowPlayingSeek");
      const btnPlay = document.getElementById("nowPlayingPlay");
      const btnPrev = document.getElementById("nowPlayingPrev");
      const btnNext = document.getElementById("nowPlayingNext");

      if (!root || !seek || !btnPlay || !btnPrev || !btnNext) return;

      musicState.ui.root = root;
      musicState.ui.title = title;
      musicState.ui.time = time;
      musicState.ui.seek = seek;
      musicState.ui.btnPlay = btnPlay;
      musicState.ui.btnPrev = btnPrev;
      musicState.ui.btnNext = btnNext;

      seek.addEventListener("input", () => {
        musicState._seeking = true;
        updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());
      });

      seek.addEventListener("change", () => {
        const el = musicElement;
        if (!el) { musicState._seeking = false; return; }

        const dur = Number.isFinite(el.duration) ? el.duration : 0;
        const frac = clamp(Number(seek.value || 0), 0.0, 1.0);
        if (dur > 0.0001) el.currentTime = frac * dur;

        musicState._seeking = false;
        updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());
      });

      btnPlay.addEventListener("click", async () => {
        if (musicState.isPlaying) {
          musicPause();
        } else {
          await musicPlay();
        }
      });

      btnPrev.addEventListener("click", async () => {
        await musicPrev();
      });

      btnNext.addEventListener("click", async () => {
        await musicNext();
      });

      musicState.uiWired = true;
    }

/* Selects a playlist by id and loads its trackList.json. */
    async function musicSelectPlaylistById(id, { keepPlaying = false } = {}) {
      await loadPlaylistsSetOnce();

      const pid = String(id || "").trim();
      const pl = musicState.playlists.find((p) => p.id === pid) || musicState.playlists[0];
      if (!pl) return;

      musicState.playlistId = pl.id;
      musicState.playlistFolder = pl.folder;

      await loadTracksForCurrentPlaylist();

      musicState.trackIndex = clamp(musicState.trackIndex | 0, 0, Math.max(0, musicState.tracks.length - 1));
      await musicLoadCurrentTrack({ autoplay: keepPlaying && musicState.isPlaying });

      updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());
    }

/* Loads the current track into the element (does not restart on volume changes). */
    async function musicLoadCurrentTrack({ autoplay = false } = {}) {
      const el = ensureMusicElement();
      if (!el) return;

      const tracks = musicState.tracks || [];
      if (!tracks.length) return;

      const idx = clamp(musicState.trackIndex | 0, 0, tracks.length - 1);
      musicState.trackIndex = idx;

      const folder = String(musicState.playlistFolder || "starter").trim() || "starter";
      const t = tracks[idx];
      const url = `${PLAYLISTS_BASE_URL}/${folder}/${t.file}`;

      const wasPlaying = musicState.isPlaying;
      musicState.isPlaying = false;

      el.pause();
      el.src = url;
      el.load();

      if (autoplay || wasPlaying) {
        await musicPlay();
      } else {
        updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());
      }
    }

    async function musicPlay() {
      if (!params || !params.musicEnabled) return;

      if (!audioListener || !audioCtx || !audioMaster) initAudio();
      if (!audioCtx) return;

      await ensureAudioResumed();

      await loadPlaylistsSetOnce();
      if (!musicState.tracks || !musicState.tracks.length) {
        await musicSelectPlaylistById(musicState.playlistId || "starter", { keepPlaying: false });
      }

      const el = ensureMusicElement();
      if (!el) return;

      const tracks = musicState.tracks || [];
      if (!tracks.length) return;

      if (!el.src) {
        await musicLoadCurrentTrack({ autoplay: false });
      }

      try {
        await el.play();
        musicState.isPlaying = true;
      } catch (_) {
        musicState.isPlaying = false;
      }

      updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());
    }

    function musicPause() {
      if (!musicElement) return;
      musicElement.pause();
      musicState.isPlaying = false;
      updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());
    }

    async function musicNext() {
      if (!musicState.tracks || !musicState.tracks.length) return;

      const wasPlaying = musicState.isPlaying;

      musicState.trackIndex++;
      if (musicState.trackIndex >= musicState.tracks.length) {
        if (musicState.loopPlaylist) {
          musicState.trackIndex = 0;
        } else if (musicState.followPlaylistsOrder) {
          await musicAdvancePlaylist(+1);
          return;
        } else {
          musicState.trackIndex = musicState.tracks.length - 1;
          musicPause();
          return;
        }
      }

      await musicLoadCurrentTrack({ autoplay: wasPlaying });
    }

    async function musicPrev() {
      if (!musicState.tracks || !musicState.tracks.length) return;

      const el = musicElement;
      const cur = (el && Number.isFinite(el.currentTime)) ? el.currentTime : 0;

      const wasPlaying = musicState.isPlaying;

      if (cur > 2.0) {
        if (el) el.currentTime = 0;
        updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());
        return;
      }

      musicState.trackIndex--;
      if (musicState.trackIndex < 0) {
        if (musicState.loopPlaylist) {
          musicState.trackIndex = musicState.tracks.length - 1;
        } else if (musicState.followPlaylistsOrder) {
          await musicAdvancePlaylist(-1);
          return;
        } else {
          musicState.trackIndex = 0;
          updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());
          return;
        }
      }

      await musicLoadCurrentTrack({ autoplay: wasPlaying });
    }

    async function musicAdvancePlaylist(dir) {
      await loadPlaylistsSetOnce();
      const order = musicState.playlistOrder || [];
      if (!order.length) return;

      const idx = Math.max(0, order.indexOf(musicState.playlistId));
      let next = idx + (dir >= 0 ? 1 : -1);

      if (next >= order.length) next = 0;
      if (next < 0) next = order.length - 1;

      const wasPlaying = musicState.isPlaying;
      await musicSelectPlaylistById(order[next], { keepPlaying: wasPlaying });
    }

/* On track end: advance within playlist, loop, or follow playlists_set.json order. */
    function handleMusicTrackEnded() {
      if (!musicState.isPlaying) return;
      musicNext().catch(() => {});
    }

/* Applies music enable/volume from params WITHOUT reloading the track. */
    function applyMusicFromParams() {
      const wantEnabled = !!(params && params.musicEnabled);
      const vol = clamp(
        Number(params && params.musicVolume != null ? params.musicVolume : 0.35),
        0.0,
        1.0
        );

      if (!audioListener || !audioCtx || !audioMaster) initAudio();
      if (!audioCtx || !musicGain) return;

      const now = audioCtx.currentTime;
      const target = wantEnabled ? clamp(vol, 0.0, 1.0) : 0.0;

      musicGain.gain.cancelScheduledValues(now);
      musicGain.gain.setValueAtTime(musicGain.gain.value, now);
      musicGain.gain.linearRampToValueAtTime(target, now + 0.12);

      if (!wantEnabled) {
        musicPause();
      }

      ensureNowPlayingUiWired();
      updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());
    }

/* AudioContext + master graph stays the same. */
    function initAudio() {
      if (audioListener) return;
      if (!camera) return;

      audioListener = new THREE.AudioListener();
      camera.add(audioListener);

      audioCtx = audioListener.context;

      audioMaster = audioCtx.createGain();
      audioMaster.gain.value = 1.0;
      audioMaster.connect(audioCtx.destination);

      musicGain = audioCtx.createGain();
      musicGain.gain.value = 0.0;
      musicGain.connect(audioMaster);
    }
















    let audioListener = null;
    let audioCtx = null;
    let audioMaster = null;

    let musicGain = null;
    let musicSource = null;
    let musicBuffer = null;
    let musicEnabled = false;

    let sfxBus = null;
    let sfxNoiseBuffer = null;
    let sfxIrCache = null;

    let sfxMakerState = {
      selected: "<none>",
      id: "jump",
      draft: null
    };


    /* Ensures SFX bus exists and is wired to the shared master output. */
    function ensureSfxBus() {
      if (!audioListener || !audioCtx || !audioMaster) initAudio();
      if (!audioCtx || !audioMaster) return null;

      if (!sfxBus) {
        sfxBus = audioCtx.createGain();
        sfxBus.gain.value = clamp(Number(params && params.sfxVolume != null ? params.sfxVolume : 0.85), 0.0, 1.0);
        sfxBus.connect(audioMaster);
      }

      if (!sfxIrCache) sfxIrCache = new Map();

      return sfxBus;
    }

    /* Reusable noise buffer to avoid allocations per SFX play. */
    function ensureSfxNoiseBuffer() {
      if (!audioCtx) return null;
      if (sfxNoiseBuffer) return sfxNoiseBuffer;

      const ctx = audioCtx;
      const bufferSize = (ctx.sampleRate * 2) | 0;
      const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.random();
        sfxNoiseBuffer = buffer;
      return buffer;
    }

    /* Builds/gets an impulse response buffer for a given IR duration (cached). */
    function getSfxIR(seconds) {
      if (!audioCtx || !sfxIrCache) return null;

      const s = clamp(Number(seconds || 1.2), 0.2, 6.0);
      const key = String(s.toFixed(3));
      if (sfxIrCache.has(key)) return sfxIrCache.get(key);

      const ctx = audioCtx;
      const len = Math.max(1, (s * ctx.sampleRate) | 0);
      const ir = ctx.createBuffer(2, len, ctx.sampleRate);

      for (let ch = 0; ch < 2; ch++) {
        const d = ir.getChannelData(ch);
        for (let i = 0; i < len; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / len);
      }

    sfxIrCache.set(key, ir);
    return ir;
  }




/* Plays a WebAudio preset by id: playFX("jump"). */
  function playFX(id, scale = 1.0, presetOverride = null) {
    if (!params || !params.sfxEnabled) return;
    if (!id) return;

    const bus = ensureSfxBus();
    if (!bus || !audioCtx) return;

    if (audioCtx.state === "suspended") return;

    const presets = (params && params.sfxPresets && typeof params.sfxPresets === "object") ? params.sfxPresets : null;

    const p =
    (presetOverride && typeof presetOverride === "object")
    ? presetOverride
    : (presets && presets[id] ? presets[id] : null);

    if (!p) return;

    const ctx = audioCtx;
    const now = ctx.currentTime;

    const kind = String(p.kind || "osc").toLowerCase();
    const oscType = String(p.oscType || "sine");
    const freq = Math.max(1, Number(p.freq || 220));
    const freqEnd = Math.max(1, Number(p.freqEnd || freq));
    const noiseAmt = clamp(Number(p.noise != null ? p.noise : 0), 0.0, 1.0);

    const gainBase = clamp(Number(p.gain != null ? p.gain : 0.5), 0.0, 2.0) * clamp(Number(scale || 1), 0.05, 3.0);
    const attack = clamp(Number(p.attack != null ? p.attack : 0.002), 0.0, 0.5);
    const decay = clamp(Number(p.decay != null ? p.decay : 0.10), 0.0, 2.0);
    const release = clamp(Number(p.release != null ? p.release : 0.05), 0.0, 2.0);
    const duration = clamp(Number(p.duration != null ? p.duration : 0.2), 0.02, 6.0);

    const filterType = String(p.filterType || "none").toLowerCase();
    const filterFreq = clamp(Number(p.filterFreq != null ? p.filterFreq : 12000), 20, 20000);
    const filterQ = clamp(Number(p.filterQ != null ? p.filterQ : 0.7), 0.0001, 30);

    const panVal = clamp(Number(p.pan != null ? p.pan : 0), -1.0, 1.0);

    const reverbMix = clamp(Number(p.reverbMix != null ? p.reverbMix : 0.0), 0.0, 1.0);
    const irSeconds = clamp(Number(p.irSeconds != null ? p.irSeconds : 1.2), 0.2, 6.0);

    const master = ctx.createGain();
    master.gain.value = 1.0;

    const env = ctx.createGain();
    env.gain.setValueAtTime(0.0001, now);

    const peak = Math.max(0.0002, gainBase);
    const tA = now + attack;
    const tD = tA + decay;
    const tEnd = now + duration;
    const tRel = tEnd + release;

    env.gain.exponentialRampToValueAtTime(peak, Math.max(now + 0.0005, tA));
    env.gain.exponentialRampToValueAtTime(Math.max(0.0001, peak * 0.35), Math.max(tA + 0.0005, tD));
    env.gain.exponentialRampToValueAtTime(0.0001, Math.max(tEnd + 0.0005, tRel));

    const panner = ctx.createStereoPanner();
    panner.pan.value = panVal;

    let post = env;

    let filter = null;
    if (filterType !== "none") {
      filter = ctx.createBiquadFilter();
      filter.type = filterType;
      filter.frequency.value = filterFreq;
      filter.Q.value = filterQ;
      env.connect(filter);
      post = filter;
    }

    let osc = null;
    if (kind === "osc" || kind === "mix") {
      osc = ctx.createOscillator();
      osc.type = oscType;
      osc.frequency.setValueAtTime(freq, now);
      osc.frequency.exponentialRampToValueAtTime(freqEnd, Math.max(now + 0.01, tEnd));
      osc.connect(env);
    }

    let noise = null;
    let noiseGain = null;
    if (kind === "noise" || kind === "mix") {
      const buf = ensureSfxNoiseBuffer();
      if (buf) {
        noise = ctx.createBufferSource();
        noise.buffer = buf;
        noise.loop = true;

        noiseGain = ctx.createGain();
        noiseGain.gain.value = noiseAmt;

        noise.connect(noiseGain);
        noiseGain.connect(env);
      }
    }

    const dry = ctx.createGain();
    const wet = ctx.createGain();
    dry.gain.value = 1.0 - reverbMix;
    wet.gain.value = reverbMix;

    post.connect(dry);
    dry.connect(panner);

    if (reverbMix > 0.0001) {
      const convolver = ctx.createConvolver();
      convolver.buffer = getSfxIR(irSeconds);

      post.connect(convolver);
      convolver.connect(wet);
      wet.connect(panner);
    }

    panner.connect(master);
    master.connect(bus);

    if (osc) {
      osc.start(now);
      osc.stop(Math.max(now + 0.02, tRel + 0.02));
    }
    if (noise) {
      noise.start(now);
      noise.stop(Math.max(now + 0.02, tRel + 0.02));
    }
  }







  //     // Put your mp3 here
  // const MUSIC_URL = "./audio/9.mp3";
  // const MUSIC_MAX_GAIN = 0.35;

  // function initAudio() {
  //   if (audioListener) return;
  //   if (!camera) return;

  //   audioListener = new THREE.AudioListener();
  //   camera.add(audioListener);

  //   audioCtx = audioListener.context;

  //   audioMaster = audioCtx.createGain();
  //   audioMaster.gain.value = 1.0;
  //   audioMaster.connect(audioCtx.destination);

  //   musicGain = audioCtx.createGain();
  //   musicGain.gain.value = 0.0;
  //   musicGain.connect(audioMaster);
  // }




  async function ensureAudioResumed() {
    if (!audioCtx) return;
    if (audioCtx.state === "suspended") {
      await audioCtx.resume();
    }
  }

  async function loadMusicBuffer() {
    if (musicBuffer) return musicBuffer;
    if (!audioCtx) return null;

    const res = await fetch(MUSIC_URL);
    const arr = await res.arrayBuffer();
    musicBuffer = await audioCtx.decodeAudioData(arr);
    return musicBuffer;
  }

  async function startMusic() {
    if (!audioListener) initAudio();
    if (!audioCtx) return;

    await ensureAudioResumed();
    const buffer = await loadMusicBuffer();
    if (!buffer) return;

    if (musicSource) {
      musicSource.stop();
      musicSource.disconnect();
      musicSource = null;
    }

    const src = audioCtx.createBufferSource();
    src.buffer = buffer;
    src.loop = true;
    src.connect(musicGain);
    src.start();

    musicSource = src;
    musicEnabled = true;

    const now = audioCtx.currentTime;
    musicGain.gain.cancelScheduledValues(now);
    musicGain.gain.setValueAtTime(musicGain.gain.value, now);
    musicGain.gain.linearRampToValueAtTime(MUSIC_MAX_GAIN, now + 2.0);
  }

  function stopMusic() {
    if (!audioCtx || !musicSource) {
      musicEnabled = false;
      return;
    }

    const now = audioCtx.currentTime;
    musicGain.gain.cancelScheduledValues(now);
    musicGain.gain.setValueAtTime(musicGain.gain.value, now);
    musicGain.gain.linearRampToValueAtTime(0.0, now + 1.5);

    musicSource.stop(now + 1.6);
    musicSource.disconnect();
    musicSource = null;
    musicEnabled = false;
  }

      // Short filtered-noise whoosh for gusts
  function playGustFx(strength) {
    if (!audioCtx || !audioMaster) return;
    if (audioCtx.state === "suspended") return;

    const ctx = audioCtx;
    const duration = 0.8;
    const now = ctx.currentTime;

    const bufferSize = Math.floor(ctx.sampleRate * duration);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
      const t = i / bufferSize;
      const fadeIn = Math.min(1.0, t * 4.0);
      const fadeOut = 1.0 - t;
      data[i] = (Math.random() * 2.0 - 1.0) * fadeIn * fadeOut;
    }

    const src = ctx.createBufferSource();
    src.buffer = buffer;

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 400 + Math.random() * 600;
    bp.Q.value = 0.8 + Math.random() * 1.2;

    const gain = ctx.createGain();
    const peak = 0.5 * (strength || 1.0);
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(peak, now + 0.1);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    src.connect(bp);
    bp.connect(gain);
    gain.connect(audioMaster);

    src.start(now);
    src.stop(now + duration + 0.05);
  }


    /* Plays a one-shot landing thump (gap/drop scaled) for stunts/jumps. */
  function playLandingFx(gapMeters, dropMeters, points) {
    if (!params || !params.sfxEnabled) return;
    if (!camera) return;

    if (!audioListener || !audioCtx || !audioMaster) initAudio();
    if (!audioCtx || !audioMaster) return;
    if (audioCtx.state === "suspended") return;

    const ctx = audioCtx;
    const now = ctx.currentTime;

    const gap = Math.max(0.0, Number(gapMeters || 0));
    const drop = Math.max(0.0, Number(dropMeters || 0));
    const pts = Math.max(0, Number(points || 0));

    const intensity = clamp((drop / 5.0) + (gap / 6.0) + (pts * 0.15), 0.08, 1.0);
    const vol = clamp(Number(params.sfxVolume ?? 0.8), 0.0, 1.0);

    const duration = 0.22 + intensity * 0.18;

    const bufferSize = Math.floor(ctx.sampleRate * duration);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
      const t = i / bufferSize;
      const env = (1.0 - t);
      data[i] = (Math.random() * 2.0 - 1.0) * env;
    }

    const src = ctx.createBufferSource();
    src.buffer = buffer;

    const lp = ctx.createBiquadFilter();
    lp.type = "lowpass";
    lp.frequency.value = 280 + intensity * 520;
    lp.Q.value = 0.7;

    const punch = ctx.createOscillator();
    punch.type = "sine";
    punch.frequency.setValueAtTime(90 + intensity * 90, now);

    const punchGain = ctx.createGain();
    punchGain.gain.setValueAtTime(0.0001, now);
    punchGain.gain.exponentialRampToValueAtTime(0.35 * intensity * vol, now + 0.01);
    punchGain.gain.exponentialRampToValueAtTime(0.0001, now + 0.12);

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.exponentialRampToValueAtTime(Math.max(0.0002, vol * intensity), now + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);

    src.connect(lp);
    lp.connect(gain);
    gain.connect(audioMaster);

    punch.connect(punchGain);
    punchGain.connect(audioMaster);

    src.start(now);
    src.stop(now + duration + 0.02);

    punch.start(now);
    punch.stop(now + 0.14);
  }


  //   /* Applies mp3 music enable/volume from params WITHOUT restarting playback. */
  // function applyMusicFromParams() {
  //   const wantEnabled = !!(params && params.musicEnabled);
  //   const vol = clamp(
  //     Number(params && params.musicVolume != null ? params.musicVolume : 0.35),
  //     0.0,
  //     1.0
  //     );

  //   if (!audioListener || !audioCtx || !audioMaster) initAudio();
  //   if (!audioCtx || !musicGain) return;

  //     // Smooth gain change (no restart)
  //   const now = audioCtx.currentTime;
  //   const target = wantEnabled ? clamp(vol, 0.0, MUSIC_MAX_GAIN) : 0.0;

  //   musicGain.gain.cancelScheduledValues(now);
  //   musicGain.gain.setValueAtTime(musicGain.gain.value, now);
  //   musicGain.gain.linearRampToValueAtTime(target, now + 0.15);

  //     // Start/stop ONLY on state transitions / missing source
  //   if (wantEnabled) {
  //     if (!musicSource) {
  //       startMusic().catch(() => {});
  //     }
  //   } else {
  //     if (musicSource) stopMusic();
  //   }

  //   musicEnabled = wantEnabled;
  // }




    // GLTF / DRACO model system
    // ---------------------------------------------------------------------------

    const modelTemplates = {};   // name -> THREE.Object3D (original loaded scene)
    const modelInstances = {};   // id   -> THREE.Object3D (instance in scene)

    // Configure all GLB models and their instances here.

    // -------------------------------------------------------------------------
    // World editor mode (TransformControls selection + move/rotate/scale)
    // -------------------------------------------------------------------------

    let transformControls = null;
    let transformControlsHelper = null;

    const worldEditState = {
      enabled: false,
      selected: null
    };

    const worldEditSelectableRoots = new Set();
    const worldEditPointerNDC = new THREE.Vector2();
    const worldEditRaycaster = new THREE.Raycaster();

    const worldEditObbBox = new THREE.Box3();
    const worldEditObbCenter = new THREE.Vector3();
    const worldEditObbSize = new THREE.Vector3();
    const worldEditObbQuat = new THREE.Quaternion();
    const worldEditObbEuler = new THREE.Euler(0, 0, 0, "YXZ");


    /**
     * Registers a model instance root as selectable in world editor mode.
     */
    function registerWorldEditRoot(root, instCfg) {
      if (!root || !instCfg) return;
      worldEditSelectableRoots.add(root);

      root.userData.worldEditSelectable = true;
      root.userData.worldEditId = instCfg.id || "";
    }

    /**
     * Returns true when `obj` is a descendant of `ancestor` in the scene graph.
     */
    function isDescendantOf(obj, ancestor) {
      let n = obj;
      while (n) {
        if (n === ancestor) return true;
        n = n.parent;
      }
      return false;
    }



    /**
     * Clears world editor selection, detaches the gizmo, and refreshes UI state.
     */
    function clearWorldEditSelection() {
      worldEditState.selected = null;

      if (transformControls) {
        transformControls.detach();
      }

      if (transformControlsHelper) {
        transformControlsHelper.visible = false;
      }

      syncWorldEditObjectGuiSelection();
      updateAvatarButtons();
    }



    /**
     * Selects a world model root for editing, attaches the gizmo, and refreshes UI state.
     */
    function selectWorldEditRoot(root) {
      if (!root || !worldEditSelectableRoots.has(root) || !transformControls) return;

      worldEditState.selected = root;
      transformControls.attach(root);

      if (transformControlsHelper) {
        transformControlsHelper.visible = true;
      }

      if (controls) {
        controls.autoRotate = false;
      }

      syncWorldEditObjectGuiSelection();
      updateAvatarButtons();
    }



    /**
     * Rebuilds collision/sticking bounds after a world edit transform is committed.
     */
    function commitWorldEditTransform() {
      if (colliderObjects && colliderObjects.length) {
        colliderBounds = buildColliderBounds(colliderObjects);
        rebuildAvatarCollisionGrid();
        refreshMinimapStaticPoints();
      }

      if (avatarModelColliderObjects && avatarModelColliderObjects.length && Array.isArray(avatarModelColliderOBBs)) {
        avatarModelColliderOBBs.length = 0;

        for (const root of avatarModelColliderObjects) {
          if (!root) continue;

          root.updateWorldMatrix(true, true);

          worldEditObbBox.setFromObject(root);
          if (!Number.isFinite(worldEditObbBox.min.x) || !Number.isFinite(worldEditObbBox.max.x)) continue;

          worldEditObbBox.getCenter(worldEditObbCenter);
          worldEditObbBox.getSize(worldEditObbSize);

          root.getWorldQuaternion(worldEditObbQuat);
          worldEditObbEuler.setFromQuaternion(worldEditObbQuat);

          const hx = Math.max(0.10, (worldEditObbSize.x * 0.5) * 0.48);
          const hz = Math.max(0.10, (worldEditObbSize.z * 0.5) * 0.48);

          avatarModelColliderOBBs.push({
            id: root.userData.worldEditId || "",
            object: root,
            center: worldEditObbCenter.clone(),
            halfX: hx,
            halfZ: hz,
            yaw: worldEditObbEuler.y,
            yMin: worldEditObbBox.min.y,
            yMax: worldEditObbBox.max.y
          });
        }
      }

      if (vehiclePromptState && vehiclePromptState.open) {
        tickVehicleProximity();
      }
    }


    /**
     * Enables/disables world editor mode. When disabled, selection is cleared and edit-only overlays close.
     */
    function setWorldEditEnabled(enabled) {
      const next = !!enabled;
      if (worldEditState.enabled === next) return;

      worldEditState.enabled = next;

      // Keep existing behavior (do not remove).
      if (!next) {
        clearWorldEditSelection();
        if (typeof setWorldObjectPickerOpen === "function") setWorldObjectPickerOpen(false);
      } else {
        if (transformControlsHelper) transformControlsHelper.visible = !!worldEditState.selected;
      }

      // NEW: canvas highlight when edit is on.
      if (renderer && renderer.domElement) {
        renderer.domElement.classList.toggle("world-edit-on", worldEditState.enabled);
      }

      updateAvatarButtons();
      setWorldNameLabel(worldUiState.title);

    }



    // World editor history + duplicate/delete + undo/redo
    // -------------------------------------------------------------------------

    const worldEditHistory = {
      undo: [],
      redo: [],
      limit: 64,
      applying: false,
      dragPushed: false
    };

    /**
     * Ensures edits are applied to a mutable worldModelsConfig (never mutates MODEL_CONFIG).
     * Initializes from the current scene snapshot so transforms/features are preserved.
     */
    function ensureEditableWorldModelsConfig() {
      if (worldModelsConfig) return;

      const snap = snapshotWorldModelsConfig();
      const normalized = normalizeWorldModelsConfig(snap);

      worldModelsConfig = normalized || JSON.parse(JSON.stringify(MODEL_CONFIG));
      worldModelsConfigLoaded = true;

      for (const entry of worldModelsConfig) {
        if (!entry || !Array.isArray(entry.instances)) continue;

        for (const instCfg of entry.instances) {
          if (!instCfg || typeof instCfg !== "object") continue;

          const id = instCfg.id != null ? String(instCfg.id) : "";
          const inst = id ? modelInstances[id] : null;
          if (!inst) continue;

          Object.defineProperty(instCfg, "runtimeObject", {
            value: inst,
            enumerable: false,
            configurable: true
          });
        }
      }
    }

    /**
     * Pushes a snapshot of the current world models state to the undo stack and clears redo.
     */
    function pushWorldEditUndoSnapshot() {
      if (worldEditHistory.applying) return;

      ensureEditableWorldModelsConfig();

      const snap = snapshotWorldModelsConfig();
      worldEditHistory.undo.push(snap);

      if (worldEditHistory.undo.length > worldEditHistory.limit) {
        worldEditHistory.undo.shift();
      }

      worldEditHistory.redo.length = 0;
    }

    /**
     * Finds the (entry, instCfg, instIndex) that owns a given runtime root.
     */
    function findWorldEditConfigForRoot(root) {
      const base = worldModelsConfig || MODEL_CONFIG;

      for (let ei = 0; ei < base.length; ei++) {
        const entry = base[ei];
        if (!entry || !Array.isArray(entry.instances)) continue;

        for (let ii = 0; ii < entry.instances.length; ii++) {
          const instCfg = entry.instances[ii];
          if (!instCfg || typeof instCfg !== "object") continue;

          const bound = instCfg.runtimeObject || null;
          if (bound === root) return { entry, instCfg, entryIndex: ei, instIndex: ii };

          const id = instCfg.id != null ? String(instCfg.id) : "";
          if (id && modelInstances[id] === root) return { entry, instCfg, entryIndex: ei, instIndex: ii };
        }
      }

      return null;
    }

    /**
     * Generates a unique instance id for duplicates (keeps exporter/importer stable).
     */
    function makeUniqueWorldModelId(seed) {
      const base = worldModelsConfig || MODEL_CONFIG;
      const ids = new Set();

      for (const e of base) {
        if (!e || !Array.isArray(e.instances)) continue;
        for (const inst of e.instances) {
          const id = inst && inst.id != null ? String(inst.id) : "";
          if (id) ids.add(id);
        }
      }

      for (const k in modelInstances) ids.add(String(k));

        const cleanSeed = String(seed || "model").trim() || "model";
      let baseId = cleanSeed.endsWith("_copy") ? cleanSeed : `${cleanSeed}_copy`;

      if (!ids.has(baseId)) return baseId;

      let n = 2;
      while (true) {
        const cand = `${baseId}${n}`;
        if (!ids.has(cand)) return cand;
        n++;
      }
    }

    /**
     * Applies instCfg transform values to a runtime instance.
     * If instCfg.ground is true, Y is treated as an offset from the current surface height at XZ.
     */
    function applyInstCfgTransformToInstance(inst, instCfg) {
      const p = instCfg.position || [0, 0, 0];
      const r = instCfg.rotation || [0, 0, 0];
      const s = instCfg.scale != null ? instCfg.scale : 1.0;

      const x = Number.isFinite(p[0]) ? p[0] : 0;
      const z = Number.isFinite(p[2]) ? p[2] : 0;

      let y;
      if (instCfg.ground) {
        const surfaceY = getWorldSurfaceY(x, z);
        const offY = Number.isFinite(p[1]) ? p[1] : 0;
        y = (Number.isFinite(surfaceY) ? surfaceY : 0) + offY;
      } else {
        y = Number.isFinite(p[1]) ? p[1] : 0;
      }

      inst.position.set(x, y, z);
      inst.rotation.set(
        Number.isFinite(r[0]) ? r[0] : 0,
        Number.isFinite(r[1]) ? r[1] : 0,
        Number.isFinite(r[2]) ? r[2] : 0
        );

      if (Array.isArray(s) && s.length === 3) {
        inst.scale.set(
          Number.isFinite(s[0]) ? s[0] : 1,
          Number.isFinite(s[1]) ? s[1] : 1,
          Number.isFinite(s[2]) ? s[2] : 1
          );
      } else {
        const u = Number.isFinite(s) ? s : 1.0;
        inst.scale.setScalar(u);
      }
    }


    /**
     * Syncs a runtime instance transform back into its instCfg (position/rotation/scale).
     * If instCfg.ground is true, Y is stored as an offset from the current surface height at XZ.
     */
    function syncInstanceTransformToInstCfg(inst, instCfg) {
      const x = inst.position.x;
      const z = inst.position.z;

      if (instCfg && instCfg.ground) {
        const surfaceY = getWorldSurfaceY(x, z);
        const baseY = Number.isFinite(surfaceY) ? surfaceY : 0;
        instCfg.position = [x, inst.position.y - baseY, z];
      } else {
        instCfg.position = [x, inst.position.y, z];
      }

      instCfg.rotation = [inst.rotation.x, inst.rotation.y, inst.rotation.z];

      const sx = inst.scale.x;
      const sy = inst.scale.y;
      const sz = inst.scale.z;

      const eps = 1e-6;
      const uniform = Math.abs(sx - sy) < eps && Math.abs(sx - sz) < eps;

      instCfg.scale = uniform ? sx : [sx, sy, sz];
    }



    /**
     * Builds an OBB record for a model root (used by avatar collisions).
     * For ground-platform colliders, limits the vertical span to the top band so overhead decks
     * don't behave like full-height walls (allows passing under bridges).
     */
    function buildWorldEditOBBForRoot(root, id, instCfg) {
      root.updateWorldMatrix(true, true);

      worldEditObbBox.setFromObject(root);
      if (!Number.isFinite(worldEditObbBox.min.x) || !Number.isFinite(worldEditObbBox.max.x)) return null;

      worldEditObbBox.getCenter(worldEditObbCenter);
      worldEditObbBox.getSize(worldEditObbSize);

      root.getWorldQuaternion(worldEditObbQuat);
      worldEditObbEuler.setFromQuaternion(worldEditObbQuat);

      const hx = Math.max(0.10, (worldEditObbSize.x * 0.5) * 0.48);
      const hz = Math.max(0.10, (worldEditObbSize.z * 0.5) * 0.48);

      let yMin = worldEditObbBox.min.y;
      const yMax = worldEditObbBox.max.y;

      if (instCfg && instCfg.ground) {
        const band = Math.max(0.18, avatarCollision.maxStep + 0.08);
        yMin = Math.min(yMax, yMax - band);
      }

      return {
        id: id || "",
        object: root,
        center: worldEditObbCenter.clone(),
        halfX: hx,
        halfZ: hz,
        yaw: worldEditObbEuler.y,
        yMin,
        yMax
      };
    }





    /**
     * Removes a model instance from the scene and runtime maps by id.
     */
    function removeWorldModelInstanceById(id) {
      const key = String(id || "");
      if (!key) return;

      const inst = modelInstances[key] || null;
      if (!inst) return;

      if (transformControls && worldEditState.selected === inst) {
        clearWorldEditSelection();
      }

      if (inst.parent) inst.parent.remove(inst);
      delete modelInstances[key];
    }



    /**
     * Rebuilds runtime caches for world models without touching non-model colliders (forest/rocks/etc).
     */
    /**
     * Rebuilds runtime caches for world models without touching non-model colliders (forest/rocks/etc).
     * Ground meshes are used for surface height only; they must not become XZ blocking walls.
     */
    function rebuildWorldModelsRuntimeCaches() {
      vehicleInteractables.length = 0;
      equipmentInteractables.length = 0;
      setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);

      avatarModelColliderObjects.length = 0;
      avatarModelColliderBounds.length = 0;
      avatarModelColliderOBBs.length = 0;

      colliderObjects = colliderObjects.filter((obj) => !(obj && obj.userData && obj.userData.worldModelStick));

      worldGroundMeshes.length = 0;

      worldEditSelectableRoots.clear();
      clearWorldEditSelection();

      const base = worldModelsConfig || MODEL_CONFIG;

      for (const entry of base) {
        if (!entry || !Array.isArray(entry.instances)) continue;

        for (const instCfg of entry.instances) {
          if (!instCfg || typeof instCfg !== "object") continue;

          const id = instCfg.id != null ? String(instCfg.id) : "";
          const inst = (instCfg.runtimeObject || (id ? modelInstances[id] : null)) || null;
          if (!inst) continue;

          Object.defineProperty(instCfg, "runtimeObject", {
            value: inst,
            enumerable: false,
            configurable: true
          });

          registerWorldEditRoot(inst, instCfg);

          const isGround = !!instCfg.ground;
          const isStick = !!instCfg.stick;

          inst.traverse((obj) => {
            if (!obj.isMesh) return;
            obj.castShadow = true;
            obj.receiveShadow = true;

            if (isGround) {
              obj.userData.worldModelGroundPlatform = true;
              if (!obj.name && id) obj.name = `ground:${id}`;
              worldGroundMeshes.push(obj);
            }

            if (isStick && !isGround) {
              obj.userData.worldModelStick = true;
              if (!obj.name && id) obj.name = `stick:${id}`;
              colliderObjects.push(obj);
            }
          });

          if (instCfg.vehicle) {
            registerVehicleInstance(inst, instCfg);
          }




          if (instCfg.collide) {
            avatarModelColliderObjects.push(inst);
            const obb = buildWorldEditOBBForRoot(inst, id);
            if (obb) avatarModelColliderOBBs.push(obb);
          }
        }
      }

      if (colliderObjects.length) {
        colliderBounds = buildColliderBounds(colliderObjects);
        rebuildAvatarCollisionGrid();
      } else {
        colliderBounds = [];
        rebuildAvatarCollisionGrid();
      }

      if (vehiclePromptState && vehiclePromptState.open) {
        tickVehicleProximity();
      }
    }







    /**
     * Applies a full world-models snapshot to the scene (adds/removes instances by id and updates transforms).
     */
    function applyWorldModelsSnapshot(snapshot) {
      const normalized = normalizeWorldModelsConfig(snapshot);
      if (!normalized) return;

      worldEditHistory.applying = true;

      try {
        const desiredIds = new Set();
        const desiredById = new Map();

        for (const entry of normalized) {
          if (!entry || !Array.isArray(entry.instances)) continue;

          for (const instCfg of entry.instances) {
            if (!instCfg || typeof instCfg !== "object") continue;

            const id = instCfg.id != null ? String(instCfg.id) : "";
            if (!id) continue;

            desiredIds.add(id);
            desiredById.set(id, { entryName: entry.name, instCfg });
          }
        }

        for (const id in modelInstances) {
          if (!desiredIds.has(String(id))) {
            removeWorldModelInstanceById(id);
          }
        }

        for (const [id, rec] of desiredById.entries()) {
          let inst = modelInstances[id] || null;

          if (!inst) {
            const template = modelTemplates[rec.entryName] || null;
            if (!template) continue;

            inst = template.clone(true);
            scene.add(inst);
            modelInstances[id] = inst;
          }

          applyInstCfgTransformToInstance(inst, rec.instCfg);
        }

        worldModelsConfig = normalized;
        worldModelsConfigLoaded = true;

        for (const entry of worldModelsConfig) {
          if (!entry || !Array.isArray(entry.instances)) continue;

          for (const instCfg of entry.instances) {
            if (!instCfg || typeof instCfg !== "object") continue;
            const id = instCfg.id != null ? String(instCfg.id) : "";
            const inst = id ? (modelInstances[id] || null) : null;
            if (!inst) continue;

            Object.defineProperty(instCfg, "runtimeObject", {
              value: inst,
              enumerable: false,
              configurable: true
            });
          }
        }

        rebuildWorldModelsRuntimeCaches();
      } finally {
        worldEditHistory.applying = false;
      }
    }

    /**
     * Performs an undo (restores previous snapshot). Redo receives the current snapshot.
     */
    function worldEditUndo() {
      if (!worldEditHistory.undo.length) return;

      ensureEditableWorldModelsConfig();

      const current = snapshotWorldModelsConfig();
      const prev = worldEditHistory.undo.pop();

      worldEditHistory.redo.push(current);
      if (worldEditHistory.redo.length > worldEditHistory.limit) {
        worldEditHistory.redo.shift();
      }

      applyWorldModelsSnapshot(prev);
      updateAvatarButtons();
      showActionToast("Undo");
    }


    /**
     * Performs a redo (restores next snapshot). Undo receives the current snapshot.
     */
    function worldEditRedo() {
      if (!worldEditHistory.redo.length) return;

      ensureEditableWorldModelsConfig();

      const current = snapshotWorldModelsConfig();
      const next = worldEditHistory.redo.pop();

      worldEditHistory.undo.push(current);
      if (worldEditHistory.undo.length > worldEditHistory.limit) {
        worldEditHistory.undo.shift();
      }

      applyWorldModelsSnapshot(next);
      updateAvatarButtons();
      showActionToast("Redo");
    }


    /**
     * Duplicates the selected model instance (Shift+D).
     */
    function duplicateSelectedWorldModel() {
      if (!worldEditState.enabled || !worldEditState.selected) return;

      ensureEditableWorldModelsConfig();

      const found = findWorldEditConfigForRoot(worldEditState.selected);
      if (!found) return;

      pushWorldEditUndoSnapshot();

      const srcRoot = worldEditState.selected;
      const srcCfg = found.instCfg;

      const dupCfg = JSON.parse(JSON.stringify(srcCfg));
      dupCfg.id = makeUniqueWorldModelId(srcCfg.id || found.entry.name);

      syncInstanceTransformToInstCfg(srcRoot, dupCfg);

      if (!Array.isArray(dupCfg.position)) dupCfg.position = [0, 0, 0];
      if (dupCfg.position.length < 3) dupCfg.position = [dupCfg.position[0] || 0, dupCfg.position[1] || 0, dupCfg.position[2] || 0];

      dupCfg.position[0] += 1.0;
      dupCfg.position[2] += 1.0;

      found.entry.instances.splice(found.instIndex + 1, 0, dupCfg);

      const template = modelTemplates[found.entry.name] || null;
      if (!template) return;

      const inst = template.clone(true);
      applyInstCfgTransformToInstance(inst, dupCfg);

      Object.defineProperty(dupCfg, "runtimeObject", {
        value: inst,
        enumerable: false,
        configurable: true
      });

      scene.add(inst);
      modelInstances[dupCfg.id] = inst;

      rebuildWorldModelsRuntimeCaches();
      selectWorldEditRoot(inst);
      updateAvatarButtons();
      showActionToast("Cloned");
    }


    /**
     * Deletes the selected model instance (X).
     */
    function deleteSelectedWorldModel() {
      if (!worldEditState.enabled || !worldEditState.selected) return;

      ensureEditableWorldModelsConfig();

      const found = findWorldEditConfigForRoot(worldEditState.selected);
      if (!found) return;

      pushWorldEditUndoSnapshot();

      const root = worldEditState.selected;
      const id = found.instCfg.id != null ? String(found.instCfg.id) : "";

      clearWorldEditSelection();

      if (root.parent) root.parent.remove(root);
      if (id && modelInstances[id] === root) delete modelInstances[id];

      found.entry.instances.splice(found.instIndex, 1);

      rebuildWorldModelsRuntimeCaches();
      updateAvatarButtons();
      showActionToast("Deleted");
    }





    /**
     * Handles canvas pointer picking for world editor selection.
     */
    function onWorldEditPointerDown(event) {
      if (!worldEditState.enabled) return;
      if (!renderer || !camera || !transformControls) return;
      if (event.button !== 0) return;
      if (transformControls.dragging) return;

      const rect = renderer.domElement.getBoundingClientRect();
      const nx = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      const ny = -(((event.clientY - rect.top) / rect.height) * 2 - 1);

      worldEditPointerNDC.set(nx, ny);
      worldEditRaycaster.setFromCamera(worldEditPointerNDC, camera);

      const roots = Array.from(worldEditSelectableRoots);
      if (!roots.length) return;

      const hits = worldEditRaycaster.intersectObjects(roots, true);

      let pickedRoot = null;

      for (const h of hits) {
        let obj = h.object;
        if (!obj) continue;

        if (transformControlsHelper && isDescendantOf(obj, transformControlsHelper)) continue;

        while (obj && !worldEditSelectableRoots.has(obj)) {
          obj = obj.parent;
        }

        if (obj && worldEditSelectableRoots.has(obj)) {
          pickedRoot = obj;
          break;
        }
      }

      if (!pickedRoot) {
        clearWorldEditSelection();
        return;
      }

      selectWorldEditRoot(pickedRoot);
    }




    // Per-instance `stick: true` means â€œsnow can stick to this modelâ€.

    const MODEL_CONFIG = [

      // {
      //   name: "ginger bread",
      //   url: "models/gingerbread_man-c.glb",
      //   instances: [
      //     {
      //       id: "model1_center",
      //       position: [3, 0, -5],
      //       rotation: [0, 0, 0],
      //       scale: 1.0,
      //       stick: true,
      //       collide: false
      //     }
      //   ]
      // },

      // {
      //   name: "5gmast",
      //   url: "models/buildings/5gmast.glb",
      //   instances: [
      //     {
      //       id: "5gmast_center",
      //       position: [3, 0, -5],
      //       rotation: [0, 0, 0],
      //       scale: 1.0,
      //       stick: true,
      //       collide: false
      //     }
      //   ]
      // },

      // {
      //   name: "vending1",
      //   url: "models/vending/vending.glb",
      //   instances: [
      //     {
      //       id: "vending1_center",
      //       position: [3, 0, -5],
      //       rotation: [0, 0, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: false
      //     }
      //   ]
      // },  

      // {
      //   name: "box1",
      //   url: "models/boxes/box1.glb",
      //   instances: [
      //     {
      //       id: "box1_center",
      //       position: [3, 0, -5],
      //       rotation: [0, 0, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: false
      //     }
      //   ]
      // },      

      // {
      //   name: "trees1",
      //   url: "models/trees/trees.glb",
      //   instances: [
      //     {
      //       id: "tree_center",
      //       position: [10, 0, -10],
      //       rotation: [0, 0, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: false
      //     }
      //   ]
      // }, 

      // {
      //   name: "box",
      //   url: "models/boxes/box1.glb",
      //   instances: [
      //     {
      //       id: "box_center",
      //       position: [14, 0, -12],
      //       rotation: [0, 0, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: false
      //     }
      //   ]
      // }, 


      // {
      //   name: "house",
      //   url: "models/buildings/house.glb",
      //   instances: [
      //     {
      //       id: "house_center",
      //       position: [21, -1, -11],
      //       rotation: [0, 0, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: true
      //     }
      //   ]
      // },       


      // {
      //   name: "cinema",
      //   url: "models/buildings/cinema/ashford-cinema-1.glb",
      //   instances: [
      //     {
      //       id: "cinema_center",
      //       position: [32, -1, -18],
      //       rotation: [0, 0, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: true
      //     }
      //   ]
      // }, 



      // {
      //   name: "model2",
      //   url: "models/christmas_tree_polycraft-c.glb",
      //   instances: [
      //     {
      //       id: "tree_center",
      //       position: [0, 0, 0],
      //       rotation: [0, 0, 0],
      //       scale: 0.05,
      //       stick: true,
      //       collide: false
      //     }
      //   ]
      // },
      // {
      //   name: "model3",
      //   url: "models/snowman-c.glb",
      //   instances: [
      //     {
      //       id: "snowman",
      //       position: [-7, -0.2, -1],
      //       rotation: [0, 1, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: false
      //     }
      //   ]
      // },
      // {
      //   name: "model4",
      //   url: "models/car-c.glb",
      //   instances: [
      //     {
      //       id: "car",
      //       position: [4, -0.5, 6],
      //       rotation: [0, 1, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: false,
      //       vehicle: {
      //         type: "Car",
      //         description: "Ground vehicle",
      //         seatLocal: [0.0, 0.55, 0.15],
      //         yawOffset: 0.0,
      //         profile: {
      //           maxSpeed: 1.0,
      //           maxReverse: 1.0,
      //           accel: 10.0,
      //           brake: 14.0,
      //           coastDecel: 3.2,
      //           turnRate: 5,
      //           radius: 0.85
      //         }
      //       }
      //     }
      //   ]
      // },


      // {
      //   name: "jetpack",
      //   url: "models/vehicles/jetpacks/jetpack.glb",
      //   instances: [
      //     {
      //       id: "jetpack_1",
      //       position: [3, 0, -5],
      //       rotation: [0, 0, 0],
      //       scale: 1,
      //       stick: false,
      //       collide: false,
      //       equipment: {
      //         type: "Jetpack",
      //         description: "Personal jetpack",
      //         action: "jetpack",
      //         attach: {
      //           bone: "Spine2",
      //           position: [0, 0.08, -0.22],
      //           rotation: [0, 3.14159, 0],
      //           scale: 1
      //         }
      //       }
      //     }
      //   ]
      // },

      // {
      //   name: "backpack",
      //   url: "models/backpacks/backpack1.glb",
      //   instances: [
      //     {
      //       id: "backpack1",
      //       position: [3, 0, -5],
      //       rotation: [0, 0, 0],
      //       scale: 1,
      //       stick: false,
      //       collide: false,
      //       equipment: {
      //         type: "Backpack",
      //         description: "Wearable backpack",
      //         action: "",
      //         attach: {
      //           bone: "Spine2",
      //           position: [0, 0.06, -0.18],
      //           rotation: [0, 3.14159, 0],
      //           scale: 1
      //         }
      //       }
      //     }
      //   ]
      // },



      // {
      //   name: "plane",
      //   url: "models/vehicles/flying/plane1.glb",

      //   instances: [
      //     {
      //       id: "plane",
      //       position: [4, 0, 15],
      //       rotation: [0, 1.5, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: true,

      //       vehicle: {
      //         type: "Small Airplane",
      //         description: "Small Airplane 1",
      //         seatLocal: [0.0, 0.8, -0.43],
      //         yawOffset: 0.0,
      //         profile: {
      //           maxSpeed: 27.2,
      //           maxReverse: 2.1,
      //           accel: 7.1,
      //           brake: 2.7,
      //           coastDecel: 1.7,
      //           turnRate: 0.6,
      //           radius: 0.95,
      //           wheelBase: 2.66,
      //           minTurnRadius: 7.7,
      //           minSteerSpeed: 0.35,
      //           steerResponse: 2.0,
      //           steerReturn: 6.0,
      //           lateralGrip: 8.0,
      //           wetWidth: 0.05,
      //           wetLength: 1.04,
      //           trackHalfWidth: 1.0,
      //           airRollResponse: 1.7,
      //           airRollReturn: 5.0,
      //           climbPitchMax: 0.17,
      //           climbPitchSpeed: 6.6,
      //           pitchResponse: 3.2,
      //           pitchReturn: 0.1,
      //           turnPitchMax: 0.08,
      //           propAxis: "z",
      //           airRollMax: 1.18,
      //           airTurnScale: 0.21,
      //           liftResponse: 0.1,
      //           maxLift: 21.9,
      //           minFlySpeed: 22.3
      //         }
      //       }
      //     }
      //   ]
      // },

      // {
      //   name: "plane2",
      //   url: "models/vehicles/flying/plane2.glb",

      //   instances: [
      //     {
      //       id: "plane2",
      //       position: [4, 0, 35],
      //       rotation: [0, 1.5, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: true,

      //       vehicle: {
      //         type: "Small Airplane 2",
      //         description: "Small Airplane 2",

      //         seatLocal: [0.19, 0.82, -0.91],

      //         yawOffset: 0.0,
      //         profile: {
      //           maxSpeed: 27.2,
      //           maxReverse: 2.1,
      //           accel: 7.1,
      //           brake: 2.7,
      //           coastDecel: 1.7,
      //           turnRate: 0.6,
      //           radius: 0.95,
      //           wheelBase: 2.66,
      //           minTurnRadius: 7.7,
      //           minSteerSpeed: 0.35,
      //           steerResponse: 2.0,
      //           steerReturn: 6.0,
      //           lateralGrip: 8.0,

      //           wetWidth: 0.05,
      //           wetLength: 1.04,

      //           trackHalfWidth: 1.57,

      //           airRollResponse: 1.7,
      //           airRollReturn: 5.0,
      //           climbPitchMax: 0.17,
      //           climbPitchSpeed: 6.6,
      //           pitchResponse: 3.2,
      //           pitchReturn: 0.1,
      //           turnPitchMax: 0.08,
      //           propAxis: "z",
      //           airRollMax: 1.18,
      //           airTurnScale: 0.21,
      //           liftResponse: 0.1,
      //           maxLift: 21.9,
      //           minFlySpeed: 22.3
      //         }
      //       }
      //     }
      //   ]
      // },


      // {
      //   name: "skipatrol",
      //   url: "models/vehicles/ski_patrol1.glb",
      //   instances: [
      //     {
      //       id: "skipatrol",
      //       position: [9, 0, 4],
      //       rotation: [0, 1, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: true,

      //       // MODEL_CONFIG -> instance "skipatrol" (Ski Patrol)
      //       vehicle: {
      //         type: "Ski Patrol",
      //         description: "Snow vehicle / patrol sled",
      //         seatLocal: [0.0, 0.034, -0.52],
      //         yawOffset: 0.0,
      //         profile: {
      //           maxSpeed: 11.2,
      //           maxReverse: 5.0,
      //           accel: 4.2,
      //           brake: 18.0,
      //           coastDecel: 4.0,
      //           turnRate: 2.8,
      //           radius: 1.55,
      //           wheelBase: 2.66,
      //           minTurnRadius: 6.0,
      //           minSteerSpeed: 0.35,
      //           steerResponse: 2.1,
      //           steerReturn: 6.0,
      //           lateralGrip: 8.0,
      //           wetWidth: 0.05,
      //           wetLength: 1.04,
      //           trackHalfWidth: 0.5,
      //           airRollResponse: 8.0,
      //           airRollReturn: 5.0,
      //           climbPitchMax: 0.22,
      //           climbPitchSpeed: 4.0,
      //           pitchResponse: 4.0,
      //           pitchReturn: 3.0,
      //           turnPitchMax: 0.1,
      //           airRollMax: 0.35,
      //           airTurnScale: 0.35,
      //           liftResponse: 5.0,
      //           maxLift: 10.0,
      //           minFlySpeed: 14.0
      //         }
      //       }



      //     }
      //   ]
      // },

      // {
      //   name: "snowcar",
      //   url: "models/vehicles/snowcar.glb",
      //   instances: [
      //     {
      //       id: "car2",
      //       position: [-4, 0.19, 6],
      //       rotation: [0, 1, 0],
      //       scale: 1.0,
      //       stick: false,
      //       collide: true,
      //       vehicle: {
      //         type: "Snowcar",
      //         description: "Snow-capable car",
      //         seatLocal: [0.5, 0.54, 1.15],
      //         yawOffset: 0.0,
      //         profile: {
      //           maxSpeed: 13.2,
      //           maxReverse: 6.9,
      //           accel: 3.2,
      //           brake: 15.9,
      //           coastDecel: 1.8,
      //           turnRate: 0.64,
      //           radius: 0.7,
      //           wheelBase: 1.9,
      //           minTurnRadius: 3.8,
      //           minSteerSpeed: 0.55,
      //           steerResponse: 5.7,
      //           steerReturn: 7.0,
      //           lateralGrip: 9.0,
      //           wetWidth: 0.15,
      //           wetLength: 1.63,
      //           trackHalfWidth: 1.1,
      //           propSpinIdle: 8.0,
      //           propSpinMax: 80.0,
      //           propSpinMul: 1.0,
      //           propAxis: "z",
      //           propInvert: false             
      //         }
      //       }
      //     }
      //   ]
      // }


    ];






    const WORLD_MODELS_URL = "models/Default.models.json";

    const WORLD_MODELS_OVERRIDE_KEY = "snow:worldModelsOverride:v1";

    const WORLDS_DB_NAME = "snow-worlds";
    const WORLDS_DB_VERSION = 1;
    const WORLDS_STORE = "worlds";
    const ACTIVE_WORLD_ID_KEY = "snow:activeWorldId:v1";
    const PENDING_WORLD_THUMB_ID_KEY = "snow:pendingWorldThumbId:v1";
    const WORLD_PICKER_SUPPRESS_ONCE_KEY = "snow:worldPickerSuppressOnce:v1";


    const worldModelsIoState = {
      source: "defaults",
      openWorlds() {
        openWorldPickerOverlay();
      },
      exportWorldModelsJson() {
        exportWorldModelsJson();
      },
      exportDefaultModelJson() {
        exportDefaultModelJson();
      },
      importWorldModelsJson() {
        importWorldModelsJson();
      }
    };


    let worldModelsConfig = null;
    let worldModelsConfigLoaded = false;

    const worldPickerState = { open: false, wired: false, editId: "" };


    const worldUiState = { id: "", title: "Default" };
    let worldNameEl = null;

    /**
     * Updates the top-center world title label.
     */
    function setWorldNameLabel(title) {
      const t = String(title || "").trim() || "Default";
      worldUiState.title = t;

      if (!worldNameEl) return;

      const isEdit = !!(worldEditState && worldEditState.enabled);
      worldNameEl.classList.toggle("is-edit", isEdit);

      worldNameEl.textContent = isEdit ? (`EDIT: ${t}`) : t;
      worldNameEl.setAttribute("aria-hidden", t ? "false" : "true");
    }


    /**
     * Sets the active world identity for UI display.
     */
    function setActiveWorldUi(id, title) {
      worldUiState.id = String(id || "").trim();
      setWorldNameLabel(title);
    }    

    let worldPickerEl = null;
    let worldPickerCloseBtn = null;

    let worldPickerListEl = null;
    let worldPickerListLocalEl = null;
    let worldPickerListPrivateEl = null;
    let worldPickerListGlobalEl = null;

    let worldPickerLocalMetaEl = null;
    let worldPickerPrivateMetaEl = null;
    let worldPickerGlobalMetaEl = null;

    let worldTitleInputEl = null;
    let worldDescInputEl = null;
    let worldSaveBtnEl = null;
    let worldImportBtnEl = null;

    const worldPickerCloudState = {
      privateWorlds: [],
      globalWorlds: [],
      lastError: ""
    };


    /**
     * Validates and normalizes a model config payload into the expected MODEL_CONFIG array shape.
     * Preserves all unknown/extra fields on entries and instances; only normalizes position/rotation/scale.
     * Returns null when the payload is unusable.
     */
    /**
     * Validates and normalizes a model config payload into the expected MODEL_CONFIG array shape.
     * Preserves all unknown/extra fields on entries and instances; only normalizes position/rotation/scale.
     * Also restores missing instance-level equipment metadata from MODEL_CONFIG templates (backwards compatibility).
     * Returns null when the payload is unusable.
     */
    function normalizeWorldModelsConfig(raw) {
      if (!Array.isArray(raw)) return null;

      const out = [];

      const hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
      const deepClonePlain = (v) => JSON.parse(JSON.stringify(v));

      const templateByName = new Map();
      if (Array.isArray(MODEL_CONFIG)) {
        for (const t of MODEL_CONFIG) {
          if (!t || typeof t !== "object") continue;
          if (typeof t.name !== "string" || !t.name) continue;
          templateByName.set(t.name, t);
        }
      }

      for (let i = 0; i < raw.length; i++) {
        const e = raw[i];
        if (!e || typeof e !== "object") continue;

        const name = typeof e.name === "string" ? e.name : "";
        const url = typeof e.url === "string" ? e.url : "";
        const instances = Array.isArray(e.instances) ? e.instances : [];

        if (!name || !url) continue;

        const cleanInstances = [];

        const tmplEntry = templateByName.get(name) || null;
        const tmplInst =
        tmplEntry && Array.isArray(tmplEntry.instances) && tmplEntry.instances.length
        ? tmplEntry.instances[0]
        : null;

        for (let k = 0; k < instances.length; k++) {
          const inst = instances[k];
          if (!inst || typeof inst !== "object") continue;

          const p = Array.isArray(inst.position) && inst.position.length === 3 ? inst.position : [0, 0, 0];
          const r = Array.isArray(inst.rotation) && inst.rotation.length === 3 ? inst.rotation : [0, 0, 0];

          let s = inst.scale;
          if (Array.isArray(s)) {
            if (s.length !== 3) s = 1.0;
          } else if (!Number.isFinite(s)) {
            s = 1.0;
          }

          const copy = { ...inst };

          copy.position = [
            Number.isFinite(p[0]) ? p[0] : 0,
            Number.isFinite(p[1]) ? p[1] : 0,
            Number.isFinite(p[2]) ? p[2] : 0
          ];

          copy.rotation = [
            Number.isFinite(r[0]) ? r[0] : 0,
            Number.isFinite(r[1]) ? r[1] : 0,
            Number.isFinite(r[2]) ? r[2] : 0
          ];

          copy.scale = s;

          if (tmplInst && tmplInst.equipment && !hasOwn(copy, "equipment")) {
            copy.equipment = deepClonePlain(tmplInst.equipment);
          }

          cleanInstances.push(copy);
        }

        const entryCopy = { ...e };
        entryCopy.name = name;
        entryCopy.url = url;
        entryCopy.instances = cleanInstances;

        out.push(entryCopy);
      }

      return out.length ? out : null;
    }





    /**
     * Opens IndexedDB (worlds) and returns a live IDBDatabase instance.
     */
    function openWorldDb() {
      return new Promise((resolve, reject) => {
        if (!("indexedDB" in window)) {
          reject(new Error("IndexedDB not available"));
          return;
        }

        const req = indexedDB.open(WORLDS_DB_NAME, WORLDS_DB_VERSION);

        req.onupgradeneeded = () => {
          const db = req.result;
          if (!db.objectStoreNames.contains(WORLDS_STORE)) {
            db.createObjectStore(WORLDS_STORE, { keyPath: "id" });
          }
        };

        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error || new Error("IndexedDB open failed"));
      });
    }

    function idbTx(db, mode) {
      return db.transaction(WORLDS_STORE, mode).objectStore(WORLDS_STORE);
    }

    /**
     * Reads all stored worlds, sorted by updatedAt descending.
     */
    async function idbGetAllWorlds() {
      const db = await openWorldDb();
      return await new Promise((resolve, reject) => {
        const store = idbTx(db, "readonly");
        const req = store.getAll();
        req.onsuccess = () => {
          const arr = Array.isArray(req.result) ? req.result : [];
          arr.sort((a, b) => (Number(b.updatedAt) || 0) - (Number(a.updatedAt) || 0));
          resolve(arr);
        };
        req.onerror = () => reject(req.error || new Error("getAll failed"));
      });
    }

    /**
     * Reads a single world by id.
     */
    async function idbGetWorld(id) {
      const db = await openWorldDb();
      return await new Promise((resolve, reject) => {
        const store = idbTx(db, "readonly");
        const req = store.get(String(id));
        req.onsuccess = () => resolve(req.result || null);
        req.onerror = () => reject(req.error || new Error("get failed"));
      });
    }

    /**
     * Writes a world record.
     */
    async function idbPutWorld(world) {
      const db = await openWorldDb();
      return await new Promise((resolve, reject) => {
        const store = idbTx(db, "readwrite");
        const req = store.put(world);
        req.onsuccess = () => resolve(true);
        req.onerror = () => reject(req.error || new Error("put failed"));
      });
    }

    /**
     * Deletes a world by id.
     */
    async function idbDeleteWorld(id) {
      const db = await openWorldDb();
      return await new Promise((resolve, reject) => {
        const store = idbTx(db, "readwrite");
        const req = store.delete(String(id));
        req.onsuccess = () => resolve(true);
        req.onerror = () => reject(req.error || new Error("delete failed"));
      });
    }

    function getActiveWorldId() {
      try {
        const v = localStorage.getItem(ACTIVE_WORLD_ID_KEY);
        return v && String(v).trim() ? String(v) : "";
      } catch (e) {
        return "";
      }
    }

    function setActiveWorldId(id) {
      try {
        const v = id && String(id).trim() ? String(id) : "";
        if (!v) localStorage.removeItem(ACTIVE_WORLD_ID_KEY);
        else localStorage.setItem(ACTIVE_WORLD_ID_KEY, v);
      } catch (e) {}
    }

    function makeWorldId() {
      try {
        if (crypto && typeof crypto.randomUUID === "function") return crypto.randomUUID();
      } catch (e) {}
      return `w_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 10)}`;
    }

    function sanitizeWorldFilename(name) {
      const base = String(name || "world").trim() || "world";
      return base
      .replace(/[\/\\?%*:|"<>]/g, "-")
      .replace(/\s+/g, " ")
      .trim()
      .slice(0, 64);
    }

    function captureWorldThumbnail() {
      try {
        if (!renderer || !renderer.domElement) return "";

        const canvas = renderer.domElement;
        const w = canvas.width | 0;
        const h = canvas.height | 0;
        if (w < 2 || h < 2) return "";

        const cam =
        (typeof activeCamera !== "undefined" && activeCamera) ? activeCamera :
        (typeof camera !== "undefined" && camera) ? camera :
        null;

        if (typeof scene !== "undefined" && scene && cam) {
          renderer.render(scene, cam);
        }

        const gl = renderer.getContext();
        if (!gl || typeof gl.readPixels !== "function") {
          return canvas.toDataURL("image/jpeg", 0.72);
        }

        const pixels = new Uint8Array(w * h * 4);
        gl.readPixels(0, 0, w, h, gl.RGBA, gl.UNSIGNED_BYTE, pixels);

        const flipped = new Uint8ClampedArray(w * h * 4);
        for (let y = 0; y < h; y++) {
          const srcRow = (h - 1 - y) * w * 4;
          const dstRow = y * w * 4;
          flipped.set(pixels.subarray(srcRow, srcRow + w * 4), dstRow);
        }

        const full = document.createElement("canvas");
        full.width = w;
        full.height = h;

        const ctx = full.getContext("2d", { willReadFrequently: true });
        if (!ctx) return canvas.toDataURL("image/jpeg", 0.72);

        ctx.putImageData(new ImageData(flipped, w, h), 0, 0);

        const maxW = 512;
        const scale = Math.min(1, maxW / w);
        const tw = Math.max(1, Math.floor(w * scale));
        const th = Math.max(1, Math.floor(h * scale));

        const thumb = document.createElement("canvas");
        thumb.width = tw;
        thumb.height = th;

        const tctx = thumb.getContext("2d");
        if (!tctx) return full.toDataURL("image/jpeg", 0.72);

        tctx.drawImage(full, 0, 0, tw, th);
        return thumb.toDataURL("image/jpeg", 0.72);
      } catch (e) {
        try {
          if (renderer && renderer.domElement) return renderer.domElement.toDataURL("image/jpeg", 0.72);
        } catch (e2) {}
        return "";
      }
    }




    /**
     * Saves current scene model transforms into the active IndexedDB world record.
     * If there is no active world, creates one and sets it active (no reload).
     */
    async function saveActiveWorld() {
      try {
        const snapshot = snapshotWorldModelsConfig();
        const normalized = normalizeWorldModelsConfig(snapshot);
        if (!normalized) return;

        const now = Date.now();
        const thumb = captureWorldThumbnail();
        const settings = safeCloneSettings(params);

        let activeId = getActiveWorldId();
        let rec = null;

        if (activeId) {
          try {
            rec = await idbGetWorld(activeId);
          } catch (e) {
            rec = null;
          }
        }

        if (rec) {
          rec.models = normalized;
          rec.settings = settings;
          if (thumb) rec.thumbnail = thumb;
          rec.updatedAt = now;
          await idbPutWorld(rec);
          setActiveWorldUi(rec.id, rec.title);
        } else {
          const created = buildWorldRecord({
            id: makeWorldId(),
            title: worldUiState.title && worldUiState.title !== "Default" ? worldUiState.title : "Untitled",
            description: "",
            models: normalized,
            settings,
            thumbnail: thumb,
            meta: {},
            createdAt: now,
            updatedAt: now
          });

          await idbPutWorld(created);
          setActiveWorldId(created.id);
          setActiveWorldUi(created.id, created.title);
        }

        if (worldPickerState.open && worldPickerListEl) {
          try {
            const worlds = await idbGetAllWorlds();
            renderWorldPickerList(worlds);
          } catch (e) {}
        }

        showActionToast("World saved");
      } catch (e) {
        console.warn("[worlds] saveActiveWorld failed", e);
      }
    }




    function buildWorldRecord({ id, title, description, models, settings, thumbnail, meta, createdAt, updatedAt }) {
      const cleanSettings =
      settings && typeof settings === "object" ? safeCloneSettings(settings) : {};

      return {
        v: 1,
        kind: "snow-world",
        id: String(id || makeWorldId()),
        title: String(title || "Untitled").trim() || "Untitled",
        description: String(description || "").trim(),
        createdAt: Number(createdAt) || Date.now(),
        updatedAt: Number(updatedAt) || Date.now(),
        thumbnail: typeof thumbnail === "string" ? thumbnail : "",
        meta: meta && typeof meta === "object" ? meta : {},
        settings: cleanSettings,
        models
      };
    }




    /**
     * Loads world model config in this priority:
     * 1) Active world from IndexedDB (snow-worlds / worlds, keyed by ACTIVE_WORLD_ID_KEY)
     * 2) Legacy localStorage override (WORLD_MODELS_OVERRIDE_KEY)
     * 3) worlds/default_model.json (if present)
     * 4) baked MODEL_CONFIG
     */
    async function getWorldModelsConfig() {
      if (worldModelsConfigLoaded) return worldModelsConfig || MODEL_CONFIG;

      worldModelsConfigLoaded = true;
      worldModelsConfig = null;
      worldModelsIoState.source = "defaults";
      setActiveWorldUi("", "Default");

      const activeId = getActiveWorldId();

      if (activeId) {
        try {
          const rec = await idbGetWorld(activeId);
          const normalized = rec && rec.models ? normalizeWorldModelsConfig(rec.models) : null;
          if (normalized) {
            worldModelsConfig = normalized;
            worldModelsIoState.source = `idb:${rec && rec.title ? rec.title : activeId}`;
            setActiveWorldUi(rec && rec.id ? rec.id : activeId, rec && rec.title ? rec.title : "Untitled");
            return worldModelsConfig;
          }
        } catch (e) {
          worldModelsConfig = null;
          worldModelsIoState.source = "defaults";
          setActiveWorldUi("", "Default");
        }
      }

      try {
        const raw = localStorage.getItem(WORLD_MODELS_OVERRIDE_KEY);
        if (raw) {
          const parsed = JSON.parse(raw);
          const normalized = normalizeWorldModelsConfig(parsed);
          if (normalized) {
            worldModelsConfig = normalized;
            worldModelsIoState.source = "imported";
            setActiveWorldUi("", "Imported");
            return worldModelsConfig;
          }
        }
      } catch (e) {
        worldModelsConfig = null;
        worldModelsIoState.source = "defaults";
        setActiveWorldUi("", "Default");
      }

      try {
        const res = await fetch(WORLD_MODELS_URL, { cache: "no-store" });
        if (res && res.ok) {
          const json = await res.json();
          const normalized = normalizeWorldModelsConfig(json);
          if (normalized) {
            worldModelsConfig = normalized;
            worldModelsIoState.source = WORLD_MODELS_URL;
            setActiveWorldUi("", "Default");
          }
        }
      } catch (e) {
        worldModelsConfig = null;
        worldModelsIoState.source = "defaults";
        setActiveWorldUi("", "Default");
      }

      return worldModelsConfig || MODEL_CONFIG;
    }





    /**
     * Imports a world JSON from disk:
     * - Accepts either a raw MODEL_CONFIG array OR a { kind:"snow-world", ... , models:[...] } record.
     * Stores the result in IndexedDB and sets it active, then refreshes the page.
     */
    function importWorldModelsJson() {
      const input = ensureImportInput();
      input.value = "";

      input.onchange = async () => {
        const file = input.files && input.files[0];
        input.value = "";
        if (!file) return;

        try {
          const text = await file.text();
          const json = JSON.parse(text);

          const isWorldRecord = json && typeof json === "object" && json.kind === "snow-world" && json.models;
          const modelsPayload = isWorldRecord ? json.models : json;

          const normalized = normalizeWorldModelsConfig(modelsPayload);
          if (!normalized) return;

          const importedSettings =
          isWorldRecord && json.settings && typeof json.settings === "object" ? json.settings : null;

          const now = Date.now();
          const baseTitle = isWorldRecord && typeof json.title === "string" ? json.title : file.name.replace(/\.[^.]+$/, "");
          const baseDesc = isWorldRecord && typeof json.description === "string" ? json.description : "";

          const id = isWorldRecord && typeof json.id === "string" && json.id.trim() ? json.id.trim() : makeWorldId();

          const rec = buildWorldRecord({
            id,
            title: baseTitle,
            description: baseDesc,
            models: normalized,
            settings: importedSettings ? Object.assign({}, DEFAULTS, importedSettings) : {},
            thumbnail: isWorldRecord && typeof json.thumbnail === "string" ? json.thumbnail : "",
            meta: isWorldRecord && json.meta && typeof json.meta === "object" ? json.meta : { importedFrom: file.name },
            createdAt: isWorldRecord && Number.isFinite(json.createdAt) ? json.createdAt : now,
            updatedAt: now
          });

          await idbPutWorld(rec);
          setActiveWorldId(rec.id);

          if (!rec.thumbnail) {
            localStorage.setItem(PENDING_WORLD_THUMB_ID_KEY, rec.id);
          } else {
            localStorage.removeItem(PENDING_WORLD_THUMB_ID_KEY);
          }

          try {
            sessionStorage.setItem(WORLD_PICKER_SUPPRESS_ONCE_KEY, "1");
          } catch (e) {}

          location.reload();
        } catch (e) {
          console.warn("[worlds] import failed", e);
        }
      };

      input.click();
    }





    /**
     * Exports either:
     * - Active IndexedDB world (full record with metadata + thumbnail), or
     * - Fallback snapshot as world_models.json if no active world record exists.
     */
    function exportWorldModelsJson() {
      (async () => {
        const activeId = getActiveWorldId();
        if (activeId) {
          try {
            const rec = await idbGetWorld(activeId);
            if (rec) {
              const name = sanitizeWorldFilename(rec.title || "world");
              downloadJson(rec, `${name}.world.json`);
              return;
            }
          } catch (e) {}
        }

        const snapshot = snapshotWorldModelsConfig();
        downloadJson(snapshot, "world_models.json");
      })();
    }

    // function exportDefaultModelJson() {
    //   (async () => {
    //     try {
    //       const res = await fetch(WORLD_MODELS_URL, { cache: "no-store" });
    //       if (res && res.ok) {
    //         const json = await res.json();
    //         downloadJson(json, "default_model.json");
    //         return;
    //       }
    //     } catch (e) {}

    //     downloadJson(MODEL_CONFIG, "default_model.json");
    //   })();
    // }
    function exportDefaultModelJson() {
      const snapshot = snapshotWorldModelsConfig();

      const title = (typeof getCurrentWorldTitle === "function") ? getCurrentWorldTitle() : "models";
      const safe = (typeof sanitizeWorldFilename === "function") ? sanitizeWorldFilename(title || "models") : "models";

      downloadJson(snapshot, `${safe}.models.json`);
    }





    /**
     * Cloud Worlds API (mock-ready):
     * - Disabled by default.
     * - When enabled, endpoints are expected to return JSON.
     * - List endpoints return { worlds:[...] } or a raw [...] array.
     */
    const CLOUD_WORLDS_API = {
      enabled: false,
      baseUrl: "/api/worlds"
    };

    function normalizeCloudWorldListPayload(json) {
      if (Array.isArray(json)) return json;
      if (json && typeof json === "object" && Array.isArray(json.worlds)) return json.worlds;
      return [];
    }

    async function cloudListWorlds(scope) {
      if (!CLOUD_WORLDS_API.enabled) return [];
      const s = scope === "private" ? "private" : "global";

      const res = await fetch(`${CLOUD_WORLDS_API.baseUrl}/${s}`, { cache: "no-store" });
      if (!res.ok) throw new Error(`Cloud list failed: ${res.status}`);
      const json = await res.json();
      return normalizeCloudWorldListPayload(json);
    }

    async function cloudGetWorld(scope, id) {
      if (!CLOUD_WORLDS_API.enabled) throw new Error("Cloud API disabled");
      const s = scope === "private" ? "private" : "global";
      const safeId = encodeURIComponent(String(id || "").trim());

      const res = await fetch(`${CLOUD_WORLDS_API.baseUrl}/${s}/${safeId}`, { cache: "no-store" });
      if (!res.ok) throw new Error(`Cloud get failed: ${res.status}`);
      return await res.json();
    }

    async function cloudSaveWorld(scope, worldRecord) {
      if (!CLOUD_WORLDS_API.enabled) throw new Error("Cloud API disabled");
      const s = scope === "private" ? "private" : "global";

      const res = await fetch(`${CLOUD_WORLDS_API.baseUrl}/${s}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(worldRecord || {})
      });

      if (!res.ok) throw new Error(`Cloud save failed: ${res.status}`);
      return await res.json();
    }

    async function cloudDeleteWorld(scope, id) {
      if (!CLOUD_WORLDS_API.enabled) throw new Error("Cloud API disabled");
      const s = scope === "private" ? "private" : "global";
      const safeId = encodeURIComponent(String(id || "").trim());

      const res = await fetch(`${CLOUD_WORLDS_API.baseUrl}/${s}/${safeId}`, { method: "DELETE" });
      if (!res.ok) throw new Error(`Cloud delete failed: ${res.status}`);
      return true;
    }





    /**
     * Builds an exportable MODEL_CONFIG snapshot using current scene transforms (when instances exist).
     */
    function snapshotWorldModelsConfig() {
      const base = worldModelsConfig || MODEL_CONFIG;
      const out = JSON.parse(JSON.stringify(base));

      const eps = 1e-6;

      for (let i = 0; i < out.length; i++) {
        const outEntry = out[i];
        const baseEntry = base[i];

        if (!outEntry || !baseEntry) continue;
        if (!Array.isArray(outEntry.instances) || !Array.isArray(baseEntry.instances)) continue;

        const n = Math.min(outEntry.instances.length, baseEntry.instances.length);

        for (let k = 0; k < n; k++) {
          const outInstCfg = outEntry.instances[k];
          const baseInstCfg = baseEntry.instances[k];
          if (!outInstCfg || !baseInstCfg) continue;

          const inst =
          baseInstCfg.runtimeObject ||
          (baseInstCfg.id ? modelInstances[String(baseInstCfg.id)] : null);

          if (!inst) continue;

          const isEquipped = (
            equipmentState.enabled &&
            equipmentState.item &&
            equipmentState.item.object === inst
            );

          let px, py, pz;
          let rx, ry, rz;
          let sx, sy, sz;

          if (isEquipped) {
            px = equipmentState.originalPosition.x;
            py = equipmentState.originalPosition.y;
            pz = equipmentState.originalPosition.z;

            equipmentTmpEuler.setFromQuaternion(
              equipmentState.originalQuaternion,
              (inst.rotation && inst.rotation.order) ? inst.rotation.order : "XYZ"
              );

            rx = equipmentTmpEuler.x;
            ry = equipmentTmpEuler.y;
            rz = equipmentTmpEuler.z;

            sx = equipmentState.originalScale.x;
            sy = equipmentState.originalScale.y;
            sz = equipmentState.originalScale.z;
          } else {
            px = inst.position.x;
            py = inst.position.y;
            pz = inst.position.z;

            rx = inst.rotation.x;
            ry = inst.rotation.y;
            rz = inst.rotation.z;

            sx = inst.scale.x;
            sy = inst.scale.y;
            sz = inst.scale.z;
          }

          outInstCfg.position = [px, py, pz];
          outInstCfg.rotation = [rx, ry, rz];

          const uniform = Math.abs(sx - sy) < eps && Math.abs(sx - sz) < eps;
          outInstCfg.scale = uniform ? sx : [sx, sy, sz];
        }
      }

      return out;
    }



    /**
     * Shows or hides the worlds overlay.
     */
    function setWorldPickerOpen(open) {
      worldPickerState.open = !!open;

      if (!worldPickerEl) return;

      if (!worldPickerState.open) {
        worldPickerState.editId = "";
        worldPickerEl.classList.remove("is-editing");
      }

      worldPickerEl.classList.toggle("is-open", worldPickerState.open);
      worldPickerEl.setAttribute("aria-hidden", worldPickerState.open ? "false" : "true");

      if (worldPickerState.open && worldPickerCloseBtn) {
        worldPickerCloseBtn.focus({ preventScroll: true });
      }
    }



/**
 * Renders the worlds list cards into the overlay.
 */
    function renderWorldPickerList(worlds) {
      if (!worldPickerListLocalEl || !worldPickerListPrivateEl || !worldPickerListGlobalEl) return;

      const local = Array.isArray(worlds) ? worlds : [];
      const priv = Array.isArray(worldPickerCloudState.privateWorlds) ? worldPickerCloudState.privateWorlds : [];
      const glob = Array.isArray(worldPickerCloudState.globalWorlds) ? worldPickerCloudState.globalWorlds : [];

      renderLocalWorldCards(local);
      renderCloudWorldCards(worldPickerListPrivateEl, priv, "private");
      renderCloudWorldCards(worldPickerListGlobalEl, glob, "global");

      if (worldPickerLocalMetaEl) worldPickerLocalMetaEl.textContent = `${local.length} saved`;
      if (worldPickerPrivateMetaEl) {
        worldPickerPrivateMetaEl.textContent = CLOUD_WORLDS_API.enabled ? `${priv.length} available` : "API disabled";
      }
      if (worldPickerGlobalMetaEl) {
        worldPickerGlobalMetaEl.textContent = CLOUD_WORLDS_API.enabled ? `${glob.length} available` : "API disabled";
      }
    }

    function renderEmptyMessage(listEl, text) {
      listEl.innerHTML = "";
      const msg = document.createElement("div");
      msg.className = "world-picker__empty";
      msg.textContent = text;
      listEl.appendChild(msg);
    }

    function renderLocalWorldCards(worlds) {
      if (!worldPickerListLocalEl) return;

      const activeId = getActiveWorldId();
      worldPickerListLocalEl.innerHTML = "";

      if (!worlds.length) {
        renderEmptyMessage(worldPickerListLocalEl, "No local worlds saved.");
        return;
      }

      for (let i = 0; i < worlds.length; i++) {
        const w = worlds[i];
        if (!w || typeof w !== "object") continue;

        const id = String(w.id || "");
        if (!id) continue;

        const card = document.createElement("div");
        card.className = "world-card" + (activeId && id === activeId ? " is-active" : "");

        const thumb = document.createElement("img");
        thumb.className = "world-card__thumb";
        thumb.alt = "";
        thumb.loading = "lazy";
        thumb.decoding = "async";
        thumb.src = typeof w.thumbnail === "string" && w.thumbnail
        ? w.thumbnail
        : "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";

        const body = document.createElement("div");
        body.className = "world-card__body";

        const titleRow = document.createElement("div");
        titleRow.className = "world-card__titleRow";

        const title = document.createElement("div");
        title.className = "world-card__title";
        title.textContent = String(w.title || "Untitled");

        const meta = document.createElement("div");
        meta.className = "world-card__meta";
        const count = w.models && Array.isArray(w.models) ? w.models.length : 0;
        meta.textContent = `${count} models`;

        const desc = document.createElement("div");
        desc.className = "world-card__desc";
        desc.textContent = String(w.description || "");

        const actions = document.createElement("div");
        actions.className = "world-card__actions";

        const loadBtn = document.createElement("button");
        loadBtn.className = "avatar-btn";
        loadBtn.type = "button";
        loadBtn.textContent = "Load";
        loadBtn.addEventListener("click", () => {
          setActiveWorldId(id);
          try {
            sessionStorage.setItem(WORLD_PICKER_SUPPRESS_ONCE_KEY, "1");
          } catch (e) {}
          location.reload();
        });

        const cloneBtn = document.createElement("button");
        cloneBtn.className = "avatar-btn";
        cloneBtn.type = "button";
        cloneBtn.textContent = "Clone";
        cloneBtn.addEventListener("click", async () => {
          try {
            const now = Date.now();
            const newId = makeWorldId();

            const cloned = buildWorldRecord({
              id: newId,
              title: String(w.title || "Untitled") + " (Copy)",
              description: String(w.description || ""),
              models: JSON.parse(JSON.stringify(w.models || [])),
              settings: w.settings ? JSON.parse(JSON.stringify(w.settings)) : safeCloneSettings(params),
              thumbnail: typeof w.thumbnail === "string" ? w.thumbnail : "",
              meta: {},
              createdAt: now,
              updatedAt: now
            });

            await idbPutWorld(cloned);

            const updated = await idbGetAllWorlds();
            renderWorldPickerList(updated);

            showActionToast("World cloned");
          } catch (e) {
            console.warn("[worlds] clone failed", e);
          }
        });

        const editBtn = document.createElement("button");
        editBtn.className = "avatar-btn";
        editBtn.type = "button";
        editBtn.textContent = "Edit";
        editBtn.addEventListener("click", () => {
          worldPickerState.editId = id;
          if (worldPickerEl) worldPickerEl.classList.add("is-editing");

          if (worldTitleInputEl) worldTitleInputEl.value = String(w.title || "");
          if (worldDescInputEl) worldDescInputEl.value = String(w.description || "");

          try {
            worldTitleInputEl && worldTitleInputEl.focus({ preventScroll: true });
          } catch (e) {}
        });

        const exportBtn = document.createElement("button");
        exportBtn.className = "avatar-btn";
        exportBtn.type = "button";
        exportBtn.textContent = "Export";
        exportBtn.addEventListener("click", () => {
          const name = sanitizeWorldFilename(w.title || "world");
          downloadJson(w, `${name}.world.json`);
          showActionToast("World exported");
        });

        const delBtn = document.createElement("button");
        delBtn.className = "avatar-btn";
        delBtn.type = "button";
        delBtn.textContent = "Delete";
        delBtn.addEventListener("click", async () => {
          const ok = confirm(`Delete "${String(w.title || "Untitled")}"?`);
          if (!ok) return;

          try {
            await idbDeleteWorld(id);

            const active = getActiveWorldId();
            if (active && active === id) {
              setActiveWorldId("");
            }

            const updated = await idbGetAllWorlds();
            renderWorldPickerList(updated);

            showActionToast("World deleted");
          } catch (e) {
            console.warn("[worlds] delete failed", e);
          }
        });

        actions.appendChild(loadBtn);
        actions.appendChild(cloneBtn);
        actions.appendChild(editBtn);
        actions.appendChild(exportBtn);
        actions.appendChild(delBtn);

        titleRow.appendChild(title);
        titleRow.appendChild(meta);

        body.appendChild(titleRow);
        body.appendChild(desc);
        body.appendChild(actions);

        card.appendChild(thumb);
        card.appendChild(body);

        worldPickerListLocalEl.appendChild(card);
      }
    }

    function renderCloudWorldCards(listEl, worlds, scope) {
      if (!listEl) return;

      listEl.innerHTML = "";

      if (!CLOUD_WORLDS_API.enabled) {
        renderEmptyMessage(listEl, "Cloud API not enabled.");
        return;
      }

      if (!worlds.length) {
        renderEmptyMessage(listEl, "No worlds available.");
        return;
      }

      for (let i = 0; i < worlds.length; i++) {
        const w = worlds[i];
        if (!w || typeof w !== "object") continue;

        const id = String(w.id || "");
        if (!id) continue;

        const card = document.createElement("div");
        card.className = "world-card";

        const thumb = document.createElement("img");
        thumb.className = "world-card__thumb";
        thumb.alt = "";
        thumb.loading = "lazy";
        thumb.decoding = "async";
        thumb.src = typeof w.thumbnail === "string" && w.thumbnail
        ? w.thumbnail
        : "data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs=";

        const body = document.createElement("div");
        body.className = "world-card__body";

        const titleRow = document.createElement("div");
        titleRow.className = "world-card__titleRow";

        const title = document.createElement("div");
        title.className = "world-card__title";
        title.textContent = String(w.title || "Untitled");

        const meta = document.createElement("div");
        meta.className = "world-card__meta";
        meta.textContent = scope === "private" ? "private" : "global";

        const desc = document.createElement("div");
        desc.className = "world-card__desc";
        desc.textContent = String(w.description || "");

        const actions = document.createElement("div");
        actions.className = "world-card__actions";

        const loadBtn = document.createElement("button");
        loadBtn.className = "avatar-btn";
        loadBtn.type = "button";
        loadBtn.textContent = "Load";
        loadBtn.addEventListener("click", async () => {
          try {
            const rec = await cloudGetWorld(scope, id);
            if (!rec || typeof rec !== "object") return;

            const now = Date.now();
            if (!rec.createdAt) rec.createdAt = now;
            rec.updatedAt = now;

            await idbPutWorld(rec);
            setActiveWorldId(String(rec.id || id));

            try {
              sessionStorage.setItem(WORLD_PICKER_SUPPRESS_ONCE_KEY, "1");
            } catch (e) {}

            location.reload();
          } catch (e) {
            console.warn("[worlds] cloud load failed", e);
            showActionToast("Cloud load failed");
          }
        });

        actions.appendChild(loadBtn);

        titleRow.appendChild(title);
        titleRow.appendChild(meta);

        body.appendChild(titleRow);
        body.appendChild(desc);
        body.appendChild(actions);

        card.appendChild(thumb);
        card.appendChild(body);

        listEl.appendChild(card);
      }
    }




/**
 * Ensures the worlds overlay is wired once and can be opened from GUI or on boot.
 */
    function ensureWorldPickerOverlayWired() {
      if (worldPickerState.wired) return;

      worldPickerEl = document.getElementById("worldPicker");
      worldPickerCloseBtn = document.getElementById("worldPickerClose");

      worldPickerListEl = document.getElementById("worldPickerList");
      worldPickerListLocalEl = document.getElementById("worldPickerListLocal");
      worldPickerListPrivateEl = document.getElementById("worldPickerListPrivate");
      worldPickerListGlobalEl = document.getElementById("worldPickerListGlobal");

      worldPickerLocalMetaEl = document.getElementById("worldPickerLocalMeta");
      worldPickerPrivateMetaEl = document.getElementById("worldPickerPrivateMeta");
      worldPickerGlobalMetaEl = document.getElementById("worldPickerGlobalMeta");

      worldTitleInputEl = document.getElementById("worldTitleInput");
      worldDescInputEl = document.getElementById("worldDescInput");
      worldSaveBtnEl = document.getElementById("worldSaveBtn");
      worldImportBtnEl = document.getElementById("worldImportBtn");


      if (!worldPickerEl) return;

      if (worldPickerCloseBtn) {
        worldPickerCloseBtn.addEventListener("click", () => setWorldPickerOpen(false));
      }

      if (worldImportBtnEl) {
        worldImportBtnEl.addEventListener("click", () => importWorldModelsJson());
      }

      if (worldSaveBtnEl) {
        worldSaveBtnEl.addEventListener("click", async () => {
          try {
            const title = worldTitleInputEl ? worldTitleInputEl.value.trim() : "";
            const description = worldDescInputEl ? worldDescInputEl.value.trim() : "";
            const editId = String(worldPickerState.editId || "").trim();

            if (editId) {
              const rec = await idbGetWorld(editId);
              if (!rec) return;

              rec.title = title || "Untitled";
              rec.description = description;
              rec.updatedAt = Date.now();

              await idbPutWorld(rec);

              if (getActiveWorldId() === editId) {
                setWorldNameLabel(rec.title || "Default");
              }

              worldPickerState.editId = "";
              if (worldPickerEl) worldPickerEl.classList.remove("is-editing");

              if (worldTitleInputEl) worldTitleInputEl.value = "";
              if (worldDescInputEl) worldDescInputEl.value = "";

              const updated = await idbGetAllWorlds();
              renderWorldPickerList(updated);

              showActionToast("World updated");
              return;
            }

            const snapshot = snapshotWorldModelsConfig();
            const normalized = normalizeWorldModelsConfig(snapshot);
            if (!normalized) return;

            const now = Date.now();
            const rec = buildWorldRecord({
              id: makeWorldId(),
              title: title || "Untitled",
              description,
              models: normalized,
              settings: safeCloneSettings(params),
              thumbnail: captureWorldThumbnail(),
              meta: {},
              createdAt: now,
              updatedAt: now
            });

            await idbPutWorld(rec);
            setActiveWorldId(rec.id);

            if (worldTitleInputEl) worldTitleInputEl.value = "";
            if (worldDescInputEl) worldDescInputEl.value = "";

            const updated = await idbGetAllWorlds();
            renderWorldPickerList(updated);

            showActionToast("World saved");
          } catch (e) {
            console.warn("[worlds] save failed", e);
          }
        });
      }

      worldPickerState.wired = true;
    }

    /**
     * Opens the overlay and refreshes its list.
     */
    function openWorldPickerOverlay() {
      ensureWorldPickerOverlayWired();

      worldPickerState.editId = "";
      if (worldPickerEl) worldPickerEl.classList.remove("is-editing");

      (async () => {
        try {
          const worlds = await idbGetAllWorlds();

          if (CLOUD_WORLDS_API.enabled) {
            try {
              const [priv, glob] = await Promise.all([
                cloudListWorlds("private"),
                cloudListWorlds("global")
              ]);

              worldPickerCloudState.privateWorlds = Array.isArray(priv) ? priv : [];
              worldPickerCloudState.globalWorlds = Array.isArray(glob) ? glob : [];
              worldPickerCloudState.lastError = "";
            } catch (e) {
              worldPickerCloudState.privateWorlds = [];
              worldPickerCloudState.globalWorlds = [];
              worldPickerCloudState.lastError = String(e && e.message ? e.message : e);
            }
          } else {
            worldPickerCloudState.privateWorlds = [];
            worldPickerCloudState.globalWorlds = [];
            worldPickerCloudState.lastError = "";
          }

          renderWorldPickerList(worlds);
          setWorldPickerOpen(true);
        } catch (e) {
          console.warn("[worlds] list failed", e);
        }
      })();
    }



    /**
     * If an imported world had no thumbnail, capture one after first paint and update the record.
     */
    async function finalizePendingWorldThumbnail() {
      let pendingId = "";
      try {
        pendingId = localStorage.getItem(PENDING_WORLD_THUMB_ID_KEY) || "";
      } catch (e) {
        pendingId = "";
      }
      if (!pendingId) return;

      try {
        const rec = await idbGetWorld(pendingId);
        if (!rec || (typeof rec.thumbnail === "string" && rec.thumbnail)) {
          localStorage.removeItem(PENDING_WORLD_THUMB_ID_KEY);
          return;
        }

        const thumb = captureWorldThumbnail();
        if (!thumb) return;

        rec.thumbnail = thumb;
        rec.updatedAt = Date.now();
        await idbPutWorld(rec);

        localStorage.removeItem(PENDING_WORLD_THUMB_ID_KEY);
      } catch (e) {
        console.warn("[worlds] thumbnail update failed", e);
      }
    }


    /**
     * Boot behavior: if any worlds exist in IndexedDB, open the picker overlay on page load.
     */
    function bootWorldPickerOverlay() {
      ensureWorldPickerOverlayWired();

      (async () => {
        let suppressOnce = false;

        try {
          suppressOnce = !!(sessionStorage && sessionStorage.getItem(WORLD_PICKER_SUPPRESS_ONCE_KEY));
          if (suppressOnce) sessionStorage.removeItem(WORLD_PICKER_SUPPRESS_ONCE_KEY);
        } catch (e) {
          suppressOnce = false;
        }

        try {
          const worlds = await idbGetAllWorlds();
          if (worlds && worlds.length) {
            renderWorldPickerList(worlds);
            if (!suppressOnce) setWorldPickerOpen(true);
            else setWorldPickerOpen(false);
          } else {
            setWorldPickerOpen(false);
          }
        } catch (e) {}

        requestAnimationFrame(() => {
          finalizePendingWorldThumbnail();
        });
      })();
    }







    function hasAlphaTexture(mat) {
      return !!(mat && (mat.alphaMap || mat.map) && (mat.transparent || mat.opacity < 1 || mat.alphaTest > 0));
    }

    function applyAlphaCutoutShadows(mesh, cutoff = 0.5) {
      /* Forces alpha-mapped foliage to behave as depth-writing cutout (not blended transparency),
         and makes shadow/depth passes respect the same alphaTest threshold. */
      if (!mesh || !mesh.material) return;

      // Ensure per-instance materials (avoid mutating shared template materials)
      if (Array.isArray(mesh.material)) {
        mesh.material = mesh.material.map(m => (m && m.isMaterial ? m.clone() : m));
      } else if (mesh.material && mesh.material.isMaterial) {
        mesh.material = mesh.material.clone();
      }

      const mats = Array.isArray(mesh.material) ? mesh.material : [mesh.material];

      let alphaTex = null;
      let alphaTest = cutoff;

      for (let i = 0; i < mats.length; i++) {
        const mat = mats[i];
        if (!mat || !mat.isMaterial) continue;

        const tex = mat.alphaMap || mat.map;
        if (tex && !alphaTex) alphaTex = tex;

        mat.alphaTest = Math.max(mat.alphaTest || 0, cutoff);
        alphaTest = Math.max(alphaTest, mat.alphaTest);

        // Critical: keep it OUT of the transparent pass, so depth sorting works with grass.
        mat.transparent = false;
        mat.opacity = 1.0;
        mat.depthTest = true;
        mat.depthWrite = true;

        mat.needsUpdate = true;
      }

      if (!alphaTex) return;

      // Make the SHADOW MAP respect alphaTest too
      const depthMat = new THREE.MeshDepthMaterial({
        depthPacking: THREE.RGBADepthPacking,
        map: alphaTex,
        alphaTest: alphaTest
      });
      depthMat.side = mats[0] && mats[0].side != null ? mats[0].side : THREE.FrontSide;

      const distMat = new THREE.MeshDistanceMaterial({
        map: alphaTex,
        alphaTest: alphaTest
      });
      distMat.side = depthMat.side;

      mesh.customDepthMaterial = depthMat;
      mesh.customDistanceMaterial = distMat;
    }










    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(
      "https://www.gstatic.com/draco/versioned/decoders/1.5.7/"
      );

    const gltfLoader = new GLTFLoader();
    gltfLoader.setDRACOLoader(dracoLoader);





    function loadAllModels() {
      avatarModelColliderObjects.length = 0;
      avatarModelColliderBounds.length = 0;
      avatarModelColliderOBBs.length = 0;

      worldGroundMeshes.length = 0;

      vehicleInteractables.length = 0;
      equipmentInteractables.length = 0;

      setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);

      for (const k in modelTemplates) delete modelTemplates[k];
        for (const k in modelInstances) delete modelInstances[k];

          function buildOBBForInstance(root, id) {
            root.updateWorldMatrix(true, true);

            obbTmpBox.setFromObject(root);
            if (!Number.isFinite(obbTmpBox.min.x) || !Number.isFinite(obbTmpBox.max.x)) return null;

            obbTmpBox.getCenter(obbTmpCenter);
            obbTmpBox.getSize(obbTmpSize);

            root.getWorldQuaternion(obbTmpQuat);
            obbTmpEuler.setFromQuaternion(obbTmpQuat);

            const hx = Math.max(0.10, (obbTmpSize.x * 0.5) * 0.48);
            const hz = Math.max(0.10, (obbTmpSize.z * 0.5) * 0.48);

            return {
              id: id || "",
              object: root,
              center: obbTmpCenter.clone(),
              halfX: hx,
              halfZ: hz,
              yaw: obbTmpEuler.y,
              yMin: obbTmpBox.min.y,
              yMax: obbTmpBox.max.y
            };
          }


          (async () => {
            const config = await getWorldModelsConfig();

            for (const entry of config) {
              gltfLoader.load(
                entry.url,
                (gltf) => {
                  const baseScene = gltf.scene;
                  modelTemplates[entry.name] = baseScene;

                  for (const instCfg of entry.instances) {
                    const inst = baseScene.clone(true);

                    const p = instCfg.position || [0, 0, 0];
                    const r = instCfg.rotation || [0, 0, 0];
                    const s = instCfg.scale != null ? instCfg.scale : 1.0;

                    inst.position.set(p[0], p[1], p[2]);
                    inst.rotation.set(r[0], r[1], r[2]);

                    if (Array.isArray(s) && s.length === 3) {
                      inst.scale.set(s[0], s[1], s[2]);
                    } else {
                      inst.scale.setScalar(s);
                    }

                    Object.defineProperty(instCfg, "runtimeObject", {
                      value: inst,
                      enumerable: false,
                      configurable: true
                    });

                    inst.traverse((obj) => {
                      /* Classifies model meshes for ground sampling vs XZ blocking collisions. */
                      if (!obj.isMesh) return;

                      obj.castShadow = true;
                      obj.receiveShadow = true;

                      const mats = Array.isArray(obj.material) ? obj.material : [obj.material];
                      if (mats.some(hasAlphaTexture)) {
                        applyAlphaCutoutShadows(obj, 0.5);
                      }

                      const isGround = !!instCfg.ground;
                      const isStick = !!instCfg.stick;

                      if (isGround) {
                        obj.userData.worldModelGroundPlatform = true;
                        if (!obj.name && instCfg.id) obj.name = `ground:${instCfg.id}`;
                        worldGroundMeshes.push(obj);
                      }

                      if (isStick && !isGround) {
                        obj.userData.worldModelStick = true;
                        if (!obj.name && instCfg.id) obj.name = `stick:${instCfg.id}`;
                        colliderObjects.push(obj);
                      }
                    });


                    scene.add(inst);

                    if (instCfg.id) {
                      modelInstances[instCfg.id] = inst;
                    }

                    registerWorldEditRoot(inst, instCfg);

                    if (instCfg.vehicle) {
                      registerVehicleInstance(inst, instCfg);
                    }

                    if (instCfg.equipment || (instCfg.meta && (instCfg.meta.kind === "food" || instCfg.meta.kind === "pickup"))) {
                      registerEquipmentInstance(inst, instCfg);
                    }


                    if (instCfg.collide) {
                      avatarModelColliderObjects.push(inst);

                      const obb = buildOBBForInstance(inst, instCfg.id);
                      if (obb) avatarModelColliderOBBs.push(obb);
                    }
                  }

                  if (colliderObjects.length) {
                    colliderBounds = buildColliderBounds(colliderObjects);
                    rebuildAvatarCollisionGrid();
                  }

                  avatarModelColliderBounds = [];
                },
                undefined,
                (error) => {
                  console.error("[snow] failed to load GLB", entry.url, error);
                }
                );
            }
          })();
        }




        function getModelInstance(id) {
          return modelInstances[id] || null;
        }





// -------------------------------------------------------------------------
// Avatar character setup and control
// -------------------------------------------------------------------------

    /* Resolves selected avatar from params (saved with worlds + last settings). */
        function getSelectedAvatarId() {
          return sanitizeAvatarId(params.avatarId, DEFAULTS.avatarId);
        }

        function getSelectedAvatarUrl() {
          const id = getSelectedAvatarId();
          const entry = getAvatarById(id);
          return entry ? entry.url : "";
        }

        const avatarSwapPos = new THREE.Vector3();
        const avatarSwapUpAxis = new THREE.Vector3(0, 1, 0);
        let avatarSwapYaw = 0;
        const avatarSwapQuat = new THREE.Quaternion();
        const avatarSwapScale = new THREE.Vector3();
        let avatarSwapToken = 0;



        let avatar = null;
        let avatarMixer = null;
        const avatarActions = {};
        let avatarCurrentAction = null;
        let avatarCurrentActionName = "";


        const avatarState = {
          enabled: false,
      viewMode: "third", // "third" | "first"
      moveX: 0,
      moveZ: 0
    };

    const avatarKeys = {
      forward: false,
      back: false,
      left: false,
      right: false,
      run: false,
      jump: false,
      jetDown: false
    };

    const avatarJetpackConfig = {
      thrustUp: 22.0,
      thrustDown: 18.0,
      gravity: 12.0,
      drag: 1.9,
      maxUpSpeed: 10.5,
      maxDownSpeed: 13.0,
      takeoffVelocity: 2.2,
      groundEps: 0.02
    };


    const AVATAR_WALK_SPEED = 2.4;
    const AVATAR_RUN_SPEED  = 4.0;


    /**
     * Resolves avatar XZ overlaps against collider bounds (trees/rocks) plus model-only colliders (cars).
     * Pushes the avatar out of penetration and removes velocity component into the obstacle for sliding.
     */
    const avatarCollision = {
      radius: 0.2,
      skin: 0,
      iterations: 3,

      probeY: 1.05,
      maxStep: 0.22,
      maxSlideIters: 3,
      broadphasePad: 0.9
    };

    const avatarCollisionDebug = {
      enabled: false,
      lastLogMs: 0,
      minIntervalMs: 160
    };

    /* Loads persisted collision debug state once on startup. */
    (function initAvatarCollisionDebug() {
      try {
        avatarCollisionDebug.enabled = localStorage.getItem("snow:debugCollisions") === "1";
      } catch {
        avatarCollisionDebug.enabled = false;
      }
    })();

    /* Enables/disables collision debug and persists it. */
    function setAvatarCollisionDebugEnabled(enabled) {
      avatarCollisionDebug.enabled = !!enabled;
      try {
        localStorage.setItem("snow:debugCollisions", avatarCollisionDebug.enabled ? "1" : "0");
      } catch {}
    }

    /* Reads current collision debug flag (no polling, toggled via F8). */
    function isAvatarCollisionDebugEnabled() {
      return !!avatarCollisionDebug.enabled;
    }

    /* Throttled collision logger to identify which collider causes push-out. */
    function logAvatarCollision(kind, payload) {
      if (!avatarCollisionDebug.enabled) return;
      const nowMs = (typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now();
      if ((nowMs - avatarCollisionDebug.lastLogMs) < avatarCollisionDebug.minIntervalMs) return;
      avatarCollisionDebug.lastLogMs = nowMs;
      console.log("[snow][collision]", kind, payload);
    }




    const avatarColTmpPos = new THREE.Vector3();
    const avatarColN = new THREE.Vector3();


    /**
     * Builds a spatial hash (XZ grid) of collider sphere-bounds for fast avatar collision broadphase.
     * Each collider is inserted into all cells overlapped by its XZ radius expanded by avatar radius + skin.
     */
    const avatarCollisionGrid = new Map(); // Map<number, Map<number, number[]>>
    const avatarCollisionCellSize = 3.0;
    const avatarCollisionCellInv = 1.0 / avatarCollisionCellSize;

    function rebuildAvatarCollisionGrid() {
      avatarCollisionGrid.clear();

      if (!colliderBounds || colliderBounds.length === 0) return;

      const pad = avatarCollision.radius + avatarCollision.skin;

      for (let i = 0; i < colliderBounds.length; i++) {
        const b = colliderBounds[i];
        if (!b) continue;

        const baseR = Number.isFinite(b.radius) ? b.radius : 0;
        const r = baseR + pad;

        const minX = Math.floor((b.center.x - r) * avatarCollisionCellInv);
        const maxX = Math.floor((b.center.x + r) * avatarCollisionCellInv);
        const minZ = Math.floor((b.center.z - r) * avatarCollisionCellInv);
        const maxZ = Math.floor((b.center.z + r) * avatarCollisionCellInv);

        for (let ix = minX; ix <= maxX; ix++) {
          let col = avatarCollisionGrid.get(ix);
          if (!col) {
            col = new Map();
            avatarCollisionGrid.set(ix, col);
          }

          for (let iz = minZ; iz <= maxZ; iz++) {
            let bucket = col.get(iz);
            if (!bucket) {
              bucket = [];
              col.set(iz, bucket);
            }
            bucket.push(i);
          }
        }
      }
    }

    /**
     * Returns colliderBounds indices potentially overlapping the avatar at the given position.
     */
    function getAvatarCollisionCandidatesXZ(pos) {
      const ix = Math.floor(pos.x * avatarCollisionCellInv);
      const iz = Math.floor(pos.z * avatarCollisionCellInv);
      const col = avatarCollisionGrid.get(ix);
      if (!col) return null;
      return col.get(iz) || null;
    }

    /* Returns the highest blocking collider top-Y at the avatar XZ (null when none). */
    function getAvatarBlockingSurfaceInfo(pos) {
      if (!pos) return null;

      const rA = avatarCollision.radius;
      const skin = avatarCollision.skin;

      const bodyMinY = pos.y - 0.05;
      const bodyMaxY = pos.y + avatarCollision.probeY + 0.55;

      const rrSphere = (b) => (rA + b.radius + skin);
      const rrObb = (rA + skin);

      let best = null;
      let bestTop = -Infinity;

      const candidates = getAvatarCollisionCandidatesXZ(pos);
      if (candidates && candidates.length) {
        for (let c = 0; c < candidates.length; c++) {
          const idx = candidates[c];
          const b = colliderBounds[idx];
          if (!b || !b.center) continue;

          let cyMin = null;
          let cyMax = null;

          if (Number.isFinite(b.yMin) && Number.isFinite(b.yMax)) {
            cyMin = b.yMin;
            cyMax = b.yMax;
          } else if (Number.isFinite(b.center.y) && Number.isFinite(b.radius)) {
            cyMin = b.center.y - b.radius;
            cyMax = b.center.y + b.radius;
          }

          if (cyMin != null && cyMax != null) {
            if (cyMin > bodyMaxY || cyMax < bodyMinY) continue;
          }

          const sumR = rrSphere(b);
          const dx = pos.x - b.center.x;
          const dz = pos.z - b.center.z;
          const d2 = dx * dx + dz * dz;
          if (d2 >= sumR * sumR) continue;

          const topY = (cyMax != null) ? cyMax : b.center.y;
          if (topY > bestTop) {
            bestTop = topY;
            best = {
              kind: "sphere",
              topY,
              bottomY: (cyMin != null) ? cyMin : b.center.y,
              index: idx,
              name: (b.obj && b.obj.name) ? b.obj.name : "",
              parentName: (b.obj && b.obj.parent && b.obj.parent.name) ? b.obj.parent.name : ""
            };
          }
        }
      }

      if (avatarModelColliderOBBs && avatarModelColliderOBBs.length) {
        for (let i = 0; i < avatarModelColliderOBBs.length; i++) {
          const obb = avatarModelColliderOBBs[i];
          if (!obb) continue;

          if (Number.isFinite(obb.yMin) && Number.isFinite(obb.yMax)) {
            if (obb.yMin > bodyMaxY || obb.yMax < bodyMinY) continue;
          }

          const dxw = pos.x - obb.center.x;
          const dzw = pos.z - obb.center.z;

          const c = Math.cos(obb.yaw);
          const s = Math.sin(obb.yaw);

          const lx = dxw * c + dzw * s;
          const lz = -dxw * s + dzw * c;

          const cx = clamp(lx, -obb.halfX, obb.halfX);
          const cz = clamp(lz, -obb.halfZ, obb.halfZ);

          const dxl = lx - cx;
          const dzl = lz - cz;

          const d2 = dxl * dxl + dzl * dzl;
          if (d2 >= rrObb * rrObb) continue;

          const topY = Number.isFinite(obb.yMax) ? obb.yMax : obb.center.y;
          if (topY > bestTop) {
            bestTop = topY;
            best = {
              kind: "obb",
              topY,
              bottomY: Number.isFinite(obb.yMin) ? obb.yMin : obb.center.y,
              index: i,
              id: obb.id || "",
              name: (obb.object && obb.object.name) ? obb.object.name : ""
            };
          }
        }
      }

      return best;
    }

    


    function resolveAvatarXZCollisions(pos) {
      const limX = Math.max(0.5, visualBounds.x - (avatarCollision.radius + 0.25));
      const limZ = Math.max(0.5, visualBounds.z - (avatarCollision.radius + 0.25));

      pos.x = clamp(pos.x, -limX, limX);
      pos.z = clamp(pos.z, -limZ, limZ);

      const rA = avatarCollision.radius;
      const skin = avatarCollision.skin;

      const bodyMinY = pos.y - 0.05;
      const bodyMaxY = pos.y + avatarCollision.probeY + 0.55;

      const yOverlapEps = 0.02;
      const pushEps = 1e-4;

      const dbg = (typeof isAvatarCollisionDebugEnabled === "function") ? isAvatarCollisionDebugEnabled() : false;

      for (let iter = 0; iter < avatarCollision.iterations; iter++) {
        let pushed = false;

    // --- sphere bounds (forest/rocks + stick meshes), grid-broadened ---
        const candidates = getAvatarCollisionCandidatesXZ(pos);
        if (candidates && candidates.length) {
          for (let c = 0; c < candidates.length; c++) {
            const idx = candidates[c];
            const b = colliderBounds[idx];
            if (!b || !b.center) continue;

            if (b.isGroundPlatform) continue;

            let cyMin = null;
            let cyMax = null;

            if (Number.isFinite(b.yMin) && Number.isFinite(b.yMax)) {
              cyMin = b.yMin;
              cyMax = b.yMax;
            } else if (Number.isFinite(b.center.y) && Number.isFinite(b.radius)) {
              cyMin = b.center.y - b.radius;
              cyMax = b.center.y + b.radius;
            }

            if (cyMin != null && cyMax != null) {
              const overlapDepth = Math.min(bodyMaxY, cyMax) - Math.max(bodyMinY, cyMin);
              if (overlapDepth <= yOverlapEps) continue;
            }

            const sumR = rA + b.radius + skin;
            const dx = pos.x - b.center.x;
            const dz = pos.z - b.center.z;
            const d2 = dx * dx + dz * dz;

            if (d2 >= sumR * sumR) continue;

            const d = Math.sqrt(d2) || 1e-6;
            const push = sumR - d;
            if (push <= pushEps) continue;

            const nx = dx / d;
            const nz = dz / d;

            pos.x += nx * push;
            pos.z += nz * push;

            const velDot = avatarVelocity.x * nx + avatarVelocity.z * nz;
            if (velDot < 0) {
              avatarVelocity.x -= velDot * nx;
              avatarVelocity.z -= velDot * nz;
            }

            if (dbg && typeof logAvatarCollision === "function") {
              const overlapDepth = (cyMin != null && cyMax != null)
              ? (Math.min(bodyMaxY, cyMax) - Math.max(bodyMinY, cyMin))
              : null;

              logAvatarCollision("sphere_push", {
                iter,
                avatar: { x: pos.x, y: pos.y, z: pos.z },
                bodyY: { min: bodyMinY, max: bodyMaxY },
                colliderIndex: idx,
                collider: {
                  yMin: cyMin,
                  yMax: cyMax,
                  overlapDepth,
                  radius: b.radius,
                  objName: b.obj && b.obj.name ? b.obj.name : "",
                  parentName: b.obj && b.obj.parent && b.obj.parent.name ? b.obj.parent.name : ""
                },
                push: { nx, nz, amount: push }
              });
            }

            pushed = true;
          }
        }

    // --- OBB bounds (explicit collide:true) ---
        if (avatarModelColliderOBBs && avatarModelColliderOBBs.length) {
          for (let i = 0; i < avatarModelColliderOBBs.length; i++) {
            const obb = avatarModelColliderOBBs[i];
            if (!obb) continue;

            if (Number.isFinite(obb.yMin) && Number.isFinite(obb.yMax)) {
              const overlapDepth = Math.min(bodyMaxY, obb.yMax) - Math.max(bodyMinY, obb.yMin);
              if (overlapDepth <= yOverlapEps) continue;
            }

            const dxw = pos.x - obb.center.x;
            const dzw = pos.z - obb.center.z;

            const c = Math.cos(obb.yaw);
            const s = Math.sin(obb.yaw);

            const lx = dxw * c + dzw * s;
            const lz = -dxw * s + dzw * c;

            const cx = clamp(lx, -obb.halfX, obb.halfX);
            const cz = clamp(lz, -obb.halfZ, obb.halfZ);

            const dxl = lx - cx;
            const dzl = lz - cz;

            const d2 = dxl * dxl + dzl * dzl;
            const rr = (rA + skin);
            if (d2 >= rr * rr) continue;

            const d = Math.sqrt(d2) || 1e-6;
            const push = rr - d;
            if (push <= pushEps) continue;

            let nlx = dxl / d;
            let nlz = dzl / d;

            if (!Number.isFinite(nlx) || !Number.isFinite(nlz)) {
              if (Math.abs(lx) > Math.abs(lz)) {
                nlx = lx >= 0 ? 1 : -1;
                nlz = 0;
              } else {
                nlx = 0;
                nlz = lz >= 0 ? 1 : -1;
              }
            }

            const nx = nlx * c - nlz * s;
            const nz = nlx * s + nlz * c;

            pos.x += nx * push;
            pos.z += nz * push;

            const velDot = avatarVelocity.x * nx + avatarVelocity.z * nz;
            if (velDot < 0) {
              avatarVelocity.x -= velDot * nx;
              avatarVelocity.z -= velDot * nz;
            }

            if (dbg && typeof logAvatarCollision === "function") {
              const overlapDepth =
              (Number.isFinite(obb.yMin) && Number.isFinite(obb.yMax))
              ? (Math.min(bodyMaxY, obb.yMax) - Math.max(bodyMinY, obb.yMin))
              : null;

              logAvatarCollision("obb_push", {
                iter,
                avatar: { x: pos.x, y: pos.y, z: pos.z },
                bodyY: { min: bodyMinY, max: bodyMaxY },
                colliderIndex: i,
                collider: {
                  id: obb.id || "",
                  objName: obb.object && obb.object.name ? obb.object.name : "",
                  yMin: Number.isFinite(obb.yMin) ? obb.yMin : null,
                  yMax: Number.isFinite(obb.yMax) ? obb.yMax : null,
                  overlapDepth,
                  halfX: obb.halfX,
                  halfZ: obb.halfZ,
                  yaw: obb.yaw
                },
                push: { nx, nz, amount: push }
              });
            }

            pushed = true;
          }
        }

        if (!pushed) break;

        pos.x = clamp(pos.x, -limX, limX);
        pos.z = clamp(pos.z, -limZ, limZ);
      }
    }










    const avatarViewConfig = {
      thirdPersonDistance: 4.0,
      thirdPersonHeight: 1.6,
      thirdPersonHeightLift: 0.4,
      firstPersonHeight: 1.6
    };

    const avatarMotionConfig = {
      maxAccel: 5.0,
      maxDecel: 3.0,
      stopEps: 0.03,
      yawLerpThird: 0.2,
      yawLerpFirst: 0.2
    };

    const avatarJumpConfig = {
      initialVelocity: 5.2,
      gravity: 12.0
    };

    const avatarJumpState = {
      active: false,
      grounded: true,
      vy: 0.0,
      groundY: 0.0
    };


    // Reusable vectors for avatar motion/camera math (avoid per-frame allocations)
    const avatarVelocity = new THREE.Vector3();
    const avatarMoveDir = new THREE.Vector3();

    const avatarWorldPos = new THREE.Vector3();
    const avatarHeadPos = new THREE.Vector3();
    const avatarForwardWorld = new THREE.Vector3();
    const avatarLastWorldPos = new THREE.Vector3();
    let avatarHasLastPos = false;

    const avatarTmpVec = new THREE.Vector3();
    const avatarTmpDir = new THREE.Vector3();
    const avatarToTarget = new THREE.Vector3();
    const avatarTmpMove = new THREE.Vector3();

    const camForward = new THREE.Vector3();
    const camRight = new THREE.Vector3();
    const worldUp = new THREE.Vector3(0, 1, 0);



    const joystickState = {
      active: false,
      pointerId: null,
      centerX: 0,
      centerY: 0,
      radius: 0,
      valueX: 0, // -1..1 (left/right)
      valueY: 0, // -1..1 (up/down screen); forward uses -valueY
      run: false // true when the thumb is pushed to the rim (full throw)
    };

    const joystickRightState = {
      active: false,
      pointerId: null,
      centerX: 0,
      centerY: 0,
      radius: 0,
      valueX: 0, // -1..1 (left/right)
      valueY: 0  // -1..1 (up/down screen); forward uses -valueY
    };


    const preAvatarCameraState = {
      has: false,
      position: new THREE.Vector3(),
      target: new THREE.Vector3(),
      enablePan: true,
      enableZoom: true,
      minDistance: 0.0,
      maxDistance: 0.0,
      minPolarAngle: 0.0,
      maxPolarAngle: Math.PI,
      autoRotateEnabled: false
    };

    /**
     * Smooth yaw interpolation that always takes the shortest arc.
     */
    function lerpYaw(current, target, t) {
      let d = target - current;
      while (d > Math.PI) d -= Math.PI * 2;
      while (d < -Math.PI) d += Math.PI * 2;
      return current + d * t;
    }

    /**
     * Captures camera + OrbitControls state before entering avatar mode.
     */
    function savePreAvatarCameraState() {
      if (!controls) return;

      preAvatarCameraState.has = true;
      preAvatarCameraState.position.copy(camera.position);
      if (controls.target) preAvatarCameraState.target.copy(controls.target);

      preAvatarCameraState.enablePan = !!controls.enablePan;
      preAvatarCameraState.enableZoom = !!controls.enableZoom;
      preAvatarCameraState.minDistance = controls.minDistance;
      preAvatarCameraState.maxDistance = controls.maxDistance;
      preAvatarCameraState.minPolarAngle = controls.minPolarAngle;
      preAvatarCameraState.maxPolarAngle = controls.maxPolarAngle;

      preAvatarCameraState.autoRotateEnabled = !!autoRotateEnabled;
    }





    /**
     * Restores camera + OrbitControls state to the exact pre-avatar snapshot.
     */
    function restorePreAvatarCameraState() {
      if (!controls) return;

      if (!preAvatarCameraState.has) {
        controls.enablePan = true;
        controls.enableZoom = true;
        controls.minDistance = 0.25;
        controls.maxDistance = 200.0;
        return;
      }

      camera.position.copy(preAvatarCameraState.position);
      if (controls.target) controls.target.copy(preAvatarCameraState.target);

      controls.enablePan = preAvatarCameraState.enablePan;
      controls.enableZoom = preAvatarCameraState.enableZoom;
      controls.minDistance = preAvatarCameraState.minDistance;
      controls.maxDistance = preAvatarCameraState.maxDistance;
      controls.minPolarAngle = preAvatarCameraState.minPolarAngle;
      controls.maxPolarAngle = preAvatarCameraState.maxPolarAngle;

      autoRotateEnabled = preAvatarCameraState.autoRotateEnabled;

      controls.update();
    }



    /* Smooth Y-follow state to prevent abrupt camera jumps on terrain/ground height changes. */
    const avatarCameraYFollowState = {
      has: false,
      y: 0,
      stiffness: 10.0,
      maxStep: 1.25
    };

    /* First-person Y-follow is tighter to reduce perceived head lag. */
    const avatarCameraYFollowFirstState = {
      has: false,
      y: 0,
      stiffness: 18.0,
      maxStep: 2.5
    };

    /* Chase-camera target Y smoothing (kept separate from standard follow). */
    const avatarChaseTargetYFollowState = {
      has: false,
      y: 0,
      stiffness: 10.0,
      maxStep: 1.25
    };

    /**
     * Smooths a desired Y value with exponential easing and a per-frame step clamp.
     * Prevents camera target/position snapping when the avatar ground height changes abruptly.
     */
    function smoothFollowY(state, desiredY, dt) {
      if (!Number.isFinite(desiredY)) return state.has ? state.y : desiredY;

      if (!state.has || !Number.isFinite(state.y)) {
        state.has = true;
        state.y = desiredY;
        return desiredY;
      }

      const k = Math.max(0.0, state.stiffness);
      const alpha = 1 - Math.pow(0.001, k * Math.max(0.0, dt));

      let step = (desiredY - state.y) * alpha;

      const maxStep = state.maxStep;
      if (Number.isFinite(maxStep) && maxStep > 0) {
        if (step > maxStep) step = maxStep;
        else if (step < -maxStep) step = -maxStep;
      }

      state.y += step;
      return state.y;
    }




    /**
     * Positions the camera behind the avatar and targets the avatar head.
     * Initializes camera Y smoothing state so snaps do not create a follow-step on the next frame.
     */
    function placeCameraBehindAvatar() {
      if (!avatar || !controls) return;

      avatar.getWorldPosition(avatarWorldPos);

      avatarCameraYFollowState.has = true;
      avatarCameraYFollowState.y = avatarWorldPos.y;
      avatarCameraYFollowFirstState.has = false;

      avatarHeadPos.copy(avatarWorldPos);
      avatarHeadPos.y += avatarViewConfig.thirdPersonHeight;

      avatarForwardWorld.set(0, 0, 1).applyQuaternion(avatar.quaternion).normalize();

      avatarTmpVec
      .copy(avatarHeadPos)
      .addScaledVector(avatarForwardWorld, -avatarViewConfig.thirdPersonDistance)
      .addScaledVector(worldUp, avatarViewConfig.thirdPersonHeightLift);

      camera.position.copy(avatarTmpVec);
      camera.lookAt(avatarHeadPos);
      controls.target.copy(avatarHeadPos);

      avatarLastWorldPos.set(avatarWorldPos.x, avatarCameraYFollowState.y, avatarWorldPos.z);
      avatarHasLastPos = true;
    }


    /**
     * Switches avatar view mode and configures OrbitControls constraints for that mode.
     */
    function setAvatarViewMode(mode, snapCamera = true) {
      if (!avatarState.enabled || !controls) return;

      avatarState.viewMode = mode;
      avatarHasLastPos = false;

      if (mode === "third") {
        if (avatar) avatar.visible = true;

        controls.enablePan = false;
        controls.enableZoom = true;
        controls.minDistance = 0.25;
        controls.maxDistance = 80.0;

        if (snapCamera) {
          placeCameraBehindAvatar();
          controls.update();
        }
        return;
      }

      if (avatar) avatar.visible = false;

      controls.enablePan = false;
      controls.enableZoom = false;
      controls.minDistance = 0.01;
      controls.maxDistance = 0.01;

      if (avatar) {
        avatar.getWorldPosition(avatarWorldPos);

        avatarHeadPos.copy(avatarWorldPos);
        avatarHeadPos.y += avatarViewConfig.firstPersonHeight;

        camera.position.copy(avatarHeadPos);

        avatarForwardWorld.set(0, 0, 1).applyQuaternion(avatar.quaternion).normalize();
        avatarTmpVec.copy(avatarHeadPos).add(avatarForwardWorld);

        camera.lookAt(avatarTmpVec);
        controls.target.copy(avatarTmpVec);
        controls.update();
      }
    }

    /**
     * Clears joystick values and re-centers the thumb indicator.
     */
    function resetJoystick() {
      joystickState.active = false;
      joystickState.pointerId = null;
      joystickState.valueX = 0;
      joystickState.valueY = 0;
      joystickState.run = false;
      const inner = document.getElementById("joystickInner");
      if (inner) {
        inner.style.transform = "translate(0px, 0px)";
      }
    }

    function resetRightJoystick() {
      joystickRightState.active = false;
      joystickRightState.pointerId = null;
      joystickRightState.valueX = 0;
      joystickRightState.valueY = 0;
      const inner = document.getElementById("joystickRightInner");
      if (inner) {
        inner.style.transform = "translate(0px, 0px)";
      }
    }


    /**
     * Maps pointer position to joystick values with dead-zones and clamped thumb motion.
     * Uses a stronger X dead-zone while driving a vehicle to prevent unintended steering drift.
     */
    function updateJoystickFromPointer(px, py) {
      if (!joystickState.radius) return;
      const dx = px - joystickState.centerX;
      const dy = py - joystickState.centerY;
      const knobRadius = 20;
      const maxDist = Math.max(1, joystickState.radius - knobRadius);
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const clampedDist = Math.min(dist, maxDist);
      joystickState.run = clampedDist >= maxDist * 0.985;
      const ratio = clampedDist / dist;
      const thumbX = dx * ratio;
      const thumbY = dy * ratio;
      const inner = document.getElementById("joystickInner");
      if (inner) {
        inner.style.transform = `translate(${thumbX}px, ${thumbY}px)`;
      }
      const isDrivingVehicle =
      !!(vehicleDriveState && vehicleDriveState.enabled);
      const rawX = clamp(dx / maxDist, -1, 1);
      const rawY = clamp(dy / maxDist, -1, 1);
      const deadX = isDrivingVehicle ? 0.32 : 0.20;
      const deadY = 0.20;
      let vx = applyDeadZone(rawX, deadX);
      let vy = applyDeadZone(rawY, deadY);
      const mag = Math.sqrt(vx * vx + vy * vy);
      if (mag < 0.01) {
        joystickState.valueX = 0;
        joystickState.valueY = 0;
        joystickState.run = false;
        return;
      }
      if (isDrivingVehicle) {
        joystickState.run = false;
        const forwardAbs = Math.min(1, Math.abs(-vy)); // forward uses -valueY elsewhere
        const steerAttenuation = 1 - forwardAbs * 0.65;
        vx *= Math.max(0.25, steerAttenuation);
      }
      joystickState.valueX = clamp(vx, -1, 1);
      joystickState.valueY = clamp(vy, -1, 1);
    }

    function updateRightJoystickFromPointer(px, py) {
      if (!joystickRightState.radius) return;
      const dx = px - joystickRightState.centerX;
      const dy = py - joystickRightState.centerY;
      const knobRadius = 20;
      const maxDist = Math.max(1, joystickRightState.radius - knobRadius);
      const dist = Math.sqrt(dx * dx + dy * dy) || 1;
      const clampedDist = Math.min(dist, maxDist);
      const ratio = clampedDist / dist;
      const thumbX = dx * ratio;
      const thumbY = dy * ratio;
      const inner = document.getElementById("joystickRightInner");
      if (inner) {
        inner.style.transform = `translate(${thumbX}px, ${thumbY}px)`;
      }
      const rawX = clamp(dx / maxDist, -1, 1);
      const rawY = clamp(dy / maxDist, -1, 1);
      const deadX = 0.20;
      const deadY = 0.20;
      let vx = applyDeadZone(rawX, deadX);
      let vy = applyDeadZone(rawY, deadY);
      const mag = Math.sqrt(vx * vx + vy * vy);
      if (mag < 0.01) {
        joystickRightState.valueX = 0;
        joystickRightState.valueY = 0;
        return;
      }
      joystickRightState.valueX = clamp(vx, -1, 1);
      joystickRightState.valueY = clamp(vy, -1, 1);
    }


/* Binds pointer input to the left joystick element and updates joystickState continuously. */
    function initJoystick(rootEl) {
      if (!rootEl || rootEl.__joyBound) return;
      rootEl.__joyBound = true;

      const computeCenter = () => {
        const r = rootEl.getBoundingClientRect();
        joystickState.centerX = r.left + r.width * 0.5;
        joystickState.centerY = r.top + r.height * 0.5;
        joystickState.radius = Math.max(10, Math.min(r.width, r.height) * 0.5);
      };

      const onDown = (e) => {
        if (uiHidden) return;
        if (!avatarState || !avatarState.enabled) return;

        computeCenter();

        joystickState.active = true;
        joystickState.pointerId = e.pointerId;

        try { rootEl.setPointerCapture(e.pointerId); } catch (_) {}

        updateJoystickFromPointer(e.clientX, e.clientY);

        e.preventDefault();
        e.stopPropagation();
      };

      const onMove = (e) => {
        if (!joystickState.active) return;
        if (joystickState.pointerId !== e.pointerId) return;

        updateJoystickFromPointer(e.clientX, e.clientY);

        e.preventDefault();
        e.stopPropagation();
      };

      const onUp = (e) => {
        if (!joystickState.active) return;
        if (joystickState.pointerId !== e.pointerId) return;

        try { rootEl.releasePointerCapture(e.pointerId); } catch (_) {}
        resetJoystick();

        e.preventDefault();
        e.stopPropagation();
      };

      rootEl.addEventListener("pointerdown", onDown, { passive: false });
      rootEl.addEventListener("pointermove", onMove, { passive: false });
      rootEl.addEventListener("pointerup", onUp, { passive: false });
      rootEl.addEventListener("pointercancel", onUp, { passive: false });
    }

/* Binds pointer input to the right joystick element and updates joystickRightState continuously. */
    function initRightJoystick(rootEl) {
      if (!rootEl || rootEl.__joyRightBound) return;
      rootEl.__joyRightBound = true;

      const computeCenter = () => {
        const r = rootEl.getBoundingClientRect();
        joystickRightState.centerX = r.left + r.width * 0.5;
        joystickRightState.centerY = r.top + r.height * 0.5;
        joystickRightState.radius = Math.max(10, Math.min(r.width, r.height) * 0.5);
      };

      const onDown = (e) => {
        if (uiHidden) return;
        if (!avatarState || !avatarState.enabled) return;

        computeCenter();

        joystickRightState.active = true;
        joystickRightState.pointerId = e.pointerId;

        try { rootEl.setPointerCapture(e.pointerId); } catch (_) {}

        updateRightJoystickFromPointer(e.clientX, e.clientY);

        e.preventDefault();
        e.stopPropagation();
      };

      const onMove = (e) => {
        if (!joystickRightState.active) return;
        if (joystickRightState.pointerId !== e.pointerId) return;

        updateRightJoystickFromPointer(e.clientX, e.clientY);

        e.preventDefault();
        e.stopPropagation();
      };

      const onUp = (e) => {
        if (!joystickRightState.active) return;
        if (joystickRightState.pointerId !== e.pointerId) return;

        try { rootEl.releasePointerCapture(e.pointerId); } catch (_) {}
        resetRightJoystick();

        e.preventDefault();
        e.stopPropagation();
      };

      rootEl.addEventListener("pointerdown", onDown, { passive: false });
      rootEl.addEventListener("pointermove", onMove, { passive: false });
      rootEl.addEventListener("pointerup", onUp, { passive: false });
      rootEl.addEventListener("pointercancel", onUp, { passive: false });
    }



    /**
     * Ensures an AnimationAction is active with deterministic weight/time scale.
     */
    function setActionWeight(action, weight) {
      action.enabled = true;
      action.setEffectiveTimeScale(1);
      action.setEffectiveWeight(weight);
    }


    /**
     * Plays a named avatar gait ("idle" | "walk" | "run") with a stable cross-fade.
     */
    function playAvatarAction(name) {
      if (!avatarMixer) return;

      const next = avatarActions[name];
      if (!next) {
        console.warn("[avatar] no action for", name);
        return;
      }

      if (avatarCurrentActionName === name) return;

      const prev = avatarActions[avatarCurrentActionName];
      const duration = 0.3;

      next.reset();
      setActionWeight(next, 1.0);
      next.play();

      if (prev) {
        prev.crossFadeTo(next, duration, true);
      } else {
        next.fadeIn(duration);
      }

      avatarCurrentAction = next;
      avatarCurrentActionName = name;
    }

    /**
     * Plays a one-shot avatar jump action (if present) without being overridden by gait switching.
     */
    function playAvatarJumpAction() {
      if (!avatarMixer) return;

      const jump = avatarActions["jump"];
      if (!jump) return;

      if (avatarCurrentActionName === "jump") return;

      const prev = avatarActions[avatarCurrentActionName];
      const duration = 0.12;

      jump.reset();
      jump.clampWhenFinished = true;
      jump.setLoop(THREE.LoopOnce, 1);
      setActionWeight(jump, 1.0);
      jump.play();

      if (prev && prev !== jump) {
        prev.crossFadeTo(jump, duration, true);
      } else {
        jump.fadeIn(duration);
      }

      avatarCurrentAction = jump;
      avatarCurrentActionName = "jump";
    }


    function getWorldSurfaceYBelow(x, z, maxY) {
  /* Returns the highest traversable surface at XZ that is NOT above maxY. */
      const snowY = getSnowSurfaceY(x, z);

      if (!worldGroundMeshes || worldGroundMeshes.length === 0) return snowY;

  // Keep matrices fresh when world-editing/transforming objects.
      if (worldEditState && worldEditState.enabled) {
        for (let i = 0; i < worldGroundMeshes.length; i++) {
          const m = worldGroundMeshes[i];
          if (m && m.matrixWorldNeedsUpdate) m.updateWorldMatrix(true, false);
        }
      }

      const limitY = Number.isFinite(maxY) ? maxY : Infinity;

      worldGroundRayOrigin.set(x, snowY + 1000.0, z);
      worldGroundRaycaster.near = 0.0;
      worldGroundRaycaster.far = 2000.0;
      worldGroundRaycaster.set(worldGroundRayOrigin, worldGroundRayDir);

      const hits = worldGroundRaycaster.intersectObjects(worldGroundMeshes, false);
      if (!hits || hits.length === 0) return snowY;

  // Ray hits are sorted nearest-first (highest surfaces first). Pick first hit that is not above maxY.
      for (let i = 0; i < hits.length; i++) {
        const y = hits[i] && hits[i].point ? hits[i].point.y : NaN;
        if (!Number.isFinite(y)) continue;
        if (y <= limitY + 1e-5) return y > snowY ? y : snowY;
      }

      //console.log(avatar.position.y, snowY)


      return snowY;
    }



    /**
     * Requests a jump if avatar is enabled, not mounted, and currently grounded.
     */
    function requestAvatarJump() {
      if (!avatarState.enabled || !avatar) return;
      if (vehicleDriveState.enabled) return;

      const meta = (equipmentState.enabled && equipmentState.item && equipmentState.item.meta) ? equipmentState.item.meta : null;
      const action = meta && typeof meta.action === "string" ? meta.action.trim().toLowerCase() : "";
      const type = meta && typeof meta.type === "string" ? meta.type.trim().toLowerCase() : "";
      const isJetpack = (action === "jetpack") || (type === "jetpack");

      if (isJetpack) {
        const maxStepUp = Number.isFinite(params.avatarMaxStepUp) ? params.avatarMaxStepUp : 0.0;

        let groundY = getWorldSurfaceYBelow(
          avatar.position.x,
          avatar.position.z,
          avatar.position.y + maxStepUp + 1e-4
          );

        if (!Number.isFinite(groundY)) groundY = avatarJumpState.groundY;

        avatarJumpState.groundY = groundY;
        avatarJumpState.active = true;
        avatarJumpState.grounded = false;

        if (!Number.isFinite(avatarJumpState.vy)) avatarJumpState.vy = 0.0;
        avatarJumpState.vy = Math.max(avatarJumpState.vy, avatarJetpackConfig.takeoffVelocity);

        switchAvatarAction("idle");
        return;
      }

      if (avatarJumpState.active || !avatarJumpState.grounded) return;

      avatarJumpState.groundY = avatar.position.y;
      avatarJumpState.vy = avatarJumpConfig.initialVelocity;
      avatarJumpState.active = true;
      avatarJumpState.grounded = false;

      playAvatarJumpAction();
    }





    /**
     * Integrates vertical jump motion and resolves landing back to the current surface height.
     * Keeps groundY tracking the traversable surface so the avatar runs on terrain and lands correctly while moving.
     */
    function updateAvatarJump(dt) {
      if (!avatarState.enabled || !avatar) return;

      if (vehicleDriveState.enabled) {
        avatarJumpState.active = false;
        avatarJumpState.grounded = true;
        avatarJumpState.vy = 0.0;
        return;
      }

      if (!avatarJumpState._lastGrounded) {
        avatarJumpState._lastGrounded = { x: avatar.position.x, y: avatar.position.y, z: avatar.position.z };
      }

      const meta =
      equipmentState.enabled && equipmentState.item && equipmentState.item.meta
      ? equipmentState.item.meta
      : null;

      const action = meta && typeof meta.action === "string" ? meta.action.trim().toLowerCase() : "";
      const type = meta && typeof meta.type === "string" ? meta.type.trim().toLowerCase() : "";
      const isJetpack = action === "jetpack" || type === "jetpack";

      const maxStepUp = Number.isFinite(params.avatarMaxStepUp) ? params.avatarMaxStepUp : 0.0;
      const jetGroundEps = Number.isFinite(avatarJetpackConfig.groundEps) ? avatarJetpackConfig.groundEps : 0.06;
      const landEps = 0.06;

  // When grounded (not active), allow small step-ups. When airborne, never allow snapping upward.
      const snapLimitY =
      !avatarJumpState.active
      ? (avatar.position.y + maxStepUp + 1e-4)
      : (avatar.position.y + (isJetpack ? jetGroundEps : landEps));

      let groundY = getWorldSurfaceYBelow(avatar.position.x, avatar.position.z, snapLimitY);
      if (!Number.isFinite(groundY)) groundY = avatarJumpState.groundY;

  // Jetpack vertical movement (never snaps upward onto higher surfaces).
      if (isJetpack) {
        const keyUp = !!avatarKeys.jump;
        const keyDown = !!avatarKeys.jetDown;

        const wantsUp = keyUp || (joystickRightState && joystickRightState.active && joystickRightState.valueY < -0.18);
        const wantsDown = keyDown || (joystickRightState && joystickRightState.active && joystickRightState.valueY > 0.18);
        const hasThrust = wantsUp || wantsDown;

    // Re-evaluate "onSurface" with a strict limit tied to current Y (prevents tower-top teleport).
        let groundY2 = getWorldSurfaceYBelow(avatar.position.x, avatar.position.z, avatar.position.y + jetGroundEps);
        if (!Number.isFinite(groundY2)) groundY2 = groundY;

        const onSurface =
        Number.isFinite(groundY2) &&
        (avatar.position.y <= groundY2 + jetGroundEps);

        if (!avatarJumpState.active && !hasThrust && onSurface) {
          avatarJumpState.grounded = true;
          avatarJumpState.vy = 0.0;
          avatarJumpState.groundY = groundY2;
          avatar.position.y = groundY2;

          const p = avatarJumpState._lastGrounded;
          p.x = avatar.position.x; p.y = avatar.position.y; p.z = avatar.position.z;
          return;
        }

        avatarJumpState.active = true;
        avatarJumpState.grounded = false;
        avatarJumpState.groundY = groundY2;

        if (!Number.isFinite(avatarJumpState.vy)) avatarJumpState.vy = 0.0;

        let ay = -(Number.isFinite(avatarJetpackConfig.gravity) ? avatarJetpackConfig.gravity : 0.0);
        if (wantsUp) ay += (Number.isFinite(avatarJetpackConfig.thrustUp) ? avatarJetpackConfig.thrustUp : 0.0);
        if (wantsDown) ay -= (Number.isFinite(avatarJetpackConfig.thrustDown) ? avatarJetpackConfig.thrustDown : 0.0);

        avatarJumpState.vy += ay * dt;

    // Jetpack damping (was using a missing config field -> NaN -> avatar disappears).
        const drag = Number.isFinite(avatarJetpackConfig.drag) ? avatarJetpackConfig.drag : 0.0;
        avatarJumpState.vy *= Math.exp(-drag * dt);

        const maxUp = Number.isFinite(avatarJetpackConfig.maxUpSpeed) ? avatarJetpackConfig.maxUpSpeed : 999.0;
        const maxDown = Number.isFinite(avatarJetpackConfig.maxDownSpeed) ? avatarJetpackConfig.maxDownSpeed : 999.0;
        avatarJumpState.vy = Math.max(-maxDown, Math.min(maxUp, avatarJumpState.vy));

        if (!Number.isFinite(avatarJumpState.vy)) avatarJumpState.vy = 0.0;

        avatar.position.y += avatarJumpState.vy * dt;

        if (!Number.isFinite(avatar.position.y)) {
          avatar.position.y = Number.isFinite(groundY2) ? groundY2 : 0.0;
          avatarJumpState.vy = 0.0;
          avatarJumpState.active = false;
          avatarJumpState.grounded = true;
          return;
        }

    // Landing check uses "below current Y" so it cannot snap upward.
        let landY = getWorldSurfaceYBelow(avatar.position.x, avatar.position.z, avatar.position.y + jetGroundEps);
        if (!Number.isFinite(landY)) landY = avatarJumpState.groundY;

        if (Number.isFinite(landY) && avatar.position.y < landY) {
          avatar.position.y = landY;
          avatarJumpState.vy = 0.0;
          avatarJumpState.grounded = true;

          if (!hasThrust) {
            avatarJumpState.active = false;

            const p = avatarJumpState._lastGrounded;
            p.x = avatar.position.x; p.y = avatar.position.y; p.z = avatar.position.z;
          }
        }

        return;
      }

  // Non-jetpack jump / fall.
      if (!avatarJumpState.active) {
        const fallStart = Number.isFinite(params.avatarFallStart) ? params.avatarFallStart : 0.0;

        if (Number.isFinite(groundY) && fallStart > 0.0) {
          const drop = avatar.position.y - groundY;
          if (drop > fallStart) {
            avatarJumpState.groundY = groundY;
            avatarJumpState.vy = 0.0;
            avatarJumpState.active = true;
            avatarJumpState.grounded = false;

            if (avatarMixer && avatarActions && avatarActions.jump) {
              if (avatarCurrentActionName !== "jump") playAvatarJumpAction();
            }
            return;
          }
        }

        avatarJumpState.grounded = true;
        avatarJumpState.vy = 0.0;
        avatarJumpState.groundY = groundY;

        if (Number.isFinite(groundY)) {
          avatar.position.y = groundY;
        }

        const p = avatarJumpState._lastGrounded;
        p.x = avatar.position.x; p.y = avatar.position.y; p.z = avatar.position.z;
        return;
      }

  // Airborne integration.
      avatarJumpState.groundY = groundY;

      avatarJumpState.vy -= avatarJumpConfig.gravity * dt;
      if (!Number.isFinite(avatarJumpState.vy)) avatarJumpState.vy = 0.0;

      avatar.position.y += avatarJumpState.vy * dt;

  // Landing check (no upward snap).
      let landY = getWorldSurfaceYBelow(avatar.position.x, avatar.position.z, avatar.position.y + landEps);
      if (!Number.isFinite(landY)) landY = avatarJumpState.groundY;

      if (Number.isFinite(landY) && avatar.position.y <= landY) {


        const takeoff = avatarJumpState._lastGrounded || { x: avatar.position.x, y: avatar.position.y, z: avatar.position.z };
        const dx = avatar.position.x - takeoff.x;
        const dz = avatar.position.z - takeoff.z;
        const gap = Math.hypot(dx, dz);
        const drop = Math.max(0.0, (takeoff.y - landY));

        const j =
        gap < 0.5 ? 0 :
        gap < 1.5 ? 1 :
        gap < 2.5 ? 2 :
        gap < 3.5 ? 3 :
        gap < 5.0 ? 4 : 5;

        const d =
        drop < 0.5 ? 0 :
        drop < 1.5 ? 1 :
        drop < 3.0 ? 2 :
        drop < 5.0 ? 3 : 4;

        const pts = j + d;

        if (pts >= 2 || drop >= 1.2) {
          // scale = loudness multiplier applied to preset.gain (final loudness = gain * scale)
          const scale = clamp(0.55 + (pts * 0.18) + (drop * 0.10), 0.6, 2.0);
          playFX("heartbeat", scale);
        }



        avatar.position.y = landY;
        avatarJumpState.vy = 0.0;
        avatarJumpState.active = false;
        avatarJumpState.grounded = true;

        const p = avatarJumpState._lastGrounded;
        p.x = avatar.position.x; p.y = avatar.position.y; p.z = avatar.position.z;
        return;
      }

      avatarJumpState.grounded = false;
      if (avatarMixer && avatarActions && avatarActions.jump) {
        if (avatarCurrentActionName !== "jump") playAvatarJumpAction();
      }
    }







    /**
     * Matches walk/run animation playback speed to actual movement speed to reduce foot sliding.
     */
    function updateAvatarClipSpeed(speed) {
      if (!avatarMixer) return;

      const walk = avatarActions["walk"];
      const run = avatarActions["run"];

      if (avatarCurrentActionName === "walk" && walk) {
        const base = AVATAR_WALK_SPEED || 1.0;
        const scale = clamp(speed / base, 0.4, 2.0);
        walk.setEffectiveTimeScale(scale);
      } else if (avatarCurrentActionName === "run" && run) {
        const base = AVATAR_RUN_SPEED || 1.0;
        const scale = clamp(speed / base, 0.4, 2.0);
        run.setEffectiveTimeScale(scale);
      }
    }



    /**
     * Loads (or swaps) the current avatar GLB, preserving transform/visibility.
     * Preserves yaw derived from quaternion to avoid 180Â° Euler ambiguity after avatar swaps/snapshots.
     */
    function loadAvatar(url = getSelectedAvatarUrl()) {
      const nextUrl = String(url ?? "").trim();
      if (!nextUrl || !gltfLoader || !scene) return;

      if (avatar && avatar.userData && avatar.userData.avatarUrl === nextUrl) return;

      const prevAvatar = avatar || null;
      const keepVisible = prevAvatar ? !!prevAvatar.visible : true;

      const yawFromQuat = (quat) => {
        const qx = quat.x, qy = quat.y, qz = quat.z, qw = quat.w;
        const sinyCosp = 2 * (qw * qy + qx * qz);
        const cosyCosp = 1 - 2 * (qy * qy + qz * qz);
        const yaw = Math.atan2(sinyCosp, cosyCosp);
        return Number.isFinite(yaw) ? yaw : 0.0;
      };

      if (prevAvatar) {
        avatarSwapPos.copy(prevAvatar.position);

        avatarSwapYaw = yawFromQuat(prevAvatar.quaternion);
        avatarSwapQuat.setFromAxisAngle(avatarSwapUpAxis, avatarSwapYaw);

        avatarSwapScale.copy(prevAvatar.scale);
      } else {
        avatarSwapPos.set(0, 0, 0);

        avatarSwapYaw = 0;
        avatarSwapQuat.setFromAxisAngle(avatarSwapUpAxis, 0);

        avatarSwapScale.set(1, 1, 1);
      }

      const prevActionName = avatarCurrentActionName || "idle";
      const token = ++avatarSwapToken;

      gltfLoader.load(
        nextUrl,
        (gltf) => {
          if (token !== avatarSwapToken) return;

          const nextAvatar = gltf.scene;

          nextAvatar.userData.avatarUrl = nextUrl;

          nextAvatar.traverse((obj) => {
            if (!obj.isMesh) return;
            obj.castShadow = true;
            obj.receiveShadow = true;
          });

          nextAvatar.position.copy(avatarSwapPos);
          nextAvatar.rotation.set(0, avatarSwapYaw, 0);
          nextAvatar.scale.copy(avatarSwapScale);
          nextAvatar.visible = keepVisible;

          scene.add(nextAvatar);

          avatar = nextAvatar;

          if (avatarMixer) {
            try { avatarMixer.stopAllAction(); } catch {}
          }

          avatarMixer = null;
          for (const k in avatarActions) delete avatarActions[k];
            avatarCurrentAction = null;
          avatarCurrentActionName = "";

          if (gltf.animations && gltf.animations.length) {
            avatarMixer = new THREE.AnimationMixer(avatar);

            for (let i = 0; i < gltf.animations.length; i++) {
              const clip = gltf.animations[i];
              const key = String(clip.name || `clip_${i}`).toLowerCase();
              avatarActions[key] = avatarMixer.clipAction(clip);
            }

            function getAction(nameFallbacks, defaultKey) {
              for (let i = 0; i < nameFallbacks.length; i++) {
                const needle = String(nameFallbacks[i]).toLowerCase();
                const found = Object.entries(avatarActions).find(([n]) => n.includes(needle));
                if (found) return found[1];
              }
              return defaultKey != null ? (avatarActions[defaultKey] || null) : null;
            }

            const keys = Object.keys(avatarActions);
            const defaultKey = keys.length ? keys[0] : null;

            const idleAction = getAction(["idle", "stand"], defaultKey);
            const walkAction = getAction(["walk"], defaultKey);
            const runAction = getAction(["run", "jog"], defaultKey);
            const sitAction = getAction(["drive", "sit", "seat"], defaultKey);
            const jumpAction = getAction(["jump"], null);

            if (idleAction) avatarActions["idle"] = idleAction;
            if (walkAction) avatarActions["walk"] = walkAction;
            if (runAction) avatarActions["run"] = runAction;
            if (sitAction) avatarActions["drive"] = sitAction;
            if (jumpAction) avatarActions["jump"] = jumpAction;

            avatarMixer.stopAllAction();

            if (avatarActions[prevActionName]) {
              playAvatarAction(prevActionName);
            } else if (avatarActions["idle"]) {
              playAvatarAction("idle");
            }
          }

          applyLocalPlayerProfileToAvatar();

          if (prevAvatar && prevAvatar.parent) {
            prevAvatar.parent.remove(prevAvatar);
          }
        },
        undefined,
        (err) => {
          console.warn("[snow] avatar load failed", err);
        }
        );
    }




    /**
     * Builds a stable slash-path for an object relative to a root.
     */
    function getObjectPath(obj, root) {
      const parts = [];
      let cur = obj;
      while (cur && cur !== root) {
        parts.push(String(cur.name || cur.type || "Object3D"));
        cur = cur.parent;
      }
      parts.push(String(root && (root.name || "avatar") || "avatar"));
      parts.reverse();
      return parts.join("/");
    }

    /**
     * Collects and prints avatar bone names (and paths) to the console.
     * Returns an array of bone info rows for downstream tooling.
     */
    function listAvatarBonesToConsole() {
      if (!avatar) {
        console.warn("[avatar] list bones: avatar is not loaded");
        return [];
      }

      const bones = [];
      avatar.traverse((o) => {
        if (o && o.isBone) bones.push(o);
      });

      const rows = bones.map((b, i) => {
        return {
          i,
          name: String(b.name || ""),
          path: getObjectPath(b, avatar),
          position: b.position ? `${b.position.x.toFixed(3)}, ${b.position.y.toFixed(3)}, ${b.position.z.toFixed(3)}` : "",
          rotation: b.rotation ? `${b.rotation.x.toFixed(3)}, ${b.rotation.y.toFixed(3)}, ${b.rotation.z.toFixed(3)}` : ""
        };
      });

      console.groupCollapsed(`[avatar] bones (${bones.length})`);
      try {
        console.table(rows);
      } catch (e) {
        console.log(rows);
      }
      console.groupEnd();

      return rows;
    }






    /**
     * Resolves avatar action names, allowing equipped items to override idle with a dedicated action.
     */
    function resolveAvatarActionName(name) {
      const n = String(name || "");
      if (n === "idle" && equipmentState.enabled) {
        const idle = String(equipmentState.idleAction || "");
        if (idle && avatarActions && avatarActions[idle]) return idle;
      }
      return n;
    }

    /**
     * Cross-fades avatar animation states.
     */
    function switchAvatarAction(name) {
      playAvatarAction(resolveAvatarActionName(name));
    }


    /**
     * Enables avatar mode and locks interaction to avatar-follow camera behavior.
     * Initializes jump grounding baseline to current avatar Y.
     */
    function enableAvatarControl(initialMode = "third") {
      if (!avatar || avatarState.enabled) return;

      savePreAvatarCameraState();

      avatarState.enabled = true;
      autoRotateEnabled = false;
      avatarHasLastPos = false;

      avatarJumpState.active = false;
      avatarJumpState.grounded = true;
      avatarJumpState.vy = 0.0;
      avatarJumpState.groundY = avatar.position.y;

      if (controls) {
        controls.autoRotate = false;
      }

      setAvatarViewMode(initialMode, true);
      updateAvatarButtons();
    }



    /**
     * Disables avatar mode and restores camera + controls to pre-avatar state.
     * Cancels jump state and restores avatar Y to its grounded baseline.
     */
    function disableAvatarControl() {
      if (!avatarState.enabled) return;

      setAvatarChaseCameraEnabled(false);

      avatarState.enabled = false;

      avatarKeys.forward = false;
      avatarKeys.back = false;
      avatarKeys.left = false;
      avatarKeys.right = false;
      avatarKeys.run = false;
      avatarKeys.jump = false;
      avatarKeys.jetDown = false;

      avatarState.moveX = 0;
      avatarState.moveZ = 0;

      avatarVelocity.set(0, 0, 0);
      avatarMoveDir.set(0, 0, 0);

      if (avatar && Number.isFinite(avatarJumpState.groundY)) {
        avatar.position.y = avatarJumpState.groundY;
      }

      avatarJumpState.active = false;
      avatarJumpState.grounded = true;
      avatarJumpState.vy = 0.0;

      avatarHasLastPos = false;

      resetJoystick();

      if (avatar) avatar.visible = true;

      if (avatarMixer && avatarActions.idle) {
        switchAvatarAction("idle");
      }

      restorePreAvatarCameraState();
      updateAvatarButtons();
    }




    /**
     * Recomputes keyboard movement intent from pressed keys.
     */
    function recomputeAvatarMoveFromKeys() {
      const f = avatarKeys.forward ? 1 : 0;
      const b = avatarKeys.back ? -1 : 0;
      const l = avatarKeys.left ? -1 : 0;
      const r = avatarKeys.right ? 1 : 0;

      avatarState.moveZ = f + b;
      avatarState.moveX = l + r;
    }




    /**
     * Swept XZ collision and sliding against scene collider meshes.
     * Uses ray tests with a radius offset to avoid tunneling and prevents "teleport to corner" failure modes.
     */
    // const avatarCollision = {
    //   radius: 0.38,
    //   skin: 0.03,
    //   probeY: 1.05,
    //   maxStep: 0.22,
    //   maxSlideIters: 3,
    //   broadphasePad: 0.9
    // };

    const avatarRaycaster = new THREE.Raycaster();
    const avatarSweepFrom = new THREE.Vector3();
    const avatarSweepDir = new THREE.Vector3();
    const avatarSweepVec = new THREE.Vector3();
    const avatarAttemptVec = new THREE.Vector3();
    const avatarCenterTmp = new THREE.Vector3();
    const avatarHitNormal = new THREE.Vector3();
    const avatarHitMat3 = new THREE.Matrix3();
    const avatarPrevPosTmp = new THREE.Vector3();

    /**
     * Clamps avatar XZ to the playable snow area while respecting the collision radius.
     */
    function clampAvatarToPlayableXZ(pos) {
      const margin = avatarCollision.radius + 0.25;
      const limX = Math.max(0.5, (visualBounds?.x ?? HALF_GROUND) - margin);
      const limZ = Math.max(0.5, (visualBounds?.z ?? HALF_GROUND) - margin);
      pos.x = clamp(pos.x, -limX, limX);
      pos.z = clamp(pos.z, -limZ, limZ);
    }

    /**
     * Moves the avatar in XZ with swept collisions and surface sliding.
     * Returns the actual horizontal distance traveled.
     */
    function moveAvatarXZWithCollisions(pos, moveX, moveZ) {
      if (!colliderBounds || colliderBounds.length === 0) {
        pos.x += moveX;
        pos.z += moveZ;
        clampAvatarToPlayableXZ(pos);
        return Math.sqrt(moveX * moveX + moveZ * moveZ);
      }

      let traveled = 0;

      avatarSweepVec.set(moveX, 0, moveZ);
      let remainingLen = avatarSweepVec.length();
      if (remainingLen <= 1e-8) return 0;

      clampAvatarToPlayableXZ(pos);

      while (remainingLen > 1e-6) {
        const stepLen = Math.min(avatarCollision.maxStep, remainingLen);
        avatarSweepDir.copy(avatarSweepVec).setLength(1);
        avatarAttemptVec.copy(avatarSweepDir).multiplyScalar(stepLen);

        let resolvedThisStep = false;

        for (let slideIter = 0; slideIter < avatarCollision.maxSlideIters; slideIter++) {
          const attemptLen = avatarAttemptVec.length();
          if (attemptLen <= 1e-6) {
            resolvedThisStep = true;
            break;
          }

          avatarSweepDir.copy(avatarAttemptVec).multiplyScalar(1 / attemptLen);
          const sweepY0 = pos.y + 0.25;
          const sweepY1 = pos.y + avatarCollision.probeY;
          const sweepY2 = pos.y + avatarCollision.probeY + 0.55;

          const sweepMinY = sweepY0;
          const sweepMaxY = sweepY2;

          avatarRaycaster.far = attemptLen + avatarCollision.radius + avatarCollision.skin;

          let bestHit = null;
          let bestDist = Infinity;

          for (const cb of colliderBounds) {
            const obj = cb && cb.obj;
            if (!obj || !obj.isMesh) continue;

            if (Number.isFinite(cb.yMin) && Number.isFinite(cb.yMax)) {
              if (cb.yMin > (sweepMaxY + avatarCollision.skin) || cb.yMax < (sweepMinY - avatarCollision.skin)) continue;
            } else if (cb.center && Number.isFinite(cb.center.y) && Number.isFinite(cb.radius)) {
              const minY = cb.center.y - cb.radius;
              const maxY = cb.center.y + cb.radius;
              if (minY > (sweepMaxY + avatarCollision.skin) || maxY < (sweepMinY - avatarCollision.skin)) continue;
            }

            obj.updateWorldMatrix(true, false);

            obj.getWorldPosition(avatarCenterTmp);
            const dx = avatarCenterTmp.x - pos.x;
            const dz = avatarCenterTmp.z - pos.z;

            const rBase = Number.isFinite(cb.radius) ? cb.radius : 0;
            const r = rBase + avatarCollision.radius + attemptLen + avatarCollision.broadphasePad;
            if (dx * dx + dz * dz > r * r) continue;

            let localHit = null;
            let localDist = Infinity;

            for (let sy = 0; sy < 3; sy++) {
              const y = sy === 0 ? sweepY0 : (sy === 1 ? sweepY1 : sweepY2);
              avatarSweepFrom.set(pos.x, y, pos.z);
              avatarRaycaster.set(avatarSweepFrom, avatarSweepDir);
              const hits = avatarRaycaster.intersectObject(obj, false);
              if (!hits || hits.length === 0) continue;

              const h = hits[0];
              if (h.distance < localDist) {
                localDist = h.distance;
                localHit = h;
              }
            }

            if (!localHit) continue;

            if (localDist < bestDist) {
              bestDist = localDist;
              bestHit = localHit;
            }
          }

          if (!bestHit || !(bestDist < Infinity)) {
            pos.x += avatarAttemptVec.x;
            pos.z += avatarAttemptVec.z;
            traveled += attemptLen;
            resolvedThisStep = true;
            break;
          }

          if (bestHit.face) {
            avatarHitNormal.copy(bestHit.face.normal);
            avatarHitMat3.getNormalMatrix(bestHit.object.matrixWorld);
            avatarHitNormal.applyMatrix3(avatarHitMat3).normalize();
          } else {
            avatarHitNormal.set(-avatarSweepDir.x, 0, -avatarSweepDir.z);
          }

          avatarHitNormal.y = 0;
          if (avatarHitNormal.lengthSq() < 1e-10) {
            avatarHitNormal.set(-avatarSweepDir.x, 0, -avatarSweepDir.z);
          } else {
            avatarHitNormal.normalize();
          }

          const allowed = Math.max(0, bestDist - avatarCollision.radius - avatarCollision.skin);

          if (allowed > 1e-6) {
            pos.x += avatarSweepDir.x * allowed;
            pos.z += avatarSweepDir.z * allowed;
            traveled += allowed;
          } else if (bestDist < 1e-4) {
            pos.x += avatarHitNormal.x * (avatarCollision.skin + 0.01);
            pos.z += avatarHitNormal.z * (avatarCollision.skin + 0.01);
          }

          clampAvatarToPlayableXZ(pos);

          const remainAfter = attemptLen - allowed;
          if (remainAfter <= 1e-6) {
            resolvedThisStep = true;
            break;
          }

          avatarSweepVec.copy(avatarSweepDir).multiplyScalar(remainAfter);
          const intoN = avatarSweepVec.dot(avatarHitNormal);
          avatarSweepVec.addScaledVector(avatarHitNormal, -intoN);

          if (avatarSweepVec.lengthSq() <= 1e-10) {
            resolvedThisStep = true;
            break;
          }

          avatarAttemptVec.copy(avatarSweepVec);
        }

        if (!resolvedThisStep) break;

        remainingLen = Math.max(0, remainingLen - traveled);
        avatarSweepVec.set(moveX, 0, moveZ);
        if (remainingLen <= 1e-6) break;
      }

      return traveled;
    }



/**
     * Returns true when stepping onto the surface at (x,z) would require rising
     * more than params.avatarMaxStepUp above prevGroundY.
     */
    function isAvatarStepUpBlocked(prevGroundY, x, z) {
      const maxStepUp = Number.isFinite(params.avatarMaxStepUp) ? params.avatarMaxStepUp : 0.0;
      if (!Number.isFinite(maxStepUp) || maxStepUp < 0) return false;
      if (!Number.isFinite(prevGroundY)) return false;

      const nextY = getWorldSurfaceY(x, z);
      if (!Number.isFinite(nextY)) return false;

      return (nextY - prevGroundY) > (maxStepUp + 1e-4);
    }



/* Updates avatar horizontal movement + yaw + gait switching from keyboard/left joystick inputs. */
    function updateAvatarFromInputs(dt) {
      if (!avatar || !avatarState.enabled) return;

      const meta = (equipmentState.enabled && equipmentState.item && equipmentState.item.meta) ? equipmentState.item.meta : null;
      const action = meta && typeof meta.action === "string" ? meta.action.trim().toLowerCase() : "";
      const type = meta && typeof meta.type === "string" ? meta.type.trim().toLowerCase() : "";
      const isJetpack = (action === "jetpack") || (type === "jetpack");

      let forwardAmount = 0;
      let strafeAmount = 0;
      let inputMag = 0;
      let wantsRun = false;

      const joyForward = -joystickState.valueY;
      const joyStrafe = joystickState.valueX;
      const joyMag = Math.min(1, Math.sqrt(joyForward * joyForward + joyStrafe * joyStrafe));

      if (joystickState.active && joyMag > 0) {
        forwardAmount = joyForward;
        strafeAmount = joyStrafe;
        inputMag = joyMag;
        wantsRun = ((!!avatarKeys.run) || (!!joystickState.run)) && joyMag > 0;
      } else {
        forwardAmount = avatarState.moveZ;
        strafeAmount = avatarState.moveX;
        inputMag = Math.min(1, Math.sqrt(forwardAmount * forwardAmount + strafeAmount * strafeAmount));
        wantsRun = !!avatarKeys.run && inputMag > 0;
      }

      if (inputMag <= 0) {
        const speedNow = avatarVelocity.length();
        if (speedNow > 1e-8) {
          const decel = avatarMotionConfig.maxDecel;
          const maxStep = decel * dt;

          if (speedNow <= maxStep) {
            avatarVelocity.set(0, 0, 0);
          } else {
            const s = (speedNow - maxStep) / speedNow;
            avatarVelocity.multiplyScalar(s);
          }
        } else {
          avatarVelocity.set(0, 0, 0);
        }
      } else {
        camera.getWorldDirection(camForward);
        camForward.y = 0;

        if (camForward.lengthSq() < 1e-8) camForward.set(0, 0, 1);
        camForward.normalize();

        camRight.crossVectors(camForward, worldUp).normalize();

        avatarMoveDir
        .copy(camForward)
        .multiplyScalar(forwardAmount)
        .addScaledVector(camRight, strafeAmount);

        if (avatarMoveDir.lengthSq() > 1e-8) {
          avatarMoveDir.normalize();
        } else {
          avatarMoveDir.set(0, 0, 0);
        }

        const jetpackFlying = isJetpack && !!avatarJumpState.active && !avatarJumpState.grounded;

        let baseSpeed = wantsRun ? AVATAR_RUN_SPEED : AVATAR_WALK_SPEED;
        if (jetpackFlying) baseSpeed = AVATAR_RUN_SPEED * 2.0;

        const speedTarget = baseSpeed * inputMag;
        const desiredVel = avatarTmpVec.copy(avatarMoveDir).multiplyScalar(speedTarget);

        const speedNow = avatarVelocity.length();
        avatarToTarget.subVectors(desiredVel, avatarVelocity);
        const distToTarget = avatarToTarget.length();

        if (distToTarget > 1e-6) {
          const accelerating = speedTarget > speedNow;
          const accel = accelerating ? avatarMotionConfig.maxAccel : avatarMotionConfig.maxDecel;
          const maxStep = accel * dt;

          if (distToTarget <= maxStep) {
            avatarVelocity.copy(desiredVel);
          } else {
            avatarToTarget.setLength(maxStep);
            avatarVelocity.add(avatarToTarget);
          }
        }
      }

      if (avatarVelocity.length() < avatarMotionConfig.stopEps) {
        avatarVelocity.set(0, 0, 0);
      }

      const prevX = avatar.position.x;
      const prevZ = avatar.position.z;

      const maxStepUp = Number.isFinite(params.avatarMaxStepUp) ? params.avatarMaxStepUp : 0.0;
      const stepCheckActive =
      (maxStepUp > 0.0) &&
      !isJetpack &&
      !avatarJumpState.active &&
      !!avatarJumpState.grounded;

      let prevGroundY = avatarJumpState.groundY;
      if (stepCheckActive) {
        const gy = getWorldSurfaceY(prevX, prevZ);
        if (Number.isFinite(gy)) prevGroundY = gy;
      }

      if (avatarVelocity.lengthSq() > 0) {
        avatarTmpMove.copy(avatarVelocity).multiplyScalar(dt);
        avatarTmpMove.y = 0;

        if (stepCheckActive && avatarTmpMove.lengthSq() > 1e-14) {
          avatarTmpVec.set(prevX, avatar.position.y, prevZ);
          moveAvatarXZWithCollisions(avatarTmpVec, avatarTmpMove.x, avatarTmpMove.z);
          resolveAvatarXZCollisions(avatarTmpVec);

          if (isAvatarStepUpBlocked(prevGroundY, avatarTmpVec.x, avatarTmpVec.z)) {
            let moved = false;

            if (Math.abs(avatarTmpMove.x) > 1e-12) {
              avatarTmpVec.set(prevX, avatar.position.y, prevZ);
              moveAvatarXZWithCollisions(avatarTmpVec, avatarTmpMove.x, 0);
              resolveAvatarXZCollisions(avatarTmpVec);

              if (!isAvatarStepUpBlocked(prevGroundY, avatarTmpVec.x, avatarTmpVec.z)) {
                avatar.position.x = avatarTmpVec.x;
                avatar.position.z = avatarTmpVec.z;
                moved = true;
              }
            }

            if (!moved && Math.abs(avatarTmpMove.z) > 1e-12) {
              avatarTmpVec.set(prevX, avatar.position.y, prevZ);
              moveAvatarXZWithCollisions(avatarTmpVec, 0, avatarTmpMove.z);
              resolveAvatarXZCollisions(avatarTmpVec);

              if (!isAvatarStepUpBlocked(prevGroundY, avatarTmpVec.x, avatarTmpVec.z)) {
                avatar.position.x = avatarTmpVec.x;
                avatar.position.z = avatarTmpVec.z;
                moved = true;
              }
            }

            if (!moved) {
              avatar.position.x = prevX;
              avatar.position.z = prevZ;
              resolveAvatarXZCollisions(avatar.position);
            }
          } else {
            avatar.position.x = avatarTmpVec.x;
            avatar.position.z = avatarTmpVec.z;
          }
        } else {
          avatarTmpVec.set(prevX, avatar.position.y, prevZ);
          moveAvatarXZWithCollisions(avatarTmpVec, avatarTmpMove.x, avatarTmpMove.z);
          resolveAvatarXZCollisions(avatarTmpVec);

          const airborne = !!avatarJumpState.active && !avatarJumpState.grounded;
          if (airborne) {
            const airEps = 0.06;
            const nextY = getWorldSurfaceY(avatarTmpVec.x, avatarTmpVec.z);

            if (Number.isFinite(nextY) && nextY > (avatar.position.y + airEps)) {
              let moved = false;

              if (Math.abs(avatarTmpMove.x) > 1e-12) {
                avatarTmpVec.set(prevX, avatar.position.y, prevZ);
                moveAvatarXZWithCollisions(avatarTmpVec, avatarTmpMove.x, 0);
                resolveAvatarXZCollisions(avatarTmpVec);

                const nxY = getWorldSurfaceY(avatarTmpVec.x, avatarTmpVec.z);
                if (!(Number.isFinite(nxY) && nxY > (avatar.position.y + airEps))) {
                  avatar.position.x = avatarTmpVec.x;
                  avatar.position.z = avatarTmpVec.z;
                  moved = true;
                }
              }

              if (!moved && Math.abs(avatarTmpMove.z) > 1e-12) {
                avatarTmpVec.set(prevX, avatar.position.y, prevZ);
                moveAvatarXZWithCollisions(avatarTmpVec, 0, avatarTmpMove.z);
                resolveAvatarXZCollisions(avatarTmpVec);

                const nzY = getWorldSurfaceY(avatarTmpVec.x, avatarTmpVec.z);
                if (!(Number.isFinite(nzY) && nzY > (avatar.position.y + airEps))) {
                  avatar.position.x = avatarTmpVec.x;
                  avatar.position.z = avatarTmpVec.z;
                  moved = true;
                }
              }

              if (!moved) {
                avatar.position.x = prevX;
                avatar.position.z = prevZ;
                resolveAvatarXZCollisions(avatar.position);
              }
            } else {
              avatar.position.x = avatarTmpVec.x;
              avatar.position.z = avatarTmpVec.z;
            }
          } else {
            avatar.position.x = avatarTmpVec.x;
            avatar.position.z = avatarTmpVec.z;
          }
        }

        if (avatarState.viewMode === "third") {
          const dx = avatar.position.x - prevX;
          const dz = avatar.position.z - prevZ;
          if (dx * dx + dz * dz > 1e-10) {
            const targetYaw = Math.atan2(dx, dz);
            avatar.rotation.y = lerpYaw(avatar.rotation.y, targetYaw, avatarMotionConfig.yawLerpThird);
          }
        }
      } else {
        resolveAvatarXZCollisions(avatar.position);
      }

      const dx = avatar.position.x - prevX;
      const dz = avatar.position.z - prevZ;
      const actualSpeed = dt > 0 ? (Math.sqrt(dx * dx + dz * dz) / dt) : 0;

      const airborneNow = !!avatarJumpState.active && !avatarJumpState.grounded;
      if (airborneNow) {
        if (isJetpack) {
          switchAvatarAction("idle");
        } else {
          if (avatarMixer && avatarActions.jump) {
            if (avatarCurrentActionName !== "jump") playAvatarJumpAction();
          }
        }
        return;
      }

      let targetAction = "idle";
      if (actualSpeed < avatarMotionConfig.stopEps) {
        targetAction = "idle";
      } else {
        const runThreshold = (AVATAR_WALK_SPEED + AVATAR_RUN_SPEED) * 0.5;
        targetAction = actualSpeed >= runThreshold ? "run" : "walk";
      }

      switchAvatarAction(targetAction);
      updateAvatarClipSpeed(actualSpeed);
      stampSnowFromAvatar(actualSpeed);
    }







    /**
     * Updates camera rig to follow the avatar.
     * third-person: move camera+target by avatar movement delta (Y is smoothed to prevent snapping).
     * first-person: camera pinned to head (head Y is smoothed to avoid abrupt vertical jumps).
     */
    function updateAvatarCamera(dt) {
      if (!avatarState.enabled || !avatar || !controls) return;

      avatar.getWorldPosition(avatarWorldPos);

      if (avatarState.viewMode === "third") {
        if (avatar) avatar.visible = true;

        if (!avatarHasLastPos) {
          placeCameraBehindAvatar();
          return;
        }

        const smoothY = smoothFollowY(avatarCameraYFollowState, avatarWorldPos.y, dt);

        avatarTmpVec.set(
          avatarWorldPos.x - avatarLastWorldPos.x,
          smoothY - avatarLastWorldPos.y,
          avatarWorldPos.z - avatarLastWorldPos.z
          );

        if (avatarTmpVec.lengthSq() > 0) {
          controls.target.add(avatarTmpVec);
          camera.position.add(avatarTmpVec);
        }

        avatarLastWorldPos.set(avatarWorldPos.x, smoothY, avatarWorldPos.z);
        return;
      }

      if (avatar) avatar.visible = false;

      avatarHeadPos.copy(avatarWorldPos);
      avatarHeadPos.y += avatarViewConfig.firstPersonHeight;

      avatarHeadPos.y = smoothFollowY(avatarCameraYFollowFirstState, avatarHeadPos.y, dt);

      camera.getWorldDirection(avatarTmpDir);
      avatarTmpDir.normalize();

      const desiredYaw = Math.atan2(avatarTmpDir.x, avatarTmpDir.z);
      avatar.rotation.y = lerpYaw(avatar.rotation.y, desiredYaw, avatarMotionConfig.yawLerpFirst);

      camera.position.copy(avatarHeadPos);
      controls.target.copy(avatarHeadPos).add(avatarTmpDir);

      avatarHasLastPos = false;
    }



    const avatarChaseCamState = {
      enabled: false,

      // OrbitControls target height above the avatar origin.
      lookHeight: 1.6,

      // How quickly the target follows the avatar translation (lower = more inertia).
      targetStiffness: 6.0,

      // How quickly the camera azimuth eases behind the avatar (lower = more inertia).
      yawStiffness: 0.95,

      // Clamp on per-frame yaw blending to keep motion smooth and non-snappy.
      maxYawAlpha: 0.035,

      // Internal state
      has: false,
      userOverride: false,
      pendingRecenter: false,
      userInteracting: false,
      hooksInstalled: false
    };

    const avatarChasePrevControlsState = {
      has: false,
      enableRotate: true,
      enablePan: true,
      enableZoom: true,
      enableDamping: true
    };

    const avatarChaseWorldPos = new THREE.Vector3();
    const avatarChaseHeadPos = new THREE.Vector3();
    const avatarChaseForward = new THREE.Vector3();

    const avatarChaseOldTarget = new THREE.Vector3();
    const avatarChaseNewTarget = new THREE.Vector3();
    const avatarChaseDelta = new THREE.Vector3();

    const avatarChaseOffset = new THREE.Vector3();
    const avatarChaseSpherical = new THREE.Spherical();

    /**
     * Marks a user-driven OrbitControls interaction while avatar chase mode is active.
     * Manual orbit sets an override that blocks auto-behind until movement input resumes.
     */
    function onAvatarChaseOrbitStart() {
      if (!avatarChaseCamState.enabled) return;
      avatarChaseCamState.userInteracting = true;
      avatarChaseCamState.userOverride = true;
      avatarChaseCamState.pendingRecenter = false;
      lastInteractionTime = performance.now() * 0.001;
    }

    /**
     * Marks the end of a user-driven OrbitControls interaction while avatar chase mode is active.
     */
    function onAvatarChaseOrbitEnd() {
      if (!avatarChaseCamState.enabled) return;
      avatarChaseCamState.userInteracting = false;
      lastInteractionTime = performance.now() * 0.001;
    }

    /**
     * Installs OrbitControls hooks used by avatar chase mode exactly once.
     */
    function ensureAvatarChaseOrbitHooks() {
      if (avatarChaseCamState.hooksInstalled || !controls) return;
      controls.addEventListener("start", onAvatarChaseOrbitStart);
      controls.addEventListener("end", onAvatarChaseOrbitEnd);
      avatarChaseCamState.hooksInstalled = true;
    }

    /**
     * Enables/disables avatar chase camera mode while keeping OrbitControls usable:
     * rotate/zoom/damping remain enabled; pan is disabled so the target stays locked to the avatar.
     * Resets chase Y smoothing state so enabling does not produce a vertical snap.
     */
    function setAvatarChaseCameraEnabled(enabled) {
      const next = !!enabled;
      if (avatarChaseCamState.enabled === next) return;

      avatarChaseCamState.enabled = next;
      avatarChaseCamState.has = false;
      avatarChaseCamState.userOverride = false;
      avatarChaseCamState.pendingRecenter = false;
      avatarChaseCamState.userInteracting = false;

      avatarChaseTargetYFollowState.has = false;

      if (!controls) return;

      if (next) {
        ensureAvatarChaseOrbitHooks();

        avatarChaseCamState.lookHeight = avatarViewConfig.thirdPersonHeight;

        if (!avatarChasePrevControlsState.has) {
          avatarChasePrevControlsState.has = true;
          avatarChasePrevControlsState.enableRotate = !!controls.enableRotate;
          avatarChasePrevControlsState.enablePan = !!controls.enablePan;
          avatarChasePrevControlsState.enableZoom = !!controls.enableZoom;
          avatarChasePrevControlsState.enableDamping = !!controls.enableDamping;
        }

        controls.enableRotate = true;
        controls.enableZoom = true;
        controls.enableDamping = true;
        controls.enablePan = false;
        controls.autoRotate = false;

        avatarHasLastPos = false;
      } else {
        controls.enableRotate = avatarChasePrevControlsState.has ? avatarChasePrevControlsState.enableRotate : true;
        controls.enablePan = avatarChasePrevControlsState.has ? avatarChasePrevControlsState.enablePan : true;
        controls.enableZoom = avatarChasePrevControlsState.has ? avatarChasePrevControlsState.enableZoom : true;
        controls.enableDamping = avatarChasePrevControlsState.has ? avatarChasePrevControlsState.enableDamping : true;
        controls.update();
      }
    }



    /**
     * Updates the avatar chase camera:
     * - Smoothly moves OrbitControls target to the avatar head while translating the camera by the same delta
     *   to preserve orbit distance and prevent drift.
     * - Auto-behind yaw easing runs while the avatar is moving, unless the user has manually orbited.
     * - Manual orbit blocks auto-behind until movement input resumes.
     * - Target Y is additionally smoothed to prevent vertical snapping when ground height changes abruptly.
     */
    function updateAvatarChaseCamera(dt) {
      if (!avatarChaseCamState.enabled || !controls) return;
      if (!avatarState.enabled || !avatar) return;
      if (vehicleDriveState.enabled) return;
      if (avatarState.viewMode !== "third") return;

      avatar.getWorldPosition(avatarChaseWorldPos);

      avatarChaseHeadPos.copy(avatarChaseWorldPos);

      const desiredHeadY = avatarChaseWorldPos.y + avatarChaseCamState.lookHeight;
      avatarChaseHeadPos.y = smoothFollowY(avatarChaseTargetYFollowState, desiredHeadY, dt);

      const targetAlpha =
      1 - Math.pow(0.001, avatarChaseCamState.targetStiffness * Math.max(0.0, dt));

      if (!avatarChaseCamState.has) {
        avatarChaseOldTarget.copy(controls.target);
        controls.target.copy(avatarChaseHeadPos);

        avatarChaseDelta.subVectors(controls.target, avatarChaseOldTarget);
        camera.position.add(avatarChaseDelta);

        avatarChaseCamState.has = true;
        controls.autoRotate = false;
        controls.update();
        return;
      }

      avatarChaseOldTarget.copy(controls.target);
      avatarChaseNewTarget.copy(controls.target).lerp(avatarChaseHeadPos, targetAlpha);

      avatarChaseDelta.subVectors(avatarChaseNewTarget, avatarChaseOldTarget);
      controls.target.copy(avatarChaseNewTarget);
      camera.position.add(avatarChaseDelta);

      const moveKeyActive =
      !!(avatarKeys.forward || avatarKeys.back || avatarKeys.left || avatarKeys.right);

      const moveJoyActive =
      !!(joystickState.active && (Math.abs(joystickState.valueX) > 0.18 || Math.abs(joystickState.valueY) > 0.18));

      const moveInputActive = moveKeyActive || moveJoyActive;

      const stopEpsSq = avatarMotionConfig.stopEps * avatarMotionConfig.stopEps;
      const movingActive = avatarVelocity.lengthSq() > stopEpsSq;

      if (avatarChaseCamState.userOverride) {
        if (moveInputActive) avatarChaseCamState.pendingRecenter = true;

        if (avatarChaseCamState.pendingRecenter && !avatarChaseCamState.userInteracting) {
          avatarChaseCamState.userOverride = false;
          avatarChaseCamState.pendingRecenter = false;
        }
      } else {
        avatarChaseCamState.pendingRecenter = false;
      }

      const allowAutoBehind =
      !avatarChaseCamState.userOverride &&
      !avatarChaseCamState.userInteracting &&
      movingActive;

      if (allowAutoBehind) {
        avatarChaseForward.set(0, 0, 1).applyQuaternion(avatar.quaternion);
        avatarChaseForward.y = 0;

        if (avatarChaseForward.lengthSq() < 1e-8) avatarChaseForward.set(0, 0, 1);
        avatarChaseForward.normalize();

        const desiredTheta = Math.atan2(-avatarChaseForward.x, -avatarChaseForward.z);

        avatarChaseOffset.copy(camera.position).sub(controls.target);

        if (avatarChaseOffset.lengthSq() > 1e-10) {
          avatarChaseSpherical.setFromVector3(avatarChaseOffset);

          let yawAlpha =
          1 - Math.pow(0.001, avatarChaseCamState.yawStiffness * Math.max(0.0, dt));
          yawAlpha = Math.min(avatarChaseCamState.maxYawAlpha, Math.max(0.0, yawAlpha));

          avatarChaseSpherical.theta = lerpYaw(avatarChaseSpherical.theta, desiredTheta, yawAlpha);

          if (Number.isFinite(controls.minPolarAngle)) {
            avatarChaseSpherical.phi = Math.max(avatarChaseSpherical.phi, controls.minPolarAngle);
          }
          if (Number.isFinite(controls.maxPolarAngle)) {
            avatarChaseSpherical.phi = Math.min(avatarChaseSpherical.phi, controls.maxPolarAngle);
          }
          if (Number.isFinite(controls.minDistance)) {
            avatarChaseSpherical.radius = Math.max(avatarChaseSpherical.radius, controls.minDistance);
          }
          if (Number.isFinite(controls.maxDistance)) {
            avatarChaseSpherical.radius = Math.min(avatarChaseSpherical.radius, controls.maxDistance);
          }

          avatarChaseOffset.setFromSpherical(avatarChaseSpherical);
          camera.position.copy(controls.target).add(avatarChaseOffset);
        }
      }

      controls.autoRotate = false;
      controls.update();
    }



    



    function tickAvatar(dt) {
      const worldId = (typeof worldUiState !== "undefined" && worldUiState && typeof worldUiState.id === "string")
      ? worldUiState.id
      : "";

      const ensureWorldBucket = () => {
        if (!playerProfile || !playerProfile.stats) return null;
        if (!playerProfile.stats.worlds || typeof playerProfile.stats.worlds !== "object") playerProfile.stats.worlds = {};
        if (!worldId) return null;

        let b = playerProfile.stats.worlds[worldId];
        if (!b || typeof b !== "object") {
          b = {
            v: 1,
            steps: 0,
            distWalkM: 0,
            distVehicleM: 0,
            actions: {
              worldLoads: 0,
              saves: 0,
              vehicleEnters: 0,
              vehicleExits: 0
            }
          };
          playerProfile.stats.worlds[worldId] = b;
        }
        if (!b.actions || typeof b.actions !== "object") {
          b.actions = { worldLoads: 0, saves: 0, vehicleEnters: 0, vehicleExits: 0 };
        }
        return b;
      };

      const worldBucket = ensureWorldBucket();

  // Snapshot positions BEFORE movement (for stats)
      const prevAx = avatar ? avatar.position.x : 0;
      const prevAy = avatar ? avatar.position.y : 0;
      const prevAz = avatar ? avatar.position.z : 0;

      const vWrapBefore = (vehicleDriveState && vehicleDriveState.enabled) ? vehicleDriveState.vehicle : null;
      const vObjBefore = (vWrapBefore && vWrapBefore.object) ? vWrapBefore.object : null;

      const prevVx = vObjBefore ? vObjBefore.position.x : 0;
      const prevVy = vObjBefore ? vObjBefore.position.y : 0;
      const prevVz = vObjBefore ? vObjBefore.position.z : 0;

      if (avatarState.enabled) {
        if (vehicleDriveState.enabled) {
          tickVehicle(dt);
        } else {
          updateAvatarFromInputs(dt);
          updateAvatarJump(dt);
          tickVehicleProximity();
        }
      } else {
        if (vehicleDriveState.enabled) {
          exitVehicle();
        } else {
          if (vehiclePromptState.open) setVehiclePrompt(false, null);
          updateVehicleOutlineFor(null);
        }

        avatarJumpState.active = false;
        avatarJumpState.grounded = true;
        avatarJumpState.vy = 0.0;
        if (avatar) avatarJumpState.groundY = avatar.position.y;
      }

  // Snapshot positions AFTER movement (for stats)
      const vWrapAfter = (vehicleDriveState && vehicleDriveState.enabled) ? vehicleDriveState.vehicle : null;
      const vObjAfter = (vWrapAfter && vWrapAfter.object) ? vWrapAfter.object : null;

      if (playerProfile && playerProfile.stats) {
    // Vehicle distance (only when actually driving and we have a vehicle object)
        if (vObjAfter) {
          const vx = vObjAfter.position.x;
          const vy = vObjAfter.position.y;
          const vz = vObjAfter.position.z;

          const dVeh = Math.hypot(vx - prevVx, vy - prevVy, vz - prevVz);
          if (Number.isFinite(dVeh) && dVeh > 1e-6) {
            playerProfile.stats.distVehicleM = (playerProfile.stats.distVehicleM || 0) + dVeh;
            if (worldBucket) worldBucket.distVehicleM = (worldBucket.distVehicleM || 0) + dVeh;
          }
        } else {
      // Walk distance + steps (only when not driving)
          const ax = avatar ? avatar.position.x : prevAx;
          const az = avatar ? avatar.position.z : prevAz;

          const dWalk = Math.hypot(ax - prevAx, az - prevAz);
          if (Number.isFinite(dWalk) && dWalk > 1e-6) {
            playerProfile.stats.distWalkM = (playerProfile.stats.distWalkM || 0) + dWalk;
            if (worldBucket) worldBucket.distWalkM = (worldBucket.distWalkM || 0) + dWalk;

            const stepLen = Number.isFinite(params.avatarStepLengthM) ? Math.max(0.2, params.avatarStepLengthM) : 0.78;
            playerProfile.stats.__stepCarryM = (playerProfile.stats.__stepCarryM || 0) + dWalk;

            const newSteps = Math.floor(playerProfile.stats.__stepCarryM / stepLen);
            if (newSteps > 0) {
              playerProfile.stats.steps = (playerProfile.stats.steps || 0) + newSteps;
              playerProfile.stats.__stepCarryM -= newSteps * stepLen;

              if (worldBucket) worldBucket.steps = (worldBucket.steps || 0) + newSteps;

          // Footsteps (sync by the same step counter; does not affect animation)
              const onFoot =
              avatarState.enabled &&
              avatar &&
              avatarJumpState &&
              avatarJumpState.grounded &&
              !vehicleDriveState.enabled;

              if (onFoot) {
            // Cap per-frame to avoid "machine gun" if dt spikes.
                const burst = Math.min(4, newSteps);

                const vx2 = (avatar.position.x - prevAx) / Math.max(1e-6, dt);
                const vz2 = (avatar.position.z - prevAz) / Math.max(1e-6, dt);
                const speed = Math.hypot(vx2, vz2);

                for (let i = 0; i < burst; i++) {
                  const scale = clamp(0.35 + speed * 0.05, 0.22, 0.95);
                  playFX("steps2", scale);
                }
              }
            }
          }
        }

    // Persist only when meaningful motion occurred
        const moved =
        (vObjAfter && Math.hypot(vObjAfter.position.x - prevVx, vObjAfter.position.z - prevVz) > 0.01) ||
        (!vObjAfter && avatar && Math.hypot(avatar.position.x - prevAx, avatar.position.z - prevAz) > 0.01);

        if (moved) savePlayerProfile(playerProfile);
      }

  // Keep original per-frame helpers + animation mixer update
      if (typeof window.__avatarLevelHelpersTick === "function") {
        window.__avatarLevelHelpersTick();
      }

      if (avatarMixer) {
        avatarMixer.update(dt);
      }
    }




/**
 * Wires UI controls (avatar, edit world, transform buttons, vehicle prompt, keyboard help, joystick).
 * Keeps all handlers in one place and ensures mobile joystick state is correctly initialized.
 */

    function setupAvatarUI() {

      const avatarToggleBtn = document.getElementById("avatarToggle");
      const avatarViewToggleBtn = document.getElementById("avatarViewToggle");
      const worldEditToggleBtn = document.getElementById("worldEditToggle");
      const worldsBtn = document.getElementById("worldsBtn");
      const saveWorldBtn = document.getElementById("saveWorldBtn");
      const inventoryBtn = document.getElementById("inventoryBtn");
      const playerProfileBtn = document.getElementById("playerProfileBtn");
      const miniMapBtn = document.getElementById("miniMap");
      const keyboardHelpBtn = document.getElementById("keyboardHelpBtn");
      const worldEditUndoBtn = document.getElementById("worldEditUndoBtn");
      const worldEditRedoBtn = document.getElementById("worldEditRedoBtn");
      const worldEditTransformModeBtn = document.getElementById("worldEditTransformMode");
      const worldEditAddBtn = document.getElementById("worldEditAddBtn");
      const worldEditDuplicateBtn = document.getElementById("worldEditDuplicateBtn");
      const worldEditDeleteBtn = document.getElementById("worldEditDeleteBtn");
      const joystickEl = document.getElementById("joystick");
      const joystickRightEl = document.getElementById("joystickRight");
      const vehicleEnterBtn = document.getElementById("vehicleEnterBtn");
      const vehicleExitBtn = document.getElementById("vehicleExitBtn");
      const vehicleCloseBtn = document.getElementById("vehicleCloseBtn");
      const vehicleQuickActionBtn = document.getElementById("vehicleQuickActionBtn");
      const avatarUiModeToggleBtn = document.getElementById("avatarUiModeToggle");

      worldNameEl = document.getElementById("worldName");
      setWorldNameLabel(worldUiState.title);

      keyboardHelpEl = document.getElementById("keyboardHelp");
      keyboardHelpCloseBtn = document.getElementById("keyboardHelpClose");

      ensurePlayerProfileOverlayWired();
      if (typeof ensureInventoryPickerOverlayWired === "function") ensureInventoryPickerOverlayWired();
      if (typeof ensureWorldObjectPickerOverlayWired === "function") ensureWorldObjectPickerOverlayWired();

      initAvatarUiLayout();

      if (avatarUiModeToggleBtn) {
        avatarUiModeToggleBtn.addEventListener("click", () => {
          const ui = document.querySelector(".avatar-ui");
          const current = ui && ui.dataset ? String(ui.dataset.layout || "text") : "text";
          const next = (current === "text") ? "icons" : (current === "icons") ? "both" : "text";
          setAvatarUiLayout(next, true);
          updateAvatarButtons();
        });
      }

      if (avatarToggleBtn) {
        avatarToggleBtn.addEventListener("click", () => {
          if (avatarState.enabled) {
            disableAvatarControl();
          } else {
            enableAvatarControl(avatarState.viewMode);
          }

          updateAvatarButtons();
          if (typeof updateVehicleQuickActionButton === "function") updateVehicleQuickActionButton();
        });
      }

      if (avatarViewToggleBtn) {
        avatarViewToggleBtn.addEventListener("click", () => {
          if (!avatarState.enabled) return;
          if (avatarState.viewMode === "third") avatarState.viewMode = "first";
          else avatarState.viewMode = "third";
          updateAvatarButtons();
        });
      }

      if (worldEditToggleBtn) {
        worldEditToggleBtn.addEventListener("click", () => {
          setWorldEditEnabled(!worldEditState.enabled);
        });
      }

      if (worldsBtn) {
        worldsBtn.addEventListener("click", (event) => {
          event.preventDefault();

          if (typeof worldPickerState === "object" && worldPickerState && worldPickerState.open) {
            if (typeof setWorldPickerOpen === "function") setWorldPickerOpen(false);
            return;
          }

          if (typeof openWorldPickerOverlay === "function") openWorldPickerOverlay();
        });
      }

      if (saveWorldBtn) {
        saveWorldBtn.addEventListener("click", () => {
          if (typeof saveActiveWorld === "function") saveActiveWorld();
        });
      }

      if (inventoryBtn) {
        inventoryBtn.addEventListener("click", () => {
          if (typeof setInventoryPickerOpen === "function") {
            const open = !(typeof inventoryPickerState !== "undefined" && inventoryPickerState && inventoryPickerState.open);
            setInventoryPickerOpen(open);
          }
        });
      }

      if (playerProfileBtn) {
        playerProfileBtn.addEventListener("click", () => {
          if (typeof setPlayerProfileOpen === "function") {
            const open = !(typeof playerProfileState !== "undefined" && playerProfileState && playerProfileState.open);
            setPlayerProfileOpen(open);
          } else {
            setPlayerProfileOpen(true);
          }
        });
      }

      if (miniMapBtn) {
        miniMapBtn.addEventListener("click", () => {
          if (typeof setMinimapMode === "function") {
            if (minimapState.mode === 0) setMinimapMode(1);
            else if (minimapState.mode === 1) setMinimapMode(2);
            else setMinimapMode(0);
          }
        });
      }

      if (keyboardHelpBtn) {
        keyboardHelpBtn.addEventListener("click", () => {
          setKeyboardHelpOpen(true);
        });
      }

      if (keyboardHelpCloseBtn) {
        keyboardHelpCloseBtn.addEventListener("click", () => {
          setKeyboardHelpOpen(false);
        });
      }

      if (worldEditUndoBtn) {
        worldEditUndoBtn.addEventListener("click", () => {
          if (typeof worldEditUndo === "function") worldEditUndo();
        });
      }

      if (worldEditRedoBtn) {
        worldEditRedoBtn.addEventListener("click", () => {
          if (typeof worldEditRedo === "function") worldEditRedo();
        });
      }

      if (worldEditTransformModeBtn) {
        worldEditTransformModeBtn.addEventListener("click", () => {
          if (typeof cycleWorldEditTransformMode === "function") cycleWorldEditTransformMode();
        });
      }

      if (worldEditAddBtn) {
        worldEditAddBtn.addEventListener("click", () => {
          if (!worldEditState.enabled) return;
          if (typeof setWorldObjectPickerOpen === "function") setWorldObjectPickerOpen(true);
        });
      }

      if (worldEditDuplicateBtn) {
        worldEditDuplicateBtn.addEventListener("click", () => {
          duplicateSelectedWorldModel();
        });
      }

      if (worldEditDeleteBtn) {
        worldEditDeleteBtn.addEventListener("click", () => {
          deleteSelectedWorldModel();
        });
      }

      if (vehicleEnterBtn) {
        vehicleEnterBtn.addEventListener("click", () => {

          const near = vehiclePromptState.nearby;
          if (!near) return;

          if (near.kind === "pickup") {
            pickupTake(near);
            return;
          }

          if (near.kind === "equipment") {
            if (!equipmentState.enabled) equipItem(near);
            return;
          }

          if (!vehicleDriveState.enabled) enterVehicle(near);

        });
      }

      if (vehicleExitBtn) vehicleExitBtn.addEventListener("click", () => { exitVehicle(); });
      
      if (vehicleCloseBtn) {
        vehicleCloseBtn.addEventListener("click", (e) => {
          e.preventDefault();

          /* Dismisses the current prompt target until the avatar leaves proximity and re-enters. */
          const near = vehiclePromptState.nearby;

          const id = near ? String(near.id || "") : "";
          const kind = near ? String(near.kind || "vehicle") : "";

          vehiclePromptState.dismissedId = id;
          vehiclePromptState.dismissedKind = kind;

          setVehiclePrompt(false, null);
          updateVehicleOutlineFor(null);

          if (typeof updateVehicleQuickActionButton === "function") updateVehicleQuickActionButton();
        });
      }
      

      if (vehicleQuickActionBtn) {
        vehicleQuickActionBtn.addEventListener("click", () => {
          if (equipmentState.enabled && equipmentState.item) {
            unequipItem();
          } else if (vehicleDriveState.enabled && vehicleDriveState.vehicle) {
            exitVehicle();
          }
          updateVehicleQuickActionButton();
        });
      }

      if (joystickEl && typeof initJoystick === "function") initJoystick(joystickEl);
      if (joystickRightEl && typeof initRightJoystick === "function") initRightJoystick(joystickRightEl);

      updateAvatarButtons();
      if (typeof updateVehicleQuickActionButton === "function") updateVehicleQuickActionButton();
    }









    /* Minimap UI: renders a centered crop in the top-left and a full-world overlay map. */
    const minimapState = {
      miniBtn: null,
      miniCanvas: null,
      miniCtx: null,
      overlay: null,
      overlayCanvas: null,
      overlayCtx: null,
      open: false,
      mode: 0, /* 0=small, 1=medium, 2=overlay */
      viewHalfWorld: 140,
      staticPoints: [],
      groundRects: [],
      lastDrawMs: 0
    };


/* Applies the current minimap mode to DOM state and accessibility labels. */
    function applyMinimapModeToUI() {
      if (!minimapState.miniBtn) return;

      minimapState.miniBtn.classList.toggle("is-medium", minimapState.mode === 1);

      const label =
      (minimapState.mode === 0 && "Map (Small)") ||
      (minimapState.mode === 1 && "Map (Medium)") ||
      "Map (Full)";

      minimapState.miniBtn.setAttribute("aria-label", label);
    }

/* Sets minimap mode: small -> medium -> overlay; updates layout and redraws. */
    function setMinimapMode(mode) {
      const nextMode = (mode === 0 || mode === 1 || mode === 2) ? mode : 0;
      minimapState.mode = nextMode;

      if (nextMode === 2) {
        setMinimapOverlayOpen(true);
      } else {
        setMinimapOverlayOpen(false);
      }

      applyMinimapModeToUI();
      layoutMinimapCanvases();
      drawMinimapFrame(true);
    }

    function setupMinimapUI() {
      minimapState.miniBtn = document.getElementById("miniMap");
      minimapState.miniCanvas = document.getElementById("miniMapCanvas");
      minimapState.overlay = document.getElementById("mapOverlay");
      minimapState.overlayCanvas = document.getElementById("mapOverlayCanvas");
      const closeBtn = document.getElementById("mapOverlayClose");

      if (!minimapState.miniBtn || !minimapState.miniCanvas || !minimapState.overlay || !minimapState.overlayCanvas) return;

      minimapState.miniCtx = minimapState.miniCanvas.getContext("2d", { alpha: true, desynchronized: true });
      minimapState.overlayCtx = minimapState.overlayCanvas.getContext("2d", { alpha: true, desynchronized: true });

      minimapState.miniBtn.addEventListener("click", () => {
        if (minimapState.mode === 0) setMinimapMode(1);
        else if (minimapState.mode === 1) setMinimapMode(2);
        else setMinimapMode(0);
      }, { passive: true });

      if (closeBtn) {
        closeBtn.addEventListener("click", () => setMinimapMode(0), { passive: true });
      }

      minimapState.overlay.addEventListener("click", (e) => {
        if (e.target === minimapState.overlay) setMinimapMode(0);
      }, { passive: true });

      setMinimapMode(0);
      refreshMinimapStaticPoints();
    }

/* Opens/closes the overlay panel only (mode switching is handled by setMinimapMode). */
    function setMinimapOverlayOpen(open) {
      minimapState.open = !!open;
      if (!minimapState.overlay) return;
      minimapState.overlay.classList.toggle("is-open", minimapState.open);
      minimapState.overlay.setAttribute("aria-hidden", minimapState.open ? "false" : "true");
    }





    function layoutMinimapCanvases() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

      const sizeCanvasToEl = (canvas, el) => {
        if (!canvas || !el) return;
        const r = el.getBoundingClientRect();
        const w = Math.max(1, Math.floor(r.width * dpr));
        const h = Math.max(1, Math.floor(r.height * dpr));
        if (canvas.width !== w) canvas.width = w;
        if (canvas.height !== h) canvas.height = h;
      };

      if (minimapState.miniBtn && minimapState.miniCanvas) {
        sizeCanvasToEl(minimapState.miniCanvas, minimapState.miniBtn);
      }

      if (minimapState.open && minimapState.overlayCanvas) {
        const panel = minimapState.overlayCanvas.closest(".map-overlay__panel");
        if (panel) {
          const header = panel.querySelector(".map-overlay__header");
          const pr = panel.getBoundingClientRect();
          const hh = header ? header.getBoundingClientRect().height : 0;
          const w = Math.max(1, Math.floor(pr.width * dpr));
          const h = Math.max(1, Math.floor(Math.max(1, pr.height - hh) * dpr));
          if (minimapState.overlayCanvas.width !== w) minimapState.overlayCanvas.width = w;
          if (minimapState.overlayCanvas.height !== h) minimapState.overlayCanvas.height = h;
        }
      }
    }

    /* Caches static collider positions (rocks/trees/etc.) for minimap rendering. */
    function refreshMinimapStaticPoints() {
      const pts = [];
      for (const obj of colliderObjects) {
        if (!obj || !obj.position) continue;
        const x = obj.position.x;
        const z = obj.position.z;
        if (!Number.isFinite(x) || !Number.isFinite(z)) continue;

        const kind =
        (obj.__isRock && "rock") ||
        (obj.__isForestTree && "tree") ||
        "collider";

        pts.push({ x, z, kind });
      }
      minimapState.staticPoints = pts;

      const rectsByKey = new Map();
      const box = new THREE.Box3();

      if (Array.isArray(worldGroundMeshes) && worldGroundMeshes.length) {
        for (let i = 0; i < worldGroundMeshes.length; i++) {
          const mesh = worldGroundMeshes[i];
          if (!mesh) continue;

          let root = mesh;
          while (root && root.parent && !(root.userData && root.userData.worldEditId)) root = root.parent;

          const key = (root && root.userData && root.userData.worldEditId) ? String(root.userData.worldEditId) : (root ? root.uuid : "");
          if (!key || rectsByKey.has(key)) continue;

          root.updateWorldMatrix(true, true);
          box.setFromObject(root);

          if (!Number.isFinite(box.min.x) || !Number.isFinite(box.max.x) || !Number.isFinite(box.min.z) || !Number.isFinite(box.max.z)) continue;

          rectsByKey.set(key, {
            minX: box.min.x,
            maxX: box.max.x,
            minZ: box.min.z,
            maxZ: box.max.z
          });
        }
      }

      minimapState.groundRects = Array.from(rectsByKey.values());
    }


    function drawMinimapFrame(force) {
      if (!minimapState.miniCtx || !minimapState.miniCanvas) return;

      const now = performance.now();
      if (!force && (now - minimapState.lastDrawMs) < 33) return;
      minimapState.lastDrawMs = now;

      const focus = getMinimapFocus();
      const yaw = getMinimapYaw();

      drawMinimapCentered(
        minimapState.miniCtx,
        minimapState.miniCanvas.width,
        minimapState.miniCanvas.height,
        focus.x,
        focus.z,
        yaw
        );

      if (minimapState.open && minimapState.overlayCtx && minimapState.overlayCanvas) {
        drawMinimapFull(
          minimapState.overlayCtx,
          minimapState.overlayCanvas.width,
          minimapState.overlayCanvas.height,
          focus.x,
          focus.z,
          yaw
          );
      }
    }

    function getMinimapFocus() {
      if (vehicleDriveState && vehicleDriveState.enabled && vehicleDriveState.vehicle && vehicleDriveState.vehicle.object) {
        const p = vehicleDriveState.vehicle.object.position;
        return { x: p.x, z: p.z };
      }
      if (avatar && avatar.position) return { x: avatar.position.x, z: avatar.position.z };
      return { x: 0, z: 0 };
    }

    function getMinimapYaw() {
      if (vehicleDriveState && vehicleDriveState.enabled) return (vehicleDriveState.yaw || 0);
      if (avatar && avatar.rotation) return (avatar.rotation.y || 0);
      return 0;
    }

    function drawMinimapCentered(ctx, w, h, focusX, focusZ, yaw) {
      ctx.clearRect(0, 0, w, h);

      const viewHalf = Math.max(20, minimapState.viewHalfWorld);
      const scale = Math.min(w, h) / (viewHalf * 2.0);

      ctx.save();
      ctx.translate(w * 0.5, h * 0.5);

      drawWorldBoundsDashed(ctx, scale, -focusX, -focusZ);

      if (minimapState.groundRects && minimapState.groundRects.length) {
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.lineWidth = 1;

        const cullX = w * 0.6;
        const cullZ = h * 0.6;

        for (const r of minimapState.groundRects) {
          const x0 = (r.minX - focusX) * scale;
          const x1 = (r.maxX - focusX) * scale;
          const z0 = (r.minZ - focusZ) * scale;
          const z1 = (r.maxZ - focusZ) * scale;

          if (x1 < -cullX || x0 > cullX || z1 < -cullZ || z0 > cullZ) continue;

          ctx.strokeRect(x0, z0, (x1 - x0), (z1 - z0));
        }

        ctx.restore();
      }

      for (const p of minimapState.staticPoints) {
        const x = (p.x - focusX) * scale;
        const z = (p.z - focusZ) * scale;
        if (Math.abs(x) > (w * 0.6) || Math.abs(z) > (h * 0.6)) continue;

        if (p.kind === "rock") ctx.fillStyle = "rgba(220,220,220,0.75)";
        else if (p.kind === "tree") ctx.fillStyle = "rgba(160,220,160,0.65)";
        else ctx.fillStyle = "rgba(200,200,200,0.35)";

        ctx.fillRect(x - 1.0, z - 1.0, 2.0, 2.0);
      }

      const cx = (-focusX) * scale;
      const cz = (-focusZ) * scale;
      drawWorldCenterCross(ctx, cx, cz);

      drawPlayerMarker(ctx, 0, 0, yaw);

      ctx.restore();

      ctx.save();
      ctx.strokeStyle = "rgba(0,255,0,0.10)";
      ctx.lineWidth = 1;
      ctx.strokeRect(0.5, 0.5, w - 1, h - 1);
      ctx.restore();
    }



    function drawWorldCenterCross(ctx, x, z) {
      if (!Number.isFinite(x) || !Number.isFinite(z)) return;

      ctx.save();
      ctx.translate(x, z);
      ctx.strokeStyle = "rgba(0,255,0,0.35)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-6, 0); ctx.lineTo(6, 0);
      ctx.moveTo(0, -6); ctx.lineTo(0, 6);
      ctx.stroke();

      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(-6, 0); ctx.lineTo(6, 0);
      ctx.moveTo(0, -6); ctx.lineTo(0, 6);
      ctx.stroke();
      ctx.restore();
    }

    function drawPlayerMarker(ctx, x, z, yaw) {
      ctx.save();
      ctx.translate(x, z);
      ctx.rotate(Math.PI - (yaw || 0));

      ctx.fillStyle = "rgba(80,200,255,0.95)";
      ctx.strokeStyle = "rgba(0,0,0,0.35)";
      ctx.lineWidth = 2;

      ctx.beginPath();
      ctx.moveTo(0, -7);
      ctx.lineTo(5.5, 6.5);
      ctx.lineTo(-5.5, 6.5);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.restore();
    }


    function drawMinimapFull(ctx, w, h, focusX, focusZ, yaw) {
      ctx.clearRect(0, 0, w, h);

      const half = Math.max(1, WORLD_BOUNDS_XZ);
      const pad = 1.06;
      const scale = Math.min(w, h) / ((half * 2.0) * pad);

      ctx.save();
      ctx.translate(w * 0.5, h * 0.5);

      drawWorldBoundsDashed(ctx, scale, 0, 0);

      if (minimapState.groundRects && minimapState.groundRects.length) {
        ctx.save();
        ctx.strokeStyle = "rgba(255,255,255,0.22)";
        ctx.lineWidth = 1;

        for (const r of minimapState.groundRects) {
          const x0 = r.minX * scale;
          const x1 = r.maxX * scale;
          const z0 = r.minZ * scale;
          const z1 = r.maxZ * scale;
          ctx.strokeRect(x0, z0, (x1 - x0), (z1 - z0));
        }

        ctx.restore();
      }

      for (const p of minimapState.staticPoints) {
        const x = p.x * scale;
        const z = p.z * scale;

        if (p.kind === "rock") ctx.fillStyle = "rgba(220,220,220,0.70)";
        else if (p.kind === "tree") ctx.fillStyle = "rgba(160,220,160,0.60)";
        else ctx.fillStyle = "rgba(200,200,200,0.30)";

        ctx.fillRect(x - 1.0, z - 1.0, 2.0, 2.0);
      }

      drawWorldCenterCross(ctx, 0, 0);

      const px = focusX * scale;
      const pz = focusZ * scale;
      drawPlayerMarker(ctx, px, pz, yaw);

      ctx.restore();
    }



    function drawWorldBoundsDashed(ctx, scale, offsetX, offsetZ) {
      const half = Math.max(1, WORLD_BOUNDS_XZ);

      const x0 = (-half + offsetX) * scale;
      const z0 = (-half + offsetZ) * scale;
      const x1 = ( half + offsetX) * scale;
      const z1 = ( half + offsetZ) * scale;

      ctx.save();
      ctx.strokeStyle = "rgba(255,255,255,0.40)";
      ctx.lineWidth = 1;
      ctx.setLineDash([6, 5]);
      ctx.beginPath();
      ctx.moveTo(x0, z0); ctx.lineTo(x1, z0);
      ctx.lineTo(x1, z1); ctx.lineTo(x0, z1);
      ctx.closePath();
      ctx.stroke();
      ctx.setLineDash([]);
      ctx.restore();
    }




/* Initializes avatar UI layout (icons/text/both) from localStorage with mobile-aware default. */
    function initAvatarUiLayout() {
      const key = "ui:avatarUiLayout";
      let mode = localStorage.getItem(key);

      if (mode !== "icons" && mode !== "text" && mode !== "both") {
        const coarse = (typeof window.matchMedia === "function") && window.matchMedia("(pointer: coarse)").matches;
        const small = (typeof window.matchMedia === "function") && window.matchMedia("(max-width: 720px)").matches;
        mode = (coarse || small) ? "icons" : "text";
      }

      setAvatarUiLayout(mode, false);
    }

/* Sets avatar UI layout and persists selection. */
    function setAvatarUiLayout(mode, persist) {
      const key = "ui:avatarUiLayout";
      const ui = document.querySelector(".avatar-ui");
      if (!ui) return;

      const m = (mode === "icons" || mode === "both") ? mode : "text";
      ui.dataset.layout = m;

      const btn = document.getElementById("avatarUiModeToggle");
      if (btn) {
        const labelEl = btn.querySelector(".avatar-btn__text");
        const txt = (m === "icons") ? "UI: ICONS" : (m === "both") ? "UI: BOTH" : "UI: TEXT";
        if (labelEl) labelEl.textContent = txt;
        btn.setAttribute("aria-label", txt);
        btn.classList.toggle("is-on", m !== "text");
      }

      if (persist) localStorage.setItem(key, m);
    }




/**
 * Refreshes UI button labels/visibility/disabled state based on avatar + world editor state.
 */
    function updateAvatarButtons() {
      const toggle = document.getElementById("avatarToggle");
      const view = document.getElementById("avatarViewToggle");
      const edit = document.getElementById("worldEditToggle");
      const uiMode = document.getElementById("avatarUiModeToggle");

      const undoBtn = document.getElementById("worldEditUndoBtn");
      const redoBtn = document.getElementById("worldEditRedoBtn");
      const modeBtn = document.getElementById("worldEditTransformMode");
      const addBtn = document.getElementById("worldEditAddBtn");
      const dupBtn = document.getElementById("worldEditDuplicateBtn");
      const delBtn = document.getElementById("worldEditDeleteBtn");

      const setBtnText = (btn, text) => {
        if (!btn) return;
        const labelEl = btn.querySelector(".avatar-btn__text");
        if (labelEl) labelEl.textContent = text;
        else btn.textContent = text;
        btn.setAttribute("aria-label", text);
      };

      if (toggle) {
        setBtnText(toggle, avatarState.enabled ? "Avatar: ON" : "Avatar: OFF");
        toggle.classList.toggle("is-on", !!avatarState.enabled);
      }

      if (view) {
        setBtnText(view, avatarState.viewMode === "third" ? "View: Behind" : "View: Eyes");
        view.classList.toggle("is-on", !!(avatarState.enabled && avatarState.viewMode !== "third"));
      }

      if (edit) {
        setBtnText(edit, worldEditState.enabled ? "Edit World: ON" : "Edit World: OFF");
        edit.classList.toggle("is-on", !!worldEditState.enabled);
      }

      if (uiMode) {
        const ui = document.querySelector(".avatar-ui");
        const layout = ui && ui.dataset ? String(ui.dataset.layout || "text") : "text";
        setBtnText(uiMode, layout === "icons" ? "UI: ICONS" : layout === "both" ? "UI: BOTH" : "UI: TEXT");
        uiMode.classList.toggle("is-on", layout !== "text");
      }

      const swapIcon = (btn) => {
        if (!btn) return;
        const img = btn.querySelector(".avatar-btn__icon");
        if (!img) return;
        const src = String(img.getAttribute("src") || "");
        if (!src) return;

        const on = btn.classList.contains("is-on");
        const wantFolder = on ? "/black/" : "/white/";

        if (src.indexOf("/white/") !== -1 || src.indexOf("/black/") !== -1) {
          const next = src.replace("/white/", wantFolder).replace("/black/", wantFolder);
          if (next !== src) img.setAttribute("src", next);
        }
      };

      swapIcon(toggle);
      swapIcon(view);
      swapIcon(edit);
      swapIcon(uiMode);

      const visible = !!worldEditState.enabled;

      const setVisible = (el) => {
        if (!el) return;
        el.style.display = visible ? "flex" : "none";
        el.setAttribute("aria-hidden", visible ? "false" : "true");
      };

      setVisible(undoBtn);
      setVisible(redoBtn);
      setVisible(modeBtn);
      setVisible(addBtn);
      setVisible(dupBtn);
      setVisible(delBtn);

      if (!visible) return;

      const hasSelection = !!worldEditState.selected;
      const canUndo = !!(worldEditHistory && worldEditHistory.undo && worldEditHistory.undo.length);
      const canRedo = !!(worldEditHistory && worldEditHistory.redo && worldEditHistory.redo.length);
      const hasTransform = !!transformControls;

      if (undoBtn) undoBtn.disabled = !canUndo;
      if (redoBtn) redoBtn.disabled = !canRedo;
      if (dupBtn) dupBtn.disabled = !hasSelection;
      if (delBtn) delBtn.disabled = !hasSelection;

      if (modeBtn) {
        modeBtn.disabled = !hasTransform;

        const mode = hasTransform ? (transformControls.mode || "translate") : "translate";
        modeBtn.textContent = mode === "translate" ? "P" : mode === "rotate" ? "R" : "S";
      }
    }











    // -------------------------------------------------------------------------
    // Snowman path animation â€“ curvy, local â€œsnailâ€ trajectory
    // -------------------------------------------------------------------------

    const snowmanPathCenter = new THREE.Vector3(-7, 0, -1);
    const snowmanPathPoints = [];
    const SNOWMAN_PATH_SEGMENTS = 9;

    (function buildSnowmanPath() {
      const baseR = DEFAULTS.snowmanPathRadius;
      for (let i = 0; i < SNOWMAN_PATH_SEGMENTS; i++) {
        const a = (i / SNOWMAN_PATH_SEGMENTS) * Math.PI * 2.0;

        // radius modulation -> mixture of almost circles and arcs
        const rMul = 0.72 + 0.20 * Math.sin(i * 1.47) + 0.12 * Math.cos(i * 2.17);
        const r = baseR * rMul;

        const x = snowmanPathCenter.x + Math.cos(a) * r;
        const z = snowmanPathCenter.z + Math.sin(a) * r;
        const y = 0.0;

        snowmanPathPoints.push(new THREE.Vector3(x, y, z));
      }
    })();

    const snowmanPathCurve = new THREE.CatmullRomCurve3(
      snowmanPathPoints,
      true,
      "catmullrom",
      0.5
      );

    const snowmanState = {
      t: 0,
      lastPos: new THREE.Vector3(NaN, NaN, NaN)
    };

    function updateSnowman(dt) {
      if (dt <= 0) return;
      if (!params.snowmanMoveEnabled) return;

      const snowmanObj = getModelInstance("snowman");
      if (!snowmanObj) return;

      // loops per second along the closed curve
      const speed = clamp(params.snowmanSpeed, 0.0, 1.0);
      if (speed <= 0.0) return;

      snowmanState.t = (snowmanState.t + dt * speed) % 1.0;

      // position on curve
      const curvePos = snowmanPathCurve.getPointAt(snowmanState.t);

      // place him on top of snow surface
      const groundY = sampleSnowHeight(curvePos.x, curvePos.z);
      snowmanObj.position.set(curvePos.x, groundY, curvePos.z);

      // face along direction of motion (XZ plane)
      const tangent = snowmanPathCurve.getTangentAt(snowmanState.t);
      const dirX = tangent.x;
      const dirZ = tangent.z;

      if (dirX !== 0 || dirZ !== 0) {
        // world +Z = forward. atan2(x, z) gives heading around Y.
        const heading = Math.atan2(dirX, dirZ);
        snowmanObj.rotation.y = heading;
      }

      snowmanState.lastPos.copy(snowmanObj.position);
    }



    // Drifts (heightfield)
    let DRIFT_GRID = 0;
    let DRIFT_STRIDE = 0;
    let DRIFT_VERTS = 0;
    let driftHeights = null;
    let driftHeightsTmp = null;
    let driftDeform = null;
    let driftGeo = null;
    let driftPosAttr = null;
    let driftPosArray = null;
    let driftColorAttr = null;
    let driftColorArray = null;
    let snowSurface = null;

    let forceDriftWrite = false;
    let forceDriftNormals = false;



        // Wet trail decals (fading surface marks)
    let wetTrailGroup = null;
    let wetTrailGeo = null;
    let wetTrailPool = [];
    let wetTrailCursor = 0;

    const wetTrailConfig = {
      enabled: true,
      maxMarks: 260,
      life: 4.5,
      opacity: 0.38,
      lift: 0.035,

      avatarSize: 0.38,
      vehicleWidth: 0.46,
      vehicleLength: 0.90,

          // Back-compat fallback (older code paths)
      color: "#1a1a1a",

          // Per-type colors (used by spawnWetTrailMark)
      avatarColor: "#ffffff",
      vehicleColor: "#1a1a1a",

          // Avatar decal alpha texture: two ovals + bridge (footprint)
      avatarUseFootprint: true,
      footTexSize: 128,
      footToeScale: 0.62,
      footHeelScale: 0.52,
      footBridge: 0.22,
      footSoftness: 0.55
    };




    /* GPU point-sprite dust/fire column; driven by params and saved/loaded with worlds/presets. */
    function disposeDust() {
      if (dustPoints) {
        scene.remove(dustPoints);
        dustPoints.geometry.dispose();
        dustPoints.material.dispose();
      }
      dustGeometry = null;
      dustMaterial = null;
      dustPoints = null;
      dustUniforms = null;
    }

    function applyDustParamsToUniforms() {
      if (!dustUniforms) return;

      const floorY = params.dustFloorY;
      const ceilY = Math.max(floorY + 0.01, params.dustCeilY);

      dustUniforms.uSpeed.value = params.dustSpeed;
      dustUniforms.uFloor.value = floorY;
      dustUniforms.uHeight.value = Math.max(0.01, ceilY - floorY);
      dustUniforms.uRadius.value = params.dustRadius;
      dustUniforms.uSize.value = params.dustSize;
      dustUniforms.uNoiseAmp.value = params.dustNoise;

      dustCenterTmp.set(params.dustCenterX, 0.0, params.dustCenterZ);
      dustUniforms.uCenter.value.copy(dustCenterTmp);

      dustUniforms.uColorInner.value.set(params.dustColorInner || "#ffc57a");
      dustUniforms.uColorOuter.value.set(params.dustColorOuter || "#222222");
    }

    function rebuildDust() {
      disposeDust();

      if (!params.dustEnabled) {
        dustLastCount = params.dustCount | 0;
        return;
      }

      const count = Math.max(1, (params.dustCount | 0) || 1);
      dustLastCount = count;

      const positions = new Float32Array(count * 3);
      const seeds = new Float32Array(count);
      const angles = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        positions[i3 + 0] = params.dustCenterX;
        positions[i3 + 1] = params.dustFloorY;
        positions[i3 + 2] = params.dustCenterZ;

        seeds[i] = Math.random() * 100.0;
        angles[i] = Math.random() * Math.PI * 2.0;
      }

      dustGeometry = new THREE.BufferGeometry();
      dustGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      dustGeometry.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));
      dustGeometry.setAttribute("aAngle", new THREE.BufferAttribute(angles, 1));

      dustUniforms = {
        uTime: { value: 0 },
        uSpeed: { value: params.dustSpeed },
        uFloor: { value: params.dustFloorY },
        uHeight: { value: Math.max(0.01, params.dustCeilY - params.dustFloorY) },
        uRadius: { value: params.dustRadius },
        uCenter: { value: new THREE.Vector3(params.dustCenterX, 0.0, params.dustCenterZ) },
        uSize: { value: params.dustSize },
        uNoiseAmp: { value: params.dustNoise },
        uColorInner: { value: new THREE.Color(params.dustColorInner || "#ffc57a") },
        uColorOuter: { value: new THREE.Color(params.dustColorOuter || "#222222") },
      };

      const dustVertexShader = /* glsl */ `
        uniform float uTime;
        uniform float uSpeed;
        uniform float uFloor;
        uniform float uHeight;
        uniform float uRadius;
        uniform vec3  uCenter;
        uniform float uSize;
        uniform float uNoiseAmp;

        attribute float aSeed;
        attribute float aAngle;

        varying float vLife;
        varying float vNoise;

        void main() {
          float t = uTime * uSpeed + aSeed;

          float life = fract(t * 0.15);
          vLife = life;

          float y = uFloor + life * uHeight;

          float baseR = uRadius * (0.65 + 0.35 * sin(aSeed * 4.123));
          float swirl = sin(t * 0.35 + aSeed * 1.7);
          float angle = aAngle + swirl * 0.8;

          float x = baseR * cos(angle);
          float z = baseR * sin(angle);

          vec3 pos = vec3(x, y, z) + uCenter;

          float wigglePhase = t * 1.7 + aSeed * 3.11;
          float wiggleStrength = uNoiseAmp * (1.0 - life);
          float wx = sin(wigglePhase) * 0.25 * wiggleStrength;
          float wz = cos(wigglePhase * 0.7) * 0.25 * wiggleStrength;
          pos.x += wx;
          pos.z += wz;

          vNoise = wiggleStrength;

          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);

          float ps = uSize * (0.7 + (1.0 - life) * 1.3);
          ps *= (300.0 / max(1.0, -mvPosition.z));
          gl_PointSize = ps;

          gl_Position = projectionMatrix * mvPosition;
        }
      `;

      const dustFragmentShader = /* glsl */ `
        uniform vec3 uColorInner;
        uniform vec3 uColorOuter;

        varying float vLife;
        varying float vNoise;

        void main() {
          vec2 uv = gl_PointCoord - 0.5;
          float d = length(uv);

          float alpha = smoothstep(0.5, 0.0, d);
          alpha *= (1.0 - vLife) * 0.9 + 0.1;

          if (alpha <= 0.01) discard;

          float mixFactor = (1.0 - vLife) + abs(vNoise) * 0.25;
          vec3 color = mix(uColorOuter, uColorInner, clamp(mixFactor, 0.0, 1.0));

          gl_FragColor = vec4(color, alpha);
        }
      `;

      dustMaterial = new THREE.ShaderMaterial({
        uniforms: dustUniforms,
        vertexShader: dustVertexShader,
        fragmentShader: dustFragmentShader,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });

      dustPoints = new THREE.Points(dustGeometry, dustMaterial);
      dustPoints.frustumCulled = false;
      scene.add(dustPoints);

      applyDustParamsToUniforms();
    }

    function updateDust(dt) {
      if (!dustUniforms) return;
      dustUniforms.uTime.value += dt;
    }



    /* GPU point-sprite rain streaks; driven by params and saved/loaded with worlds/presets. */
    function disposeRain() {
      if (rainPoints) {
        scene.remove(rainPoints);
        rainPoints.geometry.dispose();
        rainPoints.material.dispose();
      }
      rainGeometry = null;
      rainMaterial = null;
      rainPoints = null;
      rainUniforms = null;
    }

    function applyRainParamsToUniforms() {
      if (!rainUniforms) return;

      const topY = params.rainTopY;
      const bottomY = Math.min(topY - 0.01, params.rainBottomY);

      rainUniforms.uSpeed.value = params.rainSpeed;
      rainUniforms.uTop.value = topY;
      rainUniforms.uBottom.value = bottomY;
      rainUniforms.uRadius.value = params.rainRadius;
      rainUniforms.uSize.value = params.rainSize;
      rainUniforms.uThickness.value = params.rainThickness;
      rainUniforms.uStreak.value = params.rainStreak;
      rainUniforms.uOpacity.value = params.rainOpacity;

      rainUniforms.uWind.value.set(params.rainWindX, params.rainWindZ);

      rainCenterTmp.set(params.rainCenterX, 0.0, params.rainCenterZ);
      rainUniforms.uCenter.value.copy(rainCenterTmp);

      rainUniforms.uColor.value.set(params.rainColor || "#bcd7ff");
    }

    function rebuildRain() {
      disposeRain();

      if (!params.rainEnabled) {
        rainLastCount = params.rainCount | 0;
        return;
      }

      const count = Math.max(1, (params.rainCount | 0) || 1);
      rainLastCount = count;

      const positions = new Float32Array(count * 3);
      const seeds = new Float32Array(count);
      const angles = new Float32Array(count);
      const rands = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        const i3 = i * 3;
        positions[i3 + 0] = params.rainCenterX;
        positions[i3 + 1] = params.rainTopY;
        positions[i3 + 2] = params.rainCenterZ;

        seeds[i] = Math.random() * 100.0;
        angles[i] = Math.random() * Math.PI * 2.0;
        rands[i] = Math.random();
      }

      rainGeometry = new THREE.BufferGeometry();
      rainGeometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      rainGeometry.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));
      rainGeometry.setAttribute("aAngle", new THREE.BufferAttribute(angles, 1));
      rainGeometry.setAttribute("aRad", new THREE.BufferAttribute(rands, 1));

      const VERT = /* glsl */`
        attribute float aSeed;
        attribute float aAngle;
        attribute float aRad;

        uniform float uTime;
        uniform float uSpeed;
        uniform float uTop;
        uniform float uBottom;
        uniform float uRadius;
        uniform vec3 uCenter;
        uniform vec2 uWind;
        uniform float uSize;

        varying float vLife;

        float hash(float n) { return fract(sin(n) * 43758.5453123); }

        void main() {
          float life = fract(uTime * uSpeed + aSeed);
          vLife = life;

          float y = mix(uTop, uBottom, life);

          float rad = sqrt(aRad) * uRadius;
          vec2 ring = vec2(cos(aAngle), sin(aAngle)) * rad;

          float h = max(0.01, uTop - uBottom);
          vec2 drift = uWind * (1.0 - life) * h;

          vec2 jitter = vec2(hash(aSeed * 1.7) - 0.5, hash(aSeed * 2.9) - 0.5) * (0.03 * uRadius);

          vec3 p = vec3(
            uCenter.x + ring.x + drift.x + jitter.x,
            y,
            uCenter.z + ring.y + drift.y + jitter.y
          );

          vec4 mvPosition = modelViewMatrix * vec4(p, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          float dist = max(0.001, -mvPosition.z);
          gl_PointSize = uSize * (300.0 / dist);
        }
      `;

      const FRAG = /* glsl */`
        precision mediump float;

        uniform vec3 uColor;
        uniform float uOpacity;
        uniform float uThickness;
        uniform float uStreak;

        varying float vLife;

        void main() {
          vec2 uv = gl_PointCoord;

          float x = abs(uv.x - 0.5);
          float line = smoothstep(uThickness, 0.0, x);

          float head = smoothstep(0.0, 0.08, uv.y);
          float tail = 1.0 - smoothstep(1.0 - uStreak, 1.0, uv.y);
          float len = head * tail;

          float fadeBottom = 1.0 - smoothstep(0.85, 1.0, vLife);

          float a = line * len * fadeBottom * uOpacity;
          if (a <= 0.001) discard;

          gl_FragColor = vec4(uColor, a);
        }
      `;

      rainMaterial = new THREE.ShaderMaterial({
        vertexShader: VERT,
        fragmentShader: FRAG,
        transparent: true,
        depthWrite: false,
        depthTest: true,
        blending: THREE.NormalBlending
      });

      rainUniforms = {
        uTime: { value: 0.0 },
        uSpeed: { value: params.rainSpeed },
        uTop: { value: params.rainTopY },
        uBottom: { value: Math.min(params.rainTopY - 0.01, params.rainBottomY) },
        uRadius: { value: params.rainRadius },
        uCenter: { value: new THREE.Vector3(params.rainCenterX, 0.0, params.rainCenterZ) },
        uWind: { value: new THREE.Vector2(params.rainWindX, params.rainWindZ) },
        uSize: { value: params.rainSize },
        uThickness: { value: params.rainThickness },
        uStreak: { value: params.rainStreak },
        uColor: { value: new THREE.Color(params.rainColor || "#bcd7ff") },
        uOpacity: { value: params.rainOpacity }
      };

      rainMaterial.uniforms = rainUniforms;

      rainPoints = new THREE.Points(rainGeometry, rainMaterial);
      rainPoints.frustumCulled = false;
      rainPoints.renderOrder = 5;

      scene.add(rainPoints);

      applyRainParamsToUniforms();
    }

    function updateRain(dt) {
      if (!rainUniforms) return;
      rainUniforms.uTime.value += dt;
    }


    // -------------------------------------------------------------------------
    // Grass (instanced blades + wind shader; driven by params and saved/loaded)
    // -------------------------------------------------------------------------

    let grassBladeBaseGeo = null;

    let grassGeometry = null;
    let grassMaterial = null;
    let grassMesh = null;
    let grassUniforms = null;
    let grassLastCount = 0;

    const grassCenterV2 = new THREE.Vector2();

    /* Disposes grass GPU resources and removes from the scene. */
    function disposeGrass() {
      if (grassMesh) {
        scene.remove(grassMesh);
        grassMesh.geometry.dispose();
        grassMesh.material.dispose();
      }
      grassGeometry = null;
      grassMaterial = null;
      grassMesh = null;
      grassUniforms = null;
    }

    /* Pushes current grass params into shader uniforms (no geometry rebuild). */
    function applyGrassParamsToUniforms() {
      if (!grassUniforms) return;

      grassUniforms.uRadius.value = params.grassRadius;
      grassCenterV2.set(params.grassCenterX, params.grassCenterZ);
      grassUniforms.uCenter.value.copy(grassCenterV2);

      grassUniforms.uBaseY.value = params.grassBaseY;

      grassUniforms.uBladeHeight.value = params.grassBladeHeight;
      grassUniforms.uBladeWidth.value = params.grassBladeWidth;
      grassUniforms.uHeightJitter.value = params.grassHeightJitter;
      grassUniforms.uWidthJitter.value = params.grassWidthJitter;

      grassUniforms.uBend.value = params.grassBend;
      grassUniforms.uWindSpeed.value = params.grassWindSpeed;
      grassUniforms.uWindStrength.value = params.grassWindStrength;
      grassUniforms.uStiffness.value = params.grassStiffness;

      grassUniforms.uNoiseScale.value = params.grassNoiseScale;
      grassUniforms.uNoiseStrength.value = params.grassNoiseStrength;
      grassUniforms.uNoiseSpeed.value = params.grassNoiseSpeed;

      grassUniforms.uStaticHeightNoise.value = params.grassStaticHeightNoise;
      grassUniforms.uStaticWidthNoise.value = params.grassStaticWidthNoise;
      grassUniforms.uBorderNoise.value = params.grassBorderNoise;

      grassUniforms.uColorVar.value = params.grassColorVariation;

      params.grassColorBottom = normalizeHexColor(params.grassColorBottom, DEFAULTS.grassColorBottom || "#1f5f2e");
      params.grassColorTop = normalizeHexColor(params.grassColorTop, DEFAULTS.grassColorTop || "#7ee36c");
      grassUniforms.uColorBottom.value.set(params.grassColorBottom);
      grassUniforms.uColorTop.value.set(params.grassColorTop);

      grassUniforms.uOpacity.value = params.grassOpacity;
      grassUniforms.uAlphaCutoff.value = params.grassAlphaCutoff;
    }




/* Rebuilds grass instances and shader material; only needed for enabled/count/seed changes. */
    function rebuildGrass() {
      disposeGrass();

      const countRaw = params.grassCount | 0;
      if (!params.grassEnabled || countRaw <= 0) {
        grassLastCount = countRaw;
        return;
      }

      const count = clamp(countRaw | 0, 1, 120000);
      grassLastCount = count;

      if (!scene) return;

      if (!grassBladeBaseGeo) {
        const g = new THREE.PlaneGeometry(1, 1, 1, 4);
        g.translate(0, 0.5, 0);
        grassBladeBaseGeo = g;
      }

      const rng = makeSeededRandom((params.grassSeed | 0) || 1);

      const disk = new Float32Array(count * 2);
      const yaw = new Float32Array(count);
      const rand = new Float32Array(count * 2);
      const phase = new Float32Array(count);

      for (let i = 0; i < count; i++) {
        const a = rng() * Math.PI * 2.0;
        const r = Math.sqrt(rng());
        disk[i * 2 + 0] = Math.cos(a) * r;
        disk[i * 2 + 1] = Math.sin(a) * r;

        yaw[i] = rng() * Math.PI * 2.0;

        rand[i * 2 + 0] = rng();
        rand[i * 2 + 1] = rng();

        phase[i] = rng() * 10.0;
      }

      grassGeometry = new THREE.InstancedBufferGeometry();
      grassGeometry.index = grassBladeBaseGeo.index;
      grassGeometry.setAttribute("position", grassBladeBaseGeo.getAttribute("position"));
      grassGeometry.setAttribute("normal", grassBladeBaseGeo.getAttribute("normal"));
      grassGeometry.setAttribute("uv", grassBladeBaseGeo.getAttribute("uv"));

      grassGeometry.setAttribute("aDisk", new THREE.InstancedBufferAttribute(disk, 2));
      grassGeometry.setAttribute("aYaw", new THREE.InstancedBufferAttribute(yaw, 1));
      grassGeometry.setAttribute("aRand", new THREE.InstancedBufferAttribute(rand, 2));
      grassGeometry.setAttribute("aPhase", new THREE.InstancedBufferAttribute(phase, 1));

      grassGeometry.instanceCount = count;

      grassUniforms = {
        uTime: { value: 0.0 },
        uBaseWind: { value: new THREE.Vector2(0.0, 0.0) },

        uCenter: { value: new THREE.Vector2(params.grassCenterX, params.grassCenterZ) },
        uRadius: { value: params.grassRadius },
        uBaseY: { value: params.grassBaseY },

        uBladeHeight: { value: params.grassBladeHeight },
        uBladeWidth: { value: params.grassBladeWidth },
        uHeightJitter: { value: params.grassHeightJitter },
        uWidthJitter: { value: params.grassWidthJitter },

        uBend: { value: params.grassBend },
        uWindSpeed: { value: params.grassWindSpeed },
        uWindStrength: { value: params.grassWindStrength },
        uStiffness: { value: params.grassStiffness },

        uNoiseScale: { value: params.grassNoiseScale },
        uNoiseStrength: { value: params.grassNoiseStrength },
        uNoiseSpeed: { value: params.grassNoiseSpeed },

        uStaticHeightNoise: { value: params.grassStaticHeightNoise },
        uStaticWidthNoise: { value: params.grassStaticWidthNoise },
        uBorderNoise: { value: params.grassBorderNoise },

        uColorVar: { value: params.grassColorVariation },

        uColorBottom: { value: new THREE.Color(params.grassColorBottom || "#1f5f2e") },
        uColorTop: { value: new THREE.Color(params.grassColorTop || "#7ee36c") },
        uOpacity: { value: params.grassOpacity },
        uAlphaCutoff: { value: params.grassAlphaCutoff }
      };


  const VERT = /* glsl */`
    precision mediump float;

    attribute vec2 aDisk;
    attribute float aYaw;
    attribute vec2 aRand;
    attribute float aPhase;

    uniform float uTime;
    uniform vec2  uBaseWind;

    uniform vec2  uCenter;
    uniform float uRadius;
    uniform float uBaseY;

    uniform float uBladeHeight;
    uniform float uBladeWidth;
    uniform float uHeightJitter;
    uniform float uWidthJitter;

    uniform float uBend;
    uniform float uWindSpeed;
    uniform float uWindStrength;
    uniform float uStiffness;

    uniform float uNoiseScale;
    uniform float uNoiseStrength;
    uniform float uNoiseSpeed;

    uniform float uStaticHeightNoise;
    uniform float uStaticWidthNoise;
    uniform float uBorderNoise;


    varying float vY;
    varying float vEdge;
    varying float vRand;
    varying float vPatch;
    varying float vMask;

    float hash12(vec2 p) {
      vec3 p3 = fract(vec3(p.xyx) * 0.1031);
      p3 += dot(p3, p3.yzx + 33.33);
      return fract((p3.x + p3.y) * p3.z);
    }

    float valueNoise(vec2 p) {
      vec2 i = floor(p);
      vec2 f = fract(p);
      f = f * f * (3.0 - 2.0 * f);

      float a = hash12(i);
      float b = hash12(i + vec2(1.0, 0.0));
      float c = hash12(i + vec2(0.0, 1.0));
      float d = hash12(i + vec2(1.0, 1.0));

      return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
    }

    void main() {
      vec3 pos = position;

      float y01 = clamp(pos.y, 0.0, 1.0);

      vec2 base = uCenter + aDisk * uRadius;
      float d01 = clamp(length(aDisk), 0.0, 1.0);

      float jitA = (aRand.x - 0.5) * 2.0;
      float jitB = (aRand.y - 0.5) * 2.0;

      vec2 nsBase = base * max(0.01, uNoiseScale);

      /* Static (build-like) coherent variation: height + width, not time-animated. */
      vec2 npStatic = nsBase + vec2(aPhase * 0.09, aRand.y * 7.31);
      float hN = (valueNoise(npStatic * 1.37 + 11.1) - 0.5) * 2.0;
      float wN = (valueNoise(npStatic * 1.93 + 27.7) - 0.5) * 2.0;

      float hK = 0.55 * clamp(uStaticHeightNoise, 0.0, 2.0);
      float wK = 0.55 * clamp(uStaticWidthNoise, 0.0, 2.0);

      float bh = max(0.01,  uBladeHeight * (1.0 + (jitA * uHeightJitter) + (hN * uHeightJitter * hK)));
      float bw = max(0.001, uBladeWidth  * (1.0 + (jitB * uWidthJitter)  + (wN * uWidthJitter  * wK)));

      /* Irregular boundary mask: affects only the outer edge (keeps interior solid). */
      float edgeT = smoothstep(0.68, 1.0, d01);
      float edgeAmp = 0.35 * clamp(uBorderNoise, 0.0, 1.0);
      float edgeN = valueNoise(nsBase * 0.45 + vec2(19.3, 7.1));
      float edgeR = 1.0 + ((edgeN - 0.5) * 2.0) * edgeAmp;
      edgeR = mix(1.0, edgeR, edgeT);
      vMask = step(d01, edgeR);


      float s = sin(aYaw);
      float c = cos(aYaw);

      float localX = (pos.x) * bw;
      float localY = (pos.y) * bh;

      vec2 pr = vec2(localX * c, localX * s);

      vec2 w = uBaseWind * uWindStrength;
      float wl = length(w);
      vec2 wdir = (wl > 0.0001) ? (w / wl) : normalize(vec2(0.7, 0.2));
      vec2 wperp = vec2(-wdir.y, wdir.x);

      float tt = uTime * uWindSpeed + aPhase + aDisk.x * 3.1 + aDisk.y * 3.3;
      float swayN = sin(tt) * 0.55 + sin(tt * 1.7 + 1.2) * 0.35;
      float swayP = cos(tt * 1.31 + 0.4) * 0.25;

      float wgt = pow(y01, max(0.25, uStiffness));
      vec2 bend = (wdir * swayN + wperp * swayP) * (uBend * wgt);

      vec2 np = nsBase +
                vec2(aPhase * 0.07, aRand.y * 7.31) +
                vec2(0.0, uTime * uNoiseSpeed);

      float nA = valueNoise(np);
      float nB = valueNoise(np * 2.13 + 17.7);

      float n1 = (nA - 0.5) * 2.0;
      float n2 = (nB - 0.5) * 2.0;

      vec2 gust = (wdir * n1 + wperp * n2) * (uBend * wgt * 0.55 * uNoiseStrength);
      bend += gust;

      vec3 worldPos = vec3(base.x, uBaseY + localY, base.y) + vec3(pr.x, 0.0, pr.y);
      worldPos.x += bend.x;
      worldPos.z += bend.y;

      vec4 mv = modelViewMatrix * vec4(worldPos, 1.0);
      gl_Position = projectionMatrix * mv;

      vY = y01;
      vEdge = abs(pos.x);
      vRand = aRand.x * 2.0 - 1.0;
      vPatch = nA;
    }
  `;

  const FRAG = /* glsl */`
    precision mediump float;

    uniform vec3  uColorBottom;
    uniform vec3  uColorTop;
    uniform float uOpacity;
    uniform float uAlphaCutoff;
    uniform float uColorVar;

    varying float vY;
    varying float vEdge;
    varying float vRand;
    varying float vPatch;
    varying float vMask;

    void main() {
      if (vMask < 0.5) discard;

      float taper = mix(1.0, 0.10, vY);
      float x = vEdge / max(0.001, taper);

      float edgeA = smoothstep(1.0, 0.82, x);
      float tipA  = 1.0 - smoothstep(0.92, 1.0, vY);

      float micro = 0.92 + 0.08 * sin(vY * 35.0 + vRand * 6.0);

      float a = edgeA * tipA * micro * uOpacity;
      if (a < uAlphaCutoff) discard;

      float patchMul = 1.0 + ((vPatch - 0.5) * 2.0) * uColorVar;

      vec3 col = mix(uColorBottom, uColorTop, pow(vY, 0.65));
      col *= patchMul;

      gl_FragColor = vec4(col, a);
    }
  `;

  grassMaterial = new THREE.ShaderMaterial({
    uniforms: grassUniforms,
    vertexShader: VERT,
    fragmentShader: FRAG,
    transparent: true,
    depthTest: true,
    depthWrite: false,
    blending: THREE.NormalBlending,
    side: THREE.DoubleSide
  });

  grassMesh = new THREE.Mesh(grassGeometry, grassMaterial);
  grassMesh.frustumCulled = false;
  grassMesh.renderOrder = 2;

  scene.add(grassMesh);

  applyGrassParamsToUniforms();
}




// /* Rebuilds grass instances and shader material; only needed for enabled/count/seed changes. */
//     function rebuildGrass() {
//       disposeGrass();

//       const countRaw = params.grassCount | 0;
//       if (!params.grassEnabled || countRaw <= 0) {
//         grassLastCount = countRaw;
//         return;
//       }

//       const count = clamp(countRaw | 0, 1, 120000);
//       grassLastCount = count;

//       if (!scene) return;

//       if (!grassBladeBaseGeo) {
//         const g = new THREE.PlaneGeometry(1, 1, 1, 4);
//         g.translate(0, 0.5, 0);
//         grassBladeBaseGeo = g;
//       }

//       const rng = makeSeededRandom((params.grassSeed | 0) || 1);

//       const disk = new Float32Array(count * 2);
//       const yaw = new Float32Array(count);
//       const rand = new Float32Array(count * 2);
//       const phase = new Float32Array(count);

//       for (let i = 0; i < count; i++) {
//         const a = rng() * Math.PI * 2.0;
//         const r = Math.sqrt(rng());
//         disk[i * 2 + 0] = Math.cos(a) * r;
//         disk[i * 2 + 1] = Math.sin(a) * r;

//         yaw[i] = rng() * Math.PI * 2.0;

//         rand[i * 2 + 0] = rng();
//         rand[i * 2 + 1] = rng();

//         phase[i] = rng() * 10.0;
//       }

//       grassGeometry = new THREE.InstancedBufferGeometry();
//       grassGeometry.index = grassBladeBaseGeo.index;
//       grassGeometry.setAttribute("position", grassBladeBaseGeo.getAttribute("position"));
//       grassGeometry.setAttribute("normal", grassBladeBaseGeo.getAttribute("normal"));
//       grassGeometry.setAttribute("uv", grassBladeBaseGeo.getAttribute("uv"));

//       grassGeometry.setAttribute("aDisk", new THREE.InstancedBufferAttribute(disk, 2));
//       grassGeometry.setAttribute("aYaw", new THREE.InstancedBufferAttribute(yaw, 1));
//       grassGeometry.setAttribute("aRand", new THREE.InstancedBufferAttribute(rand, 2));
//       grassGeometry.setAttribute("aPhase", new THREE.InstancedBufferAttribute(phase, 1));

//       grassGeometry.instanceCount = count;

//       grassUniforms = {
//         uTime: { value: 0.0 },
//         uBaseWind: { value: new THREE.Vector2(0.0, 0.0) },

//         uCenter: { value: new THREE.Vector2(params.grassCenterX, params.grassCenterZ) },
//         uRadius: { value: params.grassRadius },
//         uBaseY: { value: params.grassBaseY },

//         uBladeHeight: { value: params.grassBladeHeight },
//         uBladeWidth: { value: params.grassBladeWidth },
//         uHeightJitter: { value: params.grassHeightJitter },
//         uWidthJitter: { value: params.grassWidthJitter },

//         uBend: { value: params.grassBend },
//         uWindSpeed: { value: params.grassWindSpeed },
//         uWindStrength: { value: params.grassWindStrength },
//         uStiffness: { value: params.grassStiffness },

//         uNoiseScale: { value: params.grassNoiseScale },
//         uNoiseStrength: { value: params.grassNoiseStrength },
//         uNoiseSpeed: { value: params.grassNoiseSpeed },
//         uColorVar: { value: params.grassColorVariation },

//         uColorBottom: { value: new THREE.Color(params.grassColorBottom || "#1f5f2e") },
//         uColorTop: { value: new THREE.Color(params.grassColorTop || "#7ee36c") },
//         uOpacity: { value: params.grassOpacity },
//         uAlphaCutoff: { value: params.grassAlphaCutoff }
//       };





//   const VERT = /* glsl */`
//     precision mediump float;

//     attribute vec2 aDisk;
//     attribute float aYaw;
//     attribute vec2 aRand;
//     attribute float aPhase;

//     uniform float uTime;
//     uniform vec2  uBaseWind;

//     uniform vec2  uCenter;
//     uniform float uRadius;
//     uniform float uBaseY;

//     uniform float uBladeHeight;
//     uniform float uBladeWidth;
//     uniform float uHeightJitter;
//     uniform float uWidthJitter;

//     uniform float uBend;
//     uniform float uWindSpeed;
//     uniform float uWindStrength;
//     uniform float uStiffness;

//     uniform float uNoiseScale;
//     uniform float uNoiseStrength;
//     uniform float uNoiseSpeed;

//     varying float vY;
//     varying float vEdge;
//     varying float vRand;
//     varying float vPatch;

//     float hash12(vec2 p) {
//       vec3 p3 = fract(vec3(p.xyx) * 0.1031);
//       p3 += dot(p3, p3.yzx + 33.33);
//       return fract((p3.x + p3.y) * p3.z);
//     }

//     float valueNoise(vec2 p) {
//       vec2 i = floor(p);
//       vec2 f = fract(p);
//       f = f * f * (3.0 - 2.0 * f);

//       float a = hash12(i);
//       float b = hash12(i + vec2(1.0, 0.0));
//       float c = hash12(i + vec2(0.0, 1.0));
//       float d = hash12(i + vec2(1.0, 1.0));

//       return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
//     }

//     void main() {
//       vec3 pos = position;

//       float y01 = clamp(pos.y, 0.0, 1.0);

//       float r = uRadius * aDisk.x;
//       vec2 base = uCenter + aDisk * uRadius;

//       float jitA = (aRand.x - 0.5) * 2.0;
//       float jitB = (aRand.y - 0.5) * 2.0;

//       float bh = max(0.01, uBladeHeight * (1.0 + jitA * uHeightJitter));
//       float bw = max(0.001, uBladeWidth  * (1.0 + jitB * uWidthJitter));

//       float s = sin(aYaw);
//       float c = cos(aYaw);

//       float localX = (pos.x) * bw;
//       float localY = (pos.y) * bh;

//       vec2 pr = vec2(localX * c, localX * s);

//       vec2 w = uBaseWind * uWindStrength;
//       float wl = length(w);
//       vec2 wdir = (wl > 0.0001) ? (w / wl) : normalize(vec2(0.7, 0.2));
//       vec2 wperp = vec2(-wdir.y, wdir.x);

//       float tt = uTime * uWindSpeed + aPhase + aDisk.x * 3.1 + aDisk.y * 3.3;
//       float swayN = sin(tt) * 0.55 + sin(tt * 1.7 + 1.2) * 0.35;
//       float swayP = cos(tt * 1.31 + 0.4) * 0.25;

//       float wgt = pow(y01, max(0.25, uStiffness));
//       vec2 bend = (wdir * swayN + wperp * swayP) * (uBend * wgt);

//       vec2 np = (base * max(0.01, uNoiseScale)) +
//                 vec2(aPhase * 0.07, aRand.y * 7.31) +
//                 vec2(0.0, uTime * uNoiseSpeed);

//       float nA = valueNoise(np);
//       float nB = valueNoise(np * 2.13 + 17.7);

//       float n1 = (nA - 0.5) * 2.0;
//       float n2 = (nB - 0.5) * 2.0;

//       vec2 gust = (wdir * n1 + wperp * n2) * (uBend * wgt * 0.55 * uNoiseStrength);
//       bend += gust;

//       vec3 worldPos = vec3(base.x, uBaseY + localY, base.y) + vec3(pr.x, 0.0, pr.y);
//       worldPos.x += bend.x;
//       worldPos.z += bend.y;

//       vec4 mv = modelViewMatrix * vec4(worldPos, 1.0);
//       gl_Position = projectionMatrix * mv;

//       vY = y01;
//       vEdge = abs(pos.x);
//       vRand = aRand.x * 2.0 - 1.0;
//       vPatch = nA;
//     }
//   `;

//   const FRAG = /* glsl */`
//     precision mediump float;

//     uniform vec3  uColorBottom;
//     uniform vec3  uColorTop;
//     uniform float uOpacity;
//     uniform float uAlphaCutoff;
//     uniform float uColorVar;

//     varying float vY;
//     varying float vEdge;
//     varying float vRand;
//     varying float vPatch;

//     void main() {
//       float taper = mix(1.0, 0.10, vY);
//       float x = vEdge / max(0.001, taper);

//       float edgeA = smoothstep(1.0, 0.82, x);
//       float tipA  = 1.0 - smoothstep(0.92, 1.0, vY);

//       float micro = 0.92 + 0.08 * sin(vY * 35.0 + vRand * 6.0);

//       float a = edgeA * tipA * micro * uOpacity;
//       if (a < uAlphaCutoff) discard;

//       float patchMul = 1.0 + ((vPatch - 0.5) * 2.0) * uColorVar;

//       vec3 col = mix(uColorBottom, uColorTop, pow(vY, 0.65));
//       col *= patchMul;

//       gl_FragColor = vec4(col, a);
//     }
//   `;







//   grassMaterial = new THREE.ShaderMaterial({
//     uniforms: grassUniforms,
//     vertexShader: VERT,
//     fragmentShader: FRAG,
//     transparent: true,
//     depthTest: true,
//     depthWrite: false,
//     blending: THREE.NormalBlending,
//     side: THREE.DoubleSide
//   });

//   grassMesh = new THREE.Mesh(grassGeometry, grassMaterial);
//   grassMesh.frustumCulled = false;
//   grassMesh.renderOrder = 2;

//   scene.add(grassMesh);

//   applyGrassParamsToUniforms();
// }




    /* Advances grass time and feeds base wind into shader. */
function updateGrass(dt, baseWindX, baseWindZ) {
  if (!grassUniforms) return;
  grassUniforms.uTime.value += dt;
  grassUniforms.uBaseWind.value.set(baseWindX, baseWindZ);
}









    // Visual flakes
let snowGeo = null;
let snowMat = null;
let snowPoints = null;

    // Sticking decals
let stuck = null;
let stuckGeo = null;
let stuckMat = null;
let stuckCount = 0;
let stuckWrite = 0;

    // Settlers
let SETTLER_COUNT = 0;
let settlerPos = null;
let settlerPrev = null;
let settlerVel = null;
let depositTokens = 0;


    // Colliders
let colliderObjects = [];
let colliderBounds = [];

    // Model-only colliders (cars etc): simplified oriented boxes built once at load-time
let avatarModelColliderObjects = [];
let avatarModelColliderBounds = [];
let avatarModelColliderOBBs = [];

// Walkable ground meshes (optional per-instance), used for surface Y ray-tests for avatar/jetpack landing.
const worldGroundMeshes = [];
const worldGroundRaycaster = new THREE.Raycaster();
const worldGroundRayOrigin = new THREE.Vector3();
const worldGroundRayDir = new THREE.Vector3(0, -1, 0);


// Vehicle interaction + driving state (POC)
const vehicleInteractables = [];
const vehiclePromptState = {
  open: false,
  nearby: null,

  dismissedId: "",
  dismissedKind: ""
};


// Equipment interaction + wearable/tool state (POC)
const equipmentInteractables = [];

const equipmentState = {
  enabled: false,
  item: null,
  idleAction: "",
  originalParent: null,
  originalPosition: new THREE.Vector3(),
  originalQuaternion: new THREE.Quaternion(),
  originalScale: new THREE.Vector3(1, 1, 1)
};

const equipmentTmpBox = new THREE.Box3();
const equipmentTmpCenter = new THREE.Vector3();
const equipmentTmpSize = new THREE.Vector3();
const equipmentTmpPos = new THREE.Vector3();
const equipmentTmpForward = new THREE.Vector3();
const equipmentWorldUp = new THREE.Vector3(0, 1, 0);
const equipmentTmpWorldScale = new THREE.Vector3();
const equipmentTmpEuler = new THREE.Euler();





const vehicleDriveState = {
  enabled: false,
  vehicle: null,
  speed: 0.0,
  yaw: 0.0,
  pitch: 0.0,
  roll: 0.0,

  steerAngle: 0.0,

      // Plane lift state (used when vehicle meta.type/profile indicates an airplane/plane).
  liftY: 0.0,
  groundOffsetY: 0.0,

  lastTrackValid: false,
  lastTrackX: 0.0,
  lastTrackZ: 0.0,
  trackAcc: 0.0
};








const vehicleChaseCamState = {
  enabled: false,

      // OrbitControls target height above the vehicle origin.
  lookHeight: 1.1,

      // How quickly OrbitControls target follows the vehicle (lower = more inertia).
  targetStiffness: 7.0,

      // How quickly the camera azimuth eases behind the vehicle (lower = more inertia).
  yawStiffness: 1.75,

      // Clamp on per-frame yaw blending to prevent â€œstiffâ€ snaps on low FPS frames.
  maxYawAlpha: 0.05,

      // Seconds since last OrbitControls interaction before auto-behind easing resumes (when not driving).
  recenterIdleSeconds: 0.45,

      // Internal state
  has: false,
  userOverride: false,
  pendingRecenter: false,
  userInteracting: false,
  hooksInstalled: false
};

const vehicleChasePrevControlsState = {
  has: false,
  enableRotate: true,
  enablePan: true,
  enableZoom: true,
  enableDamping: true
};

const vehicleChaseWorldPos = new THREE.Vector3();
const vehicleChaseForward = new THREE.Vector3();
const vehicleChaseDesiredTarget = new THREE.Vector3();

const vehicleChaseOldTarget = new THREE.Vector3();
const vehicleChaseNewTarget = new THREE.Vector3();
const vehicleChaseDelta = new THREE.Vector3();

const vehicleChaseOffset = new THREE.Vector3();
const vehicleChaseSpherical = new THREE.Spherical();

    /**
     * Marks a user-driven OrbitControls interaction for chase mode.
     * A manual orbit sets an override that blocks auto-behind until driving input resumes.
     */
function onVehicleChaseOrbitStart() {
  if (!vehicleChaseCamState.enabled) return;
  vehicleChaseCamState.userInteracting = true;
  vehicleChaseCamState.userOverride = true;
  vehicleChaseCamState.pendingRecenter = false;
  lastInteractionTime = performance.now() * 0.001;
}

    /**
     * Marks the end of a user-driven OrbitControls interaction for chase mode.
     */
function onVehicleChaseOrbitEnd() {
  if (!vehicleChaseCamState.enabled) return;
  vehicleChaseCamState.userInteracting = false;
  lastInteractionTime = performance.now() * 0.001;
}

    /**
     * Installs OrbitControls hooks used by chase mode exactly once.
     */
function ensureVehicleChaseOrbitHooks() {
  if (vehicleChaseCamState.hooksInstalled || !controls) return;
  controls.addEventListener("start", onVehicleChaseOrbitStart);
  controls.addEventListener("end", onVehicleChaseOrbitEnd);
  vehicleChaseCamState.hooksInstalled = true;
}

    /**
     * Determines whether the currently driven vehicle should be treated as an aircraft
     * for follow vector computation.
     */
function isVehiclePlane(v) {
  if (!v || !v.meta) return false;
  const prof = v.meta.profile || {};
  const driveMode = (typeof prof.driveMode === "string") ? prof.driveMode : "";
  return driveMode === "plane" || /airplane|plane/i.test((v.meta.type || ""));
}

    /**
     * Enables/disables chase camera mode for the driven vehicle while keeping OrbitControls usable:
     * rotate/zoom/damping remain enabled; pan is disabled so the target stays locked to the vehicle.
     */
function setVehicleChaseCameraEnabled(enabled) {
  const next = !!enabled;
  if (vehicleChaseCamState.enabled === next) return;

  vehicleChaseCamState.enabled = next;
  vehicleChaseCamState.has = false;
  vehicleChaseCamState.userOverride = false;
  vehicleChaseCamState.pendingRecenter = false;
  vehicleChaseCamState.userInteracting = false;
  avatarHasLastPos = false;

  if (!controls) return;

  if (next) {
    ensureVehicleChaseOrbitHooks();

    if (!vehicleChasePrevControlsState.has) {
      vehicleChasePrevControlsState.has = true;
      vehicleChasePrevControlsState.enableRotate = !!controls.enableRotate;
      vehicleChasePrevControlsState.enablePan = !!controls.enablePan;
      vehicleChasePrevControlsState.enableZoom = !!controls.enableZoom;
      vehicleChasePrevControlsState.enableDamping = !!controls.enableDamping;
    }

    controls.enableRotate = true;
    controls.enableZoom = true;
    controls.enableDamping = true;
    controls.enablePan = false;
    controls.autoRotate = false;
  } else {
    controls.enableRotate = vehicleChasePrevControlsState.has ? vehicleChasePrevControlsState.enableRotate : true;
    controls.enablePan = vehicleChasePrevControlsState.has ? vehicleChasePrevControlsState.enablePan : true;
    controls.enableZoom = vehicleChasePrevControlsState.has ? vehicleChasePrevControlsState.enableZoom : true;
    controls.enableDamping = vehicleChasePrevControlsState.has ? vehicleChasePrevControlsState.enableDamping : true;
    controls.update();
  }
}

    /**
     * Updates the chase camera:
     * - OrbitControls target is smoothly moved to the vehicle (camera translates with it, preserving orbit)
     * - Auto-behind yaw easing runs when the user is not actively orbiting and no manual override is active
     * - Manual override is set by orbiting and is cleared only after driving input resumes
     */
function updateVehicleChaseCamera(dt) {
  if (!vehicleChaseCamState.enabled || !controls) return;

  const v = vehicleDriveState.vehicle;
  if (!vehicleDriveState.enabled || !v || !v.object) return;

  v.object.getWorldPosition(vehicleChaseWorldPos);

  vehicleChaseDesiredTarget
  .copy(vehicleChaseWorldPos)
  .addScaledVector(worldUp, vehicleChaseCamState.lookHeight);

  const targetAlpha =
  1 - Math.pow(0.001, vehicleChaseCamState.targetStiffness * Math.max(0.0, dt));

  if (!vehicleChaseCamState.has) {
    vehicleChaseOldTarget.copy(controls.target);
    controls.target.copy(vehicleChaseDesiredTarget);
    vehicleChaseDelta.subVectors(controls.target, vehicleChaseOldTarget);
    camera.position.add(vehicleChaseDelta);

    vehicleChaseCamState.has = true;
    controls.autoRotate = false;
    controls.update();
    return;
  }

  vehicleChaseOldTarget.copy(controls.target);
  vehicleChaseNewTarget.copy(controls.target).lerp(vehicleChaseDesiredTarget, targetAlpha);

  vehicleChaseDelta.subVectors(vehicleChaseNewTarget, vehicleChaseOldTarget);
  controls.target.copy(vehicleChaseNewTarget);
  camera.position.add(vehicleChaseDelta);

  const nowSeconds = performance.now() * 0.001;
  const idleSeconds = nowSeconds - lastInteractionTime;

  const driveKeyActive =
  !!(avatarKeys.forward || avatarKeys.back || avatarKeys.left || avatarKeys.right);

  const driveJoyActive =
  !!(joystickState.active && (Math.abs(joystickState.valueX) > 0.18 || Math.abs(joystickState.valueY) > 0.18));

  const driveInputActive = driveKeyActive || driveJoyActive;

  if (vehicleChaseCamState.userOverride) {
    if (driveInputActive) vehicleChaseCamState.pendingRecenter = true;
    if (vehicleChaseCamState.pendingRecenter && !vehicleChaseCamState.userInteracting) {
      vehicleChaseCamState.userOverride = false;
      vehicleChaseCamState.pendingRecenter = false;
    }
  } else {
    vehicleChaseCamState.pendingRecenter = false;
  }

  const allowAutoBehind =
  !vehicleChaseCamState.userOverride &&
  !vehicleChaseCamState.userInteracting &&
  (driveInputActive || idleSeconds >= vehicleChaseCamState.recenterIdleSeconds);

  if (allowAutoBehind) {
    vehicleChaseForward.set(0, 0, 1).applyQuaternion(v.object.quaternion);

    if (!isVehiclePlane(v)) vehicleChaseForward.y = 0;

    if (vehicleChaseForward.lengthSq() < 1e-8) vehicleChaseForward.set(0, 0, 1);
    vehicleChaseForward.normalize();

    const desiredTheta = Math.atan2(-vehicleChaseForward.x, -vehicleChaseForward.z);

    vehicleChaseOffset.copy(camera.position).sub(controls.target);

    if (vehicleChaseOffset.lengthSq() > 1e-10) {
      vehicleChaseSpherical.setFromVector3(vehicleChaseOffset);

      let yawAlpha =
      1 - Math.pow(0.001, vehicleChaseCamState.yawStiffness * Math.max(0.0, dt));

      yawAlpha = Math.min(vehicleChaseCamState.maxYawAlpha, Math.max(0.0, yawAlpha));

      vehicleChaseSpherical.theta = lerpYaw(vehicleChaseSpherical.theta, desiredTheta, yawAlpha);

      if (Number.isFinite(controls.minPolarAngle)) {
        vehicleChaseSpherical.phi = Math.max(vehicleChaseSpherical.phi, controls.minPolarAngle);
      }
      if (Number.isFinite(controls.maxPolarAngle)) {
        vehicleChaseSpherical.phi = Math.min(vehicleChaseSpherical.phi, controls.maxPolarAngle);
      }
      if (Number.isFinite(controls.minDistance)) {
        vehicleChaseSpherical.radius = Math.max(vehicleChaseSpherical.radius, controls.minDistance);
      }
      if (Number.isFinite(controls.maxDistance)) {
        vehicleChaseSpherical.radius = Math.min(vehicleChaseSpherical.radius, controls.maxDistance);
      }

      vehicleChaseOffset.setFromSpherical(vehicleChaseSpherical);
      camera.position.copy(controls.target).add(vehicleChaseOffset);
    }
  }

  controls.autoRotate = false;
  controls.update();
}





const vehicleTmpBox = new THREE.Box3();
const vehicleTmpCenter = new THREE.Vector3();
const vehicleTmpSize = new THREE.Vector3();
const vehicleTmpPos = new THREE.Vector3();
const vehicleTmpVel = new THREE.Vector3();
const vehicleTmpMove = new THREE.Vector3();
const vehicleSeatLocal = new THREE.Vector3();
const vehicleSeatWorld = new THREE.Vector3();

const vehicleGroundUp = new THREE.Vector3();
const vehicleGroundFwd = new THREE.Vector3();
const vehicleGroundRight = new THREE.Vector3();
const vehicleGroundMat = new THREE.Matrix4();


const vehicleOutlineBox = new THREE.Box3();
let vehicleOutlineHelper = null;


/**
 * Attaches a non-window debug bridge for vehicle inspection/manipulation to the renderer canvas element.
 * Access from DevTools: document.querySelector("#app canvas").vehicleDebug
 */
function installVehicleDebugBridge(canvasEl) {
  if (!canvasEl) return;

  const api = {
    /**
     * Lists loaded vehicles with ids and types.
     */
    list() {
      return vehicleInteractables.map((v) => ({
        id: v.id || "",
        type: (v.meta && v.meta.type) || "Vehicle"
      }));
    },

    /**
     * Returns the per-vehicle debug handle (same shape as the one logged at load-time).
     */
    get(id) {
      const key = String(id || "");
      for (let i = 0; i < vehicleInteractables.length; i++) {
        const v = vehicleInteractables[i];
        if (!v) continue;
        if (String(v.id || "") !== key) continue;
        const h = v.object && v.object.userData ? v.object.userData.vehicleDebug : null;
        return h || null;
      }
      return null;
    },

    /**
     * Returns the vehicle root Object3D for a given id.
     */
    root(id) {
      const h = api.get(id);
      return h ? h.object : null;
    },

    /**
     * Returns detected parts for a given id.
     */
    parts(id) {
      const h = api.get(id);
      return h ? h.parts : null;
    },

    /**
     * Sets an internal selection for quicker console iteration.
     */
    select(id) {
      const h = api.get(id);
      canvasEl.vehicleSelectedId = h ? h.id : "";
      return h;
    },

    /**
     * Gets current selection debug handle.
     */
    selected() {
      const id = String(canvasEl.vehicleSelectedId || "");
      return id ? api.get(id) : null;
    }
  };

  canvasEl.vehicleDebug = api;
  if (!canvasEl.vehicleSelectedId) canvasEl.vehicleSelectedId = "";
}



/**
 * Shows/hides the bottom-center quick action button for exiting vehicles or dropping equipment when the main prompt is hidden.
 */
function updateVehicleQuickActionButton() {
  const btn = document.getElementById("vehicleQuickActionBtn");
  if (!btn) return;

  const promptVisible = !uiHidden && !!(vehiclePromptState.open && vehiclePromptState.nearby);
  const hasVehicle = !!(vehicleDriveState.enabled && vehicleDriveState.vehicle);
  const hasEquipment = !!(equipmentState.enabled && equipmentState.item);

  const shouldShow = !uiHidden && !promptVisible && (hasVehicle || hasEquipment);

  if (!shouldShow) {
    btn.style.display = "none";
    btn.setAttribute("aria-hidden", "true");
    btn.textContent = "";
    return;
  }

  btn.textContent = hasEquipment ? "Drop" : "Exit";
  btn.style.display = "";
  btn.setAttribute("aria-hidden", "false");
}



/**
 * Shows/hides the vehicle prompt panel and refreshes the current selection.
 */
/**
 * Shows/hides the vehicle prompt panel and refreshes the current selection.
 */
function setVehiclePrompt(open, near) {
  /* Shows the interaction prompt for the current nearby target and configures actions based on kind. */
  const panel = document.getElementById("vehiclePrompt");
  const titleEl = document.getElementById("vehiclePromptTitle");
  const descEl = document.getElementById("vehiclePromptDesc");
  const enterBtn = document.getElementById("vehicleEnterBtn");
  const exitBtn = document.getElementById("vehicleExitBtn");

  vehiclePromptState.open = !!open;
  vehiclePromptState.nearby = open ? (near || null) : null;

  if (!panel || !titleEl || !descEl || !enterBtn || !exitBtn) return;

  if (uiHidden || !vehiclePromptState.open || !vehiclePromptState.nearby) {
    panel.style.display = "none";
    panel.setAttribute("aria-hidden", "true");
    titleEl.textContent = "";
    descEl.textContent = "";
    enterBtn.style.display = "none";
    exitBtn.style.display = "none";
    updateVehicleQuickActionButton();
    return;
  }

  const n = vehiclePromptState.nearby;
  const kind = String(n.kind || "vehicle");
  const meta = (n.meta && typeof n.meta === "object") ? n.meta : {};

  let title = "Interact";
  let desc = "";
  let enterLabel = "";
  let exitLabel = "";
  let showEnter = true;
  let showExit = false;

  if (kind === "vehicle") {
    title = String(meta.type || "Vehicle");
    desc = String(meta.description || "");
    enterLabel = "Get in/on";
    exitLabel = "Exit";
    showEnter = !vehicleDriveState.enabled;
    showExit = !!vehicleDriveState.enabled;
  } else if (kind === "equipment") {
    title = String(meta.type || "Item");
    desc = String(meta.description || "");
    enterLabel = "Equip";
    exitLabel = "Unequip";
    showEnter = !equipmentState.enabled;
    showExit = !!equipmentState.enabled;
  } else if (kind === "pickup") {
    const isFood = String(meta.kind || "").toLowerCase() === "food";
    title = String(meta.name || meta.title || "Pickup");
    desc = String(meta.description || "");
    enterLabel = "Take";
    exitLabel = isFood ? "Consume" : "";
    showEnter = true;
    showExit = !!isFood;
  } else {
    title = String(meta.type || "Interact");
    desc = String(meta.description || "");
    enterLabel = "Use";
    exitLabel = "";
    showEnter = true;
    showExit = false;
  }

  titleEl.textContent = title;
  descEl.textContent = desc;

  enterBtn.textContent = enterLabel;
  exitBtn.textContent = exitLabel;

  enterBtn.style.display = showEnter ? "" : "none";
  exitBtn.style.display = showExit ? "" : "none";

  panel.style.display = "block";
  panel.setAttribute("aria-hidden", "false");
  updateVehicleQuickActionButton();
}






    /**
     * Builds and caches per-vehicle mesh edge outlines under the given vehicle root.
     * Outlines are attached to each mesh so they inherit transforms and can be toggled efficiently.
     */
function ensureVehicleMeshOutlines(root) {
  if (!root) return;
  if (root.userData.vehicleMeshOutlineLines) return;

  const mat = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.25,
    depthTest: false
  });

  const lines = [];

  root.traverse((o) => {
    if (!o || !o.isMesh || !o.geometry) return;

    const edges = new THREE.EdgesGeometry(o.geometry, 15);
    const l = new THREE.LineSegments(edges, mat);
    l.frustumCulled = false;
    l.renderOrder = 1000;
    l.visible = false;

    o.add(l);
    lines.push(l);
  });

  root.userData.vehicleMeshOutlineLines = lines;
}

    /**
     * Toggles cached mesh edge outlines for a vehicle root (no-op if none exist).
     */
function setVehicleMeshOutlineVisible(root, visible) {
  if (!root) return;

  const lines = root.userData.vehicleMeshOutlineLines;
  if (!lines || lines.length === 0) return;

  const v = !!visible;
  for (let i = 0; i < lines.length; i++) {
    lines[i].visible = v;
  }
}

    /**
     * Builds and caches a per-vehicle silhouette outline using the inverted-hull technique:
     * a BackSide MeshBasicMaterial clone slightly scaled up, producing a clean contour
     * without wireframe/X-ray artifacts. Uses a two-pass approach to avoid traverse
     * recursion when adding children during traversal.
     */
function ensureVehicleSilhouetteOutline(root) {
  if (!root) return;
  if (root.userData.vehicleSilhouetteOutlines) return;

  const mat = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    side: THREE.BackSide,
    depthTest: true,
    depthWrite: false,
    transparent: true,
    opacity: 0.50,
    polygonOffset: true,
    polygonOffsetFactor: 1,
    polygonOffsetUnits: 1
  });

  const meshes = [];
  root.traverse((o) => {
    if (!o || !o.isMesh || !o.geometry) return;
    if (o.isSkinnedMesh) return;
    if (o.userData && o.userData.isVehicleSilhouetteOutline) return;
    meshes.push(o);
  });

  const outlines = [];

  for (let i = 0; i < meshes.length; i++) {
    const m = meshes[i];
    if (!m) continue;

    const existing = m.userData && m.userData.vehicleSilhouetteOutlineMesh;
    if (existing && existing.isMesh) {
      outlines.push(existing);
      continue;
    }

    const outline = new THREE.Mesh(m.geometry, mat);
    outline.userData.isVehicleSilhouetteOutline = true;
    outline.frustumCulled = false;
    outline.renderOrder = -1;
    outline.visible = false;

    outline.scale.set(1.01, 1.01, 1.01);

    m.add(outline);

    if (!m.userData) m.userData = {};
    m.userData.vehicleSilhouetteOutlineMesh = outline;

    outlines.push(outline);
  }

  root.userData.vehicleSilhouetteOutlines = outlines;
}


    /**
     * Toggles cached silhouette outline visibility for a vehicle root.
     */
function setVehicleSilhouetteOutlineVisible(root, visible) {
  if (!root) return;
  const outlines = root.userData.vehicleSilhouetteOutlines;
  if (!outlines || outlines.length === 0) return;

  const v = !!visible;
  for (let i = 0; i < outlines.length; i++) {
    outlines[i].visible = v;
  }
}






    /**
     * Shows a green oriented bounding cuboid around the nearest vehicle and
     * a green silhouette outline on the vehicle meshes (inverted-hull). Bounds are
     * computed once per vehicle in the vehicle root's local space using a PCA fit
     * on mesh bounding-box corner samples (XZ), then cached. Outline is hidden while
     * driving and when UI is hidden.
     */
function updateVehicleOutlineFor(v) {
  if (!v || !v.object || uiHidden || vehicleDriveState.enabled) {
    if (vehicleOutlineHelper && vehicleOutlineHelper.parent) {
      setVehicleSilhouetteOutlineVisible(vehicleOutlineHelper.parent, false);
      vehicleOutlineHelper.parent.remove(vehicleOutlineHelper);
    }
    if (vehicleOutlineHelper) vehicleOutlineHelper.visible = false;
    return;
  }

  const root = v.object;

  if (vehicleOutlineHelper && vehicleOutlineHelper.parent && vehicleOutlineHelper.parent !== root) {
    setVehicleSilhouetteOutlineVisible(vehicleOutlineHelper.parent, false);
  }

  if (!root.userData.vehicleOutlineLocalOBB) {
    const invRoot = new THREE.Matrix4();
    const m = new THREE.Matrix4();
    const p = new THREE.Vector3();

    const pts = [];
    let yMin = Infinity;
    let yMax = -Infinity;

    root.updateWorldMatrix(true, true);
    invRoot.copy(root.matrixWorld).invert();

    root.traverse((o) => {
      if (!o || !o.isMesh || !o.geometry) return;
      if (o.userData && o.userData.isVehicleSilhouetteOutline) return;

      const g = o.geometry;
      if (!g.boundingBox) g.computeBoundingBox();
      if (!g.boundingBox) return;

      o.updateWorldMatrix(true, false);
      m.multiplyMatrices(invRoot, o.matrixWorld);

      const bb = g.boundingBox;

      const x0 = bb.min.x, y0 = bb.min.y, z0 = bb.min.z;
      const x1 = bb.max.x, y1 = bb.max.y, z1 = bb.max.z;

      const corners = [
        [x0, y0, z0], [x1, y0, z0], [x0, y0, z1], [x1, y0, z1],
        [x0, y1, z0], [x1, y1, z0], [x0, y1, z1], [x1, y1, z1]
      ];

      for (let i = 0; i < 8; i++) {
        const c = corners[i];
        p.set(c[0], c[1], c[2]).applyMatrix4(m);

        pts.push(p.x, p.z);

        if (p.y < yMin) yMin = p.y;
        if (p.y > yMax) yMax = p.y;
      }
    });

    if (!Number.isFinite(yMin) || !Number.isFinite(yMax) || pts.length < 8) {
      vehicleOutlineBox.setFromObject(root);
      const size = vehicleOutlineBox.getSize(new THREE.Vector3());
      const center = vehicleOutlineBox.getCenter(new THREE.Vector3());

      root.updateWorldMatrix(true, true);
      const inv = new THREE.Matrix4().copy(root.matrixWorld).invert();
      const cLocal = center.clone().applyMatrix4(inv);

      root.userData.vehicleOutlineLocalOBB = {
        centerLocal: cLocal,
        sizeLocal: new THREE.Vector3(
          Math.max(0.001, size.x),
          Math.max(0.001, size.y),
          Math.max(0.001, size.z)
          ),
        yawLocal: 0.0
      };
    } else {
      let meanX = 0.0;
      let meanZ = 0.0;

      for (let i = 0; i < pts.length; i += 2) {
        meanX += pts[i];
        meanZ += pts[i + 1];
      }

      const n = pts.length * 0.5;
      meanX /= n;
      meanZ /= n;

      let cXX = 0.0;
      let cXZ = 0.0;
      let cZZ = 0.0;

      for (let i = 0; i < pts.length; i += 2) {
        const dx = pts[i] - meanX;
        const dz = pts[i + 1] - meanZ;
        cXX += dx * dx;
        cXZ += dx * dz;
        cZZ += dz * dz;
      }

      cXX /= n;
      cXZ /= n;
      cZZ /= n;

      const yaw = 0.5 * Math.atan2(2.0 * cXZ, (cXX - cZZ));

      const c = Math.cos(yaw);
      const s = Math.sin(yaw);

      let minXr = Infinity, maxXr = -Infinity;
      let minZr = Infinity, maxZr = -Infinity;

      for (let i = 0; i < pts.length; i += 2) {
        const dx = pts[i] - meanX;
        const dz = pts[i + 1] - meanZ;

        const xr = dx * c + dz * s;
        const zr = -dx * s + dz * c;

        if (xr < minXr) minXr = xr;
        if (xr > maxXr) maxXr = xr;
        if (zr < minZr) minZr = zr;
        if (zr > maxZr) maxZr = zr;
      }

      const cxr = 0.5 * (minXr + maxXr);
      const czr = 0.5 * (minZr + maxZr);

      const centerX = meanX + (cxr * c - czr * s);
      const centerZ = meanZ + (cxr * s + czr * c);

      const sizeX = Math.max(0.001, maxXr - minXr);
      const sizeZ = Math.max(0.001, maxZr - minZr);
      const sizeY = Math.max(0.001, yMax - yMin);
      const centerY = 0.5 * (yMin + yMax);

      root.userData.vehicleOutlineLocalOBB = {
        centerLocal: new THREE.Vector3(centerX, centerY, centerZ),
        sizeLocal: new THREE.Vector3(sizeX, sizeY, sizeZ),
        yawLocal: yaw
      };
    }
  }

  ensureVehicleSilhouetteOutline(root);

  if (!vehicleOutlineHelper) {
    const geom = new THREE.EdgesGeometry(new THREE.BoxGeometry(1, 1, 1));
    const mat = new THREE.LineBasicMaterial({ color: 0xffffff });
    vehicleOutlineHelper = new THREE.LineSegments(geom, mat);
    vehicleOutlineHelper.frustumCulled = false;
    vehicleOutlineHelper.renderOrder = 999;
  }

  if (vehicleOutlineHelper.parent !== root) {
    if (vehicleOutlineHelper.parent) vehicleOutlineHelper.parent.remove(vehicleOutlineHelper);
    root.add(vehicleOutlineHelper);
  }

  const obb = root.userData.vehicleOutlineLocalOBB;

  vehicleOutlineHelper.visible = true;
  vehicleOutlineHelper.position.copy(obb.centerLocal);
  vehicleOutlineHelper.rotation.set(0, obb.yawLocal, 0);
  vehicleOutlineHelper.scale.set(obb.sizeLocal.x, obb.sizeLocal.y, obb.sizeLocal.z);

  setVehicleSilhouetteOutlineVisible(root, true);
}








    /**
     * Registers a vehicle instance for proximity interaction and driving.
     */
function registerVehicleInstance(inst, instCfg) {
  /**
   * Collects named sub-parts for vehicles (wheels/propellers/etc.) for debugging and future animation hooks.
   * Returns stable references to Object3D nodes found by name heuristics and a full name index.
   */
  function scanVehicleNamedParts(root) {
    const wheels = [];
    const propellers = [];
    const named = Object.create(null);
    const allNames = [];

    root.traverse((obj) => {
      const raw = typeof obj.name === "string" ? obj.name.trim() : "";
      if (!raw) return;

      named[raw] = obj;
      allNames.push(raw);

      const n = raw.toLowerCase();

      if (n.includes("wheel") || n.startsWith("whl") || n.includes("tyre") || n.includes("tire")) {
        wheels.push(obj);
        return;
      }

      if (
        n.includes("propeller") ||
        n === "prop" ||
        n.startsWith("prop_") ||
        n.includes("rotor") ||
        n.includes("fan")
        ) {
        propellers.push(obj);
    }
  });

    wheels.sort((a, b) => (a.name || "").localeCompare(b.name || ""));
    propellers.sort((a, b) => (a.name || "").localeCompare(b.name || ""));

    return { wheels, propellers, named, allNames };
  }

  /**
   * Builds a lightweight debug handle that can be stored from the console for manual traversal.
   * No globals are created; the handle is only emitted via console logging.
   */
  function makeVehicleDebugHandle(id, meta, root, parts) {
    return {
      id,
      type: (meta && meta.type) || "Vehicle",
      object: root,
      parts: {
        wheels: parts.wheels,
        propellers: parts.propellers,
        named: parts.named
      },
      listNames() {
        return parts.allNames.slice();
      },
      getByName(name) {
        if (!name) return null;
        return parts.named[name] || null;
      },
      findBySubstring(substr) {
        const q = (substr || "").toLowerCase();
        if (!q) return [];
        const out = [];
        for (let i = 0; i < parts.allNames.length; i++) {
          const nm = parts.allNames[i];
          if (nm.toLowerCase().includes(q)) out.push(nm);
        }
        return out;
      }
    };
  }

  if (!instCfg || !instCfg.vehicle) return;

  inst.updateWorldMatrix(true, true);
  vehicleTmpBox.setFromObject(inst);

  if (!Number.isFinite(vehicleTmpBox.min.x) || !Number.isFinite(vehicleTmpBox.max.x)) return;

  vehicleTmpBox.getCenter(vehicleTmpCenter);
  vehicleTmpBox.getSize(vehicleTmpSize);

  const radius = Math.max(0.35, 0.5 * Math.max(vehicleTmpSize.x, vehicleTmpSize.z));
  const meta = instCfg.vehicle;

  const parts = scanVehicleNamedParts(inst);
  inst.userData.vehicleParts = parts;

  const v = {
    id: instCfg.id || "",
    object: inst,
    meta,
    radius,
    parts
  };

  vehicleInteractables.push(v);

  const debugHandle = makeVehicleDebugHandle(v.id, meta, inst, parts);
  inst.userData.vehicleDebug = debugHandle;

  console.groupCollapsed(
`[vehicle] loaded "${v.id || "(no-id)"}" (${(meta && meta.type) || "Vehicle"})`
);
  console.log("root:", inst);
  console.log("meta:", meta);
  console.log("detected:", {
    wheels: parts.wheels.map((o) => o.name),
    propellers: parts.propellers.map((o) => o.name),
    namedCount: parts.allNames.length
  });
  console.log("debug-handle:", debugHandle);
  console.groupEnd();
}


/**
 * Registers an equipment instance for proximity interaction and avatar attachment.
 */
/**
 * Registers an equipment instance for proximity interaction and avatar attachment.
 */
function registerEquipmentInstance(inst, instCfg) {
  /* Registers equipment instance for proximity interaction and avatar attachment using bounds center for stable pickup distance. */
  if (!instCfg || !inst) return;

  const metaEquip = (instCfg.equipment && typeof instCfg.equipment === "object") ? instCfg.equipment : null;
  const metaWorld = (instCfg.meta && typeof instCfg.meta === "object") ? instCfg.meta : null;

  const metaKind = metaWorld && typeof metaWorld.kind === "string" ? String(metaWorld.kind) : "";
  const isPickup = (metaKind === "food" || metaKind === "pickup");
  const isEquipment = !!metaEquip;

  if (!isEquipment && !isPickup) return;

  inst.updateWorldMatrix(true, true);
  equipmentTmpBox.setFromObject(inst);

  if (!Number.isFinite(equipmentTmpBox.min.x) || !Number.isFinite(equipmentTmpBox.max.x)) return;

  equipmentTmpBox.getCenter(equipmentTmpCenter);
  equipmentTmpBox.getSize(equipmentTmpSize);

  const radius = Math.max(0.25, 0.5 * Math.max(equipmentTmpSize.x, equipmentTmpSize.z));
  const localCenter = inst.worldToLocal(equipmentTmpCenter.clone());

  const e = {
    id: instCfg.id || "",
    kind: isEquipment ? "equipment" : "pickup",
    object: inst,
    meta: isEquipment ? metaEquip : metaWorld,
    radius,
    localCenter
  };

  equipmentInteractables.push(e);

  inst.userData.equipmentMeta = e.meta;
  inst.userData.equipmentLocalCenter = localCenter;
  inst.userData.equipmentKind = e.kind;
}



/**
 * Finds the nearest equipment item within reach of the avatar.
 */
function findNearbyEquipment() {
  if (!avatar) return null;

  const pos = avatar.position;
  let best = null;
  let bestD2 = Infinity;

  for (let i = 0; i < equipmentInteractables.length; i++) {
    const e = equipmentInteractables[i];
    if (!e || !e.object) continue;

    if (e.localCenter) {
      equipmentTmpPos.copy(e.localCenter).applyMatrix4(e.object.matrixWorld);
    } else {
      e.object.getWorldPosition(equipmentTmpPos);
    }

    const dx = pos.x - equipmentTmpPos.x;
    const dz = pos.z - equipmentTmpPos.z;

    const reach = (avatarCollision.radius + e.radius + 0.65);
    const d2 = dx * dx + dz * dz;

    if (d2 <= reach * reach && d2 < bestD2) {
      bestD2 = d2;
      best = e;
    }
  }

  return best;
}






    /**
     * Finds the nearest vehicle within interaction range.
     */
function findNearbyVehicle() {
  if (!avatar) return null;

  const pos = avatar.position;
  let best = null;
  let bestD2 = Infinity;

  for (let i = 0; i < vehicleInteractables.length; i++) {
    const v = vehicleInteractables[i];
    if (!v || !v.object) continue;

    v.object.getWorldPosition(vehicleTmpPos);

    const dx = pos.x - vehicleTmpPos.x;
    const dz = pos.z - vehicleTmpPos.z;

    const reach = (avatarCollision.radius + v.radius + 0.65);
    const d2 = dx * dx + dz * dz;

    if (d2 <= reach * reach && d2 < bestD2) {
      bestD2 = d2;
      best = v;
    }
  }

  return best;
}




/**
 * Enters vehicle mode: locks controls to the vehicle and seats the avatar.
 * Vehicle chase camera is enabled on entry so camera always follows while driving.
 */
function enterVehicle(v) {
  if (!v || !v.object || !v.meta) return;
  if (!avatar || !avatarState.enabled) return;

  const carryChase = !!avatarChaseCamState.enabled;

  setAvatarChaseCameraEnabled(false);

  vehicleDriveState.enabled = true;
  vehicleDriveState.vehicle = v;
  vehicleDriveState.speed = 0.0;
  vehicleDriveState.yaw = v.object.rotation.y + (v.meta.yawOffset || 0.0);
  vehicleDriveState.steerAngle = 0.0;
  vehicleDriveState.pitch = 0.0;
  vehicleDriveState.roll = 0.0;
  vehicleDriveState.pitchVel = 0.0;
  vehicleDriveState.rollVel = 0.0;

  vehicleDriveState.liftY = 0.0;
  vehicleDriveState.groundOffsetY = v.object.position.y - getWorldSurfaceY(v.object.position.x, v.object.position.z);

  vehicleDriveState.lastTrackValid = false;
  vehicleDriveState.trackAcc = 0.0;

  if (avatarMixer && avatarActions.sit) {
    switchAvatarAction("drive");
  } else if (avatarMixer && avatarActions.idle) {
    switchAvatarAction("idle");
  }

  setVehiclePrompt(true, v);

  setVehicleChaseCameraEnabled(true);

  if (carryChase) {
    vehicleChaseCamState.userOverride = true;
    vehicleChaseCamState.pendingRecenter = false;
    vehicleChaseCamState.userInteracting = false;
    lastInteractionTime = performance.now() * 0.001;
  } else {
    vehicleChaseCamState.userOverride = false;
    vehicleChaseCamState.pendingRecenter = false;
    vehicleChaseCamState.userInteracting = false;
    lastInteractionTime = performance.now() * 0.001;
  }

  if (typeof showActionToast === "function") {
    const desc = (v.meta && typeof v.meta.description === "string" && v.meta.description.trim())
    ? v.meta.description.trim()
    : String(v.meta.type || "Vehicle");
    showActionToast(`ENTER â€¢ ${desc}`);
  }

  resetJoystick();
}








/**
 * Exits vehicle mode: restores avatar walking controls and places avatar beside the vehicle on the surface.
 * Uses vehicleDriveState yaw (not vehicle Euler) so slope-tilt does not break exit placement.
 */
function exitVehicle() {
  const v = vehicleDriveState.vehicle;
  if (!vehicleDriveState.enabled || !v || !v.object) return;

  setVehicleChaseCameraEnabled(false);

  v.object.getWorldPosition(vehicleTmpPos);

  const side = 1.1 + (v.radius || 0.8);
  const yaw = vehicleDriveState.yaw;

  const outX = vehicleTmpPos.x + Math.sin(yaw + Math.PI * 0.5) * side;
  const outZ = vehicleTmpPos.z + Math.cos(yaw + Math.PI * 0.5) * side;
  const outY = getWorldSurfaceY(outX, outZ);

  avatar.position.set(outX, outY, outZ);

  avatar.quaternion.identity();
  avatar.rotation.set(0, yaw, 0);

  /* Seed avatar camera follow so switching from vehicle -> avatar does not snap camera behind the avatar. */
  avatarLastWorldPos.set(outX, outY, outZ);
  avatarHasLastPos = true;

  if (controls) {
    avatar.getWorldPosition(avatarWorldPos);
    avatarHeadPos.copy(avatarWorldPos);
    avatarHeadPos.y += avatarViewConfig.thirdPersonHeight;
    controls.target.copy(avatarHeadPos);
  }

  vehicleDriveState.enabled = false;
  vehicleDriveState.vehicle = null;

  vehicleDriveState.speed = 0.0;
  vehicleDriveState.yaw = 0.0;
  vehicleDriveState.steerAngle = 0.0;
  vehicleDriveState.pitch = 0.0;
  vehicleDriveState.roll = 0.0;
  vehicleDriveState.pitchVel = 0.0;
  vehicleDriveState.rollVel = 0.0;

  vehicleDriveState.liftY = 0.0;
  vehicleDriveState.groundOffsetY = 0.0;

  vehicleDriveState.lastTrackValid = false;
  vehicleDriveState.trackAcc = 0.0;

  if (avatarVelocity) {
    avatarVelocity.set(0, 0, 0);
  }

  if (avatarMixer && avatarActions.idle) {
    switchAvatarAction("idle");
  }

  setVehiclePrompt(false, null);
  updateVehicleOutlineFor(null);

  if (typeof showActionToast === "function") showActionToast("EXIT â€¢ vehicle");

  resetJoystick();
}






/**
 * Finds an attachment node on the avatar by bone name; falls back to the avatar root when missing.
 */
function getAvatarEquipAttachmentNode(boneName) {
  if (!avatar) return null;

  const nm = String(boneName || "").trim();
  if (!nm) return avatar;

  const cache =
  (avatar.userData && avatar.userData.equipmentBoneCache) ||
  (avatar.userData.equipmentBoneCache = Object.create(null));

  if (cache[nm] !== undefined) return cache[nm] || avatar;

  let best = null;

  avatar.traverse((o) => {
    if (best) return;
    if (o && o.isBone && typeof o.name === "string" && o.name === nm) best = o;
  });

  if (!best) {
    const lower = nm.toLowerCase();
    avatar.traverse((o) => {
      if (best) return;
      if (o && o.isBone && typeof o.name === "string" && o.name.toLowerCase() === lower) best = o;
    });
  }

  cache[nm] = best || null;
  return best || avatar;
}

/**
 * Attaches a nearby equipment object to the avatar and activates its idle override action if present.
 */
function equipItem(e) {
  if (!avatar || !scene || !e || !e.object) return;
  if (vehicleDriveState.enabled) return;
  if (equipmentState.enabled) return;

  const obj = e.object;
  const meta = (e.meta && typeof e.meta === "object") ? e.meta : {};
  const attach = (meta.attach && typeof meta.attach === "object") ? meta.attach : {};

  equipmentState.item = e;
  equipmentState.enabled = true;

  equipmentState.originalParent = obj.parent || null;
  equipmentState.originalPosition.copy(obj.position);
  equipmentState.originalQuaternion.copy(obj.quaternion);
  equipmentState.originalScale.copy(obj.scale);

  const action = typeof meta.action === "string" ? meta.action.trim() : "";
  equipmentState.idleAction = action;

  obj.removeFromParent();

  const bone = typeof attach.bone === "string" ? attach.bone.trim() : "";
  const node = getAvatarEquipAttachmentNode(bone) || avatar;

  node.updateWorldMatrix(true, false);
  node.getWorldScale(equipmentTmpWorldScale);

  const wsx = Math.abs(equipmentTmpWorldScale.x) > 1e-6 ? equipmentTmpWorldScale.x : 1.0;
  const wsy = Math.abs(equipmentTmpWorldScale.y) > 1e-6 ? equipmentTmpWorldScale.y : 1.0;
  const wsz = Math.abs(equipmentTmpWorldScale.z) > 1e-6 ? equipmentTmpWorldScale.z : 1.0;

  node.add(obj);

  const p = Array.isArray(attach.position) && attach.position.length === 3 ? attach.position : [0, 0.06, -0.22];
  const r = Array.isArray(attach.rotation) && attach.rotation.length === 3 ? attach.rotation : [0, 0, 0];

  obj.position.set(
    Number.isFinite(p[0]) ? p[0] : 0,
    Number.isFinite(p[1]) ? p[1] : 0,
    Number.isFinite(p[2]) ? p[2] : 0
    );

  obj.rotation.set(
    Number.isFinite(r[0]) ? r[0] : 0,
    Number.isFinite(r[1]) ? r[1] : 0,
    Number.isFinite(r[2]) ? r[2] : 0
    );

  const s = attach.scale;

  if (Array.isArray(s) && s.length === 3) {
    const sx = Number.isFinite(s[0]) ? s[0] : 1;
    const sy = Number.isFinite(s[1]) ? s[1] : 1;
    const sz = Number.isFinite(s[2]) ? s[2] : 1;

    obj.scale.set(
      sx / wsx,
      sy / wsy,
      sz / wsz
      );
  } else if (Number.isFinite(s)) {
    const ss = s;
    obj.scale.set(
      ss / wsx,
      ss / wsy,
      ss / wsz
      );
  } else {
    obj.scale.set(
      1.0 / wsx,
      1.0 / wsy,
      1.0 / wsz
      );
  }

  switchAvatarAction("idle");
  setVehiclePrompt(true, e);
  updateVehicleOutlineFor(null);
}


/**
 * Detaches the currently equipped item, restores its pre-equip transform/visibility,
 * and drops it in front of the avatar so it remains re-interactable in the world.
 */
function unequipItem() {
  if (!equipmentState.enabled || !equipmentState.item || !avatar || !scene) return;

  const e = equipmentState.item;
  const obj = e && e.object ? e.object : null;

  if (!obj) {
    equipmentState.enabled = false;
    equipmentState.item = null;
    equipmentState.idleAction = "";
    equipmentState.originalParent = null;
    equipmentState.originalPosition.set(0, 0, 0);
    equipmentState.originalQuaternion.set(0, 0, 0, 1);
    equipmentState.originalScale.set(1, 1, 1);
    setVehiclePrompt(false, null);
    updateVehicleOutlineFor(null);
    return;
  }

  obj.removeFromParent();
  scene.add(obj);

  obj.traverse((o) => {
    if (o && typeof o.visible === "boolean") o.visible = true;
  });

  obj.position.copy(equipmentState.originalPosition);
  obj.quaternion.copy(equipmentState.originalQuaternion);
  obj.scale.copy(equipmentState.originalScale);

  const dist = 1.25;
  equipmentTmpForward.set(0, 0, -1).applyAxisAngle(equipmentWorldUp, avatar.rotation.y);

  obj.position.copy(avatar.position).addScaledVector(equipmentTmpForward, dist);
  obj.position.y = avatar.position.y;

  obj.rotation.set(0, avatar.rotation.y + Math.PI, 0);
  obj.updateMatrixWorld(true);

  equipmentState.enabled = false;
  equipmentState.item = null;
  equipmentState.idleAction = "";
  equipmentState.originalParent = null;
  equipmentState.originalPosition.set(0, 0, 0);
  equipmentState.originalQuaternion.set(0, 0, 0, 1);
  equipmentState.originalScale.set(1, 1, 1);

  switchAvatarAction("idle");
  setVehiclePrompt(false, null);
  updateVehicleOutlineFor(null);
}


/**
 * Equipment attachment tuning state for lil-gui, bound to the current equipment target:
 * - while equipped: the equipped item
 * - otherwise: the currently nearby (prompt) equipment
 */
const equipmentTuningState = {
  available: false,
  id: "",
  type: "",
  description: "",

  bone: "",

  posX: 0.0,
  posY: 0.06,
  posZ: -0.22,

  rotX: 0.0,
  rotY: 0.0,
  rotZ: 0.0,

  scale: 1.0
};

let equipmentTuningLastId = "";
let equipmentTuningFolder = null;

/**
 * Resolves the current tuning target equipment based on interaction/equip state.
 */
function getEquipmentTuningTarget() {
  if (equipmentState.enabled && equipmentState.item) return equipmentState.item;
  if (vehiclePromptState.open && vehiclePromptState.nearby && vehiclePromptState.nearby.kind === "equipment") return vehiclePromptState.nearby;
  return null;
}

/**
 * Copies equipment attachment values into the tuning state (used for GUI display/listen).
 */
function readEquipmentMetaIntoTuningState(e) {
  if (!e || !e.meta) return;
  equipmentTuningState.available = true;
  equipmentTuningState.id = e.id || "";
  equipmentTuningState.type = e.meta.type || "Item";
  equipmentTuningState.description = e.meta.description || "";
  const attach = (e.meta.attach && typeof e.meta.attach === "object") ? e.meta.attach : {};
  equipmentTuningState.bone = typeof attach.bone === "string" ? attach.bone : "";
  const p = Array.isArray(attach.position) && attach.position.length === 3 ? attach.position : [0, 0.06, -0.22];
  equipmentTuningState.posX = Number.isFinite(p[0]) ? p[0] : 0.0;
  equipmentTuningState.posY = Number.isFinite(p[1]) ? p[1] : 0.06;
  equipmentTuningState.posZ = Number.isFinite(p[2]) ? p[2] : -0.22;
  const r = Array.isArray(attach.rotation) && attach.rotation.length === 3 ? attach.rotation : [0, 0, 0];
  equipmentTuningState.rotX = Number.isFinite(r[0]) ? r[0] : 0.0;
  equipmentTuningState.rotY = Number.isFinite(r[1]) ? r[1] : 0.0;
  equipmentTuningState.rotZ = Number.isFinite(r[2]) ? r[2] : 0.0;
  const s = attach.scale;
  if (Array.isArray(s) && s.length === 3) {
    let sx = Number.isFinite(s[0]) ? s[0] : 1.0;
    let sy = Number.isFinite(s[1]) ? s[1] : 1.0;
    let sz = Number.isFinite(s[2]) ? s[2] : 1.0;
    if (sx > 10 || sy > 10 || sz > 10) {
      sx *= 0.01;
      sy *= 0.01;
      sz *= 0.01;
    }
    equipmentTuningState.scale = (sx + sy + sz) / 3.0;
  } else if (Number.isFinite(s)) {
    equipmentTuningState.scale = (s > 10) ? (s * 0.01) : s;
  } else {
    equipmentTuningState.scale = 1.0;
  }
}


/**
 * Writes the tuning state back to the target equipment meta (saved with worlds).
 */
function writeTuningStateIntoEquipmentMeta(e) {
  if (!e || !e.meta) return;

  if (!e.meta.attach || typeof e.meta.attach !== "object") e.meta.attach = {};
  const attach = e.meta.attach;

  attach.bone = String(equipmentTuningState.bone || "").trim();

  attach.position = [
    Number.isFinite(equipmentTuningState.posX) ? equipmentTuningState.posX : 0.0,
    Number.isFinite(equipmentTuningState.posY) ? equipmentTuningState.posY : 0.06,
    Number.isFinite(equipmentTuningState.posZ) ? equipmentTuningState.posZ : -0.22
  ];

  attach.rotation = [
    Number.isFinite(equipmentTuningState.rotX) ? equipmentTuningState.rotX : 0.0,
    Number.isFinite(equipmentTuningState.rotY) ? equipmentTuningState.rotY : 0.0,
    Number.isFinite(equipmentTuningState.rotZ) ? equipmentTuningState.rotZ : 0.0
  ];

  attach.scale = Number.isFinite(equipmentTuningState.scale) ? Math.max(0.001, equipmentTuningState.scale) : 1.0;
}

/**
 * Applies the current equipment meta.attach transform to the equipped object (bone-relative, scale-compensated).
 */
function applyEquipmentAttachmentNow(e) {
  if (!avatar || !e || !e.object || !e.meta) return;
  if (!equipmentState.enabled || equipmentState.item !== e) return;

  if (!e.meta.attach || typeof e.meta.attach !== "object") e.meta.attach = {};
  const attach = e.meta.attach;

  const bone = typeof attach.bone === "string" ? attach.bone.trim() : "";
  const node = getAvatarEquipAttachmentNode(bone) || avatar;
  if (!node) return;

  const obj = e.object;

  if (obj.parent !== node) {
    obj.removeFromParent();
    node.add(obj);
  }

  node.updateWorldMatrix(true, false);
  node.getWorldScale(equipmentTmpWorldScale);

  const wsx = Math.abs(equipmentTmpWorldScale.x) > 1e-6 ? equipmentTmpWorldScale.x : 1.0;
  const wsy = Math.abs(equipmentTmpWorldScale.y) > 1e-6 ? equipmentTmpWorldScale.y : 1.0;
  const wsz = Math.abs(equipmentTmpWorldScale.z) > 1e-6 ? equipmentTmpWorldScale.z : 1.0;

  const p = Array.isArray(attach.position) && attach.position.length === 3 ? attach.position : [0, 0.06, -0.22];
  const r = Array.isArray(attach.rotation) && attach.rotation.length === 3 ? attach.rotation : [0, 0, 0];

  obj.position.set(
    Number.isFinite(p[0]) ? p[0] : 0.0,
    Number.isFinite(p[1]) ? p[1] : 0.0,
    Number.isFinite(p[2]) ? p[2] : 0.0
    );

  obj.rotation.set(
    Number.isFinite(r[0]) ? r[0] : 0.0,
    Number.isFinite(r[1]) ? r[1] : 0.0,
    Number.isFinite(r[2]) ? r[2] : 0.0
    );

  const s = attach.scale;

  if (Array.isArray(s) && s.length === 3) {
    const sx = Number.isFinite(s[0]) ? s[0] : 1.0;
    const sy = Number.isFinite(s[1]) ? s[1] : 1.0;
    const sz = Number.isFinite(s[2]) ? s[2] : 1.0;

    obj.scale.set(
      sx / wsx,
      sy / wsy,
      sz / wsz
      );
  } else if (Number.isFinite(s)) {
    const ss = Math.max(0.001, s);
    obj.scale.set(
      ss / wsx,
      ss / wsy,
      ss / wsz
      );
  } else {
    obj.scale.set(
      1.0 / wsx,
      1.0 / wsy,
      1.0 / wsz
      );
  }

  obj.updateMatrixWorld(true);
}

/**
 * Keeps the equipment tuning state aligned with the current selection.
 */
function syncEquipmentTuningSelection() {
  if (!equipmentTuningFolder) return;

  const e = getEquipmentTuningTarget();
  const id = e ? (e.id || "") : "";

  if (!e) {
    equipmentTuningState.available = false;
    equipmentTuningState.id = "";
    equipmentTuningState.type = "";
    equipmentTuningState.description = "";
    equipmentTuningState.bone = "";
    equipmentTuningLastId = "";
    return;
  }

  if (id === equipmentTuningLastId) return;

  equipmentTuningLastId = id;
  readEquipmentMetaIntoTuningState(e);
}

/**
 * Sets up lil-gui controls for the selected equipment attachment transform.
 */
function setupEquipmentTuningGui(folder) {
  equipmentTuningFolder = folder;

  const info = folder.addFolder("Selection");
  info.add(equipmentTuningState, "available").name("Available").listen();
  info.add(equipmentTuningState, "id").name("Id").listen();
  info.add(equipmentTuningState, "type").name("Type").listen();
  info.add(equipmentTuningState, "description").name("Description").listen();
  info.close();

  const attach = folder.addFolder("Attach");

  attach.add(equipmentTuningState, "bone").name("Bone").listen().onFinishChange(() => {
    const e = getEquipmentTuningTarget();
    writeTuningStateIntoEquipmentMeta(e);
    applyEquipmentAttachmentNow(e);
  });

  attach.add(equipmentTuningState, "posX", -150.0, 150.0, 0.001).name("Pos X").listen().onChange(() => {
    const e = getEquipmentTuningTarget();
    writeTuningStateIntoEquipmentMeta(e);
    applyEquipmentAttachmentNow(e);
  });

  attach.add(equipmentTuningState, "posY", -150.0, 150.0, 0.001).name("Pos Y").listen().onChange(() => {
    const e = getEquipmentTuningTarget();
    writeTuningStateIntoEquipmentMeta(e);
    applyEquipmentAttachmentNow(e);
  });

  attach.add(equipmentTuningState, "posZ", -150.0, 150.0, 0.001).name("Pos Z").listen().onChange(() => {
    const e = getEquipmentTuningTarget();
    writeTuningStateIntoEquipmentMeta(e);
    applyEquipmentAttachmentNow(e);
  });

  attach.add(equipmentTuningState, "rotX", -Math.PI, Math.PI, 0.001).name("Rot X").listen().onChange(() => {
    const e = getEquipmentTuningTarget();
    writeTuningStateIntoEquipmentMeta(e);
    applyEquipmentAttachmentNow(e);
  });

  attach.add(equipmentTuningState, "rotY", -Math.PI, Math.PI, 0.001).name("Rot Y").listen().onChange(() => {
    const e = getEquipmentTuningTarget();
    writeTuningStateIntoEquipmentMeta(e);
    applyEquipmentAttachmentNow(e);
  });

  attach.add(equipmentTuningState, "rotZ", -Math.PI, Math.PI, 0.001).name("Rot Z").listen().onChange(() => {
    const e = getEquipmentTuningTarget();
    writeTuningStateIntoEquipmentMeta(e);
    applyEquipmentAttachmentNow(e);
  });

  attach.add(equipmentTuningState, "scale", 0.01, 10.0, 0.01).name("Scale").listen().onChange(() => {
    const e = getEquipmentTuningTarget();
    writeTuningStateIntoEquipmentMeta(e);
    applyEquipmentAttachmentNow(e);
  });

  attach.close();
}




    // -------------------------------------------------------------------------
    // World edit selection inspector (lil-gui)
    // -------------------------------------------------------------------------

let worldEditObjectFolder = null;

const worldEditObjectState = {
  available: false,

  entryName: "",
  url: "",
  id: "",

  posX: 0.0,
  posY: 0.0,
  posZ: 0.0,

  rotX: 0.0,
  rotY: 0.0,
  rotZ: 0.0,

  uniformScale: true,
  scale: 1.0,
  scaleX: 1.0,
  scaleY: 1.0,
  scaleZ: 1.0
};

const worldEditObjectActions = {
      /* Copies the currently selected world-edit object transform snapshot as JSON text to the clipboard. */
  copy: () => {
    copyWorldEditObjectSnapshotToClipboard();
  }
};

    /* Updates the Object folder state from the currently selected world-edit root (if any). */
function syncWorldEditObjectGuiSelection() {
  if (!worldEditObjectFolder) return;

  const root = worldEditState.enabled ? worldEditState.selected : null;

  if (!root) {
    worldEditObjectState.available = false;
    worldEditObjectState.entryName = "";
    worldEditObjectState.url = "";
    worldEditObjectState.id = "";

    worldEditObjectState.posX = 0.0;
    worldEditObjectState.posY = 0.0;
    worldEditObjectState.posZ = 0.0;

    worldEditObjectState.rotX = 0.0;
    worldEditObjectState.rotY = 0.0;
    worldEditObjectState.rotZ = 0.0;

    worldEditObjectState.uniformScale = true;
    worldEditObjectState.scale = 1.0;
    worldEditObjectState.scaleX = 1.0;
    worldEditObjectState.scaleY = 1.0;
    worldEditObjectState.scaleZ = 1.0;
    return;
  }

  const found = findWorldEditConfigForRoot(root);

  worldEditObjectState.available = true;
  worldEditObjectState.entryName = found && found.entry && found.entry.name != null ? String(found.entry.name) : "";
  worldEditObjectState.url = found && found.entry && found.entry.url != null ? String(found.entry.url) : "";
  worldEditObjectState.id = found && found.instCfg && found.instCfg.id != null ? String(found.instCfg.id) : "";

  worldEditObjectState.posX = root.position.x;
  worldEditObjectState.posY = root.position.y;
  worldEditObjectState.posZ = root.position.z;

  worldEditObjectState.rotX = root.rotation.x;
  worldEditObjectState.rotY = root.rotation.y;
  worldEditObjectState.rotZ = root.rotation.z;

  const sx = root.scale.x;
  const sy = root.scale.y;
  const sz = root.scale.z;

  const eps = 1e-6;
  const uniform = Math.abs(sx - sy) < eps && Math.abs(sx - sz) < eps;

  worldEditObjectState.uniformScale = uniform;
  worldEditObjectState.scale = uniform ? sx : sx;

  worldEditObjectState.scaleX = sx;
  worldEditObjectState.scaleY = sy;
  worldEditObjectState.scaleZ = sz;
}



    /* Produces a JSON-safe deep clone of config objects (drops runtime/Three.js references). */
function sanitizeWorldEditJson(value) {
  return JSON.parse(JSON.stringify(value, (k, v) => {
    if (typeof v === "function") return undefined;

    if (
      k === "runtimeObject" ||
      k === "object" ||
      k === "mesh" ||
      k === "model" ||
      k === "gltf" ||
      k === "scene" ||
      k === "parent"
      ) {
      return undefined;
  }

  if (v && typeof v === "object") {
    if (v.isObject3D || v.isScene || v.isMesh || v.isGroup) return undefined;
  }

  return v;
}));
}




    /* Builds a full entry+instance JSON snapshot of the selected world-edit object. */
function buildWorldEditObjectSnapshot() {
  const root = worldEditState.enabled ? worldEditState.selected : null;
  if (!root) return null;

  const found = findWorldEditConfigForRoot(root);
  if (!found || !found.entry || !found.instCfg) return null;

  const entryCopy = sanitizeWorldEditJson(found.entry);
  const instCopy = sanitizeWorldEditJson(found.instCfg);

  const sx = root.scale.x;
  const sy = root.scale.y;
  const sz = root.scale.z;

  const eps = 1e-6;
  const uniform = Math.abs(sx - sy) < eps && Math.abs(sx - sz) < eps;

  instCopy.position = [root.position.x, root.position.y, root.position.z];
  instCopy.rotation = [root.rotation.x, root.rotation.y, root.rotation.z];
  instCopy.scale = uniform ? sx : [sx, sy, sz];

  entryCopy.name = entryCopy.name != null ? entryCopy.name : (found.entry.name != null ? String(found.entry.name) : "");
  entryCopy.url = entryCopy.url != null ? entryCopy.url : (found.entry.url != null ? String(found.entry.url) : "");
  entryCopy.instances = [instCopy];

  return entryCopy;
}


    /* Copies the selected entry+instance snapshot JSON to clipboard. */
async function copyWorldEditObjectSnapshotToClipboard() {
  const snap = buildWorldEditObjectSnapshot();
  if (!snap) return;

  const text = JSON.stringify(snap, null, 2);

  try {
    if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
      await navigator.clipboard.writeText(text);
      return;
    }
  } catch (e) {
  }

  try {
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.setAttribute("readonly", "true");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.top = "-9999px";
    document.body.appendChild(ta);
    ta.select();
    document.execCommand("copy");
    document.body.removeChild(ta);
  } catch (e) {
    console.warn("Clipboard copy failed:", e);
  }
}


    /* Creates the Object folder UI (read-only fields + Copy button). */
function setupWorldEditObjectGui(folder) {
  worldEditObjectFolder = folder;

  const info = folder.addFolder("Selection");
  trackController(info.add(worldEditObjectState, "available").name("Available").listen().disable());
  trackController(info.add(worldEditObjectState, "entryName").name("Name").listen().disable());
  trackController(info.add(worldEditObjectState, "url").name("Url").listen().disable());
  trackController(info.add(worldEditObjectState, "id").name("Id").listen().disable());
  info.close();

  const t = folder.addFolder("Transform");
  trackController(t.add(worldEditObjectState, "posX").name("Pos X").listen().disable());
  trackController(t.add(worldEditObjectState, "posY").name("Pos Y").listen().disable());
  trackController(t.add(worldEditObjectState, "posZ").name("Pos Z").listen().disable());

  trackController(t.add(worldEditObjectState, "rotX").name("Rot X").listen().disable());
  trackController(t.add(worldEditObjectState, "rotY").name("Rot Y").listen().disable());
  trackController(t.add(worldEditObjectState, "rotZ").name("Rot Z").listen().disable());

  trackController(t.add(worldEditObjectState, "uniformScale").name("Uniform").listen().disable());
  trackController(t.add(worldEditObjectState, "scale").name("Scale").listen().disable());
  trackController(t.add(worldEditObjectState, "scaleX").name("Scale X").listen().disable());
  trackController(t.add(worldEditObjectState, "scaleY").name("Scale Y").listen().disable());
  trackController(t.add(worldEditObjectState, "scaleZ").name("Scale Z").listen().disable());
  t.close();

  trackController(folder.add(worldEditObjectActions, "copy").name("Copy"));

  syncWorldEditObjectGuiSelection();
}






/**
 * Adds avatar locomotion limits (step-up + ledge-fall start) controls to lil-gui.
 * Max step up blocks stepping onto ledges higher than the threshold while grounded.
 * Fall start triggers falling physics + jump animation when walking off a ledge above the threshold.
 */
function setupAvatarStepGui(folder) {
  if (!folder) return;

  const state = (window.__avatarLevelHelpersState ||= {
    enabled: false,
    baseY: 0,
    group: null,
    tiles: [],
    meshes: null
  });

  // Helper area controls (only width + height).
  if (typeof params.avatarHelpersWidth !== "number") params.avatarHelpersWidth = 10;   // tiles left/right
  if (typeof params.avatarHelpersHeight !== "number") params.avatarHelpersHeight = 12; // tiles forward/back

  // Per-value helper toggles (no master toggle).
  if (typeof params.avatarHelperShowBase !== "boolean") params.avatarHelperShowBase = false;
  if (typeof params.avatarHelperShowMaxStepUp !== "boolean") params.avatarHelperShowMaxStepUp = false;
  if (typeof params.avatarHelperShowFallStart !== "boolean") params.avatarHelperShowFallStart = false;

  // Jump helper toggles are per-slider, but both control the same "Max height" plane.
  if (typeof params.avatarHelperShowMaxHeightFromVelocity !== "boolean") params.avatarHelperShowMaxHeightFromVelocity = false;
  if (typeof params.avatarHelperShowMaxHeightFromGravity !== "boolean") params.avatarHelperShowMaxHeightFromGravity = false;

  // Jump tuning uses: maxHeight â‰ˆ v^2 / (2g)
  const jumpUi = { maxHeight: 0.0 };

  function computeJumpMaxHeight() {
    const v = Number.isFinite(avatarJumpConfig.initialVelocity) ? avatarJumpConfig.initialVelocity : 0.0;
    const g = Number.isFinite(avatarJumpConfig.gravity) ? Math.max(1e-6, avatarJumpConfig.gravity) : 1e-6;
    return (v * v) / (2.0 * g);
  }

  function recomputeJumpMaxHeight() {
    jumpUi.maxHeight = Number(computeJumpMaxHeight().toFixed(3));
  }

  function wantMaxHeightHelper() {
    return !!(params.avatarHelperShowMaxHeightFromVelocity || params.avatarHelperShowMaxHeightFromGravity);
  }

  function anyHelperVisible() {
    return !!(
      params.avatarHelperShowBase ||
      params.avatarHelperShowMaxStepUp ||
      params.avatarHelperShowFallStart ||
      wantMaxHeightHelper()
      );
  }

  function clampInt(v, lo, hi) {
    v = (v | 0);
    if (v < lo) return lo;
    if (v > hi) return hi;
    return v;
  }

  function desiredInstanceCount() {
    const w = clampInt(params.avatarHelpersWidth, 1, 60);
    const h = clampInt(params.avatarHelpersHeight, 1, 60);
    return (w * 2 + 1) * (h * 2 + 1);
  }

  function buildTiles() {
    state.tiles.length = 0;

    const w = clampInt(params.avatarHelpersWidth, 1, 60);
    const h = clampInt(params.avatarHelpersHeight, 1, 60);

    for (let z = -h; z <= h; z++) {
      for (let x = -w; x <= w; x++) {
        state.tiles.push({ x, z });
      }
    }
  }

  function disposeLevelHelpers() {
    if (!state.group) return;

    if (state.meshes) {
      const list = [state.meshes.base, state.meshes.maxStepUp, state.meshes.fallStart, state.meshes.maxHeight].filter(Boolean);
      for (let i = 0; i < list.length; i++) {
        const m = list[i];
        if (m.geometry) m.geometry.dispose();
        if (m.material) m.material.dispose();
      }
    }

    if (state.group.parent) state.group.parent.remove(state.group);

    state.enabled = false;
    state.group = null;
    state.meshes = null;
    state.tiles.length = 0;
    window.__avatarLevelHelpersTick = null;
  }

  // Depth-tested transparent planes so avatar shading is not tinted "on top".
  function makeInstancedPlane(hex, count) {
    const geo = new THREE.PlaneGeometry(1, 1);
    geo.rotateX(-Math.PI / 2);

    const mat = new THREE.MeshBasicMaterial({
      color: hex,
      transparent: true,
      opacity: 0.16,
      side: THREE.DoubleSide,
      depthTest: true,
      depthWrite: false,
      fog: false,
      polygonOffset: true,
      polygonOffsetFactor: -1,
      polygonOffsetUnits: -1
    });

    mat.toneMapped = false;

    const mesh = new THREE.InstancedMesh(geo, mat, count);
    mesh.frustumCulled = false;
    mesh.renderOrder = 10;

    if (mesh.instanceMatrix && mesh.instanceMatrix.setUsage) {
      mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
    }

    return mesh;
  }

  function updateVisibilityFromParams() {
    if (!state.meshes) return;

    if (state.meshes.base) state.meshes.base.visible = !!params.avatarHelperShowBase;
    if (state.meshes.maxStepUp) state.meshes.maxStepUp.visible = !!params.avatarHelperShowMaxStepUp;
    if (state.meshes.fallStart) state.meshes.fallStart.visible = !!params.avatarHelperShowFallStart;
    if (state.meshes.maxHeight) state.meshes.maxHeight.visible = wantMaxHeightHelper();
  }

  function updateHelpersNow() {
    if (!anyHelperVisible()) return;
    if (!avatar || !state.group || !state.meshes) return;

    updateVisibilityFromParams();

    // Base follows the avatar's current ground level (so walking onto higher terrain updates helpers).
    const groundedY =
    (typeof avatarJumpState !== "undefined" && avatarJumpState && Number.isFinite(avatarJumpState.groundY))
    ? avatarJumpState.groundY
    : (Number.isFinite(avatar.position.y) ? avatar.position.y : state.baseY);

    if (Number.isFinite(groundedY)) state.baseY = groundedY;

    const baseY = state.baseY;
    const stepY = baseY + (Number.isFinite(params.avatarMaxStepUp) ? params.avatarMaxStepUp : 0.0);
    const fallY = baseY - (Number.isFinite(params.avatarFallStart) ? params.avatarFallStart : 0.0);
    const jumpY = baseY + computeJumpMaxHeight();

    // Helpers are axis-aligned in world-space (no rotation with avatar).
    state.group.position.set(avatar.position.x, 0, avatar.position.z);
    state.group.rotation.set(0, 0, 0);

    const eps = 0.05;

    const setLevel = (inst, y) => {
      const m = new THREE.Matrix4();
      for (let i = 0; i < state.tiles.length; i++) {
        const t = state.tiles[i];
        m.makeTranslation(t.x, y + eps, t.z);
        inst.setMatrixAt(i, m);
      }
      inst.instanceMatrix.needsUpdate = true;
    };

    if (state.meshes.base && state.meshes.base.visible) setLevel(state.meshes.base, baseY);
    if (state.meshes.maxStepUp && state.meshes.maxStepUp.visible) setLevel(state.meshes.maxStepUp, stepY);
    if (state.meshes.maxHeight && state.meshes.maxHeight.visible) setLevel(state.meshes.maxHeight, jumpY);
    if (state.meshes.fallStart && state.meshes.fallStart.visible) setLevel(state.meshes.fallStart, fallY);
  }

  function ensureLevelHelpers() {
    if (!anyHelperVisible()) {
      disposeLevelHelpers();
      return;
    }

    if (!avatar || !scene) return;

    const wantCount = desiredInstanceCount();
    const haveCount = state.meshes?.base?.count || 0;

    if (state.group && haveCount && wantCount !== haveCount) {
      disposeLevelHelpers();
    }

    if (!state.group) {
      state.enabled = true;

      const grounded =
      (typeof avatarJumpState !== "undefined" && avatarJumpState && Number.isFinite(avatarJumpState.groundY))
      ? avatarJumpState.groundY
      : (Number.isFinite(avatar.position.y) ? avatar.position.y : 0.0);

      state.baseY = grounded;

      buildTiles();
      const count = state.tiles.length;

      state.group = new THREE.Group();
      state.group.name = "AvatarLevelHelpers";
      scene.add(state.group);

      state.meshes = {
        base: makeInstancedPlane(0x00ff00, count),       // Base level (start)
        maxStepUp: makeInstancedPlane(0xffff00, count),  // Max step up
        maxHeight: makeInstancedPlane(0x00aaff, count),  // Max height (jump)
        fallStart: makeInstancedPlane(0xff3355, count)   // Fall start
      };

      state.group.add(state.meshes.base);
      state.group.add(state.meshes.maxStepUp);
      state.group.add(state.meshes.maxHeight);
      state.group.add(state.meshes.fallStart);

      window.__avatarLevelHelpersTick = updateHelpersNow;
    }

    updateHelpersNow();
  }

  function wireCtrl(ctrl, onChange) {
    if (typeof guiControllers !== "undefined" && guiControllers && guiControllers.push) {
      guiControllers.push(ctrl);
    }
    ctrl.onChange(() => {
      if (typeof onChange === "function") onChange();
      if (typeof saveLastDebounced === "function") saveLastDebounced(params);
    });
    return ctrl;
  }

  recomputeJumpMaxHeight();

  wireCtrl(
    folder.add(params, "avatarHelperShowBase").name("Base level â€” Show helper").listen(),
    () => ensureLevelHelpers()
    );

  wireCtrl(
    folder.add(params, "avatarMaxStepUp", 0.0, 3.0, 0.01).name("Max step up").listen(),
    () => ensureLevelHelpers()
    );
  wireCtrl(
    folder.add(params, "avatarHelperShowMaxStepUp").name("Show helper").listen(),
    () => ensureLevelHelpers()
    );

  wireCtrl(
    folder.add(params, "avatarFallStart", 0.0, 3.0, 0.01).name("Fall start").listen(),
    () => ensureLevelHelpers()
    );
  wireCtrl(
    folder.add(params, "avatarHelperShowFallStart").name("Show helper").listen(),
    () => ensureLevelHelpers()
    );

  wireCtrl(
    folder.add(avatarJumpConfig, "initialVelocity", 0.5, 15.0, 0.05).name("Jump velocity").listen(),
    () => {
      recomputeJumpMaxHeight();
      ensureLevelHelpers();
    }
    );
  wireCtrl(
    folder.add(params, "avatarHelperShowMaxHeightFromVelocity").name("Show helper").listen(),
    () => ensureLevelHelpers()
    );

  wireCtrl(
    folder.add(avatarJumpConfig, "gravity", 1.0, 30.0, 0.1).name("Jump gravity").listen(),
    () => {
      recomputeJumpMaxHeight();
      ensureLevelHelpers();
    }
    );
  wireCtrl(
    folder.add(params, "avatarHelperShowMaxHeightFromGravity").name("Show helper").listen(),
    () => ensureLevelHelpers()
    );

  const maxHeightCtrl = folder.add(jumpUi, "maxHeight").name("Max height (m)").listen();
  if (typeof maxHeightCtrl.disable === "function") maxHeightCtrl.disable();

  wireCtrl(
    folder.add(params, "avatarHelpersWidth", 1, 60, 1).name("Helpers width").listen(),
    () => ensureLevelHelpers()
    );
  wireCtrl(
    folder.add(params, "avatarHelpersHeight", 1, 60, 1).name("Helpers height").listen(),
    () => ensureLevelHelpers()
    );

  ensureLevelHelpers();
}







    /**
     * Vehicle profile tuning state for lil-gui, bound to the currently selected vehicle:
     * - while driving: the driven vehicle
     * - otherwise: the currently nearby (prompt) vehicle
     */
const vehicleTuningState = {
  available: false,
  id: "",
  type: "",
  description: "",

      // Seat offset for avatar while riding (vehicle-local space)
  seatX: 0.0,
  seatY: 0.6,
  seatZ: 0.0,

  maxSpeed: 10.0,
  maxReverse: 4.0,
  accel: 10.0,
  brake: 14.0,
  coastDecel: 3.0,
  turnRate: 2.4,
  radius: 0.9,

  wheelBase: 2.5,
  minTurnRadius: 3.0,
  minSteerSpeed: 0.35,
  steerResponse: 8.0,
  steerReturn: 6.0,
  lateralGrip: 8.0,

      // Plane lift and attitude tuning (used when driveMode/profile indicates a plane).
  minFlySpeed: 14.0,
  maxLift: 10.0,
  liftResponse: 5.0,

  airTurnScale: 0.35,
  airRollMax: 0.35,
  airRollResponse: 8.0,
  airRollReturn: 5.0,

  climbPitchMax: 0.22,
  climbPitchSpeed: 4.0,
  pitchResponse: 4.0,
  pitchReturn: 3.0,
  turnPitchMax: 0.10,

      // Wet trail mark dimensions (vehicle-local override; defaults to wetTrailConfig.*)
  wetWidth: wetTrailConfig.vehicleWidth,
  wetLength: wetTrailConfig.vehicleLength,

      // Vehicle snow track half-width (vehicle-local override; used by snow deformation).
  trackHalfWidth: 1.0
};




let vehicleTuningLastId = "";
let vehicleTuningFolder = null;

    /**
     * Resolves the current tuning target vehicle based on interaction/drive state.
     */
function getVehicleTuningTarget() {
  if (vehicleDriveState.enabled && vehicleDriveState.vehicle) return vehicleDriveState.vehicle;
  if (vehiclePromptState.open && vehiclePromptState.nearby) return vehiclePromptState.nearby;
  return null;
}

    /**
     * Copies vehicle profile values into the tuning state (used for GUI display/listen).
     */
function readVehicleProfileIntoTuningState(v) {
  if (!v || !v.meta) return;

  const prof = v.meta.profile || {};
  vehicleTuningState.available = true;

  vehicleTuningState.id = v.id || "";
  vehicleTuningState.type = v.meta.type || "Vehicle";
  vehicleTuningState.description = v.meta.description || "";

  const seat = Array.isArray(v.meta.seatLocal) ? v.meta.seatLocal : [0, 0.6, 0];
  vehicleTuningState.seatX = Number.isFinite(seat[0]) ? seat[0] : 0.0;
  vehicleTuningState.seatY = Number.isFinite(seat[1]) ? seat[1] : 0.6;
  vehicleTuningState.seatZ = Number.isFinite(seat[2]) ? seat[2] : 0.0;

  vehicleTuningState.maxSpeed = Math.max(0.1, prof.maxSpeed ?? 10.0);
  vehicleTuningState.maxReverse = Math.max(0.1, prof.maxReverse ?? 4.0);
  vehicleTuningState.accel = Math.max(0.1, prof.accel ?? 10.0);
  vehicleTuningState.brake = Math.max(0.1, prof.brake ?? 14.0);
  vehicleTuningState.coastDecel = Math.max(0.1, prof.coastDecel ?? 3.0);
  vehicleTuningState.turnRate = Math.max(0.1, prof.turnRate ?? 2.4);

  vehicleTuningState.radius = Math.max(0.35, prof.radius ?? 0.9);

  vehicleTuningState.wheelBase = Math.max(0.5, prof.wheelBase ?? 2.5);
  vehicleTuningState.minTurnRadius = Math.max(1.0, prof.minTurnRadius ?? 3.0);
  vehicleTuningState.minSteerSpeed = Math.max(0.0, prof.minSteerSpeed ?? 0.35);
  vehicleTuningState.steerResponse = Math.max(0.1, prof.steerResponse ?? 8.0);
  vehicleTuningState.steerReturn = Math.max(0.1, prof.steerReturn ?? 6.0);
  vehicleTuningState.lateralGrip = Math.max(0.0, prof.lateralGrip ?? 8.0);

  vehicleTuningState.minFlySpeed = Math.max(0.0, prof.minFlySpeed ?? 14.0);
  vehicleTuningState.maxLift = Math.max(0.0, prof.maxLift ?? 10.0);
  vehicleTuningState.liftResponse = Math.max(0.1, prof.liftResponse ?? 5.0);

  vehicleTuningState.airTurnScale = clamp(Number.isFinite(prof.airTurnScale) ? prof.airTurnScale : 0.35, 0.0, 1.0);
  vehicleTuningState.airRollMax = Math.max(0.0, prof.airRollMax ?? 0.35);
  vehicleTuningState.airRollResponse = Math.max(0.1, prof.airRollResponse ?? 8.0);
  vehicleTuningState.airRollReturn = Math.max(0.1, prof.airRollReturn ?? 5.0);

  vehicleTuningState.climbPitchMax = Math.max(0.0, prof.climbPitchMax ?? 0.22);
  vehicleTuningState.climbPitchSpeed = Math.max(0.1, prof.climbPitchSpeed ?? 4.0);
  vehicleTuningState.pitchResponse = Math.max(0.1, prof.pitchResponse ?? 4.0);
  vehicleTuningState.pitchReturn = Math.max(0.1, prof.pitchReturn ?? 3.0);
  vehicleTuningState.turnPitchMax = Math.max(0.0, prof.turnPitchMax ?? 0.10);

  const ww = Number.isFinite(prof.wetWidth) ? prof.wetWidth : wetTrailConfig.vehicleWidth;
  const wl = Number.isFinite(prof.wetLength) ? prof.wetLength : wetTrailConfig.vehicleLength;
  vehicleTuningState.wetWidth = Math.max(0.05, ww);
  vehicleTuningState.wetLength = Math.max(0.05, wl);

  const r = Math.max(0.35,
    Number.isFinite(prof.radius) ? prof.radius : (Number.isFinite(v.radius) ? v.radius : 0.9)
    );
  const thw = Number.isFinite(prof.trackHalfWidth) ? prof.trackHalfWidth : (r * 0.55);
  vehicleTuningState.trackHalfWidth = Math.min(4.0, Math.max(0.22, thw));
}




    /**
     * Writes the tuning state back to the target vehicle profile (live steering changes).
     */
function writeTuningStateIntoVehicleProfile(v) {
  if (!v || !v.meta) return;

  v.meta.seatLocal = [
    Number.isFinite(vehicleTuningState.seatX) ? vehicleTuningState.seatX : 0.0,
    Number.isFinite(vehicleTuningState.seatY) ? vehicleTuningState.seatY : 0.6,
    Number.isFinite(vehicleTuningState.seatZ) ? vehicleTuningState.seatZ : 0.0
  ];

  if (!v.meta.profile || typeof v.meta.profile != "object") v.meta.profile = {};
  const prof = v.meta.profile;

  prof.maxSpeed = Math.max(0.1, vehicleTuningState.maxSpeed);
  prof.maxReverse = Math.max(0.1, vehicleTuningState.maxReverse);
  prof.accel = Math.max(0.1, vehicleTuningState.accel);
  prof.brake = Math.max(0.1, vehicleTuningState.brake);
  prof.coastDecel = Math.max(0.1, vehicleTuningState.coastDecel);
  prof.turnRate = Math.max(0.1, vehicleTuningState.turnRate);

  prof.radius = Math.max(0.35, vehicleTuningState.radius);
  v.radius = prof.radius;

  prof.wheelBase = Math.max(0.5, vehicleTuningState.wheelBase);
  prof.minTurnRadius = Math.max(1.0, vehicleTuningState.minTurnRadius);
  prof.minSteerSpeed = Math.max(0.0, vehicleTuningState.minSteerSpeed);
  prof.steerResponse = Math.max(0.1, vehicleTuningState.steerResponse);
  prof.steerReturn = Math.max(0.1, vehicleTuningState.steerReturn);
  prof.lateralGrip = Math.max(0.0, vehicleTuningState.lateralGrip);

  prof.minFlySpeed = Math.max(0.0, vehicleTuningState.minFlySpeed);
  prof.maxLift = Math.max(0.0, vehicleTuningState.maxLift);
  prof.liftResponse = Math.max(0.1, vehicleTuningState.liftResponse);

  prof.airTurnScale = clamp(Number.isFinite(vehicleTuningState.airTurnScale) ? vehicleTuningState.airTurnScale : 0.35, 0.0, 1.0);
  prof.airRollMax = Math.max(0.0, vehicleTuningState.airRollMax);
  prof.airRollResponse = Math.max(0.1, vehicleTuningState.airRollResponse);
  prof.airRollReturn = Math.max(0.1, vehicleTuningState.airRollReturn);

  prof.climbPitchMax = Math.max(0.0, vehicleTuningState.climbPitchMax);
  prof.climbPitchSpeed = Math.max(0.1, vehicleTuningState.climbPitchSpeed);
  prof.pitchResponse = Math.max(0.1, vehicleTuningState.pitchResponse);
  prof.pitchReturn = Math.max(0.1, vehicleTuningState.pitchReturn);
  prof.turnPitchMax = Math.max(0.0, vehicleTuningState.turnPitchMax);

  prof.trackHalfWidth = Math.min(4.0, Math.max(0.22, vehicleTuningState.trackHalfWidth));

  prof.wetWidth = Math.max(0.05, vehicleTuningState.wetWidth);
  prof.wetLength = Math.max(0.05, vehicleTuningState.wetLength);
}




    /**
     * Keeps the tuning state aligned with the current selection (no polling/traversal hacks).
     */
function syncVehicleTuningSelection() {
  if (!vehicleTuningFolder) return;

  const v = getVehicleTuningTarget();
  const id = v ? (v.id || "") : "";

  if (!v) {
    vehicleTuningState.available = false;
    vehicleTuningState.id = "";
    vehicleTuningState.type = "";
    vehicleTuningState.description = "";
    vehicleTuningLastId = "";
    return;
  }

  if (id === vehicleTuningLastId) return;

  vehicleTuningLastId = id;
  readVehicleProfileIntoTuningState(v);
}

    /**
     * Sets up lil-gui controls for the selected vehicle profile and provides an export action.
     */
function setupVehicleTuningGui(folder) {
  vehicleTuningFolder = folder;

  const info = folder.addFolder("Selection");
  info.add(vehicleTuningState, "available").name("Available").listen();
  info.add(vehicleTuningState, "id").name("Id").listen();
  info.add(vehicleTuningState, "type").name("Type").listen();
  info.add(vehicleTuningState, "description").name("Description").listen();
  info.close();


  const seat = folder.addFolder("Seat");

  seat.add(vehicleTuningState, "seatX", -2.0, 2.0, 0.01).name("Seat X").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  seat.add(vehicleTuningState, "seatY", -1.0, 3.0, 0.01).name("Seat Y").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  seat.add(vehicleTuningState, "seatZ", -2.0, 2.0, 0.01).name("Seat Z").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  seat.close();


  const wet = folder.addFolder("Wet Trail");

  wet.add(vehicleTuningState, "wetWidth", 0.05, 3.0, 0.01).name("Mark width").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  wet.add(vehicleTuningState, "wetLength", 0.05, 4.0, 0.01).name("Mark length").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  wet.add(vehicleTuningState, "trackHalfWidth", 0.22, 4.0, 0.01).name("Track half width").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  wet.close();



  const profile = folder.addFolder("Profile");

  profile.add(vehicleTuningState, "maxSpeed", 0.5, 120.0, 0.1).name("Max speed").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "maxReverse", 0.5, 40.0, 0.1).name("Max reverse").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "accel", 0.1, 60.0, 0.1).name("Accel").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "brake", 0.1, 80.0, 0.1).name("Brake").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "coastDecel", 0.1, 40.0, 0.1).name("Coast").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "turnRate", 0.1, 12.0, 0.05).name("Turn rate").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "radius", 0.35, 4.0, 0.01).name("Radius").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "wheelBase", 0.2, 8.0, 0.01).name("Wheelbase").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "minTurnRadius", 0.5, 20.0, 0.1).name("Min radius").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "minSteerSpeed", 0.0, 3.0, 0.01).name("Min steer").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "steerResponse", 0.1, 30.0, 0.1).name("Steer resp").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "steerReturn", 0.1, 30.0, 0.1).name("Steer return").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.add(vehicleTuningState, "lateralGrip", 0.0, 30.0, 0.1).name("Grip").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  profile.close();


  const flight = folder.addFolder("Flight");

  flight.add(vehicleTuningState, "minFlySpeed", 0.0, 60.0, 0.1).name("Min fly speed").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "maxLift", 0.0, 1000.0, 1).name("Max lift").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "liftResponse", 0.1, 20.0, 0.1).name("Lift resp").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "airTurnScale", 0.0, 1.0, 0.01).name("Air turn").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "airRollMax", 0.0, 1.2, 0.01).name("Roll max").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "airRollResponse", 0.1, 30.0, 0.1).name("Roll resp").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "airRollReturn", 0.1, 30.0, 0.1).name("Roll return").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "climbPitchMax", 0.0, 0.8, 0.01).name("Pitch max").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "climbPitchSpeed", 0.1, 20.0, 0.1).name("Pitch spd").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "pitchResponse", 0.1, 30.0, 0.1).name("Pitch resp").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "pitchReturn", 0.1, 30.0, 0.1).name("Pitch return").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.add(vehicleTuningState, "turnPitchMax", 0.0, 0.5, 0.01).name("Turn pitch").listen().onChange(() => {
    const v = getVehicleTuningTarget();
    writeTuningStateIntoVehicleProfile(v);
  });

  flight.close();





  const actions = {
    exportProfile: async () => {
      const v = getVehicleTuningTarget();
      if (!v || !v.meta) return;

      writeTuningStateIntoVehicleProfile(v);

      function fmtNum(n, digits = 3) {
        const x = Number(n);
        if (!Number.isFinite(x)) return null;
        const p = Math.pow(10, digits);
        const r = Math.round(x * p) / p;
        let s = r.toFixed(digits).replace(/0+$/, "").replace(/\.$/, "");
        if (!s.includes(".")) s += ".0";
        return s;
      }

      function fmtStr(s) {
        return JSON.stringify(String(s ?? ""));
      }

      function fmtBool(b) {
        return b ? "true" : "false";
      }

      function fmtArr3(a, dx, dy, dz) {
        const x = Array.isArray(a) ? a : [dx, dy, dz];
        const sx = fmtNum(x[0]) ?? "0.0";
        const sy = fmtNum(x[1]) ?? "0.0";
        const sz = fmtNum(x[2]) ?? "0.0";
        return `[${sx}, ${sy}, ${sz}]`;
      }

      const type = v.meta.type || "Vehicle";
      const description = v.meta.description || "";
      const seatLocal = v.meta.seatLocal || [0, 0.6, 0];
      const yawOffset = Number.isFinite(v.meta.yawOffset) ? v.meta.yawOffset : 0.0;

      const prof = (v.meta.profile && typeof v.meta.profile === "object") ? v.meta.profile : {};
      const used = new Set();
      const lines = [];

      lines.push("vehicle: {");
      lines.push(`  type: ${fmtStr(type)},`);
      lines.push(`  description: ${fmtStr(description)},`);
      lines.push(`  seatLocal: ${fmtArr3(seatLocal, 0, 0.6, 0)},`);
      lines.push(`  yawOffset: ${fmtNum(yawOffset) ?? "0.0"},`);
      lines.push("  profile: {");

      function pushNum(key) {
        used.add(key);
        const val = prof[key];
        const s = fmtNum(val);
        if (s == null) return;
        lines.push(`    ${key}: ${s},`);
      }

      function pushStrKey(key) {
        used.add(key);
        const val = prof[key];
        if (typeof val !== "string") return;
        lines.push(`    ${key}: ${fmtStr(val)},`);
      }

      function pushBoolKey(key) {
        used.add(key);
        const val = prof[key];
        if (typeof val !== "boolean") return;
        lines.push(`    ${key}: ${fmtBool(val)},`);
      }

      pushNum("maxSpeed");
      pushNum("maxReverse");
      pushNum("accel");
      pushNum("brake");
      pushNum("coastDecel");
      pushNum("turnRate");
      pushNum("radius");
      pushNum("wheelBase");
      pushNum("minTurnRadius");
      pushNum("minSteerSpeed");
      pushNum("steerResponse");
      pushNum("steerReturn");
      pushNum("lateralGrip");

      pushNum("wetWidth");
      pushNum("wetLength");
      pushNum("trackHalfWidth");

      pushNum("propSpinIdle");
      pushNum("propSpinMax");
      pushNum("propSpinMul");

      pushNum("liftOffSpeed");
      pushNum("liftOffRise");
      pushNum("liftOffFall");

      pushNum("airYawRate");
      pushNum("airRollRate");
      pushNum("airRollResponse");
      pushNum("airRollReturn");

      pushNum("climbPitchMax");
      pushNum("climbPitchSpeed");
      pushNum("pitchResponse");
      pushNum("pitchReturn");
      pushNum("turnPitchMax");

      pushStrKey("driveMode");
      pushStrKey("propAxis");
      pushBoolKey("propInvert");

      const extraKeys = Object.keys(prof).filter((k) => !used.has(k)).sort();
      for (let i = 0; i < extraKeys.length; i++) {
        const k = extraKeys[i];
        const val = prof[k];

        if (typeof val === "number") {
          const s = fmtNum(val);
          if (s != null) lines.push(`    ${k}: ${s},`);
          continue;
        }
        if (typeof val === "string" && val.length) {
          lines.push(`    ${k}: ${fmtStr(val)},`);
          continue;
        }
        if (typeof val === "boolean") {
          lines.push(`    ${k}: ${fmtBool(val)},`);
          continue;
        }
      }

      if (lines[lines.length - 1].endsWith(",")) {
        lines[lines.length - 1] = lines[lines.length - 1].slice(0, -1);
      }

      lines.push("  }");
      lines.push("}");

      const out = `// MODEL_CONFIG -> instance ${JSON.stringify(v.id)} (${type})\n${lines.join("\n")}`;

      console.log(out);

      try {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          await navigator.clipboard.writeText(out);
        }
      } catch (e) {
      }

      return out;
    }
  };






  folder.add(actions, "exportProfile").name("Copy MODEL_CONFIG").listen();
}






    /**
     * Resolves simplified XZ collisions for a moving vehicle using prebuilt sphere bounds and model OBBs.
     */
function resolveVehicleXZCollisions(pos, vel, radius, ignoreObject) {
  const limX = Math.max(0.5, visualBounds.x - (radius + 0.25));
  const limZ = Math.max(0.5, visualBounds.z - (radius + 0.25));

  pos.x = clamp(pos.x, -limX, limX);
  pos.z = clamp(pos.z, -limZ, limZ);

  if (ignoreObject === true) return;

  const skin = avatarCollision.skin;

  for (let iter = 0; iter < avatarCollision.iterations; iter++) {
    let pushed = false;

    const candidates = getAvatarCollisionCandidatesXZ(pos);
    if (candidates && candidates.length) {
      for (let c = 0; c < candidates.length; c++) {
        const b = colliderBounds[candidates[c]];
        if (!b) continue;

        const sumR = radius + b.radius + skin;
        const dx = pos.x - b.center.x;
        const dz = pos.z - b.center.z;
        const d2 = dx * dx + dz * dz;

        if (d2 >= sumR * sumR) continue;

        const d = Math.sqrt(d2) || 1e-6;
        const push = sumR - d;

        const nx = dx / d;
        const nz = dz / d;

        pos.x += nx * push;
        pos.z += nz * push;

        const velDot = vel.x * nx + vel.z * nz;
        if (velDot < 0) {
          vel.x -= velDot * nx;
          vel.z -= velDot * nz;
        }

        pushed = true;
      }
    }

    if (avatarModelColliderOBBs && avatarModelColliderOBBs.length) {
      for (let i = 0; i < avatarModelColliderOBBs.length; i++) {
        const obb = avatarModelColliderOBBs[i];
        if (!obb) continue;
        if (ignoreObject && obb.object === ignoreObject) continue;

        const dxw = pos.x - obb.center.x;
        const dzw = pos.z - obb.center.z;

        const c = Math.cos(obb.yaw);
        const s = Math.sin(obb.yaw);

        const lx = dxw * c + dzw * s;
        const lz = -dxw * s + dzw * c;

        const cx = clamp(lx, -obb.halfX, obb.halfX);
        const cz = clamp(lz, -obb.halfZ, obb.halfZ);

        const dxl = lx - cx;
        const dzl = lz - cz;

        const d2 = dxl * dxl + dzl * dzl;
        const sumR = radius + skin;

        if (d2 >= sumR * sumR) continue;

        const d = Math.sqrt(d2) || 1e-6;
        const push = sumR - d;

        let nlx = dxl / d;
        let nlz = dzl / d;

        if (!Number.isFinite(nlx) || !Number.isFinite(nlz)) {
          const px = obb.halfX - Math.abs(lx);
          const pz = obb.halfZ - Math.abs(lz);
          if (px < pz) {
            nlx = lx >= 0 ? 1 : -1;
            nlz = 0;
          } else {
            nlx = 0;
            nlz = lz >= 0 ? 1 : -1;
          }
        }

        const nx = nlx * c - nlz * s;
        const nz = nlx * s + nlz * c;

        pos.x += nx * push;
        pos.z += nz * push;

        const velDot = vel.x * nx + vel.z * nz;
        if (velDot < 0) {
          vel.x -= velDot * nx;
          vel.z -= velDot * nz;
        }

        pushed = true;
      }
    }

    pos.x = clamp(pos.x, -limX, limX);
    pos.z = clamp(pos.z, -limZ, limZ);

    if (!pushed) break;
  }
}










/**
 * Advances the currently-driven vehicle simulation (ground or aircraft), applying steering, speed, movement,
 * collision resolution (XZ), then surface-follow for ground vehicles and lift/attitude for aircraft.
 * Aircraft keep taxi terrain-follow, but once airborne they no longer inherit terrain height variation.
 */
function tickVehicle(dt) {
  const v = vehicleDriveState.vehicle;
  if (!vehicleDriveState.enabled || !v || !v.object || !v.meta) return;

  const prof = v.meta.profile || {};

  const driveMode = (typeof prof.driveMode === "string") ? prof.driveMode : "";
  const isPlane = driveMode === "plane" || /airplane|plane/i.test((v.meta.type || ""));

  const maxSpeed = Math.max(0.1, prof.maxSpeed ?? 10.0);
  const maxReverse = Math.max(0.1, prof.maxReverse ?? 4.0);
  const accel = Math.max(0.1, prof.accel ?? 10.0);
  const brake = Math.max(0.1, prof.brake ?? 14.0);
  const coastDecel = Math.max(0.1, prof.coastDecel ?? 3.0);
  const turnRate = Math.max(0.1, prof.turnRate ?? 2.4);

  const radius = Math.max(0.35, (prof.radius ?? v.radius ?? 0.9));
  const wheelBase = Math.max(0.1, prof.wheelBase ?? 2.0);
  const minTurnRadius = Math.max(0.5, prof.minTurnRadius ?? 6.0);
  const lateralGrip = Math.max(0.1, prof.lateralGrip ?? 8.0);

  let forwardAmount = 0.0;
  let steerAmount = 0.0;

  const joyForward = -joystickState.valueY;
  const joySteer = joystickState.valueX;

  if (joystickState.active) {
    forwardAmount = clamp(joyForward, -1, 1);
    steerAmount = clamp(joySteer, -1, 1);
  } else {
    const f = avatarKeys.forward ? 1 : 0;
    const b = avatarKeys.back ? -1 : 0;
    forwardAmount = f + b;

    const l = avatarKeys.left ? -1 : 0;
    const r = avatarKeys.right ? 1 : 0;
    steerAmount = l + r;
  }

  forwardAmount = clamp(forwardAmount, -1, 1);
  steerAmount = clamp(steerAmount, -1, 1);

  const speedNow = vehicleDriveState.speed;
  const speedAbsPrev = Math.abs(speedNow);

  const targetSpeed =
  forwardAmount > 0
  ? forwardAmount * maxSpeed
  : forwardAmount < 0
  ? forwardAmount * maxReverse
  : 0.0;

  const speedDiff = targetSpeed - speedNow;

  if (Math.abs(forwardAmount) > 1e-3) {
    const rate = (Math.sign(targetSpeed) === Math.sign(speedNow) || speedNow === 0) ? accel : brake;
    const step = clamp(speedDiff, -rate * dt, rate * dt);
    vehicleDriveState.speed = speedNow + step;
  } else {
    const decelStep = coastDecel * dt;
    if (Math.abs(speedNow) <= decelStep) vehicleDriveState.speed = 0.0;
    else vehicleDriveState.speed = speedNow - Math.sign(speedNow) * decelStep;
  }

  const speedAbs = Math.abs(vehicleDriveState.speed);

  const minSteerSpeed = Math.max(0.0, prof.minSteerSpeed ?? 0.35);
  const steerGate = (speedAbs > minSteerSpeed) ? 1 : 0;

  const steerResponse = Math.max(0.1, prof.steerResponse ?? 8.0);
  const steerReturn = Math.max(0.1, prof.steerReturn ?? 6.0);

  const desiredSteer = steerAmount * (Math.PI * 0.5) * clamp(turnRate, 0.05, 10.0);
  const steerNow = Number.isFinite(vehicleDriveState.steerAngle) ? vehicleDriveState.steerAngle : 0.0;

  const steerK = (Math.abs(steerAmount) > 1e-3) ? steerResponse : steerReturn;
  const steerAlpha = 1 - Math.pow(0.001, steerK * dt);
  const steerAngle = steerNow + (desiredSteer - steerNow) * steerAlpha;

  vehicleDriveState.steerAngle = steerAngle;

  if (isPlane) {
    if (typeof vehicleDriveState.planeAirborne !== "boolean") vehicleDriveState.planeAirborne = false;
    if (!Number.isFinite(vehicleDriveState.planeBaseGroundY)) vehicleDriveState.planeBaseGroundY = 0.0;
  }

  if (steerGate > 0 && Math.abs(steerAngle) > 1e-5 && speedAbs > 1e-5) {
    const base = (wheelBase / Math.max(1e-6, Math.tan(Math.abs(steerAngle))));
    const turnRadius = Math.max(minTurnRadius, base);

    if (Number.isFinite(turnRadius) && turnRadius > 1e-6) {
      const steerSign = steerAngle > 0 ? 1 : -1;
      const yawRate = speedAbs / turnRadius;

      let yawDelta = (-steerSign) * yawRate * dt;

      if (isPlane && vehicleDriveState.planeAirborne) {
        const airTurnScale = clamp(Number.isFinite(prof.airTurnScale) ? prof.airTurnScale : 0.35, 0.0, 1.0);
        yawDelta *= airTurnScale;
      }

      vehicleDriveState.yaw += yawDelta;
    }
  }

  const yawAdj = vehicleDriveState.yaw - (v.meta.yawOffset || 0.0);

  if (isPlane) {
    v.object.rotation.y = yawAdj;
  }

  const fx = Math.sin(vehicleDriveState.yaw);
  const fz = Math.cos(vehicleDriveState.yaw);

  vehicleTmpVel.set(fx * vehicleDriveState.speed, 0, fz * vehicleDriveState.speed);

  vehicleTmpMove.copy(vehicleTmpVel).multiplyScalar(dt);
  v.object.position.add(vehicleTmpMove);

  resolveVehicleXZCollisions(
    v.object.position,
    vehicleTmpVel,
    radius,
    (isPlane && vehicleDriveState.planeAirborne) ? true : v.object
    );

  if (isPlane) {
    const maxLift = Math.max(0.0, prof.maxLift ?? 10.0);
    const minFlySpeed = Math.max(0.0, prof.minFlySpeed ?? 14.0);
    const liftResponse = Math.max(0.1, prof.liftResponse ?? 5.0);

    const airRollMax = Math.max(0.0, prof.airRollMax ?? 0.35);
    const airRollResponse = Math.max(0.1, prof.airRollResponse ?? 8.0);
    const airRollReturn = Math.max(0.1, prof.airRollReturn ?? 5.0);

    const climbPitchMax = Math.max(0.0, prof.climbPitchMax ?? 0.22);
    const climbPitchSpeed = Math.max(0.1, prof.climbPitchSpeed ?? 4.0);
    const pitchResponse = Math.max(0.1, prof.pitchResponse ?? 4.0);
    const pitchReturn = Math.max(0.1, prof.pitchReturn ?? 3.0);
    const turnPitchMax = Math.max(0.0, prof.turnPitchMax ?? 0.10);

    const pos = v.object.position;
    const base = Number.isFinite(vehicleDriveState.groundOffsetY) ? vehicleDriveState.groundOffsetY : 0.0;
    const groundYNow = getWorldSurfaceY(pos.x, pos.z) + base;

    const denom = Math.max(1e-6, (maxSpeed - minFlySpeed));
    const t = clamp((speedAbs - minFlySpeed) / denom, 0.0, 1.0);
    const targetLift = maxLift * t;

    const liftPrev = Number.isFinite(vehicleDriveState.liftY) ? vehicleDriveState.liftY : 0.0;
    const liftAlpha = 1 - Math.pow(0.001, liftResponse * dt);
    let liftY = liftPrev + (targetLift - liftPrev) * liftAlpha;

    vehicleDriveState.liftY = liftY;

    let airborne = !!vehicleDriveState.planeAirborne;

    if (!airborne && liftY > 0.15) {
      airborne = true;
      vehicleDriveState.planeAirborne = true;
      vehicleDriveState.planeBaseGroundY = groundYNow;
    }



    if (airborne) {
      const refPrev = Number.isFinite(vehicleDriveState.planeBaseGroundY) ? vehicleDriveState.planeBaseGroundY : groundYNow;

      /* Keeps plane altitude decoupled from terrain while airborne; relaxes the reference floor near landing so touchdown uses local ground height. */
      const landBlend = clamp(1.0 - (liftY / Math.max(1e-3, maxLift * 0.35)), 0.0, 1.0);
      const baseAlpha = 1 - Math.pow(0.001, 2.5 * dt);

      let refY = refPrev + (groundYNow - refPrev) * (baseAlpha * landBlend);

      const clearBase = clamp(Number.isFinite(prof.minAirClearance) ? prof.minAirClearance : 0.25, 0.0, 5.0);
      const clearT = clamp(liftY / Math.max(1e-3, maxLift * 0.25), 0.0, 1.0);
      const minAirClear = clearBase * clearT;

      let y = refY + liftY;

      const minY = groundYNow + minAirClear;
      if (y < minY) {
        y = minY;
        refY = y - liftY;
      }

      vehicleDriveState.planeBaseGroundY = refY;
      pos.y = y;

      if (liftY <= 0.12 && pos.y <= groundYNow + 0.03) {
        airborne = false;
        vehicleDriveState.planeAirborne = false;
        vehicleDriveState.planeBaseGroundY = groundYNow;
        vehicleDriveState.liftY = 0.0;
        liftY = 0.0;
        pos.y = groundYNow;
      }
    } else {
      vehicleDriveState.planeBaseGroundY = groundYNow;
      pos.y = groundYNow + liftY;
    }
    

    const rollNow = Number.isFinite(vehicleDriveState.roll) ? vehicleDriveState.roll : 0.0;
    const rollVelNow = Number.isFinite(vehicleDriveState.rollVel) ? vehicleDriveState.rollVel : 0.0;

    const rollTarget = airborne ? clamp(steerAmount * airRollMax, -airRollMax, airRollMax) : 0.0;

    const rollK = (Math.abs(steerAmount) > 1e-3) ? airRollResponse : airRollReturn;
    const rollDamp = Math.max(0.1, prof.airRollDamp ?? (rollK * 1.25));
    const rollVelMax = Math.max(0.25, airRollMax * 8.0);

    let rollVel = rollVelNow + (rollTarget - rollNow) * rollK * dt;
    rollVel *= Math.exp(-rollDamp * dt);
    rollVel = clamp(rollVel, -rollVelMax, rollVelMax);

    let roll = rollNow + rollVel * dt;
    roll = clamp(roll, -airRollMax, airRollMax);

    vehicleDriveState.rollVel = rollVel;
    vehicleDriveState.roll = roll;



    const pitchNow = Number.isFinite(vehicleDriveState.pitch) ? vehicleDriveState.pitch : 0.0;
    const pitchVelNow = Number.isFinite(vehicleDriveState.pitchVel) ? vehicleDriveState.pitchVel : 0.0;

    const speedAbsRate = (speedAbs - speedAbsPrev) / Math.max(1e-6, dt);
    const accelNorm = clamp(speedAbsRate / Math.max(1e-6, climbPitchSpeed), -1.0, 1.0);

    const pitchFromAccel = -accelNorm * climbPitchMax;
    const pitchFromTurn = -(Math.abs(steerAmount) * turnPitchMax);

    const pitchTarget = (Math.max(speedAbs, speedAbsPrev) > 0.2)
    ? clamp(
      pitchFromAccel + pitchFromTurn,
      -Math.max(climbPitchMax, turnPitchMax),
      Math.max(climbPitchMax, turnPitchMax)
      )
    : 0.0;

    const pitchK = (Math.abs(pitchTarget) > 1e-4) ? pitchResponse : pitchReturn;
    const pitchDamp = Math.max(0.1, prof.pitchDamp ?? (pitchK * 1.25));
    const pitchVelMax = Math.max(0.25, Math.max(climbPitchMax, turnPitchMax) * 8.0);

    let pitchVel = pitchVelNow + (pitchTarget - pitchNow) * pitchK * dt;
    pitchVel *= Math.exp(-pitchDamp * dt);
    pitchVel = clamp(pitchVel, -pitchVelMax, pitchVelMax);

    let pitch = pitchNow + pitchVel * dt;
    pitch = clamp(
      pitch,
      -Math.max(climbPitchMax, turnPitchMax),
      Math.max(climbPitchMax, turnPitchMax)
      );

    vehicleDriveState.pitchVel = pitchVel;
    vehicleDriveState.pitch = pitch;

    v.object.rotation.set(pitch, yawAdj, roll, "YXZ");
  } else {
    vehicleDriveState.pitch = 0.0;
    vehicleDriveState.roll = 0.0;
    vehicleDriveState.pitchVel = 0.0;
    vehicleDriveState.rollVel = 0.0;

    const pos = v.object.position;
    const base = Number.isFinite(vehicleDriveState.groundOffsetY) ? vehicleDriveState.groundOffsetY : 0.0;

    pos.y = getWorldSurfaceY(pos.x, pos.z) + base;

    const nEps = clamp((prof.groundNormalEps ?? 0.85), 0.15, 3.0);
    getWorldSurfaceNormal(pos.x, pos.z, nEps, vehicleGroundUp);

    vehicleGroundFwd.set(Math.sin(yawAdj), 0, Math.cos(yawAdj));
    vehicleGroundFwd.addScaledVector(vehicleGroundUp, -vehicleGroundFwd.dot(vehicleGroundUp));

    if (vehicleGroundFwd.lengthSq() < 1e-10) {
      vehicleGroundFwd.set(0, 0, 1);
      vehicleGroundFwd.addScaledVector(vehicleGroundUp, -vehicleGroundFwd.dot(vehicleGroundUp));
      if (vehicleGroundFwd.lengthSq() < 1e-10) {
        vehicleGroundFwd.set(1, 0, 0);
        vehicleGroundFwd.addScaledVector(vehicleGroundUp, -vehicleGroundFwd.dot(vehicleGroundUp));
      }
    }

    vehicleGroundFwd.normalize();
    vehicleGroundRight.crossVectors(vehicleGroundUp, vehicleGroundFwd).normalize();
    vehicleGroundFwd.crossVectors(vehicleGroundRight, vehicleGroundUp).normalize();

    vehicleGroundMat.makeBasis(vehicleGroundRight, vehicleGroundUp, vehicleGroundFwd);
    v.object.quaternion.setFromRotationMatrix(vehicleGroundMat);
  }

  const long = vehicleTmpVel.x * fx + vehicleTmpVel.z * fz;
  const latX = vehicleTmpVel.x - fx * long;
  const latZ = vehicleTmpVel.z - fz * long;

  const latDamp = Math.exp(-lateralGrip * dt);
  vehicleTmpVel.x = fx * long + latX * latDamp;
  vehicleTmpVel.z = fz * long + latZ * latDamp;

  if (!isPlane || !vehicleDriveState.planeAirborne) {
    stampSnowFromVehicle(v, speedAbs, maxSpeed);
  }

  if (v.parts && v.parts.propellers && v.parts.propellers.length) {
    const axis = (prof.propAxis || "y");
    const idle = Math.max(0.0, prof.propIdle ?? 6.0);
    const max = Math.max(idle, prof.propMax ?? 38.0);
    const mul = Math.max(0.0, prof.propMul ?? 1.0);
    const invert = !!prof.propInvert;

    const signed =
    Math.abs(vehicleDriveState.speed) > 1e-3
    ? Math.sign(vehicleDriveState.speed)
    : Math.abs(targetSpeed) > 1e-3
    ? Math.sign(targetSpeed)
    : 0;

    const sign = invert ? -signed : signed;

    const spin = idle + (max - idle) * clamp((speedAbs / Math.max(1e-6, maxSpeed)) * mul, 0.0, 1.0);
    const d = spin * dt * sign;

    for (let i = 0; i < v.parts.propellers.length; i++) {
      const p = v.parts.propellers[i];
      if (!p) continue;

      if (axis === "x") p.rotation.x += d;
      else if (axis === "z") p.rotation.z += d;
      else p.rotation.y += d;
    }
  }

  vehicleSeatLocal.set(
    (v.meta.seatLocal && v.meta.seatLocal[0]) || 0,
    (v.meta.seatLocal && v.meta.seatLocal[1]) || 0.6,
    (v.meta.seatLocal && v.meta.seatLocal[2]) || 0
    );

  vehicleSeatWorld.copy(vehicleSeatLocal);
  v.object.localToWorld(vehicleSeatWorld);

  avatar.position.copy(vehicleSeatWorld);

  if (isVehiclePlane(v)) {
    avatar.quaternion.copy(v.object.quaternion);
  } else {
    avatar.rotation.set(0, vehicleDriveState.yaw, 0);
  }

  if (vehiclePromptState.open) {
    const titleEl = document.getElementById("vehiclePromptTitle");
    const descEl = document.getElementById("vehiclePromptDesc");
    const enterBtn = document.getElementById("vehicleEnterBtn");
    const exitBtn = document.getElementById("vehicleExitBtn");

    if (titleEl) titleEl.textContent = v.meta.type || "Vehicle";
    if (descEl) descEl.textContent = v.meta.description || "";
    if (enterBtn) enterBtn.style.display = "none";
    if (exitBtn) exitBtn.style.display = "";
  }

  /* Keeps the prompt closed while dismissed for this vehicle id. */
  const dismissed =
  vehiclePromptState.dismissedId &&
  String(vehiclePromptState.dismissedId) === String(v.id || "") &&
  String(vehiclePromptState.dismissedKind || "vehicle") === "vehicle";

  if (dismissed) {
    if (vehiclePromptState.open) setVehiclePrompt(false, null);
    updateVehicleOutlineFor(null);
  } else {
    updateVehicleOutlineFor(v);
    setVehiclePrompt(true, v);
  }
}







/**
 * Shows the interaction prompt for nearby vehicles/equipment (and updates vehicle outline when applicable).
 */
function tickVehicleProximity() {
  /* Shows prompt for nearby interactables unless that specific target was dismissed and still in range. */
  if (!avatarState.enabled || vehicleDriveState.enabled) {
    if (vehiclePromptState.open) setVehiclePrompt(false, null);
    updateVehicleOutlineFor(null);
    return;
  }

  const dismissedId = String(vehiclePromptState.dismissedId || "");
  const dismissedKind = String(vehiclePromptState.dismissedKind || "");

  const isDismissed = (near) => {
    if (!dismissedId || !near) return false;
    const id = String(near.id || "");
    const kind = String(near.kind || "vehicle");
    return id === dismissedId && kind === (dismissedKind || kind);
  };

  if (equipmentState.enabled && equipmentState.item) {
    if (isDismissed(equipmentState.item)) {
      if (vehiclePromptState.open) setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);
      return;
    }
    setVehiclePrompt(true, equipmentState.item);
    updateVehicleOutlineFor(null);
    return;
  }

  const nearVehicle = findNearbyVehicle();
  if (nearVehicle) {
    if (isDismissed(nearVehicle)) {
      if (vehiclePromptState.open) setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);
      return;
    }
    setVehiclePrompt(true, nearVehicle);
    updateVehicleOutlineFor(nearVehicle);
    return;
  }

  const nearEquip = findNearbyEquipment();
  if (nearEquip) {
    if (isDismissed(nearEquip)) {
      if (vehiclePromptState.open) setVehiclePrompt(false, null);
      updateVehicleOutlineFor(null);
      return;
    }
    setVehiclePrompt(true, nearEquip);
    updateVehicleOutlineFor(null);
    return;
  }

  if (dismissedId) {
    vehiclePromptState.dismissedId = "";
    vehiclePromptState.dismissedKind = "";
  }

  if (vehiclePromptState.open) setVehiclePrompt(false, null);
  updateVehicleOutlineFor(null);
}




const boundCenter = new THREE.Vector3();
const raycaster = new THREE.Raycaster();
const segDir = new THREE.Vector3();
const segDelta = new THREE.Vector3();
const hitFrom = new THREE.Vector3();
const tmpNormal = new THREE.Vector3();
const tmpMatrix3 = new THREE.Matrix3();

const obbTmpBox = new THREE.Box3();
const obbTmpCenter = new THREE.Vector3();
const obbTmpSize = new THREE.Vector3();
const obbTmpQuat = new THREE.Quaternion();
const obbTmpEuler = new THREE.Euler(0, 0, 0, "YXZ");



    // Decal helpers
const tmpM = new THREE.Matrix4();
const tmpQ = new THREE.Quaternion();
const tmpS = new THREE.Vector3();
const tmpP = new THREE.Vector3();
const zAxis = new THREE.Vector3(0, 0, 1);

    // extra helpers for object sticking burst
const tmpMatrix = new THREE.Matrix4();
const tmpDir = new THREE.Vector3();






// Rock builder ------------------------------------------------------------
// Builds a deterministic scattered rock field (annulus distribution) and updates collision bounds.
// Rock builder ------------------------------------------------------------

// Rock builder ------------------------------------------------------------

function rebuildRocks() {
  if (!scene) return;

  /* Builds a deterministic scattered rock field (50% buried by default) and refreshes collision/minimap data. */

  // Remove old rocks from scene & collider lists
  if (Array.isArray(rocks) && rocks.length) {
    for (const r of rocks) {
      if (!r) continue;
      if (r.parent) r.parent.remove(r);

      if (r.material && r.material !== rockMat && typeof r.material.dispose === "function") {
        r.material.dispose();
      }
    }
  }
  rocks.length = 0;

  colliderObjects = colliderObjects.filter((obj) => !obj || !obj.__isRock);

  // 2D value noise + FBM helpers (deterministic, cheap)
  const hash2 = (x, y, seed) => {
    const n = (x * 374761393 + y * 668265263 + seed * 1442695040888963407) | 0;
    let t = n ^ (n >>> 13);
    t = (t * 1274126177) | 0;
    return ((t ^ (t >>> 16)) >>> 0) / 4294967295;
  };

  const lerp = (a, b, t) => a + (b - a) * t;
  const smooth = (t) => t * t * (3 - 2 * t);

  const valueNoise2 = (x, y, seed) => {
    const xi = Math.floor(x), yi = Math.floor(y);
    const xf = x - xi, yf = y - yi;

    const v00 = hash2(xi, yi, seed);
    const v10 = hash2(xi + 1, yi, seed);
    const v01 = hash2(xi, yi + 1, seed);
    const v11 = hash2(xi + 1, yi + 1, seed);

    const u = smooth(xf);
    const v = smooth(yf);

    const a = lerp(v00, v10, u);
    const b = lerp(v01, v11, u);
    return lerp(a, b, v) * 2.0 - 1.0;
  };

  const fbm2 = (x, y, seed, octaves, lacunarity, gain) => {
    let amp = 0.5;
    let freq = 1.0;
    let sum = 0.0;
    let norm = 0.0;

    for (let o = 0; o < octaves; o++) {
      sum += amp * valueNoise2(x * freq, y * freq, seed + o * 1013);
      norm += amp;
      amp *= gain;
      freq *= lacunarity;
    }
    return norm > 0.0 ? (sum / norm) : 0.0;
  };

  const fbm3Approx = (x, y, z, seed, octaves, lacunarity, gain, freq) => {
    const a = fbm2(x * freq + 11.1, z * freq + 7.7, seed + 17, octaves, lacunarity, gain);
    const b = fbm2(y * freq + 3.3,  x * freq + 9.9, seed + 131, octaves, lacunarity, gain);
    const c = fbm2(z * freq + 5.5,  y * freq + 13.3, seed + 911, octaves, lacunarity, gain);
    return (a + b + c) / 3.0;
  };

  const baseColor = normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442");
  const baseRough = clamp(params.rockRoughness, 0.0, 1.0);
  const baseMetal = clamp(params.rockMetalness, 0.0, 1.0);

  if (!rockMat) {
    rockMat = new THREE.MeshStandardMaterial({
      color: baseColor,
      roughness: baseRough,
      metalness: baseMetal
    });
  } else {
    if (rockMat.color) rockMat.color.set(baseColor);
    rockMat.roughness = baseRough;
    rockMat.metalness = baseMetal;
  }

  const detail = clamp((params.rockDetail | 0), 0, 16);
  const variantCount = clamp((params.rockVariantCount | 0), 1, 24);

  const noiseAmp = clamp(params.rockNoiseAmp, 0.0, 1.5);
  const noiseFreq = clamp(params.rockNoiseFreq, 0.01, 20.0);
  const noiseOct = clamp((params.rockNoiseOctaves | 0), 1, 8);
  const noiseLac = clamp(params.rockNoiseLacunarity, 1.1, 4.0);
  const noiseGain = clamp(params.rockNoiseGain, 0.15, 0.95);
  const ridgeBlend = clamp(params.rockNoiseRidge, 0.0, 1.0);

  const variantKey =
`${detail}|${variantCount}|` +
`${noiseAmp.toFixed(4)}|${noiseFreq.toFixed(4)}|${noiseOct}|${noiseLac.toFixed(3)}|${noiseGain.toFixed(3)}|${ridgeBlend.toFixed(3)}`;

if (rockVariantKey !== variantKey) {
  for (const g of rockVariantGeos) {
    if (g && typeof g.dispose === "function") g.dispose();
  }
  rockVariantGeos.length = 0;
  rockVariantMidY.length = 0;

  const tmpV = new THREE.Vector3();
  const tmpN = new THREE.Vector3();

  for (let v = 0; v < variantCount; v++) {
    const seed = ((params.rockSeed * 1000003) | 0) + v * 7919;

    const geo = new THREE.IcosahedronGeometry(1.1, detail);
    const pos = geo.attributes.position;

    for (let i = 0; i < pos.count; i++) {
      tmpV.fromBufferAttribute(pos, i);
      tmpN.copy(tmpV).normalize();

      const n0 = fbm3Approx(tmpV.x, tmpV.y, tmpV.z, seed, noiseOct, noiseLac, noiseGain, noiseFreq);
      const n1 = 1.0 - Math.abs(n0);
      const n = n0 * (1.0 - ridgeBlend) + n1 * ridgeBlend;

      tmpV.addScaledVector(tmpN, n * noiseAmp);
      pos.setXYZ(i, tmpV.x, tmpV.y, tmpV.z);
    }

    pos.needsUpdate = true;
    geo.computeVertexNormals();
    geo.computeBoundingBox();

    const bb = geo.boundingBox;
    const midY = bb ? (bb.min.y + bb.max.y) * 0.5 : 0.0;

    rockVariantGeos.push(geo);
    rockVariantMidY.push(midY);
  }

  rockVariantKey = variantKey;
}

const count = clamp((params.rockCount | 0), 0, 20000);
if (count <= 0) {
  colliderBounds = buildColliderBounds(colliderObjects);
  rebuildAvatarCollisionGrid();
  refreshMinimapStaticPoints();
  drawMinimapFrame(true);
  return;
}

const radius = clamp(params.rockRadius, 0.0, 5000.0);
const innerR = clamp(params.rockInnerRadius, 0.0, radius);
const minS = clamp(params.rockMinScale, 0.01, 100.0);
const maxS = clamp(params.rockMaxScale, minS, 200.0);
const jitter = clamp(params.rockJitter, 0.0, 25.0);

const flatten = clamp(params.rockFlatten, 0.0, 0.85);
const aniso = clamp(params.rockAnisotropy, 0.0, 1.0);
const embed = clamp(params.rockEmbed, 0.0, 10.0);
const colorVar = clamp(params.rockColorVar, 0.0, 1.0);

const rng = makeSeededRandom((params.rockSeed | 0) ^ 0x9e3779b9);

for (let i = 0; i < count; i++) {
  const ang = rng() * Math.PI * 2.0;
  const rr = innerR * innerR + rng() * (radius * radius - innerR * innerR);
  const r = Math.sqrt(Math.max(0.0, rr));

  const px = Math.cos(ang) * r + (rng() * 2.0 - 1.0) * jitter;
  const pz = Math.sin(ang) * r + (rng() * 2.0 - 1.0) * jitter;

  const groundY = sampleSnowHeight(px, pz);
  if (!Number.isFinite(groundY)) continue;

  const vIdx = Math.floor(rng() * variantCount) % variantCount;
  const geo = rockVariantGeos[vIdx];

  let mat = rockMat;
  if (colorVar > 0.0001) {
    mat = rockMat.clone();
    const dv = (rng() * 2.0 - 1.0) * colorVar;
    if (mat.color) mat.color.offsetHSL(0.0, 0.0, dv);
  }

  const s = minS + (maxS - minS) * rng();
  const sy = Math.max(0.15, 1.0 - flatten * (0.35 + 0.65 * rng()));

  const k = (rng() * 2.0 - 1.0) * (0.65 * aniso);
  const sx = Math.max(0.25, 1.0 + k);
  const sz = Math.max(0.25, 1.0 - k);

  const rock = new THREE.Mesh(geo, mat);
  rock.__isRock = true;

  rock.scale.set(s * sx, s * sy, s * sz);

    // Ground passes through the rock's vertical mid (50% buried), with optional extra embed.
  const midY = (rockVariantMidY[vIdx] || 0.0) * rock.scale.y;
  rock.position.set(px, groundY - midY - embed, pz);

  rock.rotation.set(
    (rng() * 2.0 - 1.0) * 0.25,
    rng() * Math.PI * 2.0,
    (rng() * 2.0 - 1.0) * 0.25
    );

  scene.add(rock);
  rocks.push(rock);
  colliderObjects.push(rock);
}

colliderBounds = buildColliderBounds(colliderObjects);
rebuildAvatarCollisionGrid();
refreshMinimapStaticPoints();
drawMinimapFrame(true);
}



/* Snaps existing forest tree Y positions back onto the current snow/terrain surface and refreshes colliders/minimap. */
function snapForestToTerrain() {
  if (!cones || !cones.length) return;

  for (const tree of cones) {
    if (!tree) continue;

    const x = tree.position.x;
    const z = tree.position.z;

    const groundY = sampleSnowHeight(x, z);
    if (!Number.isFinite(groundY)) continue;

    const scale = (tree.scale && Number.isFinite(tree.scale.y)) ? tree.scale.y : 1.0;
    tree.position.y = groundY + 1.65 * scale;
  }

  colliderBounds = buildColliderBounds(colliderObjects);
  rebuildAvatarCollisionGrid();
  refreshMinimapStaticPoints();
  drawMinimapFrame(true);
}



    // Forest builder ----------------------------------------------------------
function rebuildForest() {
  if (!scene) return;

  // Remove old forest trees from scene and colliders
  for (const t of cones) {
    if (t && t.parent === scene) scene.remove(t);
  }
  cones.length = 0;

  colliderObjects = colliderObjects.filter((obj) => !obj.__isForestTree);

  if (!forestConeGeo) {
    forestConeGeo = new THREE.ConeGeometry(0.9, 3.3, 24, 1);
  }
  if (!forestConeMat) {
    forestConeMat = new THREE.MeshStandardMaterial({
      color: normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b"),
      roughness: 1.0,
      metalness: 0.0
    });
  } else if (forestConeMat.color) {
    forestConeMat.color.set(normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b"));
  }

  const rng = makeSeededRandom((params.forestSeed * 1000003) | 0);

  const count = clamp(params.forestCount | 0, 0, 4000);
  const maxR = clamp(params.forestRadius, 1.0, HALF_GROUND - 1.0);
  const minR = clamp(params.forestInnerRadius, 0.0, Math.max(maxR - 1.0, 0.0));
  const minS = Math.max(0.2, params.forestMinScale);
  const maxS = Math.max(minS, params.forestMaxScale);
  const jitter = clamp(params.forestJitter, 0.0, 3.0);

  for (let i = 0; i < count; i++) {
    const t = rng();
    const rBase = Math.sqrt(t);
    const r = minR + (maxR - minR) * rBase;

    let ang = rng() * Math.PI * 2.0;
    ang += (rng() - 0.5) * jitter * 0.4;

    let x = Math.cos(ang) * r;
    let z = Math.sin(ang) * r;

    x += (rng() - 0.5) * jitter * 0.4;
    z += (rng() - 0.5) * jitter * 0.4;

    const tree = new THREE.Mesh(forestConeGeo, forestConeMat);

    const scale = minS + (maxS - minS) * rng();
    tree.scale.set(scale, scale, scale);

    const groundY = sampleSnowHeight(x, z);
    const y = groundY + 1.65 * scale;
    tree.position.set(x, y, z);

    tree.rotation.y = rng() * Math.PI * 2.0;
    tree.castShadow = true;
    tree.receiveShadow = true;
    tree.__isForestTree = true;

    scene.add(tree);
    cones.push(tree);
    colliderObjects.push(tree);
  }

  colliderBounds = buildColliderBounds(colliderObjects);
  rebuildAvatarCollisionGrid();
  refreshMinimapStaticPoints();
  drawMinimapFrame(true);
}








    // Gust system -------------------------------------------------------------

class Gust {
  constructor() {
    this.x = 0;
    this.z = 0;
    this.radius = 1;
    this.strength = 0;
    this.swirl = 0;
    this.updraft = 0;
    this.ttl = 0;
    this.life = 0;
  }
  reset(x, z, radius, strength, swirl, updraft, ttl) {
    this.x = x;
    this.z = z;
    this.radius = radius;
    this.strength = strength;
    this.swirl = swirl;
    this.updraft = updraft;
    this.ttl = ttl;
    this.life = ttl;
  }
  step(dt) {
    this.life = Math.max(0, this.life - dt);
  }
  get active() {
    return this.life > 0;
  }
  get fade() {
    if (this.ttl <= 1e-6) return 0;
    const t = this.life / this.ttl;
    return t * t;
  }
}

const GUST_MAX = 6;
const gusts = Array.from({ length: GUST_MAX }, () => new Gust());
let gustSpawnTimer = 0;

const gustTmp = new THREE.Vector3();
const gustPosRad = new Float32Array(GUST_MAX * 3);
const gustParams = new Float32Array(GUST_MAX * 3);


function spawnGusts(dt) {
  gustSpawnTimer -= dt;
  if (gustSpawnTimer > 0) return;

  const minI = clamp(params.gustMinInterval, 0.2, 20.0);
  const maxI = clamp(params.gustMaxInterval, minI + 0.1, 40.0);
  gustSpawnTimer = minI + Math.random() * (maxI - minI);

  if (!cones.length) return;
  const tpos = cones[(Math.random() * cones.length) | 0].position;
  const gx = tpos.x + (Math.random() * 2 - 1) * 2.2;
  const gz = tpos.z + (Math.random() * 2 - 1) * 2.2;

  const tornadoChance = clamp(params.gustTornadoChance, 0.0, 1.0);
  const isTornado = Math.random() < tornadoChance;

  const radius = isTornado ? (1.8 + Math.random() * 1.2) : (3.4 + Math.random() * 3.2);
  const strength =
  (isTornado ? (2.4 + Math.random() * 2.2) : (0.9 + Math.random() * 1.2)) *
  clamp(params.gustStrengthMul, 0.0, 4.0);
  const swirlSign = Math.random() < 0.5 ? -1 : 1;
  const swirl =
  swirlSign *
  (isTornado ? 4.4 : 2.2) *
  clamp(params.gustSwirlMul, 0.0, 4.0);
  const updraft =
  (isTornado ? (2.2 + Math.random() * 2.0) : (0.20 + Math.random() * 0.55)) *
  clamp(params.gustUpdraftMul, 0.0, 4.0);
  const ttl = isTornado ? (1.5 + Math.random() * 1.8) : (1.1 + Math.random() * 1.8);

      // find slot
  let slot = 0;
  for (let i = 0; i < gusts.length; i++) {
    if (!gusts[i].active) {
      slot = i;
      break;
    }
  }

  gusts[slot].reset(gx, gz, radius, strength, swirl, updraft, ttl);

    // audio whoosh tied to gust strength
    //playGustFx(strength);

}


function gustWindAt(x, z, heightAboveSnow, out) {
  out.set(0, 0, 0);
  for (let i = 0; i < gusts.length; i++) {
    const g = gusts[i];
    if (!g.active) continue;

    const dx = x - g.x;
    const dz = z - g.z;
    const r2 = dx * dx + dz * dz;
    const r = g.radius;
    if (r2 > r * r) continue;

    const rr = Math.max(1e-6, Math.sqrt(r2));
    const npx = dx / rr;
    const npz = dz / rr;

    const heightK = 1.0 / (1.0 + Math.max(0, heightAboveSnow) * 1.15);
    const radial = 1.0 - rr / r;
    const k = g.fade * g.strength * radial * radial * heightK;

    const tx = -npz;
    const tz = npx;

    out.x += tx * (g.swirl * k) + (-npx) * (0.18 * k);
    out.z += tz * (g.swirl * k) + (-npz) * (0.18 * k);
    out.y += g.updraft * k * (radial * radial);
  }
  return out;
}

function applyGustScour(baseWindX, baseWindZ) {
  const scourBase = clamp(params.gustScour, 0.0, 0.10);
  const redepBase = clamp(params.gustRedeposit, 0.0, 0.10);
  if (scourBase === 0 && redepBase === 0) return;

  for (let i = 0; i < gusts.length; i++) {
    const g = gusts[i];
    if (!g.active) continue;

    const fade = g.fade;
    const scour = -scourBase * fade;
    const redeposit = redepBase * fade;

        // scour around gust center, redeposit downwind
    depositHeightAtWorld(g.x, g.z, scour, 0, 0);
    depositHeightAtWorld(g.x, g.z, scour * 0.7, 0, 0);
    depositHeightAtWorld(g.x, g.z, redeposit, baseWindX, baseWindZ);
  }
}

    // GUI / presets -----------------------------------------------------------

let gui = null;
const guiControllers = [];




const presetState = {
  presetName: "",
  selected: "<none>"
};
let presetSelectCtrl = null;



    // JSON file presets (edit / extend this list)
const FILE_PRESET_URLS = [
  "presets/preset-default.json",
  "presets/snow-Forrest.json",
  "presets/snow-Moist-1.json",
  "presets/snow-More-Snow.json",
  "presets/snow-Delicate.json",
  "presets/snow-heavy.json"
];

function getBuiltinPresets() {
  return FILE_PRESET_URLS.map((url) => {
    const parts = url.split("/");
    const file = parts[parts.length - 1] || url;
    const withoutExt = file.replace(/\.json$/i, "");
    const spaced = withoutExt
    .replace(/^snow-/, "")
    .replace(/[-_]+/g, " ");
    const name = sanitizePresetName(spaced);
    return { name: name || withoutExt, url };
  });
}



    // Drift deposition kernel -------------------------------------------------

const KERNEL_RADIUS = 3;
const KERNEL_SIGMA = 1.05;
const driftKernel = [];

(function buildKernel() {
  let sum = 0;
  for (let dz = -KERNEL_RADIUS; dz <= KERNEL_RADIUS; dz++) {
    for (let dx = -KERNEL_RADIUS; dx <= KERNEL_RADIUS; dx++) {
      const r2 = dx * dx + dz * dz;
      const w = Math.exp(-r2 / (2 * KERNEL_SIGMA * KERNEL_SIGMA));
      driftKernel.push({ dx, dz, w });
      sum += w;
    }
  }
  for (const k of driftKernel) k.w /= sum || 1;
})();






// -------------------------------------------------------------------------
// Apply settings (clamps)
// -------------------------------------------------------------------------

function applySettings(
  obj,
  { rebuild = false, updateGui = true, persist = true } = {}
  ) {
  const prevPersistBlocked = persistBlocked;

  const prevSnowEnabled = !!params.snowEnabled;

  const prevDustEnabled = !!params.dustEnabled;
  const prevDustCount = params.dustCount | 0;

  const prevRainEnabled = !!params.rainEnabled;
  const prevRainCount = params.rainCount | 0;

  const prevGrassEnabled = !!params.grassEnabled;
  const prevGrassCount = params.grassCount | 0;
  const prevGrassSeed = params.grassSeed | 0;


  const prevAvatarId = params.avatarId;



  persistBlocked = persistBlocked || !persist;

  try {
    if (!obj || typeof obj !== "object") return;

    for (const k in obj) {
      if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;
      if (!Object.prototype.hasOwnProperty.call(params, k)) continue;
      params[k] = obj[k];
    }

    // core sim
    params.timeScale = clamp(params.timeScale, 0.05, 5.0);
    params.dtMax = clamp(params.dtMax, 0.005, 0.25);

    params.pixelRatio = clamp(params.pixelRatio, 0.5, 2.5);

    params.avatarId = sanitizeAvatarId(params.avatarId, DEFAULTS.avatarId);


    // performance (shadows)
    params.shadowsEnabled = !!params.shadowsEnabled;
    params.shadowsAutoUpdate = !!params.shadowsAutoUpdate;
    params.shadowType = sanitizeShadowType(params.shadowType);
    params.shadowMapSize = sanitizeShadowMapSize(params.shadowMapSize | 0);

    applyShadowSettingsFromParams(false);

    // snow master enable
    params.snowEnabled = !!params.snowEnabled;

    params.visualCount = clamp(params.visualCount | 0, 1000, 150000);

    params.windStrength = clamp(params.windStrength, 0.0, 0.6);
    params.windSpeed = clamp(params.windSpeed, 0.01, 2.0);




    params.fallSpeed = clamp(params.fallSpeed, 0.2, 10.0);
    params.fallJitter = clamp(params.fallJitter, 0.0, 1.0);

    params.flakeSize = clamp(params.flakeSize, 0.1, 4.0);
    params.flakeSizeJitter = clamp(params.flakeSizeJitter, 0.0, 1.0);


    // environmental sounds
    params.envSoundEnabled = !!params.envSoundEnabled;
    params.envSoundVolume = clamp(params.envSoundVolume, 0.0, 1.0);
    params.envSoundPanDepth = clamp(params.envSoundPanDepth, 0.0, 1.0);
    params.envSoundPanSpeed = clamp(params.envSoundPanSpeed, 0.0, 6.0);
    params.envSoundReverbMix = clamp(params.envSoundReverbMix, 0.0, 1.0);
    params.envSoundIrSeconds = clamp(params.envSoundIrSeconds, 0.2, 6.0);
    params.envSoundToneHz = clamp(params.envSoundToneHz | 0, 0, 8000);


    params.musicEnabled = !!params.musicEnabled;
    params.musicVolume = clamp(params.musicVolume, 0.0, 1.0);

    params.sfxEnabled = !!params.sfxEnabled;
    params.sfxVolume = clamp(params.sfxVolume, 0.0, 1.0);



    params.gustMinInterval = clamp(params.gustMinInterval, 0.2, 20.0);
    params.gustMaxInterval = clamp(params.gustMaxInterval, params.gustMinInterval, 40.0);
    params.gustTornadoChance = clamp(params.gustTornadoChance, 0.0, 1.0);

    params.gustStrengthMul = clamp(params.gustStrengthMul, 0.0, 4.0);
    params.gustSwirlMul = clamp(params.gustSwirlMul, 0.0, 4.0);
    params.gustUpdraftMul = clamp(params.gustUpdraftMul, 0.0, 4.0);
    params.gustScour = clamp(params.gustScour, 0.0, 0.08);
    params.gustRedeposit = clamp(params.gustRedeposit, 0.0, 0.08);

    params.driftGrid = clamp(params.driftGrid | 0, 64, 512);
    params.driftMaxHeight = clamp(params.driftMaxHeight, 0.0, 8.0);

    params.coverBase = clamp(params.coverBase, 0.0, 2.0);
    params.coverMacroAmp = clamp(params.coverMacroAmp, 0.0, 2.0);
    params.coverMacroFreq = clamp(params.coverMacroFreq, 0.0, 30.0);
    params.coverMicroAmp = clamp(params.coverMicroAmp, 0.0, 2.0);
    params.coverMicroFreq = clamp(params.coverMicroFreq, 0.0, 80.0);

    params.driftDiffusion = clamp(params.driftDiffusion, 0.0, 0.2);
    params.driftAdvection = clamp(params.driftAdvection, 0.0, 0.05);

    params.obstacleShapeInterval = clamp(params.obstacleShapeInterval | 0, 1, 600);
    params.driftWriteInterval = clamp(params.driftWriteInterval | 0, 1, 600);
    params.normalUpdateInterval = clamp(params.normalUpdateInterval | 0, 1, 1200);

    params.settlerCount = clamp(params.settlerCount | 0, 0, 60000);

    params.groundDepositBudget = clamp(params.groundDepositBudget, 0.0, 2000.0);
    params.depositUnit = clamp(params.depositUnit, 0.00001, 0.01);

    params.objectTestsPerFrame = clamp(params.objectTestsPerFrame | 0, 0, 5000);
    params.objectDeposit = clamp(params.objectDeposit, 0.0, 0.02);

    params.stuckMax = clamp(params.stuckMax | 0, 0, 80000);
    params.decalSize = clamp(params.decalSize, 0.02, 1.5);

    // fog
    params.fogNear = clamp(params.fogNear, 0.1, 400.0);
    params.fogFar = clamp(params.fogFar, 1.0, 2000.0);
    params.fadeEndOfWorldEnabled = !!params.fadeEndOfWorldEnabled;

    params.fadeEndOfWorldDistance = clamp(
      Number(params.fadeEndOfWorldDistance ?? (WORLD_BOUNDS_XZ * 0.18)),
      12.0,
      Math.min(400.0, WORLD_BOUNDS_XZ)
      );


    // surface colors
    params.groundColor = normalizeHexColor(params.groundColor, DEFAULTS.groundColor || "#ffffff");
    params.rockColor = normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442");
    params.forestColor = normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b");
    params.cubeColor = normalizeHexColor(params.cubeColor, DEFAULTS.cubeColor || "#4e9cff");

    // snowman
    params.snowmanMoveEnabled = !!params.snowmanMoveEnabled;
    params.snowmanPathRadius = clamp(params.snowmanPathRadius, 0.0, 50.0);
    params.snowmanSpeed = clamp(params.snowmanSpeed, 0.0, 2.0);

    // forest
    params.forestCount = clamp(params.forestCount | 0, 0, 4000);
    params.forestRadius = clamp(params.forestRadius, 2.0, 2000.0);
    params.forestInnerRadius = clamp(params.forestInnerRadius, 0.0, 2000.0);
    params.forestMinScale = clamp(params.forestMinScale, 0.1, 20.0);
    params.forestMaxScale = clamp(params.forestMaxScale, params.forestMinScale, 30.0);
    params.forestSeed = clamp(params.forestSeed | 0, 0, 999999);
    params.forestJitter = clamp(params.forestJitter, 0.0, 3.0);

    // rocks
    params.rockCount = clamp(params.rockCount | 0, 0, 800);
    params.rockRadius = clamp(params.rockRadius, 2.0, 2000.0);
    params.rockInnerRadius = clamp(params.rockInnerRadius, 0.0, 2000.0);
    params.rockMinScale = clamp(params.rockMinScale, 0.1, 50.0);
    params.rockMaxScale = clamp(params.rockMaxScale, params.rockMinScale, 80.0);
    params.rockSeed = clamp(params.rockSeed | 0, 0, 999999);
    params.rockJitter = clamp(params.rockJitter, 0.0, 3.0);

    // clouds
    params.cloudEnabled = !!params.cloudEnabled;
    params.cloudHeightBase = clamp(params.cloudHeightBase, 0.0, 200.0);
    params.cloudHeightRange = clamp(params.cloudHeightRange, 0.0, 200.0);
    params.cloudRadius = clamp(params.cloudRadius, 5.0, 400.0);
    params.cloudSliceCount = clamp(params.cloudSliceCount | 0, 32, 1024);
    params.cloudSpeed = clamp(params.cloudSpeed, 0.0, 2.0);
    params.cloudDensity = clamp(params.cloudDensity, 0.0, 2.0);
    params.cloudSoftness = clamp(params.cloudSoftness, 0.0, 4.0);
    params.cloudOpacity = clamp(params.cloudOpacity, 0.0, 1.0);

    // dust
    params.dustEnabled = !!params.dustEnabled;
    params.dustRadius = clamp(params.dustRadius, 0.1, 200.0);
    params.dustFloorY = clamp(params.dustFloorY, -50.0, 500.0);
    params.dustCeilY = clamp(params.dustCeilY, params.dustFloorY + 0.01, 1000.0);
    params.dustSpeed = clamp(params.dustSpeed, 0.0, 20.0);
    params.dustCount = clamp(params.dustCount | 0, 1, 20000);
    params.dustSize = clamp(params.dustSize, 0.001, 10.0);
    params.dustNoise = clamp(params.dustNoise, 0.0, 10.0);
    params.dustCenterX = clamp(params.dustCenterX, -HALF_GROUND, HALF_GROUND);
    params.dustCenterZ = clamp(params.dustCenterZ, -HALF_GROUND, HALF_GROUND);

    // rain
    params.rainEnabled = !!params.rainEnabled;
    params.rainRadius = clamp(params.rainRadius, 0.1, 2000.0);
    params.rainTopY = clamp(params.rainTopY, -50.0, 1000.0);
    params.rainBottomY = clamp(params.rainBottomY, -200.0, 1000.0);
    if (params.rainBottomY > params.rainTopY - 0.01) params.rainBottomY = params.rainTopY - 0.01;
    params.rainSpeed = clamp(params.rainSpeed, 0.0, 30.0);
    params.rainCount = clamp(params.rainCount | 0, 1, 40000);
    params.rainSize = clamp(params.rainSize, 0.001, 20.0);
    params.rainThickness = clamp(params.rainThickness, 0.001, 0.5);
    params.rainStreak = clamp(params.rainStreak, 0.05, 0.98);
    params.rainWindX = clamp(params.rainWindX, -20.0, 20.0);
    params.rainWindZ = clamp(params.rainWindZ, -20.0, 20.0);
    params.rainCenterX = clamp(params.rainCenterX, -HALF_GROUND, HALF_GROUND);
    params.rainCenterZ = clamp(params.rainCenterZ, -HALF_GROUND, HALF_GROUND);
    params.rainOpacity = clamp(params.rainOpacity, 0.0, 1.0);

    // grass
    params.grassEnabled = !!params.grassEnabled;
    params.grassCount = clamp(params.grassCount | 0, 0, 120000);
    params.grassRadius = clamp(params.grassRadius, 0.1, 2000.0);
    params.grassCenterX = clamp(params.grassCenterX, -HALF_GROUND, HALF_GROUND);
    params.grassCenterZ = clamp(params.grassCenterZ, -HALF_GROUND, HALF_GROUND);
    params.grassBaseY = clamp(params.grassBaseY, -5.0, 25.0);

    params.grassBladeHeight = clamp(params.grassBladeHeight, 0.01, 4.0);
    params.grassBladeWidth = clamp(params.grassBladeWidth, 0.001, 2.0);
    params.grassHeightJitter = clamp(params.grassHeightJitter, 0.0, 1.0);
    params.grassWidthJitter = clamp(params.grassWidthJitter, 0.0, 1.0);

    params.grassBend = clamp(params.grassBend, 0.0, 6.0);
    params.grassWindSpeed = clamp(params.grassWindSpeed, 0.0, 20.0);
    params.grassWindStrength = clamp(params.grassWindStrength, 0.0, 6.0);
    params.grassStiffness = clamp(params.grassStiffness, 0.25, 4.0);

    params.grassNoiseScale = clamp(params.grassNoiseScale, 0.01, 4.0);
    params.grassNoiseStrength = clamp(params.grassNoiseStrength, 0.0, 2.0);
    params.grassNoiseSpeed = clamp(params.grassNoiseSpeed, 0.0, 10.0);
    params.grassColorVariation = clamp(params.grassColorVariation, 0.0, 0.5);

    params.grassColorBottom = normalizeHexColor(params.grassColorBottom, DEFAULTS.grassColorBottom || "#1f5f2e");
    params.grassColorTop = normalizeHexColor(params.grassColorTop, DEFAULTS.grassColorTop || "#7ee36c");
    params.grassOpacity = clamp(params.grassOpacity, 0.0, 1.0);
    params.grassAlphaCutoff = clamp(params.grassAlphaCutoff, 0.0, 0.95);
    params.grassSeed = clamp(params.grassSeed | 0, 0, 999999);

    const snowEnabledChanged = (!!params.snowEnabled !== prevSnowEnabled);

    const dustNeedsRebuild =
    rebuild ||
    (!!params.dustEnabled !== prevDustEnabled) ||
    ((params.dustCount | 0) !== (prevDustCount | 0)) ||
    (dustLastCount !== (params.dustCount | 0));

    const rainNeedsRebuild =
    rebuild ||
    (!!params.rainEnabled !== prevRainEnabled) ||
    ((params.rainCount | 0) !== (prevRainCount | 0)) ||
    (rainLastCount !== (params.rainCount | 0));

    const grassNeedsRebuild =
    rebuild ||
    (!!params.grassEnabled !== prevGrassEnabled) ||
    ((params.grassCount | 0) !== (prevGrassCount | 0)) ||
    ((params.grassSeed | 0) !== (prevGrassSeed | 0)) ||
    (grassLastCount !== (params.grassCount | 0));

    if (rebuild) {
      rebuildWorld();
      rebuildForest();
      rebuildRocks();
      rebuildClouds();
    } else {
      applyCloudParamsToUniforms();
      if (snowEnabledChanged) {
        rebuildWorld();
      }
    }

    if (dustNeedsRebuild) {
      rebuildDust();
    } else {
      if (!params.dustEnabled) {
        disposeDust();
      } else if (!dustUniforms) {
        rebuildDust();
      } else {
        applyDustParamsToUniforms();
      }
    }

    if (rainNeedsRebuild) {
      rebuildRain();
    } else {
      if (!params.rainEnabled) {
        disposeRain();
      } else if (!rainUniforms) {
        rebuildRain();
      } else {
        applyRainParamsToUniforms();
      }
    }

    if (grassNeedsRebuild) {
      rebuildGrass();
    } else {
      if (!params.grassEnabled) {
        disposeGrass();
      } else if (!grassUniforms) {
        rebuildGrass();
      } else {
        applyGrassParamsToUniforms();
      }
    }

    if (params.avatarId !== prevAvatarId) {
      loadAvatar();
      if (playerProfileState && playerProfileState.open) {
        syncProfileAvatarPickerFromCurrent();
      }
    }    

    applySurfaceColorsFromParams();
    applyEnvSoundFromParams();
    applyMusicFromParams();

    if (updateGui && gui) {
      refreshGuiDisplays();
    }

    if (persist && !persistBlocked) {
      saveLastDebounced(params);
    }
  } finally {
    persistBlocked = prevPersistBlocked;
  }
}




    // -------------------------------------------------------------------------
    // Snow texture (point sprite)
    // -------------------------------------------------------------------------

function makeRadialTexture(size = 96) {
  const c = document.createElement("canvas");
  c.width = c.height = size;
  const g = c.getContext("2d");

  const grad = g.createRadialGradient(
    size / 2, size / 2, 0,
    size / 2, size / 2, size / 2
    );
  grad.addColorStop(0.00, "rgba(254,254,254,1.00)");
  grad.addColorStop(0.42, "rgba(255,255,255,0.92)");
  grad.addColorStop(0.78, "rgba(255,255,255,0.22)");
  grad.addColorStop(1.00, "rgba(255,255,255,0.00)");

  g.clearRect(0, 0, size, size);
  g.fillStyle = grad;
  g.beginPath();
  g.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
  g.fill();

  const tex = new THREE.CanvasTexture(c);
  tex.anisotropy = 4;
  tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
  return tex;
}

    // -------------------------------------------------------------------------
    // Drifts: heightfield
    // -------------------------------------------------------------------------

function gridIndex(i, j) {
  return j * DRIFT_STRIDE + i;
}


/* Deterministic 2D value-noise + fBm helpers for procedural terrain. */
function _hash2D(ix, iz, seed) {
  let n = (ix * 374761393 + iz * 668265263 + (seed | 0) * 1442695041) | 0;
  n = (n ^ (n >>> 13)) >>> 0;
  n = (n * 1274126177) >>> 0;
  n = (n ^ (n >>> 16)) >>> 0;
  return n / 4294967295;
}

function _fade01(t) {
  t = clamp(t, 0, 1);
  return t * t * (3 - 2 * t);
}

function _valueNoise2D(x, z, seed) {
  const ix = Math.floor(x);
  const iz = Math.floor(z);
  const fx = x - ix;
  const fz = z - iz;

  const a = _hash2D(ix, iz, seed);
  const b = _hash2D(ix + 1, iz, seed);
  const c = _hash2D(ix, iz + 1, seed);
  const d = _hash2D(ix + 1, iz + 1, seed);

  const ux = _fade01(fx);
  const uz = _fade01(fz);

  const ab = a + (b - a) * ux;
  const cd = c + (d - c) * ux;
  return ab + (cd - ab) * uz;
}

function _fbm2D(x, z, seed, octaves, lacunarity, gain) {
  let sum = 0;
  let amp = 1;
  let freq = 1;

  const o = clamp(octaves | 0, 1, 10);
  const lac = Math.max(1.0, lacunarity);
  const g = clamp(gain, 0.0, 1.0);

  for (let i = 0; i < o; i++) {
    const n = _valueNoise2D(x * freq, z * freq, seed + i * 1013);
    sum += (n * 2 - 1) * amp;
    amp *= g;
    freq *= lac;
  }
  return sum;
}

function _smoothstep(edge0, edge1, x) {
  const t = clamp((x - edge0) / (edge1 - edge0), 0, 1);
  return t * t * (3 - 2 * t);
}

function _terrainMaskAt(x, z) {
  const outer = Math.max(0, params.terrainRadius);
  const inner = clamp(params.terrainInnerRadius, 0, outer);
  const fade = Math.max(0.0, params.terrainEdgeFade);

  if (outer <= 0.0001) return 0;

  const r = Math.sqrt(x * x + z * z);

  const edgeFreq = Math.max(0.0001, params.terrainEdgeNoiseFreq);
  const edgeAmp = clamp(params.terrainEdgeNoiseAmp, 0.0, 0.9);
  const edgeN = (_valueNoise2D(x * edgeFreq, z * edgeFreq, (params.terrainSeed | 0) + 9001) * 2 - 1) * edgeAmp;

  const effectiveOuter = Math.max(0.0, outer * (1.0 + edgeN));
  const outerMask = 1.0 - _smoothstep(Math.max(0.0, effectiveOuter - fade), effectiveOuter, r);
  const innerMask = inner <= 0.0001 ? 1.0 : _smoothstep(inner, inner + fade, r);

  return clamp(outerMask * innerMask, 0, 1);
}

function _terrainHeightAt(x, z) {
  if (!params.terrainEnabled) return 0;

  const mask = _terrainMaskAt(x, z);
  if (mask <= 0.00001) return 0;

  const amp = Math.max(0, params.terrainAmp);
  if (amp <= 0.00001) return 0;

  const freq = Math.max(0.0001, params.terrainFreq);
  const seed = params.terrainSeed | 0;

  const warpFreq = Math.max(0.0001, params.terrainWarpFreq);
  const warpAmp = Math.max(0.0, params.terrainWarpAmp);

  const wx = (_valueNoise2D(x * warpFreq, z * warpFreq, seed + 30011) * 2 - 1) * warpAmp;
  const wz = (_valueNoise2D(x * warpFreq, z * warpFreq, seed + 30071) * 2 - 1) * warpAmp;

  const n = _fbm2D(
    (x + wx) * freq,
    (z + wz) * freq,
    seed + 701,
    params.terrainOctaves | 0,
    params.terrainLacunarity,
    params.terrainGain
    );

  let t = n * 0.5 + 0.5;
  t = clamp(t, 0, 1);

  if (params.terrainRidge) {
    const r = 1.0 - Math.abs(n);
    t = clamp(r, 0, 1);
  }

  const exp = Math.max(0.25, params.terrainExponent);
  t = Math.pow(t, exp);

  return t * amp * mask;
}

/* Re-initializes terrain base + cover without rebuilding the full world. */
function rebuildTerrainBase() {
  if (!params.snowEnabled || !snowSurface || !driftGeo || !driftHeights) return;
  initSnowCover();

  applyHeightsToGeometry();
  snapForestToTerrain();

  driftGeo.computeVertexNormals();
  driftGeo.attributes.normal.needsUpdate = true;
}


function initSnowCover() {
  if (!driftHeights) return;

  const base = Math.max(0, params.coverBase);
  const macroAmp = Math.max(0, params.coverMacroAmp);
  const macroFreq = Math.max(0.1, params.coverMacroFreq);
  const microAmp = Math.max(0, params.coverMicroAmp);
  const microFreq = Math.max(0.1, params.coverMicroFreq);
  const TAU = Math.PI * 2;

  const maxH = Math.max(0.5, params.driftMaxHeight);
  const colStrength = clamp(params.terrainColorStrength || 0, 0, 1);

  let lowR = 1, lowG = 1, lowB = 1, highR = 1, highG = 1, highB = 1;
  if (driftColorArray && colStrength > 0.00001) {
    const lo = new THREE.Color(normalizeHexColor(params.terrainColorLow, "#ffffff"));
    const hi = new THREE.Color(normalizeHexColor(params.terrainColorHigh, "#ffffff"));
    lowR = lo.r; lowG = lo.g; lowB = lo.b;
    highR = hi.r; highG = hi.g; highB = hi.b;
  }

  for (let j = 0; j <= DRIFT_GRID; j++) {
    for (let i = 0; i <= DRIFT_GRID; i++) {
      const u = i / DRIFT_GRID;
      const v = j / DRIFT_GRID;

      const sin1 = Math.sin((u * macroFreq + 0.11) * TAU);
      const cos1 = Math.cos((v * macroFreq - 0.27) * TAU);
      const macro = (sin1 + cos1) * 0.5;

      const sin3 = Math.sin(((u * microFreq + v * (microFreq * 0.70)) + 0.19) * TAU);
      const cos2 = Math.cos(((v * microFreq - u * (microFreq * 0.80)) - 0.23) * TAU);
      const micro = (sin3 + cos2) * 0.5;

      const x = (u - 0.5) * GROUND_SIZE;
      const z = (v - 0.5) * GROUND_SIZE;

      const terrain = _terrainHeightAt(x, z);

      const h = base + macro * macroAmp + micro * microAmp + terrain;
      const idx = gridIndex(i, j);

      const hc = clamp(h, 0, maxH);
      driftHeights[idx] = hc;

      if (driftColorArray) {
        let t = hc / maxH;
        t = clamp(t, 0, 1);
        t = Math.pow(t, 0.65);

        const cr = lowR + (highR - lowR) * t;
        const cg = lowG + (highG - lowG) * t;
        const cb = lowB + (highB - lowB) * t;

        const outR = 1 + (cr - 1) * colStrength;
        const outG = 1 + (cg - 1) * colStrength;
        const outB = 1 + (cb - 1) * colStrength;

        const o = idx * 3;
        driftColorArray[o + 0] = outR;
        driftColorArray[o + 1] = outG;
        driftColorArray[o + 2] = outB;
      }
    }
  }

  if (driftDeform) driftDeform.fill(0);

  if (driftColorAttr) driftColorAttr.needsUpdate = true;
}



function applyHeightsToGeometry() {
  if (!driftHeights || !driftPosArray) return;

  const d = driftDeform && driftDeform.length === DRIFT_VERTS ? driftDeform : null;

  for (let v = 0; v < DRIFT_VERTS; v++) {
    const y = driftHeights[v] + (d ? d[v] : 0);
    driftPosArray[v * 3 + 1] = y;
  }

  driftPosAttr.needsUpdate = true;
}


function sampleSnowHeight(x, z) {
  if (!driftHeights) return 0;

  const d = driftDeform && driftDeform.length === DRIFT_VERTS ? driftDeform : null;

  let u = (x + HALF_GROUND) / GROUND_SIZE;
  let v = (z + HALF_GROUND) / GROUND_SIZE;
  u = clamp(u, 0, 0.999999);
  v = clamp(v, 0, 0.999999);

  const fx = u * DRIFT_GRID;
  const fz = v * DRIFT_GRID;

  const i0 = fx | 0;
  const j0 = fz | 0;
  const i1 = Math.min(DRIFT_GRID, i0 + 1);
  const j1 = Math.min(DRIFT_GRID, j0 + 1);

  const tx = fx - i0;
  const tz = fz - j0;

  const idx00 = gridIndex(i0, j0);
  const idx10 = gridIndex(i1, j0);
  const idx01 = gridIndex(i0, j1);
  const idx11 = gridIndex(i1, j1);

  const h00 = driftHeights[idx00] + (d ? d[idx00] : 0);
  const h10 = driftHeights[idx10] + (d ? d[idx10] : 0);
  const h01 = driftHeights[idx01] + (d ? d[idx01] : 0);
  const h11 = driftHeights[idx11] + (d ? d[idx11] : 0);

  const hx0 = h00 + (h10 - h00) * tx;
  const hx1 = h01 + (h11 - h01) * tx;
  return hx0 + (hx1 - hx0) * tz;
}


function ensureWetTrailTex() {
  /* Creates the radial alpha texture used by wet decals (soft edge, no harsh squares). */
  if (wetTrailTex) return wetTrailTex;
  wetTrailTex = makeRadialTexture(128);
  wetTrailTex.wrapS = THREE.ClampToEdgeWrapping;
  wetTrailTex.wrapT = THREE.ClampToEdgeWrapping;
  wetTrailTex.needsUpdate = true;
  return wetTrailTex;
}

function makeFootprintTexture(size, cfg) {
  /* Creates an alpha texture shaped like a footprint: heel + toe ovals connected by a soft bridge. */
  const s = Math.max(32, size | 0);
  const canvas = document.createElement("canvas");
  canvas.width = s;
  canvas.height = s;

  const ctx = canvas.getContext("2d");
  ctx.clearRect(0, 0, s, s);

  const softness = clamp(cfg.footSoftness ?? 0.55, 0.05, 0.95);
  const toeScale = clamp(cfg.footToeScale ?? 0.62, 0.1, 1.0);
  const heelScale = clamp(cfg.footHeelScale ?? 0.52, 0.1, 1.0);
  const bridge = clamp(cfg.footBridge ?? 0.22, 0.0, 0.9);

  function drawSoftOval(cx, cy, rx, ry) {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(rx, ry);

    const g = ctx.createRadialGradient(0, 0, 0, 0, 0, 1);
    g.addColorStop(0.0, "rgba(255,255,255,1.0)");
    g.addColorStop(Math.max(0.01, 1.0 - softness), "rgba(255,255,255,1.0)");
    g.addColorStop(1.0, "rgba(255,255,255,0.0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.arc(0, 0, 1, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  const cx = s * 0.5;

  const toeCy = s * 0.34;
  const heelCy = s * 0.68;

  const baseRx = s * 0.22;
  const baseRy = s * 0.28;

  drawSoftOval(cx, toeCy, baseRx * toeScale, baseRy * toeScale);
  drawSoftOval(cx, heelCy, baseRx * heelScale, baseRy * heelScale);

  // Bridge: soft vertical capsule between toe and heel
  if (bridge > 0.001) {
    const bridgeW = baseRx * (0.9 * bridge + 0.1);
    const topY = toeCy + baseRy * toeScale * 0.45;
    const botY = heelCy - baseRy * heelScale * 0.55;
    const h = Math.max(1, botY - topY);

    ctx.save();
    ctx.translate(cx, topY);

    const g = ctx.createLinearGradient(0, 0, 0, h);
    g.addColorStop(0.0, "rgba(255,255,255,0.0)");
    g.addColorStop(0.25, "rgba(255,255,255,1.0)");
    g.addColorStop(0.75, "rgba(255,255,255,1.0)");
    g.addColorStop(1.0, "rgba(255,255,255,0.0)");

    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.moveTo(-bridgeW, 0);
    ctx.lineTo(bridgeW, 0);
    ctx.lineTo(bridgeW, h);
    ctx.lineTo(-bridgeW, h);
    ctx.closePath();
    ctx.fill();

    ctx.restore();
  }

  const tex = new THREE.CanvasTexture(canvas);
  tex.wrapS = THREE.ClampToEdgeWrapping;
  tex.wrapT = THREE.ClampToEdgeWrapping;
  tex.needsUpdate = true;
  return tex;
}

function ensureWetFootTex() {
  /* Creates/caches the footprint alpha texture; re-creates when footprint params change. */
  const sig =
  String(wetTrailConfig.footTexSize | 0) + "|" +
  String(wetTrailConfig.footToeScale) + "|" +
  String(wetTrailConfig.footHeelScale) + "|" +
  String(wetTrailConfig.footBridge) + "|" +
  String(wetTrailConfig.footSoftness);

  if (wetFootTex && wetFootSig === sig) return wetFootTex;

  if (wetFootTex && wetFootTex.dispose) wetFootTex.dispose();

  wetFootSig = sig;
  wetFootTex = makeFootprintTexture(wetTrailConfig.footTexSize, wetTrailConfig);
  return wetFootTex;
}






function getSnowSurfaceY(x, z) {
  /* Returns world-space snow surface Y (snowSurface offset + sampled drift height). */
  const baseY = snowSurface ? snowSurface.position.y : 0.0;
  return baseY + sampleSnowHeight(x, z);
}





/**
 * Returns the current traversable surface Y at XZ.
 * Today this is the snow surface; future surfaces (water/dunes/etc.) can be routed here.
 */
function getWorldSurfaceY(x, z) {
  /* Returns the highest traversable surface at XZ: snow surface plus any instance meshes flagged `ground:true`. */
  const snowY = getSnowSurfaceY(x, z);

  if (!worldGroundMeshes || worldGroundMeshes.length === 0) return snowY;

  // Keep matrices fresh when world-editing/transforming objects.
  if (worldEditState && worldEditState.enabled) {
    for (let i = 0; i < worldGroundMeshes.length; i++) {
      const m = worldGroundMeshes[i];
      if (m && m.matrixWorldNeedsUpdate) m.updateWorldMatrix(true, false);
    }
  }

  worldGroundRayOrigin.set(x, snowY + 1000.0, z);
  worldGroundRaycaster.near = 0.0;
  worldGroundRaycaster.far = 2000.0;
  worldGroundRaycaster.set(worldGroundRayOrigin, worldGroundRayDir);

  const hits = worldGroundRaycaster.intersectObjects(worldGroundMeshes, false);
  if (!hits || hits.length === 0) return snowY;

  const hitY = hits[0].point ? hits[0].point.y : NaN;
  if (!Number.isFinite(hitY)) return snowY;


  // if(avatar.position.y > 6 ) {

  //   return 0;

  // } else {

  //   return hitY > snowY ? hitY : snowY;

  // }


  return hitY > snowY ? hitY : snowY;
  





}


/**
 * Approximates the current traversable surface normal at XZ using central differences.
 */
function getWorldSurfaceNormal(x, z, eps, out) {
  const e = Math.max(1e-3, Number.isFinite(eps) ? eps : 0.75);

  const hL = getWorldSurfaceY(x - e, z);
  const hR = getWorldSurfaceY(x + e, z);
  const hD = getWorldSurfaceY(x, z - e);
  const hU = getWorldSurfaceY(x, z + e);

  out.set(hL - hR, 2.0 * e, hD - hU);

  if (!Number.isFinite(out.x) || !Number.isFinite(out.y) || !Number.isFinite(out.z) || out.lengthSq() < 1e-12) {
    out.set(0, 1, 0);
    return out;
  }

  out.normalize();
  return out;
}


function setupWetTrailSystem() {
  /* Builds a pooled decal system for short-lived wet marks behind avatar/vehicles. */
  if (!scene) return;

  if (!wetTrailGroup) {
    wetTrailGroup = new THREE.Group();
    wetTrailGroup.renderOrder = 6;
    scene.add(wetTrailGroup);
  }

  if (!wetTrailGeo) {
    wetTrailGeo = new THREE.PlaneGeometry(1, 1, 1, 1);
    wetTrailGeo.rotateX(-Math.PI / 2);
  }

  rebuildWetTrailPool();
}

function rebuildWetTrailPool() {
  /* Resizes the decal pool to wetTrailConfig.maxMarks and keeps old ones hidden. */
  if (!wetTrailGroup || !wetTrailGeo) return;

  const target = clamp(wetTrailConfig.maxMarks | 0, 0, 3000);

  while (wetTrailPool.length > target) {
    const m = wetTrailPool.pop();
    if (m) {
      wetTrailGroup.remove(m);
      if (m.material) m.material.dispose();
    }
  }

  while (wetTrailPool.length < target) {
    const tex = ensureWetTrailTex();
    const mat = new THREE.MeshBasicMaterial({
      color: new THREE.Color(wetTrailConfig.color),
      transparent: true,
      opacity: 0.0,
      alphaMap: tex,
      depthWrite: false,
      depthTest: true
    });
    mat.polygonOffset = true;
    mat.polygonOffsetFactor = -2;
    mat.polygonOffsetUnits = -2;

    const m = new THREE.Mesh(wetTrailGeo, mat);
    m.visible = false;
    m.frustumCulled = true;
    m.userData.age = 0.0;
    m.userData.life = 0.0;
    m.userData.baseOpacity = 0.0;

    wetTrailGroup.add(m);
    wetTrailPool.push(m);
  }

  wetTrailCursor = 0;
}

function clearWetTrails() {
  /* Hides all decals immediately. */
  for (let i = 0; i < wetTrailPool.length; i++) {
    const m = wetTrailPool[i];
    if (!m) continue;
    m.visible = false;
    m.userData.age = 0.0;
    m.userData.life = 0.0;
    m.userData.baseOpacity = 0.0;
    if (m.material) m.material.opacity = 0.0;
  }
}

function spawnWetTrailMark(x, z, yaw, sx, sz, baseOpacity, life, opts) {
  /* Spawns a single fading decal at world XZ, aligned to yaw, sitting on the snow surface. */
  if (!wetTrailConfig.enabled) return;
  if (!wetTrailPool || wetTrailPool.length === 0) return;

  const m = wetTrailPool[wetTrailCursor];
  wetTrailCursor = (wetTrailCursor + 1) % wetTrailPool.length;

  const y = getSnowSurfaceY(x, z) + wetTrailConfig.lift;

  m.position.set(x, y, z);
  m.rotation.set(0, yaw, 0);
  m.scale.set(Math.max(0.01, sx), 1.0, Math.max(0.01, sz));

  m.userData.age = 0.0;
  m.userData.life = Math.max(0.05, life);
  m.userData.baseOpacity = clamp(baseOpacity, 0.0, 1.0);

  const col =
  (opts && opts.color) ||
  wetTrailConfig.color ||
  "#1a1a1a";

  const alpha =
  (opts && opts.alphaMap) ||
  ensureWetTrailTex();

  if (m.material) {
    if (m.material.alphaMap !== alpha) {
      m.material.alphaMap = alpha;
      m.material.needsUpdate = true;
    }
    m.material.color.set(col);
    m.material.opacity = m.userData.baseOpacity;
  }

  m.visible = true;
}


function updateWetTrails(dt) {
  /* Advances decal fade-outs and hides expired marks. */
  if (!wetTrailConfig.enabled) return;
  if (!(dt > 0)) return;

  for (let i = 0; i < wetTrailPool.length; i++) {
    const m = wetTrailPool[i];
    if (!m || !m.visible) continue;

    const life = m.userData.life || 0.0;
    if (!(life > 0)) {
      m.visible = false;
      continue;
    }

    m.userData.age += dt;
    const a = clamp(1.0 - (m.userData.age / life), 0.0, 1.0);

    const fade = a * a;
    if (m.material) m.material.opacity = (m.userData.baseOpacity || 0.0) * fade;

    if (a <= 0.0) {
      m.visible = false;
      if (m.material) m.material.opacity = 0.0;
    }
  }
}



function depositHeightAtWorld(x, z, amount, windX = 0, windZ = 0) {
  if (!driftHeights || amount === 0) return;

      // push deposits slightly downwind (turbulence bias)
  const drift = 0.35;
  const nx = x + windX * drift;
  const nz = z + windZ * drift;

  let u = (nx + HALF_GROUND) / GROUND_SIZE;
  let v = (nz + HALF_GROUND) / GROUND_SIZE;
  u = clamp(u, 0, 1);
  v = clamp(v, 0, 1);

  const ci = clamp((u * DRIFT_GRID) | 0, 0, DRIFT_GRID);
  const cj = clamp((v * DRIFT_GRID) | 0, 0, DRIFT_GRID);

  const maxH = Math.max(0.5, params.driftMaxHeight);
  const baseAmount = amount;

  for (const k of driftKernel) {
    const i = ci + k.dx;
    const j = cj + k.dz;
    if (i < 0 || i > DRIFT_GRID || j < 0 || j > DRIFT_GRID) continue;
    const idx = gridIndex(i, j);
    const h = driftHeights[idx];
    const shelter = clamp(1.0 - h / maxH, 0.1, 1.0);
    const delta = baseAmount * k.w * shelter;
    driftHeights[idx] = clamp(h + delta, 0, maxH);
  }
}

/**
 * Requests an immediate drift height write to geometry (and normals refresh) on the next simulation tick.
 * Used by local deformation (footprints/tracks) so marks appear immediately without lowering global intervals.
 */
function requestDriftWrite() {
  forceDriftWrite = true;
  forceDriftNormals = true;
}




/**
 * Carves a smooth circular depression into the snow surface.
 * Size is stable across driftGrid values (no "cell-sized" craters).
 * Writes into driftDeform so drifting (driftHeights) can continue evolving independently.
 */
function carveHeightAtWorld(x, z, depth) {
  if (!snowDeformConfig.enabled) return false;
  if (!driftHeights || !driftDeform) return false;
  if (!(depth > 0)) return false;

  const grid = DRIFT_GRID;
  const cell = GROUND_SIZE / grid;

  const depthMin = Math.max(0, snowDeformConfig.carveDepthMin);
  const depthMax = Math.max(depthMin + 1e-6, snowDeformConfig.carveDepthMax);
  const d = clamp(depth, depthMin, depthMax);

  let radiusWorld = snowDeformConfig.carveRadiusBase + d * snowDeformConfig.carveRadiusFromDepth;
  radiusWorld = clamp(radiusWorld, snowDeformConfig.carveRadiusMin, snowDeformConfig.carveRadiusMax);
  radiusWorld = Math.max(radiusWorld, cell * Math.max(0, snowDeformConfig.carveMinCellFrac));

  const maxCells = Math.max(1, (snowDeformConfig.carveMaxCells | 0));
  const rCells = Math.min(maxCells, Math.max(1, Math.ceil(radiusWorld / cell)));
  const r2 = radiusWorld * radiusWorld;

  const sigma = Math.max(1e-4, radiusWorld * Math.max(0.05, snowDeformConfig.carveSigmaFrac));
  const invTwoSigma2 = 1.0 / (2.0 * sigma * sigma);

  const maxCarve = Math.max(0.001, snowDeformConfig.carveMaxCarve);
  const minDeform = -maxCarve;

  let u = (x + HALF_GROUND) / GROUND_SIZE;
  let v = (z + HALF_GROUND) / GROUND_SIZE;
  u = clamp(u, 0, 1);
  v = clamp(v, 0, 1);

  const ci = clamp((u * grid) | 0, 0, grid);
  const cj = clamp((v * grid) | 0, 0, grid);

  let changed = false;

  for (let dj = -rCells; dj <= rCells; dj++) {
    const j = cj + dj;
    if (j < 0 || j > grid) continue;

    const wz = -HALF_GROUND + j * cell;
    const dz = wz - z;
    const dz2 = dz * dz;
    if (dz2 > r2) continue;

    for (let di = -rCells; di <= rCells; di++) {
      const i = ci + di;
      if (i < 0 || i > grid) continue;

      const wx = -HALF_GROUND + i * cell;
      const dx = wx - x;

      const dist2 = dx * dx + dz2;
      if (dist2 > r2) continue;

      const w = Math.exp(-dist2 * invTwoSigma2);
      if (w < 1e-4) continue;

      const idx = gridIndex(i, j);

      const baseAmount = d * w;
      const next = driftDeform[idx] - baseAmount;

      driftDeform[idx] = next < minDeform ? minDeform : next;
      changed = true;
    }
  }

  return changed;
}





const snowDeformConfig = {
  enabled: true,

  avatarFootRadius: 0.22,
  avatarStepDistance: 0.55,
  avatarDepthWalk: 0.010,
  avatarDepthRun: 0.016,

  vehicleTrackDepth: 0.050,
  vehicleHalfWidthFallback: 0.42,
  vehicleTrackSpacing: 0.70,

  carveDepthMin: 0.005,
  carveDepthMax: 0.080,

  carveRadiusBase: 0.18,
  carveRadiusFromDepth: 9.0,
  carveRadiusMin: 0.22,
  carveRadiusMax: 1.35,

  carveMinCellFrac: 0.25,
  carveMaxCells: 12,

  carveSigmaFrac: 0.55,
  carveMaxCarve: 0.18
};




const avatarFootprintState = {
  has: false,
  lastX: 0,
  lastZ: 0,
  acc: 0,
  phase: 0
};

/**
 * Stamps alternating left/right footprints into the deformation field and optionally spawns wet footprint decals.
 * Step spacing uses snowDeformConfig.avatarStepDistance; depth uses avatarDepthWalk/avatarDepthRun.
 */
function stampSnowFromAvatar(speedAbs) {
  if (!snowDeformConfig.enabled || !avatar || !driftHeights || !driftDeform) return;

  const minSpeed = 0.15;
  if (!(speedAbs >= minSpeed)) {
    avatarFootprintState.has = false;
    avatarFootprintState.acc = 0;
    return;
  }


  const x = avatar.position.x;
  const z = avatar.position.z;

  if (!avatarFootprintState.has) {
    avatarFootprintState.has = true;
    avatarFootprintState.lastX = x;
    avatarFootprintState.lastZ = z;
    avatarFootprintState.acc = 0;
    avatarFootprintState.phase = 0;
    return;
  }

  const dx = x - avatarFootprintState.lastX;
  const dz = z - avatarFootprintState.lastZ;
  const dist = Math.sqrt(dx * dx + dz * dz);

  avatarFootprintState.lastX = x;
  avatarFootprintState.lastZ = z;

  if (!(dist > 1e-6)) return;

  avatarFootprintState.acc += dist;

  const step = Math.max(0.10, snowDeformConfig.avatarStepDistance);
  const yaw = avatar.rotation.y;

  const fx = Math.sin(yaw);
  const fz = Math.cos(yaw);
  const rx = Math.sin(yaw + Math.PI * 0.5);
  const rz = Math.cos(yaw + Math.PI * 0.5);

  const runThreshold = (AVATAR_WALK_SPEED + AVATAR_RUN_SPEED) * 0.5;
  const depth = speedAbs >= runThreshold ? snowDeformConfig.avatarDepthRun : snowDeformConfig.avatarDepthWalk;

  const lateral = Math.max(0.06, snowDeformConfig.avatarFootRadius * 0.65);

  const markSize = Math.max(0.05, wetTrailConfig.avatarSize);
  const markOpacity = wetTrailConfig.opacity;
  const markLife = wetTrailConfig.life;

  const footColor = wetTrailConfig.avatarColor || wetTrailConfig.color || "#1a1a1a";
  const footAlpha = wetTrailConfig.avatarUseFootprint ? ensureWetFootTex() : ensureWetTrailTex();

  let didCarve = false;

  while (avatarFootprintState.acc >= step) {
    avatarFootprintState.acc -= step;

    const side = (avatarFootprintState.phase & 1) ? -1 : 1;
    const px = x + rx * lateral * side - fx * (step * 0.15);
    const pz = z + rz * lateral * side - fz * (step * 0.15);

    if (carveHeightAtWorld(px, pz, depth)) didCarve = true;


    spawnWetTrailMark(px, pz, yaw, markSize, markSize, markOpacity, markLife, {
      color: footColor,
      alphaMap: footAlpha
    });

    avatarFootprintState.phase++;
  }

  if (didCarve) requestDriftWrite();
}






/**
 * Stamps simple dual tracks (left/right) into the deformation field for the active vehicle.
 * Uses vehicleTrackDepth/vehicleTrackSpacing from snowDeformConfig.
 */
/**
 * Stamps simple dual tracks (left/right) into the deformation field for the active vehicle.
 * Uses vehicleTrackDepth/vehicleTrackSpacing from snowDeformConfig.
 */
function stampSnowFromVehicle(v, speedAbs, maxSpeed) {
  if (!snowDeformConfig.enabled || !v || !v.object || !v.meta || !driftHeights || !driftDeform) return;

  const ms = Math.max(1e-6, maxSpeed || 1);
  const minSpeed = Math.max(0.15, ms * 0.05);
  if (!(speedAbs >= minSpeed)) {
    vehicleDriveState.lastTrackValid = false;
    vehicleDriveState.trackAcc = 0;
    return;
  }

  const x = v.object.position.x;
  const z = v.object.position.z;

  if (!vehicleDriveState.lastTrackValid) {
    vehicleDriveState.lastTrackValid = true;
    vehicleDriveState.lastTrackX = x;
    vehicleDriveState.lastTrackZ = z;
    vehicleDriveState.trackAcc = 0;
    return;
  }

  const dx = x - vehicleDriveState.lastTrackX;
  const dz = z - vehicleDriveState.lastTrackZ;
  const dist = Math.sqrt(dx * dx + dz * dz);

  vehicleDriveState.lastTrackX = x;
  vehicleDriveState.lastTrackZ = z;

  if (!(dist > 1e-6)) return;

  vehicleDriveState.trackAcc += dist;

  const prof = (v.meta && v.meta.profile) ? v.meta.profile : {};
  const radius = Math.max(0.35, (prof.radius ?? v.radius ?? 0.9));

  const halfWidth = Math.max(
    0.22,
    (prof.trackHalfWidth != null ? prof.trackHalfWidth : (radius * 0.55)) ||
    snowDeformConfig.vehicleHalfWidthFallback
    );

  const wheelBase = Math.max(0.6, prof.wheelBase ?? (radius * 2.2));
  const fore = wheelBase * 0.35;

  const yaw = vehicleDriveState.yaw;
  const fx = Math.sin(yaw);
  const fz = Math.cos(yaw);
  const rx = Math.sin(yaw + Math.PI * 0.5);
  const rz = Math.cos(yaw + Math.PI * 0.5);

  const depthScale = clamp(speedAbs / ms, 0.25, 1.0);
  const depth = snowDeformConfig.vehicleTrackDepth * depthScale;

  const spacing = Math.max(0.15, snowDeformConfig.vehicleTrackSpacing);

  const sx = Math.max(
    0.05,
    Number.isFinite(prof.wetWidth) ? prof.wetWidth : wetTrailConfig.vehicleWidth
    );

  const sz = Math.max(
    0.05,
    Number.isFinite(prof.wetLength) ? prof.wetLength : wetTrailConfig.vehicleLength
    );

  const trailColor = wetTrailConfig.vehicleColor || wetTrailConfig.color || "#1a1a1a";
  const trailAlpha = ensureWetTrailTex();
  const trailOpts = { color: trailColor, alphaMap: trailAlpha };

  let didCarve = false;

  while (vehicleDriveState.trackAcc >= spacing) {
    vehicleDriveState.trackAcc -= spacing;

    const p1x = x - rx * halfWidth + fx * fore;
    const p1z = z - rz * halfWidth + fz * fore;
    const p2x = x - rx * halfWidth - fx * fore;
    const p2z = z - rz * halfWidth - fz * fore;

    const p3x = x + rx * halfWidth + fx * fore;
    const p3z = z + rz * halfWidth + fz * fore;
    const p4x = x + rx * halfWidth - fx * fore;
    const p4z = z + rz * halfWidth - fz * fore;

    if (carveHeightAtWorld(p1x, p1z, depth)) didCarve = true;
    if (carveHeightAtWorld(p2x, p2z, depth)) didCarve = true;
    if (carveHeightAtWorld(p3x, p3z, depth)) didCarve = true;
    if (carveHeightAtWorld(p4x, p4z, depth)) didCarve = true;

    spawnWetTrailMark(p1x, p1z, yaw, sx, sz, wetTrailConfig.opacity, wetTrailConfig.life, trailOpts);
    spawnWetTrailMark(p2x, p2z, yaw, sx, sz, wetTrailConfig.opacity, wetTrailConfig.life, trailOpts);
    spawnWetTrailMark(p3x, p3z, yaw, sx, sz, wetTrailConfig.opacity, wetTrailConfig.life, trailOpts);
    spawnWetTrailMark(p4x, p4z, yaw, sx, sz, wetTrailConfig.opacity, wetTrailConfig.life, trailOpts);
  }

  if (didCarve) requestDriftWrite();
}










function evolveDrifts(windX, windZ) {
  if (!driftHeights || !driftHeightsTmp) return;

  const diff = clamp(params.driftDiffusion, 0.0, 0.25);
  const adv = clamp(params.driftAdvection, 0.0, 0.30);
  if (diff <= 0 && adv <= 0) return;

  const wx = clamp(windX, -1, 1);
  const wz = clamp(windZ, -1, 1);

  for (let j = 0; j <= DRIFT_GRID; j++) {
    const jb = j > 0 ? j - 1 : j;
    const jf = j < DRIFT_GRID ? j + 1 : j;
    for (let i = 0; i <= DRIFT_GRID; i++) {
      const ib = i > 0 ? i - 1 : i;
      const ifw = i < DRIFT_GRID ? i + 1 : i;

      const idx = gridIndex(i, j);
      const h = driftHeights[idx];

      const hL = driftHeights[gridIndex(ib, j)];
      const hR = driftHeights[gridIndex(ifw, j)];
      const hD = driftHeights[gridIndex(i, jb)];
      const hU = driftHeights[gridIndex(i, jf)];
      const avg = (hL + hR + hD + hU) * 0.25;

          // simple upwind sample
      const upI = clamp(i - Math.round(wx), 0, DRIFT_GRID);
      const upJ = clamp(j - Math.round(wz), 0, DRIFT_GRID);
      const upH = driftHeights[gridIndex(upI, upJ)];

      let nh = h + diff * (avg - h) + adv * (upH - h);
      nh = Math.max(0, nh * 0.99982);
      driftHeightsTmp[idx] = nh;
    }
  }

  const tmp = driftHeights;
  driftHeights = driftHeightsTmp;
  driftHeightsTmp = tmp;
}

function shapeDriftsAroundObstacles(windX, windZ) {
  if (!driftHeights || !colliderBounds.length) return;
  const wx = windX;
  const wz = windZ;
  const len = Math.sqrt(wx * wx + wz * wz);
  if (len < 1e-4) return;

  const nx = wx / len;
  const nz = wz / len;

  for (const cb of colliderBounds) {
    const ox = cb.center.x;
    const oz = cb.center.z;

    const scourX = ox - nx * (cb.radius * 1.20);
    const scourZ = oz - nz * (cb.radius * 1.20);

    const driftX = ox + nx * (cb.radius * 1.55);
    const driftZ = oz + nz * (cb.radius * 1.55);

    depositHeightAtWorld(scourX, scourZ, -0.0016, 0, 0);
    depositHeightAtWorld(driftX, driftZ, 0.0030, wx, wz);
  }
}



/* Removes the snow surface mesh and clears drift buffers so snow can be fully disabled. */

/* Removes the snow surface mesh and clears drift buffers so snow can be fully disabled. */
function disposeSnowSurface() {
  if (snowSurface) {
    scene.remove(snowSurface);
    snowSurface.geometry.dispose();
    snowSurface.material.dispose();
    snowSurface = null;
  } else if (driftGeo) {
    driftGeo.dispose();
  }

  driftGeo = null;
  driftPosAttr = null;
  driftPosArray = null;
  driftColorAttr = null;
  driftColorArray = null;

  driftHeights = null;
  driftHeightsTmp = null;
  driftDeform = null;
}



function buildSnowSurface() {
  disposeSnowSurface();
  if (!params.snowEnabled) return;

  DRIFT_GRID = clamp(params.driftGrid | 0, 32, 256);
  DRIFT_STRIDE = DRIFT_GRID + 1;
  DRIFT_VERTS = DRIFT_STRIDE * DRIFT_STRIDE;

  driftHeights = new Float32Array(DRIFT_VERTS);
  driftHeightsTmp = new Float32Array(DRIFT_VERTS);
  driftDeform = new Float32Array(DRIFT_VERTS);

  driftGeo = new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE, DRIFT_GRID, DRIFT_GRID);
  driftGeo.rotateX(-Math.PI / 2);

  const colors = new Float32Array(DRIFT_VERTS * 3);
  colors.fill(1);
  driftGeo.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  const mat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    vertexColors: true,
    roughness: 0.995,
    metalness: 0.0,
    polygonOffset: true,
    polygonOffsetFactor: -2,
    polygonOffsetUnits: -2
  });

  snowSurface = new THREE.Mesh(driftGeo, mat);
  snowSurface.position.y = 0.02;
  snowSurface.receiveShadow = true;
  scene.add(snowSurface);

  driftPosAttr = driftGeo.attributes.position;
  driftPosArray = driftPosAttr.array;

  driftColorAttr = driftGeo.attributes.color;
  driftColorArray = driftColorAttr.array;

  initSnowCover();
  applyHeightsToGeometry();
  driftGeo.computeVertexNormals();
  driftGeo.attributes.normal.needsUpdate = true;
}




    // Clouds Shaders
const CLOUD_VERTEX_SHADER = /* glsl */ `
  attribute float aLayer;
  uniform float uRadius;
  uniform float uHeightBase;
  uniform float uHeightRange;

  varying vec3 vWorldPos;
  varying float vLayer;

  void main() {
    vec3 pos = position;

    float layerT = aLayer;
    float ang = layerT * 6.2831853;
    float h = uHeightBase + (layerT - 0.5) * uHeightRange;

    pos.x += cos(ang) * uRadius * 0.4;
    pos.z += sin(ang) * uRadius * 0.4;
    pos.y = h;

    vec4 world = modelMatrix * vec4(pos, 1.0);
    vWorldPos = world.xyz;
    vLayer = layerT;

    gl_Position = projectionMatrix * viewMatrix * world;
  }
`;





const CLOUD_FRAGMENT_SHADER = /* glsl */ `
  precision highp float;

  varying vec3 vWorldPos;
  varying float vLayer;

  uniform float uTime;
  uniform float uRadius;
  uniform float uHeightBase;
  uniform float uHeightRange;
  uniform float uDensity;
  uniform float uSoftness;
  uniform float uSpeed;
  uniform vec3 uCloudColor;
  uniform vec3 uSkyColor;
  // NEW: overall opacity mul, driven from params.cloudOpacity
  uniform float uOpacity;

  float hash(vec2 p) {
    p = fract(p * vec2(123.34, 456.21));
    p += dot(p, p + 45.32);
    return fract(p.x * p.y);
  }

  float noise(vec2 p) {
    vec2 i = floor(p);
    vec2 f = fract(p);

    float a = hash(i);
    float b = hash(i + vec2(1.0, 0.0));
    float c = hash(i + vec2(0.0, 1.0));
    float d = hash(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
           (c - a) * u.y * (1.0 - u.x) +
           (d - b) * u.x * u.y;
  }

  float fbm(vec2 p) {
    float v = 0.0;
    float a = 0.5;
    float f = 1.0;
    for (int i = 0; i < 4; i++) {
      v += a * noise(p * f);
      f *= 2.0;
      a *= 0.5;
    }
    return v;
  }

  void main() {
    vec2 uv = vWorldPos.xz / uRadius;

    float scroll = uTime * uSpeed;
    vec2 p = uv * 1.2 + vec2(scroll, vLayer * 0.27);

    float n = fbm(p);

    // center of the cloud band in noise space
    float center = 1.0 - uDensity;

    // softness controls *band width* around that center
    float halfWidth = max(0.001, uSoftness * 0.5);

    // alpha = 0 below center - halfWidth
    // alpha = 1 above center + halfWidth
    // smooth fade in between â†’ nice white â†’ transparent gradient
    float alpha = smoothstep(center - halfWidth, center + halfWidth, n);

    float dist = length(vWorldPos.xz) / uRadius;
    float edgeFade = smoothstep(1.0, 0.6, dist);
    alpha *= edgeFade;

    float hFade = smoothstep(0.0, 0.4, vLayer) * smoothstep(1.0, 0.5, vLayer);
    alpha *= hFade;

    // NEW: use uniform instead of hard-coded 1.35
    alpha = clamp(alpha * uOpacity, 0.0, 1.0);

    if (alpha < 0.02) discard;

    // color is still a blend between sky and cloud colors
    vec3 rgb = mix(uSkyColor, uCloudColor, alpha);
    gl_FragColor = vec4(rgb, alpha);
  }
`;




function setupClouds() {
  if (!params.cloudEnabled) return;

  const sliceCount = Math.max(1, params.cloudSliceCount | 0);

  const geo = new THREE.PlaneGeometry(
    params.cloudRadius * 2.0,
    params.cloudRadius * 1.4,
    1,
    1
    );
  geo.rotateX(-Math.PI / 2);

  const layerAttr = new Float32Array(sliceCount);
  const denom = sliceCount > 1 ? sliceCount - 1 : 1;
  for (let i = 0; i < sliceCount; i++) {
    layerAttr[i] = i / denom;
  }
  geo.setAttribute(
    "aLayer",
    new THREE.InstancedBufferAttribute(layerAttr, 1)
    );

  cloudMaterial = new THREE.ShaderMaterial({
    vertexShader: CLOUD_VERTEX_SHADER,
    fragmentShader: CLOUD_FRAGMENT_SHADER,
    transparent: true,
    depthWrite: false,
    depthTest: true,
    side: THREE.DoubleSide
  });

  cloudMaterial.uniforms = {
    uTime: { value: 0 },
    uRadius: { value: params.cloudRadius },
    uHeightBase: { value: params.cloudHeightBase },
    uHeightRange: { value: params.cloudHeightRange },
    uDensity: { value: params.cloudDensity },
    uSoftness: { value: params.cloudSoftness },
    uSpeed: { value: params.cloudSpeed },
    // NEW: driven from params so presets/files carry it
    uCloudColor: { value: new THREE.Color(params.cloudColor || "#f5f7ff") },
    uSkyColor: { value: new THREE.Color(params.cloudSkyColor || "#0a1220") },
    uOpacity: { value: params.cloudOpacity }
  };

  cloudLayer = new THREE.InstancedMesh(geo, cloudMaterial, sliceCount);
  // draw clouds after snow points (2) and stuck decals (3)
  cloudLayer.renderOrder = 4;

  const dummy = new THREE.Object3D();
  for (let i = 0; i < sliceCount; i++) {
    dummy.position.set(0, 0, 0);
    dummy.rotation.set(0, 0, 0);
    dummy.scale.set(1, 1, 1);
    dummy.updateMatrix();
    cloudLayer.setMatrixAt(i, dummy.matrix);
  }

  cloudLayer.instanceMatrix.needsUpdate = true;
  scene.add(cloudLayer);
}






// function updateClouds(dt) {
//   if (!cloudMaterial) return;
//   cloudMaterial.uniforms.uTime.value += dt;
// }


/* Updates cloud shader time; throttled while flying to avoid jitter from drift/grid frame spikes. */
function updateClouds(dt) {
  if (!cloudMaterial) return;

  const flyingPlane = !!(vehicleDriveState && vehicleDriveState.enabled && vehicleDriveState.planeAirborne);

  const jetpackEquipped =
  !!(equipmentState && equipmentState.enabled && equipmentState.item && equipmentState.item.meta &&
   typeof equipmentState.item.meta.action === "string" &&
   equipmentState.item.meta.action.trim().toLowerCase() === "jetpack");

  const flyingJetpack = jetpackEquipped && !!(avatarJumpState && avatarJumpState.active);

  if (!updateClouds._accum) updateClouds._accum = 0;

  if (flyingPlane || flyingJetpack) {
    // Accumulate small dt chunks and step at a steady cadence while flying.
    updateClouds._accum += dt;

    // Update at ~30Hz max during flight; keeps visuals stable without per-frame dt spikes.
    const step = 1 / 30;
    if (updateClouds._accum < step) return;

    const adv = Math.min(0.12, updateClouds._accum);
    updateClouds._accum = 0;
    cloudMaterial.uniforms.uTime.value += adv;
    return;
  }

  updateClouds._accum = 0;
  cloudMaterial.uniforms.uTime.value += dt;
}





/* Builds or updates the environmental noise audio graph from params (no rebuild unless needed). */
function applyEnvSoundFromParams() {
  const enabled = !!params.envSoundEnabled;

  // Turn OFF: stop + close
  if (!enabled) {
    if (envAudioState && envAudioState.source) {
      try { envAudioState.source.stop(); } catch (e) {}
    }
    if (envAudioState && envAudioState.ctx) {
      try { envAudioState.ctx.close(); } catch (e) {}
    }
    envAudioState = null;
    return;
  }

  // Turn ON: create graph once
  if (!envAudioState) {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();

    const bufferSize = (ctx.sampleRate * 2) | 0;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * Math.random();

      const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;

    const filter = ctx.createBiquadFilter();
    filter.type = "bandpass";

    const convolver = ctx.createConvolver();
    const dry = ctx.createGain();
    const wet = ctx.createGain();
    const panner = ctx.createStereoPanner();
    const master = ctx.createGain();

    source.connect(filter);
    filter.connect(dry);
    filter.connect(convolver);
    convolver.connect(wet);
    dry.connect(panner);
    wet.connect(panner);
    panner.connect(master);
    master.connect(ctx.destination);

    source.start();

    envAudioState = {
      ctx,
      source,
      filter,
      convolver,
      dryGain: dry,
      wetGain: wet,
      panner,
      master,
      panPhase: 0,
      _irSeconds: -1
    };
  }

  const s = envAudioState;
  if (s.ctx.state === "suspended") s.ctx.resume().catch(() => {});

  // Cheap parameter updates (no graph rebuild)
  const vol = clamp(Number(params.envSoundVolume ?? 0.18), 0.0, 1.0);
  const mix = clamp(Number(params.envSoundReverbMix ?? 0.35), 0.0, 1.0);
  const irSeconds = clamp(Number(params.envSoundIrSeconds ?? 1.5), 0.2, 6.0);

  s.master.gain.value = vol;
  s.dryGain.gain.value = 1 - mix;
  s.wetGain.gain.value = mix;

  // Only rebuild IR when the IR length actually changes
  if (Math.abs(irSeconds - s._irSeconds) > 1e-6) {
    s._irSeconds = irSeconds;

    const irLen = Math.max(1, (irSeconds * s.ctx.sampleRate) | 0);
    const ir = s.ctx.createBuffer(2, irLen, s.ctx.sampleRate);
    for (let c = 0; c < 2; c++) {
      const d = ir.getChannelData(c);
      for (let i = 0; i < irLen; i++) d[i] = (Math.random() * 2 - 1) * (1 - i / irLen);
    }
  s.convolver.buffer = ir;
}

const toneHz = clamp(Number(params.envSoundToneHz ?? 0), 0, 8000);
if (toneHz > 0) {
  s.filter.frequency.value = toneHz;
  s.filter.Q.value = 0.9;
} else {
  s.filter.frequency.value = 12000;
  s.filter.Q.value = 0.1;
}
}






/* Advances stereo panning for environmental sound (throttled). */
function tickEnvSound(dt) {
  if (!envAudioState) return;

  if (!tickEnvSound._accum) tickEnvSound._accum = 0;
  tickEnvSound._accum += dt;

  const step = 1 / 30;
  if (tickEnvSound._accum < step) return;

  const adv = tickEnvSound._accum;
  tickEnvSound._accum = 0;

  envAudioState.panPhase += adv * params.envSoundPanSpeed;
  envAudioState.panner.pan.value =
  Math.sin(envAudioState.panPhase) * params.envSoundPanDepth;
}




function applyCloudParamsToUniforms() {
  if (!cloudMaterial) return;
  const u = cloudMaterial.uniforms;

  u.uRadius.value = params.cloudRadius;
  u.uHeightBase.value = params.cloudHeightBase;
  u.uHeightRange.value = params.cloudHeightRange;
  u.uDensity.value = params.cloudDensity;
  u.uSoftness.value = params.cloudSoftness;
  u.uSpeed.value = params.cloudSpeed;

  // NEW:
  if (params.cloudColor) {
    u.uCloudColor.value.set(params.cloudColor);
  }
  if (params.cloudSkyColor) {
    u.uSkyColor.value.set(params.cloudSkyColor);
  }
  u.uOpacity.value = params.cloudOpacity;
}


function disposeClouds() {
  if (cloudLayer) {
    scene.remove(cloudLayer);
    cloudLayer.geometry.dispose();
    cloudLayer.material.dispose();
    cloudLayer = null;
    cloudMaterial = null;
  }
}

function rebuildClouds() {
  disposeClouds();
  if (!params.cloudEnabled) return;
  setupClouds();
  applyCloudParamsToUniforms();
}







    // -------------------------------------------------------------------------
    // Visual flakes (GPU point sprites + gust uniforms)
    // -------------------------------------------------------------------------

/* Disposes the visual snow point-sprite system and releases GPU resources. */
function disposeSnowField() {
  if (snowPoints) {
    scene.remove(snowPoints);
    snowPoints = null;
  }
  if (snowGeo) {
    snowGeo.dispose();
    snowGeo = null;
  }
  if (snowMat) {
    snowMat.dispose();
    snowMat = null;
  }
}

function buildSnowField() {
  disposeSnowField();
  if (!params.snowEnabled) return;

  const count = clamp(params.visualCount | 0, 20000, 600000);
  const pos = new Float32Array(count * 3);
  const seeds = new Float32Array(count);

  for (let i = 0; i < count; i++) {
    const p = i * 3;
    pos[p + 0] = (Math.random() * 2 - 1) * visualBounds.x;
    pos[p + 1] = visualBounds.yMin + Math.random() * (visualBounds.yMax - visualBounds.yMin);
    pos[p + 2] = (Math.random() * 2 - 1) * visualBounds.z;
    seeds[i] = Math.random();
  }

  snowGeo = new THREE.BufferGeometry();
  snowGeo.setAttribute("position", new THREE.BufferAttribute(pos, 3));
  snowGeo.setAttribute("aSeed", new THREE.BufferAttribute(seeds, 1));

  snowMat = new THREE.ShaderMaterial({
    transparent: true,
    depthWrite: false,
    uniforms: {
      uTime: { value: 0 },
      uTex: { value: snowTex },
      uWind: { value: new THREE.Vector2(0, 0) },
      uBounds: { value: new THREE.Vector2(visualBounds.x, visualBounds.z) },
      uYTop: { value: visualBounds.yMax },
      uYBot: { value: visualBounds.yMin },
      uGroundY: { value: 0.06 },
      uFallSpeed: { value: params.fallSpeed },
      uFallJitter: { value: params.fallJitter },
      uFlakeSize: { value: params.flakeSize },
      uFlakeSizeJitter: { value: params.flakeSizeJitter },
      uGustPosRad: { value: gustPosRad },
      uGustParams: { value: gustParams }
    },
    vertexShader: `
          uniform float uTime;
          uniform vec2 uWind;
          uniform vec2 uBounds;
          uniform float uYTop;
          uniform float uYBot;
          uniform float uGroundY;

          uniform float uFallSpeed;
          uniform float uFallJitter;
          uniform float uFlakeSize;
          uniform float uFlakeSizeJitter;

          uniform float uGustPosRad[${GUST_MAX * 3}];
          uniform float uGustParams[${GUST_MAX * 3}];

          attribute float aSeed;

          varying float vAlpha;

          float wrapCoord(float x, float halfSpan) {
            float span = halfSpan * 2.0;
            return -halfSpan + mod(x + halfSpan + span * 1000.0, span);
          }

          float jitter01(float x) {
            return fract(sin(x) * 43758.5453123);
          }

          void main() {
            vec3 p = position;

            float spanY = (uYTop - uYBot);

            float jf = jitter01(aSeed * 91.7 + 3.1);
            float fallMul = mix(1.0 - uFallJitter, 1.0 + uFallJitter, jf);
            float speed = max(0.001, uFallSpeed) * fallMul;

            float phase = aSeed * 37.0;
            float y = uYTop - mod(uTime * speed + phase, spanY);

            float nearGround = clamp(1.0 - (y - uYBot) / 6.0, 0.0, 1.0);

            float flutter =
              sin(uTime * 1.15 + aSeed * 83.0) * 0.10 +
              sin(uTime * 1.85 + aSeed * 19.0) * 0.05;

            vec2 drift =
              uWind * (0.22 + 0.16 * sin(aSeed * 11.0)) +
              vec2(flutter * 0.18,
                   cos(uTime * 0.9 + aSeed * 41.0) * 0.03);

            vec2 gustVec = vec2(0.0);
            float lift = 0.0;

            for (int gi = 0; gi < ${GUST_MAX}; gi++) {
              float gx = uGustPosRad[gi * 3 + 0];
              float gz = uGustPosRad[gi * 3 + 1];
              float gr = uGustPosRad[gi * 3 + 2];

              float gs  = uGustParams[gi * 3 + 0];
              float gsw = uGustParams[gi * 3 + 1];
              float gup = uGustParams[gi * 3 + 2];

              vec2 d = vec2(p.x - gx, p.z - gz);
              float r2 = dot(d, d);
              float rr = sqrt(max(r2, 1e-6));
              if (rr > gr) continue;

              float radial = 1.0 - rr / gr;
              float k = radial * radial * nearGround * gs;

              vec2 n = d / rr;
              vec2 t = vec2(-n.y, n.x);

              gustVec += t * (gsw * k) + (-n) * (0.12 * k);
              lift += gup * k * (radial * radial);
            }

            float gustLen = length(gustVec);
            float gustMax = 3.0;
            if (gustLen > gustMax) {
              gustVec *= gustMax / max(gustLen, 1e-5);
            }
            lift = clamp(lift, -3.0, 3.0);

            y += lift * 0.12;

            float x = p.x + drift.x * uTime + gustVec.x;
            float z = p.z + drift.y * uTime + gustVec.y;

            x = wrapCoord(x, uBounds.x);
            z = wrapCoord(z, uBounds.y);

            vec3 worldPos = vec3(x, y, z);
            vec4 mvPosition = modelViewMatrix * vec4(worldPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            float js = jitter01(aSeed * 13.9 + 7.7);
            float sizeMul = mix(1.0 - uFlakeSizeJitter, 1.0 + uFlakeSizeJitter, js);
            float size = max(0.05, uFlakeSize) * sizeMul;

            gl_PointSize = size * (300.0 / -mvPosition.z);

            float groundFade = clamp((y - uGroundY) / 0.9, 0.0, 1.0);
            vAlpha = (mix(0.55, 0.95, fract(aSeed * 4.77))
                     * (0.65 + 0.35 * nearGround)) * groundFade;
          }
      `,

      fragmentShader: `
          uniform sampler2D uTex;
          varying float vAlpha;

          void main() {
            vec4 tex = texture2D(uTex, gl_PointCoord);
            float a = tex.a * vAlpha * 0.65;
            if (a < 0.01) discard;
            gl_FragColor = vec4(1.0, 1.0, 1.0, a);
          }
        `
      });

snowPoints = new THREE.Points(snowGeo, snowMat);
snowPoints.frustumCulled = false;
snowPoints.renderOrder = 2;
scene.add(snowPoints);
}


    // -------------------------------------------------------------------------
    // Decals (sticking snow)
    // -------------------------------------------------------------------------

/* Disposes the sticking snow decal instancing system. */
function disposeStuckSystem() {
  if (stuck) {
    scene.remove(stuck);
    stuck.geometry.dispose();
    stuck.material.dispose();
    stuck = null;
  }
  stuckGeo = null;
  stuckMat = null;
  stuckCount = 0;
  stuckWrite = 0;
}

function buildStuckSystem() {
  disposeStuckSystem();
  if (!params.snowEnabled) return;

  const max = Math.max(1000, params.stuckMax | 0);
  stuckGeo = new THREE.CircleGeometry(Math.max(0.05, params.decalSize), 20);
  stuckMat = new THREE.MeshStandardMaterial({
    color: 0xffffff,
    roughness: 0.97,
    metalness: 0.0,
    map: snowTex,
    transparent: true,
    depthWrite: false,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1,
    emissive: new THREE.Color(0x202020),
    emissiveIntensity: 0.65
  });

  stuck = new THREE.InstancedMesh(stuckGeo, stuckMat, max);
  stuck.frustumCulled = false;
  stuck.renderOrder = 3;
  scene.add(stuck);

  stuckCount = 0;
  stuckWrite = 0;
  stuck.count = 0;
  stuck.instanceMatrix.needsUpdate = true;
}

function addStuckSnow(point, normal) {
  if (!stuck) return;
  if (!Number.isFinite(point.x + point.y + point.z)) return;

  tmpNormal.set(0, 1, 0);
  if (normal && Number.isFinite(normal.x + normal.y + normal.z)) {
    tmpNormal.copy(normal);
  }

  const len = tmpNormal.length();
  if (len < 1e-6) tmpNormal.set(0, 1, 0);
  else tmpNormal.multiplyScalar(1.0 / len);

  const max = stuck.instanceMatrix.count;
  const idx = stuckWrite % max;

  const up01 = clamp((tmpNormal.y + 1.0) * 0.5, 0.0, 1.0);

  const lift = 0.008 + Math.random() * 0.012;
  tmpP.copy(point).addScaledVector(tmpNormal, lift);

  const baseSize = Math.max(0.05, params.decalSize);
  const slopeMul = 0.25 + 0.75 * up01;
  const base = baseSize * (0.55 + Math.random() * 1.05) * slopeMul;

  const anis = 0.70 + Math.random() * 0.85;
  const steep = 1.0 - up01;
  const sx = base * (1.0 - 0.15 * steep);
  const sy = base * anis * (1.0 + 0.35 * steep);
  tmpS.set(sx, sy, 1);

  tmpQ.setFromUnitVectors(zAxis, tmpNormal);
  tmpQ.multiply(new THREE.Quaternion().setFromAxisAngle(tmpNormal, Math.random() * Math.PI * 2));

  tmpM.compose(tmpP, tmpQ, tmpS);
  stuck.setMatrixAt(idx, tmpM);

  stuckWrite++;
  stuckCount = Math.min(stuckCount + 1, max);
  stuck.count = stuckCount;
  stuck.instanceMatrix.needsUpdate = true;
}

    // -------------------------------------------------------------------------
    // Settlers (CPU flakes building drifts + decals)
    // -------------------------------------------------------------------------

/* Clears the CPU snow-settler buffers so drift/deposit simulation can be fully disabled. */
function disposeSettlers() {
  SETTLER_COUNT = 0;
  settlerPos = null;
  settlerPrev = null;
  settlerVel = null;
  depositTokens = 0;
}

function buildSettlers() {
  disposeSettlers();
  if (!params.snowEnabled) return;

  SETTLER_COUNT = clamp(params.settlerCount | 0, 1000, 300000);
  settlerPos = new Float32Array(SETTLER_COUNT * 3);
  settlerPrev = new Float32Array(SETTLER_COUNT * 3);
  settlerVel = new Float32Array(SETTLER_COUNT * 3);
  for (let i = 0; i < SETTLER_COUNT; i++) respawnSettler(i);
    depositTokens = 0;
}

function respawnSettler(i) {
  const p = i * 3;
  const x = (Math.random() * 2 - 1) * settleBounds.x;
  const y = settleBounds.yMax * (0.72 + Math.random() * 0.28);
  const z = (Math.random() * 2 - 1) * settleBounds.z;

  settlerPos[p + 0] = x;
  settlerPos[p + 1] = y;
  settlerPos[p + 2] = z;

  settlerPrev[p + 0] = x;
  settlerPrev[p + 1] = y;
  settlerPrev[p + 2] = z;

  settlerVel[p + 0] = (Math.random() * 2 - 1) * 0.02;
  settlerVel[p + 1] = -(0.35 + Math.random() * 0.35);
  settlerVel[p + 2] = (Math.random() * 2 - 1) * 0.02;
}









/**
 * Builds simple sphere bounds for collision broadphase.
 * - Meshes: uses geometry.boundingSphere (fast).
 * - Non-mesh roots (e.g., GLTF instance roots): uses Box3.setFromObject once (built-time only).
 * - Forest cone trees: uses cone base radius in XZ to avoid oversized bounding-sphere radii.
 */
function buildColliderBounds(objs) {
  const out = [];

  const box = new THREE.Box3();
  const size = new THREE.Vector3();
  const center = new THREE.Vector3();

  for (const obj of objs) {
    if (!obj) continue;

    obj.updateWorldMatrix(true, false);

    const isGroundPlatform = !!(obj.userData && obj.userData.worldModelGroundPlatform);

    if (obj.isMesh && obj.geometry) {
      if (!obj.geometry.boundingSphere) obj.geometry.computeBoundingSphere();
      const bs = obj.geometry.boundingSphere;
      if (!bs) continue;

      if (!obj.geometry.boundingBox) obj.geometry.computeBoundingBox();
      if (obj.geometry.boundingBox) {
        box.copy(obj.geometry.boundingBox).applyMatrix4(obj.matrixWorld);
      } else {
        box.setFromObject(obj);
      }

      boundCenter.copy(bs.center);
      obj.localToWorld(boundCenter);

      tmpS.set(1, 1, 1);
      obj.getWorldScale(tmpS);

      const sx = Math.abs(tmpS.x);
      const sy = Math.abs(tmpS.y);
      const sz = Math.abs(tmpS.z);

      const maxS = Math.max(sx, sy, sz);
      const maxXZ = Math.max(sx, sz);

      let radius;

      if (
        obj.__isForestTree &&
        obj.geometry &&
        obj.geometry.parameters &&
        Number.isFinite(obj.geometry.parameters.radius)
        ) {
        radius = obj.geometry.parameters.radius * maxXZ;
    } else {
      radius = bs.radius * (Number.isFinite(maxS) ? maxS : 1);
    }

    out.push({
      obj,
      isGroundPlatform,
      center: boundCenter.clone(),
      radius: Number.isFinite(radius) ? radius : bs.radius,
      yMin: Number.isFinite(box.min.y) ? box.min.y : (boundCenter.y - (Number.isFinite(radius) ? radius : bs.radius)),
      yMax: Number.isFinite(box.max.y) ? box.max.y : (boundCenter.y + (Number.isFinite(radius) ? radius : bs.radius))
    });

    continue;
  }

  box.setFromObject(obj);
  if (!Number.isFinite(box.min.x) || !Number.isFinite(box.max.x)) continue;

  box.getCenter(center);
  box.getSize(size);

  const radius = 0.5 * Math.sqrt(
    size.x * size.x +
    size.y * size.y +
    size.z * size.z
    );

  out.push({
    obj,
    isGroundPlatform,
    center: center.clone(),
    radius: Number.isFinite(radius) ? radius : 0.0,
    yMin: Number.isFinite(box.min.y) ? box.min.y : (center.y - (Number.isFinite(radius) ? radius : 0.0)),
    yMax: Number.isFinite(box.max.y) ? box.max.y : (center.y + (Number.isFinite(radius) ? radius : 0.0))
  });
}

return out;
}








const gustVec = new THREE.Vector3();

function updateSettlers(dt, baseWindX, baseWindZ) {
  if (!settlerPos || dt <= 0) return;

  depositTokens += params.groundDepositBudget * dt;
  let depositsRemaining = Math.max(0, Math.floor(depositTokens));
  if (depositsRemaining > 0) {
    depositTokens -= depositsRemaining;
  }

  const depositUnit = params.depositUnit;
  const objectDepositAmount = params.objectDeposit;
  const maxObjectTests = clamp(params.objectTestsPerFrame | 0, 0, 20000);
  let objectTests = 0;

  const gravity = 1.5;

  for (let i = 0; i < SETTLER_COUNT; i++) {
    const p = i * 3;

    const px = settlerPos[p + 0];
    const py = settlerPos[p + 1];
    const pz = settlerPos[p + 2];

    let vx = settlerVel[p + 0];
    let vy = settlerVel[p + 1];
    let vz = settlerVel[p + 2];

    settlerPrev[p + 0] = px;
    settlerPrev[p + 1] = py;
    settlerPrev[p + 2] = pz;

        // base wobble
    vx += (Math.random() * 2 - 1) * 0.25 * dt;
    vz += (Math.random() * 2 - 1) * 0.25 * dt;

        // global wind
    vx += baseWindX * dt * 0.5;
    vz += baseWindZ * dt * 0.5;

        // gust field (local turbulence + updraft)
    const snowY = sampleSnowHeight(px, pz);
    gustWindAt(px, pz, py - snowY, gustVec);
    vx += gustVec.x * dt;
    vy += gustVec.y * dt;
    vz += gustVec.z * dt;

    vy -= gravity * dt;

    let nx = px + vx * dt;
    let ny = py + vy * dt;
    let nz = pz + vz * dt;

        // wrap in XZ
    if (nx < -settleBounds.x) nx += settleBounds.x * 2;
    if (nx > settleBounds.x) nx -= settleBounds.x * 2;
    if (nz < -settleBounds.z) nz += settleBounds.z * 2;
    if (nz > settleBounds.z) nz -= settleBounds.z * 2;

    const groundY = sampleSnowHeight(nx, nz);

        // Hit ground -> deposit and respawn
    if (ny <= groundY + 0.02) {
      if (depositsRemaining > 0 && depositUnit > 0) {
        depositHeightAtWorld(nx, nz, depositUnit, baseWindX, baseWindZ);
        depositsRemaining--;
      }
      respawnSettler(i);
      continue;
    }

    settlerPos[p + 0] = nx;
    settlerPos[p + 1] = ny;
    settlerPos[p + 2] = nz;

    settlerVel[p + 0] = vx;
    settlerVel[p + 1] = vy;
    settlerVel[p + 2] = vz;




    // Object collisions (trees, rocks, cube)
    if (!colliderBounds.length || objectTests >= maxObjectTests) continue;

    const prevX = settlerPrev[p + 0];
    const prevY = settlerPrev[p + 1];
    const prevZ = settlerPrev[p + 2];

    // segment from previous to current position
    segDelta.set(nx - prevX, ny - prevY, nz - prevZ);
    const segLen = segDelta.length();
    if (segLen < 1e-4) continue;
    segDir.copy(segDelta).multiplyScalar(1.0 / segLen);

    hitFrom.set(prevX, prevY, prevZ);
    raycaster.set(hitFrom, segDir);
    raycaster.far = segLen;

    let hitSomething = false;

    for (const cb of colliderBounds) {
      if (objectTests >= maxObjectTests) break;

      // looser bounding-sphere cull so more flakes can hit
      const dx = cb.center.x - nx;
      const dy = cb.center.y - ny;
      const dz = cb.center.z - nz;
      const dist2 = dx * dx + dy * dy + dz * dz;
      const extraRadius = 1.5;
      const r = cb.radius + extraRadius;
      if (dist2 > r * r) continue;

      const intersections = raycaster.intersectObject(cb.obj, false);
      objectTests++;
      if (!intersections.length) continue;

      const hit = intersections[0];

      tmpNormal.set(0, 1, 0);
      if (hit.face) {
        tmpNormal.copy(hit.face.normal);
        tmpMatrix3.getNormalMatrix(hit.object.matrixWorld);
        tmpNormal.applyMatrix3(tmpMatrix3).normalize();
      }

      // more sticking: many decals per hit, scaled by objectDeposit
      const baseBurst = Math.floor(objectDepositAmount * 900); // 0.02 -> ~18
      const burst = clamp(baseBurst, 6, 40);

      for (let b = 0; b < burst; b++) {
        // jitter along normal
        const jitterN = (Math.random() - 0.5) * 0.05;

        // small tangent jitter so they spread over the surface
        const jitterT = 0.08;
        tmpP.copy(hit.point);
        tmpP.addScaledVector(tmpNormal, jitterN);

        tmpMatrix.makeRotationAxis(tmpNormal, Math.random() * Math.PI * 2.0);
        tmpDir.set(1, 0, 0).applyMatrix4(tmpMatrix);
        tmpP.addScaledVector(tmpDir, (Math.random() - 0.5) * jitterT);

        addStuckSnow(tmpP, tmpNormal);
      }

      if (objectDepositAmount > 0 && depositsRemaining > 0) {
        depositHeightAtWorld(
          hit.point.x,
          hit.point.z,
          objectDepositAmount,
          baseWindX,
          baseWindZ
          );
        depositsRemaining--;
      }

      respawnSettler(i);
      hitSomething = true;
      break;
    }

    if (hitSomething) continue;


  }


      depositTokens += depositsRemaining; // put back unused
    }


    // -------------------------------------------------------------------------
    // Camera idle auto-rotate (desktop only, not in XR)
    // -------------------------------------------------------------------------
    const AUTO_ROTATE_IDLE_SECONDS = 1.5;   // how long to wait
    const AUTO_ROTATE_SPEED = 0.35;        // OrbitControls autoRotateSpeed
    let lastInteractionTime = performance.now() * 0.001; // seconds
    let autoRotateEnabled = true;

    function markUserInteraction() {
      lastInteractionTime = performance.now() * 0.001;
      if (controls) {
        // disable auto-rotate immediately when the user touches the controls
        controls.autoRotate = false;
      }
    }







    // -------------------------------------------------------------------------
    // Scene / world setup
    // -------------------------------------------------------------------------


    /* Normalizes shadow type strings to a supported set. */
    function sanitizeShadowType(v) {
      const s = String(v || "").trim();
      if (s === "PCFSoft" || s === "PCF" || s === "Basic") return s;
      return "PCFSoft";
    }

    /* Snaps shadow map size to a supported power-of-two set. */
    function sanitizeShadowMapSize(v) {
      const n = (v | 0) || 0;
      const allowed = [256, 512, 1024, 2048, 4096];
      let best = allowed[0];
      let bestD = Math.abs(n - best);
      for (let i = 1; i < allowed.length; i++) {
        const d = Math.abs(n - allowed[i]);
        if (d < bestD) {
          bestD = d;
          best = allowed[i];
        }
      }
      return best;
    }


    /* Applies shadow performance settings to renderer and main directional light. */
    function applyShadowSettingsFromParams(force = false) {
      if (!renderer || !dirLight) return;

      const enabled = !!params.shadowsEnabled;
      const autoUpdate = !!params.shadowsAutoUpdate;
      const typeKey = sanitizeShadowType(params.shadowType);
      const mapSize = sanitizeShadowMapSize(params.shadowMapSize | 0);

      const enabledChanged = shadowApplied.enabled !== enabled;
      const autoUpdateChanged = shadowApplied.autoUpdate !== autoUpdate;
      const typeChanged = shadowApplied.typeKey !== typeKey;
      const mapSizeChanged = shadowApplied.mapSize !== mapSize;

      if (!force && !enabledChanged && !autoUpdateChanged && !typeChanged && !mapSizeChanged) return;

      shadowApplied.enabled = enabled;
      shadowApplied.autoUpdate = autoUpdate;
      shadowApplied.typeKey = typeKey;
      shadowApplied.mapSize = mapSize;

      renderer.shadowMap.enabled = enabled;
      renderer.shadowMap.autoUpdate = enabled && autoUpdate;

      if (typeKey === "Basic") renderer.shadowMap.type = THREE.BasicShadowMap;
      else if (typeKey === "PCF") renderer.shadowMap.type = THREE.PCFShadowMap;
      else renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      dirLight.castShadow = enabled;

      /* Forces a correct rebuild of the internal shadow render target when type/size toggles or shadows are re-enabled. */
      if (!enabled) {
        if (dirLight.shadow && dirLight.shadow.map) {
          dirLight.shadow.map.dispose();
          dirLight.shadow.map = null;
        }
        renderer.shadowMap.needsUpdate = true;
        return;
      }

      if (typeChanged || enabledChanged) {
        if (dirLight.shadow && dirLight.shadow.map) {
          dirLight.shadow.map.dispose();
          dirLight.shadow.map = null;
        }
        dirLight.shadow.needsUpdate = true;
        renderer.shadowMap.needsUpdate = true;
      }

      const ms = dirLight.shadow.mapSize;
      if (mapSizeChanged || ms.x !== mapSize || ms.y !== mapSize) {
        ms.set(mapSize, mapSize);

        if (dirLight.shadow.map) {
          dirLight.shadow.map.dispose();
          dirLight.shadow.map = null;
        }

        dirLight.shadow.needsUpdate = true;
        renderer.shadowMap.needsUpdate = true;
      }

      if (autoUpdateChanged) {
        renderer.shadowMap.needsUpdate = true;
      }
    }






    function setupScene() {

      const container = document.getElementById("app");

      scene = new THREE.Scene();
      updateFogFromParams();

      camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        params.fogFar
        );
      camera.position.set(-2, 7, -10);


      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.xr.enabled = true; // WebXR ON

      renderer.setPixelRatio(Math.min(window.devicePixelRatio, params.pixelRatio));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      //renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      container.appendChild(renderer.domElement);

      // temp to debug vehicles
      installVehicleDebugBridge(renderer.domElement);




      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 0.3;
      controls.maxDistance = 30;
      controls.target.set(0, 0.5, 0);

      // If your ground is at y = 0:
      const groundY = 0;
      const margin = 0.2; // â€œalways slightly aboveâ€

      // Keep the orbit in the upper hemisphere (above the ground)
      controls.maxPolarAngle = Math.PI / 2 - 0.001; // never go below horizon

      // Optional: keep the orbit from going perfectly top-down / perfectly flat
      controls.minPolarAngle = 0.05;

      // Optional: keep target a bit above the surface (helps a lot)
      // controls.target.y = groundY + margin;

      // Auto-rotate is controlled per-frame based on idle time
      controls.autoRotate = false;
      controls.autoRotateSpeed = AUTO_ROTATE_SPEED;

      // Any pointer/touch/wheel interaction on the canvas resets idle timer
      const orbitInteractionEvents = [
        "pointerdown",
        "pointermove",
        "wheel",
        "touchstart",
        "touchmove"
      ];

      for (const ev of orbitInteractionEvents) {
        renderer.domElement.addEventListener(ev, markUserInteraction, {
          passive: true
        });
      }

      controls.update();

      // TransformControls setup block
      transformControls = new TransformControls(camera, renderer.domElement);
      transformControls.setSpace("world");
      transformControls.setMode("translate");

      transformControlsHelper = transformControls.getHelper();
      transformControlsHelper.visible = false;
      scene.add(transformControlsHelper);

      transformControls.addEventListener("dragging-changed", (event) => {
        if (controls) controls.enabled = !event.value;
        markUserInteraction();

        if (event.value) {
          if (worldEditState.enabled && worldEditState.selected && !worldEditHistory.applying && !worldEditHistory.dragPushed) {
            pushWorldEditUndoSnapshot();
            worldEditHistory.dragPushed = true;
          }
          return;
        }

        worldEditHistory.dragPushed = false;

        if (worldEditState.enabled && worldEditState.selected) {
          const found = findWorldEditConfigForRoot(worldEditState.selected);
          if (found && found.instCfg) {
            syncInstanceTransformToInstCfg(worldEditState.selected, found.instCfg);
          }
        }

        syncWorldEditObjectGuiSelection();
        commitWorldEditTransform();
      });

      transformControls.addEventListener("change", () => {
        if (!worldEditState.enabled || !worldEditState.selected) return;
        syncWorldEditObjectGuiSelection();
      });


      renderer.domElement.addEventListener("pointerdown", (event) => {
        onWorldEditPointerDown(event);
      });



      // WebXR â€œEnter VRâ€ button (Quest 3 etc.)
      // Hides the non-actionable â€œWebXR NOT Availableâ€ UI on phone browsers while keeping it on XR browsers (Quest/Pico/etc.).
      const sessionInit = {
        optionalFeatures: ["local-floor", "bounded-floor"]
      };

      const hideVrButtonOnPhone = (() => {
        const coarse = !!(window.matchMedia && window.matchMedia("(pointer: coarse)").matches);
        if (!coarse) return false;

        const ua = navigator.userAgent || "";
        const isXrBrowser = /OculusBrowser|Quest|PicoBrowser|ViveBrowser/i.test(ua);

        return !isXrBrowser;
      })();

      if (!hideVrButtonOnPhone) {
        const vrButton = VRButton.createButton(renderer, sessionInit);
        document.body.appendChild(vrButton);
      }


      // Disable desktop OrbitControls while in XR so they don't fight head pose
      renderer.xr.addEventListener("sessionstart", () => {
        if (controls) controls.enabled = false;
      });
      renderer.xr.addEventListener("sessionend", () => {
        if (controls) controls.enabled = true;
      });


      // Enhanced Lights
      // Lights (with better control + shadow quality)
      hemiLight = new THREE.HemisphereLight(0xdce7ff, 0x0b0f18, 1.0);
      scene.add(hemiLight);

      dirLight = new THREE.DirectionalLight(0xffffff, 1.35);
      dirLight.position.set(8, 14, 6);

      // Shadow quality defaults (final enable/type/size controlled by params)
      dirLight.castShadow = true;

      // Shadow map size is applied by applyShadowSettingsFromParams (params.shadowMapSize)
      const shadowSize = 1024;
      dirLight.shadow.mapSize.set(shadowSize, shadowSize);

      // Tighten shadow camera frustum (reduces banding/striping)
      dirLight.shadow.camera.left = -18;
      dirLight.shadow.camera.right = 18;
      dirLight.shadow.camera.top = 18;
      dirLight.shadow.camera.bottom = -18;
      dirLight.shadow.camera.near = 2;
      dirLight.shadow.camera.far = 60;

      // Bias tuning (reduce acne / stripe artifacts)
      dirLight.shadow.normalBias = 0.03; // try 0.01â€“0.08
      dirLight.shadow.bias = -0.00015;   // try -0.00005 to -0.0003

      scene.add(dirLight);

      // Renderer shadow settings (performance tuning via params)
      applyShadowSettingsFromParams(true);



      // Renderer (ensure these are set once in your setup)
      // renderer.shadowMap.enabled = true;
      // renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      applyShadowSettingsFromParams(true);

      // Debug helpers (toggle on when tuning)
      const LIGHT_DEBUG = false;
      if (LIGHT_DEBUG) {
        scene.add(new THREE.HemisphereLightHelper(hemiLight, 2));
        scene.add(new THREE.DirectionalLightHelper(dirLight, 2));
        scene.add(new THREE.CameraHelper(dirLight.shadow.camera));
      }

      // // Lights
      // scene.add(new THREE.HemisphereLight(0xdce7ff, 0x0b0f18, 1));

      // const dir = new THREE.DirectionalLight(0xffffff, 1.35);
      // dir.position.set(8, 14, 6);
      // dir.castShadow = true;
      // dir.shadow.mapSize.set(2048, 2048);
      // dir.shadow.camera.left = -26;
      // dir.shadow.camera.right = 26;
      // dir.shadow.camera.top = 26;
      // dir.shadow.camera.bottom = -26;
      // dir.shadow.camera.near = 0.1;
      // dir.shadow.camera.far = 120;
      // scene.add(dir);




      setupWetTrailSystem();


      // Ground
      const groundMat = new THREE.MeshStandardMaterial({
        color: normalizeHexColor(params.groundColor, DEFAULTS.groundColor || "#ffffff"),
        roughness: 1.0,
        metalness: 0.0
      });
      ground = new THREE.Mesh(
        new THREE.PlaneGeometry(GROUND_SIZE, GROUND_SIZE),
        groundMat
        );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);


      // Axes helper at origin
      const axes = new THREE.AxesHelper(5);
      //scene.add(axes);


      // Cube centered at origin (sitting on ground)
      const cubeGeo = new THREE.BoxGeometry(1, 1, 1);
      const cubeMat = new THREE.MeshStandardMaterial({
        color: normalizeHexColor(params.cubeColor, DEFAULTS.cubeColor || "#4e9cff"),
        roughness: 0.4,
        metalness: 0.2
      });
      cube = new THREE.Mesh(cubeGeo, cubeMat);
      cube.position.set(0, 0.5, 0);
      cube.castShadow = true;
      //scene.add(cube);


      // Rocks
      const rockGeo = new THREE.IcosahedronGeometry(1.1, 0);
      const rockMat = new THREE.MeshStandardMaterial({
        color: normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442"),
        roughness: 1.0
      });


      const rockPos = [
        [-9, 1.0,  6],
        [-7, 0.8, -8],
        [ 8, 1.0, -6]
      ];

      for (let i = 0; i < rockPos.length; i++) {
        const [x, _y, z] = rockPos[i];

        const r = new THREE.Mesh(rockGeo, rockMat);
        r.scale.setScalar(1.0 + i * 0.25);

        r.position.set(x, 0.0, z);

        r.rotation.set(Math.random() * 2, Math.random() * 2, Math.random() * 2);
        r.castShadow = true;
        r.receiveShadow = true;

        scene.add(r);
        rocks.push(r);
      }



      // Base colliders: rocks + cube, forest trees added in rebuildForest()
      colliderObjects = [...rocks, cube];

      // Build forest according to params (fills cones[] and colliderObjects)
      rebuildForest();


      //loadModel1();
      //loadAllModels();

      setupClouds();
      rebuildDust();
      rebuildRain();
      rebuildGrass();

      initAudio();

    }

    /**
     * Repositions all rock meshes so the snow surface cuts through the middle of each rock,
     * keeping them half-buried even when snow height changes.
     */
    function updateRocksGrounding() {
      for (const r of rocks) {
        if (!r) continue;
        const s = r.scale.y || 1.0;
        const groundY = sampleSnowHeight(r.position.x, r.position.z);
        r.position.y = groundY - rockGeoMidY * s;
      }
    }



    function rebuildWorld() {
      if (params.snowEnabled) {
        buildSnowSurface();
        buildSnowField();
      } else {
        disposeSnowField();
        disposeSnowSurface();
      }

      updateRocksGrounding();

      if (params.snowEnabled) {
        buildStuckSystem();
        buildSettlers();
      } else {
        disposeStuckSystem();
        disposeSettlers();
      }

      colliderBounds = buildColliderBounds(colliderObjects);
      rebuildAvatarCollisionGrid();
    }




    // -------------------------------------------------------------------------
    // GUI (with gust controls + preset dropdown)
    // -------------------------------------------------------------------------

    function trackController(ctrl, { rebuild = false, instant = true } = {}) {
      guiControllers.push(ctrl);
      const needsFinish = typeof ctrl.onFinishChange === "function";

      if (needsFinish && !instant) {
        ctrl.onChange(() => {
          saveLastDebounced(params);
        });
        ctrl.onFinishChange(() => {
          if (rebuild) rebuildWorld();
          saveLastDebounced(params);
        });
      } else {
        ctrl.onChange(() => {
          if (rebuild) rebuildWorld();
          saveLastDebounced(params);
        });
      }
      return ctrl;
    }

    function refreshGuiDisplays() {
      for (const c of guiControllers) {
        c.updateDisplay();
      }
    }

    async function refreshPresetList() {
      try {
        const builtin = getBuiltinPresets();
        const builtinNames = builtin.map((p) => p.name);

        const savedNames = await idbListPresetNames();

        const seen = new Set();
        const mergedNames = [];

        function pushName(raw) {
          const key = sanitizePresetName(raw);
          if (!key || key === "<none>") return;
          if (seen.has(key)) return;
          seen.add(key);
          mergedNames.push(raw);
        }

        for (const n of builtinNames) pushName(n);
          for (const n of savedNames) pushName(n);

            const names = mergedNames;
          const opts = names.length ? names : ["<none>"];

          presetSelectCtrl.options(opts);

          if (!names.includes(presetState.selected)) {
            presetState.selected = names[0] || "<none>";
          }

          presetSelectCtrl.updateDisplay();
        } catch (e) {
          console.error("[snow] refresh presets failed", e);
        }
      }



      async function savePreset() {
        const name = sanitizePresetName(presetState.presetName || `preset-${nowStamp()}`);
        if (!name) return;
        presetState.presetName = name;
        const settings = safeCloneSettings(params);
        try {
          await idbPutPreset(name, settings);
          presetState.selected = name;
          await refreshPresetList();
          saveLastDebounced(params);
        } catch (e) {
          console.error("[snow] preset save failed", e);
        }
      }



      async function loadPreset() {
        const selectedRaw = presetState.selected;
        const key = sanitizePresetName(selectedRaw);
        if (!key || key === "<none>") return;

        const builtin = getBuiltinPresets().find(
          (p) => sanitizePresetName(p.name) === key
          );

        try {
          if (builtin) {
            const response = await fetch(builtin.url, {
              cache: "no-store"
            });

            if (!response.ok) {
              console.warn(
                "[snow] builtin preset fetch failed:",
                builtin.url,
                response.status,
                response.statusText
                );
              return;
            }

            const json = await response.json();

            const srcSettings =
            json &&
            typeof json === "object" &&
            json.settings &&
            typeof json.settings === "object"
            ? json.settings
            : json;

            if (!srcSettings || typeof srcSettings !== "object") {
              console.warn("[snow] builtin preset JSON has no settings object");
              return;
            }

            const merged = Object.assign({}, DEFAULTS, srcSettings);

            applySettings(merged, {
              rebuild: true,
              updateGui: true,
              persist: true
            });

            presetState.presetName = builtin.name;
            return;
          }

          const row = await idbGetPreset(key);
          if (!row || !row.settings) {
            console.warn("[snow] preset not found:", key);
            return;
          }

          applySettings(row.settings, {
            rebuild: true,
            updateGui: true,
            persist: true
          });
          presetState.presetName = key;
        } catch (e) {
          console.error("[snow] preset load failed", e);
        }
      }



      async function deletePreset() {
        const name = sanitizePresetName(presetState.selected);
        if (!name || name === "<none>") return;
        try {
          await idbDeletePreset(name);
          presetState.selected = "<none>";
          await refreshPresetList();
        } catch (e) {
          console.error("[snow] preset delete failed", e);
        }
      }

      function exportSettings() {
        const hasSelection =
        presetState.selected && presetState.selected !== "<none>";

        const baseName = hasSelection
        ? presetState.selected
        : (presetState.presetName || `preset-${nowStamp()}`);

        const name = sanitizePresetName(baseName);

        const payload = {
          v: 1,
          kind: "snow-preset",
          exportedAt: Date.now(),
          name,
          settings: safeCloneSettings(params)
        };

        const safeName = name
        ? name.replace(/\s+/g, "-")
        : `preset-${nowStamp()}`;

        const filename = `snow-${safeName}.json`;
        downloadJson(payload, filename);
      }

      function importSettings() {
        const input = ensureImportInput();

        input.onchange = async () => {
          const file = input.files && input.files[0];
          input.value = "";
          if (!file) return;

          try {
            const text = await file.text();
            const json = JSON.parse(text);

            if (!json || typeof json !== "object") {
              throw new Error("Invalid JSON root");
            }

          // Accept both:
          //   { v: 1, kind, name, settings: { ... } }
          //   { ...paramsDirectly }
            const srcSettings =
            json.settings && typeof json.settings === "object"
            ? json.settings
            : json;

            if (!srcSettings || typeof srcSettings !== "object") {
              throw new Error("No settings object found");
            }

          // Merge onto DEFAULTS so missing keys get sane values
            const merged = { ...DEFAULTS, ...srcSettings };

            applySettings(merged, {
              rebuild: true,
              updateGui: true,
              persist: true
            });

          // Update preset name in GUI if present in file
            let importedName = null;
            if (typeof json.name === "string" && json.name.trim()) {
              importedName = sanitizePresetName(json.name);
            } else if (
              typeof json.presetName === "string" &&
              json.presetName.trim()
              ) {
              importedName = sanitizePresetName(json.presetName);
            }

            if (importedName) {
              presetState.presetName = importedName;
              presetState.selected = importedName;
              if (presetSelectCtrl) {
                await refreshPresetList();
              }
            }
          } catch (e) {
            console.error("[snow] import failed", e);
          }
        };

        input.click();
      }












      function setupGui() {
        gui = new GUI({ width: 380 });

        trackController(gui.add(params, "paused").name("Paused"), { instant: true });
        trackController(gui.add(params, "debug").name("Debug logs"), { instant: true });
        const avatarDebugActions = {
          listBones: () => {
            listAvatarBonesToConsole();
          }
        };

        gui.add(avatarDebugActions, "listBones").name("Avatar: list bones");


        const sim = gui.addFolder("Simulation");
        trackController(sim.add(params, "timeScale", 0.05, 2.0, 0.01).name("Time scale"));
        trackController(sim.add(params, "dtMax", 0.008, 0.050, 0.001).name("dt max (clamp)"));
        trackController(sim.add(params, "pixelRatio", 0.5, 2.5, 0.01).name("Pixel ratio"), {
          rebuild: false
        });

        const perf = gui.addFolder("Performance");

        trackController(perf.add(params, "shadowsEnabled").name("Shadows").listen(), { instant: true });

        trackController(
          perf.add(params, "shadowsAutoUpdate").name("Shadow auto update").listen(),
          { instant: true }
          );

        trackController(
          perf.add(params, "shadowType", ["PCFSoft", "PCF", "Basic"]).name("Shadow type").listen(),
          { instant: true }
          );

        trackController(
          perf.add(params, "shadowMapSize", [256, 512, 1024, 2048, 4096]).name("Shadow map size").listen(),
          { instant: true }
          );

        perf.close();


      //sim.open();

        const wind = gui.addFolder("Wind");
        trackController(wind.add(params, "windStrength", 0.0, 2.0, 0.01).name("Strength"));
        trackController(wind.add(params, "windSpeed", 0.0, 5, 0.01).name("Speed"));












/* Sound Maker */

        const soundMaker = gui.addFolder("Sound Maker");

        if (!sfxMakerState || typeof sfxMakerState !== "object") {
          sfxMakerState = { selected: "jump", id: "jump", draft: {}, loop: false, _loopTimer: null };
        }
        if (typeof sfxMakerState.selected !== "string" || !sfxMakerState.selected.trim()) sfxMakerState.selected = "jump";
        if (typeof sfxMakerState.id !== "string" || !sfxMakerState.id.trim()) sfxMakerState.id = sfxMakerState.selected || "jump";
        if (typeof sfxMakerState.loop !== "boolean") sfxMakerState.loop = false;
        if (!sfxMakerState.draft || typeof sfxMakerState.draft !== "object") sfxMakerState.draft = {};

        let sfxSelectCtrl = null;
        let sfxIdCtrl = null;
        const sfxDraftCtrls = [];

/* Keeps Sound Maker controls in sync after loading/saving presets. */
        function refreshSfxDraftUi() {
          for (let i = 0; i < sfxDraftCtrls.length; i++) {
            const c = sfxDraftCtrls[i];
            if (c && typeof c.updateDisplay === "function") c.updateDisplay();
          }
          if (sfxIdCtrl && typeof sfxIdCtrl.updateDisplay === "function") sfxIdCtrl.updateDisplay();
          if (sfxSelectCtrl && typeof sfxSelectCtrl.updateDisplay === "function") sfxSelectCtrl.updateDisplay();
        }

        function stopSfxMakerLoop() {
          if (sfxMakerState._loopTimer) {
            clearInterval(sfxMakerState._loopTimer);
            sfxMakerState._loopTimer = null;
          }
        }

        function startSfxMakerLoop() {
          stopSfxMakerLoop();
          if (!sfxMakerState.loop) return;

          const d = sfxMakerState.draft;
          const cycle = clamp(Number(d.duration ?? 0.2) + Number(d.release ?? 0.06) + 0.05, 0.05, 3.0);
          const ms = Math.max(50, (cycle * 1000) | 0);

          sfxMakerState._loopTimer = setInterval(() => {
            const id = String(sfxMakerState.selected || "").trim() || "jump";
            playFX(id, 1.0);
          }, ms);
        }

        function getMergedPresetsObject() {
          const merged = {};
          if (DEFAULTS && DEFAULTS.sfxPresets && typeof DEFAULTS.sfxPresets === "object") {
            for (const k in DEFAULTS.sfxPresets) {
              if (!Object.prototype.hasOwnProperty.call(DEFAULTS.sfxPresets, k)) continue;
              merged[String(k)] = DEFAULTS.sfxPresets[k];
            }
          }
          if (params && params.sfxPresets && typeof params.sfxPresets === "object") {
            for (const k in params.sfxPresets) {
              if (!Object.prototype.hasOwnProperty.call(params.sfxPresets, k)) continue;
              merged[String(k)] = params.sfxPresets[k];
            }
          }
          return merged;
        }

        function getAllPresetIds() {
          const merged = getMergedPresetsObject();
          const keys = Object.keys(merged).sort();
          return keys.length ? keys : ["jump"];
        }

        function getPresetById(id) {
          const merged = getMergedPresetsObject();
          const k = String(id || "").trim();
          return (k && merged[k]) ? merged[k] : null;
        }

/* Loads preset into the existing draft object (no draft reassign). */
        function ensureSfxDraftFromPreset(id) {
          const src = getPresetById(id) || (DEFAULTS && DEFAULTS.sfxPresets ? DEFAULTS.sfxPresets.jump : null);
          if (!src) return;

          const next = JSON.parse(JSON.stringify(src));
          const d = sfxMakerState.draft;

          for (const k in d) {
            if (Object.prototype.hasOwnProperty.call(d, k)) delete d[k];
          }
          for (const k in next) {
            if (Object.prototype.hasOwnProperty.call(next, k)) d[k] = next[k];
          }

          refreshSfxDraftUi();
        }

/* Writes the current draft into params.sfxPresets under sfxMakerState.selected. */
        function commitDraftToSelectedPreset() {
          const id = String(sfxMakerState.selected || "").trim();
          if (!id) return;

          if (!params.sfxPresets || typeof params.sfxPresets !== "object") params.sfxPresets = {};
          params.sfxPresets[id] = JSON.parse(JSON.stringify(sfxMakerState.draft || {}));
          saveLastDebounced(params);
        }

/* Rebuilds the preset dropdown without re-creating the controller. */
        function rebuildSfxSelect() {
          const ids = getAllPresetIds();

          if (!sfxSelectCtrl) {
            sfxSelectCtrl = soundMaker.add(sfxMakerState, "selected", ids).name("Preset");
            sfxSelectCtrl.onChange((v) => {
              stopSfxMakerLoop();

              const picked = String(v || "").trim() || "jump";
              sfxMakerState.selected = picked;
              sfxMakerState.id = picked;

              ensureSfxDraftFromPreset(picked);

              if (sfxMakerState.loop) startSfxMakerLoop();
            });
          }

          const sel = sfxSelectCtrl.domElement && sfxSelectCtrl.domElement.querySelector("select");
          if (sel) {
            const prev = String(sfxMakerState.selected || "").trim();
            sel.innerHTML = "";
            for (let i = 0; i < ids.length; i++) {
              const opt = document.createElement("option");
              opt.value = ids[i];
              opt.textContent = ids[i];
              sel.appendChild(opt);
            }
            sel.value = ids.includes(prev) ? prev : (ids[0] || "jump");
            sfxMakerState.selected = sel.value;
            sfxMakerState.id = sel.value;
          }

          refreshSfxDraftUi();
        }

        function savePresetFromDraft() {
          stopSfxMakerLoop();

          const id = String(sfxMakerState.id || "").trim();
          if (!id) return;

          if (!params.sfxPresets || typeof params.sfxPresets !== "object") params.sfxPresets = {};
          params.sfxPresets[id] = JSON.parse(JSON.stringify(sfxMakerState.draft || {}));

          sfxMakerState.selected = id;
          sfxMakerState.id = id;

          saveLastDebounced(params);

          rebuildSfxSelect();
          ensureSfxDraftFromPreset(id);

          if (sfxMakerState.loop) startSfxMakerLoop();
        }

        function deleteSelectedPreset() {
          stopSfxMakerLoop();

          const id = String(sfxMakerState.selected || "").trim();
          if (!id) return;

          if (params && params.sfxPresets && params.sfxPresets[id]) {
            delete params.sfxPresets[id];
            saveLastDebounced(params);
          }

          const ids = getAllPresetIds();
          const fallback = ids[0] || "jump";

          sfxMakerState.selected = fallback;
          sfxMakerState.id = fallback;

          ensureSfxDraftFromPreset(fallback);
          rebuildSfxSelect();

          if (sfxMakerState.loop) startSfxMakerLoop();
        }

        function exportSfxPresetsJson() {
          const presets = (params && params.sfxPresets && typeof params.sfxPresets === "object") ? params.sfxPresets : {};
          const text = JSON.stringify(presets, null, 2);
          const blob = new Blob([text], { type: "application/json" });
          const url = URL.createObjectURL(blob);

          const a = document.createElement("a");
          a.href = url;
          a.download = "sounds_presets.json";
          document.body.appendChild(a);
          a.click();
          a.remove();

          setTimeout(() => URL.revokeObjectURL(url), 1000);
        }

        function importSfxPresetsJson() {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "application/json,.json";
          input.onchange = async () => {
            const file = input.files && input.files[0];
            if (!file) return;

            let obj = null;
            try { obj = JSON.parse(await file.text()); } catch (e) { return; }
            if (!obj || typeof obj !== "object") return;

            if (!params.sfxPresets || typeof params.sfxPresets !== "object") params.sfxPresets = {};
            for (const k in obj) {
              if (!Object.prototype.hasOwnProperty.call(obj, k)) continue;
              if (!obj[k] || typeof obj[k] !== "object") continue;
              params.sfxPresets[String(k)] = obj[k];
            }

            saveLastDebounced(params);

            rebuildSfxSelect();

            const picked = String(sfxMakerState.selected || "").trim() || "jump";
            ensureSfxDraftFromPreset(picked);

            if (sfxMakerState.loop) startSfxMakerLoop();
          };
          input.click();
        }

        function copySoundDataToClipboard() {
          const id = String(sfxMakerState.selected || "").trim() || String(sfxMakerState.id || "").trim() || "sound";
          const obj = {};
          obj[id] = JSON.parse(JSON.stringify(sfxMakerState.draft || {}));
          const text = JSON.stringify(obj, null, 2);

          if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
            navigator.clipboard.writeText(text);
            return;
          }

          const ta = document.createElement("textarea");
          ta.value = text;
          ta.style.position = "fixed";
          ta.style.left = "-9999px";
          ta.style.top = "-9999px";
          document.body.appendChild(ta);
          ta.focus();
          ta.select();
          try { document.execCommand("copy"); } catch (e) {}
          ta.remove();
        }

        ensureSfxDraftFromPreset(sfxMakerState.selected || "jump");
        rebuildSfxSelect();

        sfxIdCtrl = soundMaker.add(sfxMakerState, "id").name("Id (save as)").listen();

        soundMaker.add(sfxMakerState, "loop").name("Loop preview").onChange((v) => {
          sfxMakerState.loop = !!v;
          if (sfxMakerState.loop) startSfxMakerLoop();
          else stopSfxMakerLoop();
        });

        const d = sfxMakerState.draft;

        function onDraftChanged() {
          commitDraftToSelectedPreset();
          if (sfxMakerState.loop) startSfxMakerLoop();
        }

        sfxDraftCtrls.push(soundMaker.add(d, "kind", ["osc", "noise", "mix"]).name("Kind").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "oscType", ["sine", "square", "sawtooth", "triangle"]).name("Osc type").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "freq", 20, 2000, 1).name("Freq").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "freqEnd", 20, 2000, 1).name("Freq end").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "noise", 0.0, 1.0, 0.01).name("Noise mix").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "gain", 0.0, 2.0, 0.01).name("Gain").onChange(onDraftChanged));

        sfxDraftCtrls.push(soundMaker.add(d, "attack", 0.0, 0.5, 0.001).name("Attack").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "decay", 0.0, 1.0, 0.001).name("Decay").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "release", 0.0, 1.0, 0.001).name("Release").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "duration", 0.02, 2.0, 0.01).name("Duration").onChange(onDraftChanged));

        sfxDraftCtrls.push(soundMaker.add(d, "filterType", ["none", "lowpass", "highpass", "bandpass", "notch"]).name("Filter").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "filterFreq", 20, 20000, 10).name("Filter freq").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "filterQ", 0.01, 20.0, 0.01).name("Filter Q").onChange(onDraftChanged));

        sfxDraftCtrls.push(soundMaker.add(d, "pan", -1.0, 1.0, 0.01).name("Pan").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "reverbMix", 0.0, 1.0, 0.01).name("Reverb mix").onChange(onDraftChanged));
        sfxDraftCtrls.push(soundMaker.add(d, "irSeconds", 0.2, 6.0, 0.1).name("IR seconds").onChange(onDraftChanged));

        soundMaker.add({ play: () => playFX(String(sfxMakerState.selected || "").trim() || "jump", 1.0) }, "play").name("Play FX");
        soundMaker.add({ save: savePresetFromDraft }, "save").name("Save / Update");
        soundMaker.add({ copy: copySoundDataToClipboard }, "copy").name("Copy sound data");
        soundMaker.add({ del: deleteSelectedPreset }, "del").name("Delete");
        soundMaker.add({ exportJson: exportSfxPresetsJson }, "exportJson").name("Export JSON");
        soundMaker.add({ importJson: importSfxPresetsJson }, "importJson").name("Import JSON");

        refreshSfxDraftUi();

        soundMaker.close();











        //wind.open();

        const envSound = gui.addFolder("Environmental Sounds");

        envSound.add(params, "envSoundEnabled").name("Enabled").onChange(() => {
          applyEnvSoundFromParams();
          saveLastDebounced(params);
        });

        envSound.add(params, "envSoundVolume", 0.0, 1.0, 0.01).name("Volume").onChange(() => {
          applyEnvSoundFromParams();
          saveLastDebounced(params);
        });

        envSound.add(params, "envSoundPanDepth", 0.0, 1.0, 0.01).name("Pan depth").onChange(() => {
          saveLastDebounced(params);
        });

        envSound.add(params, "envSoundPanSpeed", 0.0, 6.0, 0.01).name("Pan speed").onChange(() => {
          saveLastDebounced(params);
        });

        envSound.add(params, "envSoundReverbMix", 0.0, 1.0, 0.01).name("Reverb mix").onChange(() => {
          applyEnvSoundFromParams();
          saveLastDebounced(params);
        });

        envSound.add(params, "envSoundIrSeconds", 0.2, 6.0, 0.1).name("IR seconds").onChange(() => {
          applyEnvSoundFromParams();
          saveLastDebounced(params);
        });

        envSound.add(params, "envSoundToneHz", 0, 8000, 1).name("Tone Hz").onChange(() => {
          applyEnvSoundFromParams();
          saveLastDebounced(params);
        });

        envSound.close();


        const audioFolder = gui.addFolder("Audio");

        audioFolder.add(params, "musicEnabled").name("Music").onChange(async () => {
          applyMusicFromParams();
          if (params.musicEnabled) {
            await loadPlaylistsSetOnce().catch(() => {});
            await musicSelectPlaylistById(musicState.playlistId || "starter", { keepPlaying: false }).catch(() => {});
          }
          saveLastDebounced(params);
        });

        audioFolder.add(params, "musicVolume", 0.0, 1.0, 0.01).name("Music volume").onChange(() => {
          applyMusicFromParams();
          saveLastDebounced(params);
        });

        const musicFolder = audioFolder.addFolder("Music Player");

        const musicGuiState = {
          playlist: "starter",
          loopPlaylist: true,
          followPlaylistsOrder: false,
          play: async () => { await musicPlay(); },
          pause: () => { musicPause(); },
          prev: async () => { await musicPrev(); },
          next: async () => { await musicNext(); },
          reloadLists: async () => {
            musicState.playlists = [];
            musicState.playlistOrder = [];
            await loadPlaylistsSetOnce();
            const ids = (musicState.playlistOrder && musicState.playlistOrder.length)
            ? musicState.playlistOrder.slice()
            : (musicState.playlists || []).map((p) => p.id);

            if (musicPlaylistCtrl) musicPlaylistCtrl.options(ids);
            musicGuiState.playlist = musicState.playlistId || "starter";
          }
        };

        let musicPlaylistCtrl = null;

        (async () => {
          await loadPlaylistsSetOnce().catch(() => {});
          const ids = (musicState.playlistOrder && musicState.playlistOrder.length)
          ? musicState.playlistOrder.slice()
          : (musicState.playlists || []).map((p) => p.id);

          if (!ids.length) ids.push("starter");

          musicGuiState.playlist = musicState.playlistId || "starter";

          musicPlaylistCtrl = musicFolder.add(musicGuiState, "playlist", ids).name("Playlist");
          musicPlaylistCtrl.onChange(async (v) => {
            musicGuiState.playlist = String(v || "starter");
            await musicSelectPlaylistById(musicGuiState.playlist, { keepPlaying: musicState.isPlaying }).catch(() => {});
            saveLastDebounced(params);
          });
        })();

        musicFolder.add(musicGuiState, "loopPlaylist").name("Loop playlist").onChange((v) => {
          musicState.loopPlaylist = !!v;
          saveLastDebounced(params);
        });

        musicFolder.add(musicGuiState, "followPlaylistsOrder").name("Follow playlist order").onChange((v) => {
          musicState.followPlaylistsOrder = !!v;
          saveLastDebounced(params);
        });

        musicFolder.add(musicGuiState, "play").name("Play");
        musicFolder.add(musicGuiState, "pause").name("Pause");
        musicFolder.add(musicGuiState, "prev").name("Prev");
        musicFolder.add(musicGuiState, "next").name("Next");
        musicFolder.add(musicGuiState, "reloadLists").name("Reload JSON");

        musicFolder.close();


        audioFolder.add(params, "musicVolume", 0.0, 1.0, 0.01).name("Music volume").onChange(() => {
          applyMusicFromParams();
          saveLastDebounced(params);
        });

        audioFolder.add(params, "sfxEnabled").name("SFX").onChange(() => {
          saveLastDebounced(params);
        });

        audioFolder.add(params, "sfxVolume", 0.0, 1.0, 0.01).name("SFX volume").onChange(() => {
          saveLastDebounced(params);
        });

        audioFolder.close();



        const rocksFolder = gui.addFolder("Rocks");

        const rockCountCtrl = rocksFolder.add(params, "rockCount", 0, 800, 1).name("Rock count");
        const rockRadiusCtrl = rocksFolder.add(params, "rockRadius", 2.0, 1500.0, 0.5).name("Radius");
        const rockInnerCtrl = rocksFolder.add(params, "rockInnerRadius", 0.0, 200.0, 0.5).name("Inner radius");
        const rockMinScaleCtrl = rocksFolder.add(params, "rockMinScale", 0.01, 5.0, 0.01).name("Min scale");
        const rockMaxScaleCtrl = rocksFolder.add(params, "rockMaxScale", 0.2, 100.0, 0.05).name("Max scale");
        const rockSeedCtrl = rocksFolder.add(params, "rockSeed", 0, 9999, 1).name("Seed");
        const rockJitterCtrl = rocksFolder.add(params, "rockJitter", 0.0, 2.0, 0.05).name("Randomness");

        const rockDetailCtrl = rocksFolder.add(params, "rockDetail", 0, 16, 1).name("Detail");
        const rockVarCountCtrl = rocksFolder.add(params, "rockVariantCount", 1, 24, 1).name("Variants");

        const rockNoiseAmpCtrl = rocksFolder.add(params, "rockNoiseAmp", 0.0, 1.2, 0.01).name("Shape noise");
        const rockNoiseFreqCtrl = rocksFolder.add(params, "rockNoiseFreq", 0.1, 8.0, 0.01).name("Noise scale");
        const rockNoiseOctCtrl = rocksFolder.add(params, "rockNoiseOctaves", 1, 8, 1).name("Octaves");
        const rockNoiseLacCtrl = rocksFolder.add(params, "rockNoiseLacunarity", 1.1, 3.5, 0.01).name("Lacunarity");
        const rockNoiseGainCtrl = rocksFolder.add(params, "rockNoiseGain", 0.15, 0.95, 0.01).name("Gain");
        const rockNoiseRidgeCtrl = rocksFolder.add(params, "rockNoiseRidge", 0.0, 1.0, 0.01).name("Ridged");

        const rockFlattenCtrl = rocksFolder.add(params, "rockFlatten", 0.0, 1.0, 0.01).name("Flatten");
        const rockAnisoCtrl = rocksFolder.add(params, "rockAnisotropy", 0.0, 1.0, 0.01).name("Anisotropy");
        const rockEmbedCtrl = rocksFolder.add(params, "rockEmbed", 0.0, 1.2, 0.01).name("Embed");

        const rockColorVarCtrl = rocksFolder.add(params, "rockColorVar", 0.0, 0.6, 0.01).name("Color var");
        const rockRoughCtrl = rocksFolder.add(params, "rockRoughness", 0.0, 1.0, 0.01).name("Roughness");
        const rockMetalCtrl = rocksFolder.add(params, "rockMetalness", 0.0, 1.0, 0.01).name("Metalness");

        const rockCtrls = [
          rockCountCtrl,
          rockRadiusCtrl,
          rockInnerCtrl,
          rockMinScaleCtrl,
          rockMaxScaleCtrl,
          rockSeedCtrl,
          rockJitterCtrl,

          rockDetailCtrl,
          rockVarCountCtrl,

          rockNoiseAmpCtrl,
          rockNoiseFreqCtrl,
          rockNoiseOctCtrl,
          rockNoiseLacCtrl,
          rockNoiseGainCtrl,
          rockNoiseRidgeCtrl,

          rockFlattenCtrl,
          rockAnisoCtrl,
          rockEmbedCtrl,

          rockColorVarCtrl,
          rockRoughCtrl,
          rockMetalCtrl
        ];

        rockCtrls.forEach((ctrl) => {
          trackController(ctrl, { rebuild: false, instant: true });
          if (typeof ctrl.onFinishChange === "function") {
            ctrl.onFinishChange(() => {
              applySettings(params, { rebuild: false, updateGui: false });
              rebuildRocks();
              saveLastDebounced(params);
            });
          }
        });

        rocksFolder
        .add(
        {
          rebuildRocks: () => {
            applySettings(params, { rebuild: false, updateGui: false });
            rebuildRocks();
            saveLastDebounced(params);
          }
        },
        "rebuildRocks"
        )
        .name("Rebuild rocks");

        rocksFolder.close();



        const forest = gui.addFolder("Forest");

        const forestCountCtrl = forest
        .add(params, "forestCount", 0, 4000, 1)
        .name("Tree count");
        const forestRadiusCtrl = forest
        .add(params, "forestRadius", 2.0, 1500.0, 0.5)
        .name("Radius");
        const forestInnerCtrl = forest
        .add(params, "forestInnerRadius", 0.0, 16.0, 0.5)
        .name("Inner radius");
        const forestMinScaleCtrl = forest
        .add(params, "forestMinScale", 0.3, 2.5, 0.05)
        .name("Min scale");
        const forestMaxScaleCtrl = forest
        .add(params, "forestMaxScale", 0.3, 3.0, 0.05)
        .name("Max scale");
        const forestSeedCtrl = forest
        .add(params, "forestSeed", 0, 9999, 1)
        .name("Seed");
        const forestJitterCtrl = forest
        .add(params, "forestJitter", 0.0, 2.0, 0.05)
        .name("Randomness");

        const forestCtrls = [
          forestCountCtrl,
          forestRadiusCtrl,
          forestInnerCtrl,
          forestMinScaleCtrl,
          forestMaxScaleCtrl,
          forestSeedCtrl,
          forestJitterCtrl
        ];

        forestCtrls.forEach((ctrl) => {
          trackController(ctrl, { rebuild: false, instant: true });
          if (typeof ctrl.onFinishChange === "function") {
            ctrl.onFinishChange(() => {
              applySettings(params, { rebuild: false, updateGui: false });
              rebuildForest();
              saveLastDebounced(params);
            });
          }
        });

        forest
        .add(
        {
          rebuildForest: () => {
            applySettings(params, { rebuild: false, updateGui: false });
            rebuildForest();
            saveLastDebounced(params);
          }
        },
        "rebuildForest"
        )
        .name("Rebuild forest");

        //wind.open();



        const surfaces = gui.addFolder("Surfaces");

        const surfaceUpdate = () => {
          params.groundColor = normalizeHexColor(params.groundColor, DEFAULTS.groundColor || "#ffffff");
          params.rockColor = normalizeHexColor(params.rockColor, DEFAULTS.rockColor || "#2b3442");
          params.forestColor = normalizeHexColor(params.forestColor, DEFAULTS.forestColor || "#2b7a2b");
          params.cubeColor = normalizeHexColor(params.cubeColor, DEFAULTS.cubeColor || "#4e9cff");
          applySurfaceColorsFromParams();
          saveLastDebounced(params);
        };

        const groundColorCtrl = surfaces.addColor(params, "groundColor").name("Ground").listen();
        const rockColorCtrl = surfaces.addColor(params, "rockColor").name("Rocks").listen();
        const forestColorCtrl = surfaces.addColor(params, "forestColor").name("Forest").listen();
        const cubeColorCtrl = surfaces.addColor(params, "cubeColor").name("Cube").listen();

        guiControllers.push(groundColorCtrl, rockColorCtrl, forestColorCtrl, cubeColorCtrl);

        groundColorCtrl.onChange(surfaceUpdate);
        rockColorCtrl.onChange(surfaceUpdate);
        forestColorCtrl.onChange(surfaceUpdate);
        cubeColorCtrl.onChange(surfaceUpdate);

        surfaces.close();

        const fogFolder = gui.addFolder("Fog");
        const fogUpdate = () => {
          updateFogFromParams();
          saveLastDebounced(params);
        };

        const fogEdgeCtrl = fogFolder
        .add(params, "fadeEndOfWorldEnabled")
        .name("Fade End of the World")
        .listen();

        const fogEdgeDistCtrl = fogFolder
        .add(params, "fadeEndOfWorldDistance", 12.0, Math.min(400.0, WORLD_BOUNDS_XZ), 1.0)
        .name("Fade distance")
        .listen();

        const fogNearCtrl = fogFolder
        .add(params, "fogNear", 0.1, 200.0, 0.5)
        .name("Near");
        const fogFarCtrl = fogFolder
        .add(params, "fogFar", 1.0, 400.0, 0.5)
        .name("Far");
        const fogColorCtrl = fogFolder
        .addColor(params, "fogColor")
        .name("Color");

        guiControllers.push(fogEdgeCtrl, fogEdgeDistCtrl, fogNearCtrl, fogFarCtrl, fogColorCtrl);

        fogEdgeCtrl.onChange((v) => {
          params.fadeEndOfWorldEnabled = !!v;
          fogUpdate();
        });

        fogEdgeDistCtrl.onChange(fogUpdate);
        fogNearCtrl.onChange(fogUpdate);
        fogFarCtrl.onChange(fogUpdate);
        fogColorCtrl.onChange(fogUpdate);

        //fogFolder.open();


        //fogFolder.open();

        const gustFolder = gui.addFolder("Gusts");



        trackController(
          gustFolder.add(params, "gustMinInterval", 0.2, 6.0, 0.1).name("Min interval")
          );
        trackController(
          gustFolder.add(params, "gustMaxInterval", 0.4, 12.0, 0.1).name("Max interval")
          );
        trackController(
          gustFolder.add(params, "gustTornadoChance", 0.0, 0.6, 0.01).name("Tornado chance")
          );
        trackController(
          gustFolder.add(params, "gustStrengthMul", 0.3, 2.0, 0.01).name("Strength mul")
          );
        trackController(
          gustFolder.add(params, "gustSwirlMul", 0.3, 2.0, 0.01).name("Swirl mul")
          );
        trackController(
          gustFolder.add(params, "gustUpdraftMul", 0.0, 2.0, 0.01).name("Updraft mul")
          );
        trackController(
          gustFolder.add(params, "gustScour", 0.0, 0.03, 0.0005).name("Scour")
          );
        trackController(
          gustFolder.add(params, "gustRedeposit", 0.0, 0.03, 0.0005).name("Redeposit")
          );
      //gustFolder.open();



        const cloudFolder = gui.addFolder("Clouds");

        cloudFolder
        .add(params, "cloudEnabled")
        .name("Enabled")
        .onChange((v) => {
          params.cloudEnabled = !!v;

          if (!params.cloudEnabled) {
            if (cloudLayer) cloudLayer.visible = false;
          } else {
            if (!cloudLayer) {
              rebuildClouds();
            } else {
              cloudLayer.visible = true;
              applyCloudParamsToUniforms();
            }
          }
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudHeightBase", 0.0, 200.0, 1)
        .name("Base height")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudHeightRange", 0.0, 150.0, 1)
        .name("Height range")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudRadius", 1.0, 300.0, 1.0)
        .name("Radius")
        .onChange(() => {
          rebuildClouds();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudSliceCount", 1, 256, 1)
        .name("Slices")
        .onChange(() => {
          rebuildClouds();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudDensity", 0.0, 1.0, 0.01)
        .name("Density")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudSoftness", 0.001, 1, 0.001)
        .name("Softness")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        cloudFolder
        .add(params, "cloudSpeed", -0.05, 0.05, 0.001)
        .name("Scroll speed")
        .onChange(() => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        });

        // NEW: color + opacity controls

        const cloudColorCtrl = cloudFolder
        .addColor(params, "cloudColor")
        .name("Cloud color");

        const skyColorCtrl = cloudFolder
        .addColor(params, "cloudSkyColor")
        .name("Sky color");

        const cloudOpacityCtrl = cloudFolder
        .add(params, "cloudOpacity", 0.0, 3.0, 0.05)
        .name("Opacity");

        const updateCloudAppearance = () => {
          applyCloudParamsToUniforms();
          saveLastDebounced(params);
        };

        cloudColorCtrl.onChange(updateCloudAppearance);
        skyColorCtrl.onChange(updateCloudAppearance);
        cloudOpacityCtrl.onChange(updateCloudAppearance);


        cloudFolder.close();




        const dustFolder = gui.addFolder("Dust");

        dustFolder
        .add(params, "dustEnabled")
        .name("Enabled")
        .onChange(() => {
          rebuildDust();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustCount", 16, 100000, 1)
        .name("Particles")
        .onChange(() => {
          rebuildDust();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustRadius", 0.1, 400.0, 0.1)
        .name("Radius")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustFloorY", -2.0, 10.0, 0.01)
        .name("Floor Y")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustCeilY", 0.1, 500.0, 0.1)
        .name("Ceiling Y")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustSpeed", 0.0, 20.0, 0.01)
        .name("Speed (time)")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustSize", 0.01, 5.0, 0.01)
        .name("Point size")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustNoise", 0.0, 2.0, 0.01)
        .name("Wiggle")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustCenterX", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center X")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        dustFolder
        .add(params, "dustCenterZ", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center Z")
        .onChange(() => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        });

        const dustInnerCtrl = dustFolder.addColor(params, "dustColorInner").name("Inner color");
        const dustOuterCtrl = dustFolder.addColor(params, "dustColorOuter").name("Outer color");

        const updateDustAppearance = () => {
          applyDustParamsToUniforms();
          saveLastDebounced(params);
        };

        dustInnerCtrl.onChange(updateDustAppearance);
        dustOuterCtrl.onChange(updateDustAppearance);

        dustFolder.close();



        // Rain GUI

        const rainFolder = gui.addFolder("Rain");

        rainFolder
        .add(params, "rainEnabled")
        .name("Enabled")
        .onChange(() => {
          rebuildRain();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainCount", 16, 40000, 1)
        .name("Drops")
        .onChange(() => {
          rebuildRain();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainRadius", 0.1, 200.0, 0.1)
        .name("Radius")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainTopY", -10.0, 200.0, 0.1)
        .name("Top Y")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainBottomY", -50.0, 80.0, 0.1)
        .name("Bottom Y")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainSpeed", 0.0, 12.0, 0.01)
        .name("Speed (time)")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainWindX", -10.0, 10.0, 0.01)
        .name("Wind X")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainWindZ", -10.0, 10.0, 0.01)
        .name("Wind Z")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainSize", 0.01, 2.0, 0.01)
        .name("Point size")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainThickness", 0.01, 0.25, 0.005)
        .name("Thickness")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainStreak", 0.10, 0.98, 0.01)
        .name("Streak")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainCenterX", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center X")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        rainFolder
        .add(params, "rainCenterZ", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center Z")
        .onChange(() => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        });

        const rainColorCtrl = rainFolder.addColor(params, "rainColor").name("Color");

        rainFolder
        .add(params, "rainOpacity", 0.0, 1.0, 0.01)
        .name("Opacity");

        const updateRainAppearance = () => {
          applyRainParamsToUniforms();
          saveLastDebounced(params);
        };

        rainColorCtrl.onChange(updateRainAppearance);

        rainFolder.close();





        // Grass GUI

        const grassFolder = gui.addFolder("Grass");

        grassFolder
        .add(params, "grassEnabled")
        .name("Enabled")
        .listen()
        .onChange(() => {
          rebuildGrass();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassCount", 0, 120000, 1)
        .name("Blades")
        .onChange(() => {
          rebuildGrass();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassSeed", 0, 999999, 1)
        .name("Seed")
        .onChange(() => {
          rebuildGrass();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassRadius", 0.1, 2000.0, 0.1)
        .name("Radius")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassCenterX", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center X")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassCenterZ", -HALF_GROUND, HALF_GROUND, 0.01)
        .name("Center Z")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBaseY", -2.0, 5.0, 0.005)
        .name("Base Y")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBladeHeight", 0.01, 50, 0.005)
        .name("Height")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBladeWidth", 0.001, 5, 0.001)
        .name("Width")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassHeightJitter", 0.0, 1.0, 0.01)
        .name("Height jitter")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassWidthJitter", 0.0, 1.0, 0.01)
        .name("Width jitter")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBend", 0.0, 12.0, 0.01)
        .name("Bend")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassWindSpeed", 0.0, 20.0, 0.01)
        .name("Wind speed")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassWindStrength", 0.0, 6.0, 0.01)
        .name("Wind strength")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassStiffness", 0.25, 4.0, 0.01)
        .name("Stiffness")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });


        grassFolder
        .add(params, "grassNoiseScale", 0.01, 20.0, 0.01)
        .name("Noise scale")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassNoiseStrength", 0.0, 2.0, 0.01)
        .name("Gust strength")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassNoiseSpeed", 0.0, 10.0, 0.01)
        .name("Gust speed")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassStaticHeightNoise", 0.0, 20.0, 0.01)
        .name("Height noise")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassStaticWidthNoise", 0.0, 10.0, 0.01)
        .name("Width noise")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassBorderNoise", 0.0, 10.0, 0.01)
        .name("Border noise")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassColorVariation", 0.0, 0.5, 0.01)
        .name("Color var")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });





        const grassBottomCtrl = grassFolder.addColor(params, "grassColorBottom").name("Bottom").listen();
        const grassTopCtrl = grassFolder.addColor(params, "grassColorTop").name("Top").listen();




        grassFolder
        .add(params, "grassOpacity", 0.0, 1.0, 0.01)
        .name("Opacity")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        grassFolder
        .add(params, "grassAlphaCutoff", 0.0, 0.95, 0.01)
        .name("Cutoff")
        .onChange(() => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        });

        const updateGrassAppearance = () => {
          applyGrassParamsToUniforms();
          saveLastDebounced(params);
        };

        grassBottomCtrl.onChange(updateGrassAppearance);
        grassTopCtrl.onChange(updateGrassAppearance);

        grassFolder.close();








        // Snowing

        const flakes = gui.addFolder("Flakes");
        trackController(flakes.add(params, "snowEnabled").name("Enabled"), { rebuild: true, instant: true });

        trackController(
          flakes.add(params, "visualCount", 20000, 600000, 5000).name("Visual flakes"),
          { rebuild: true, instant: false }
          );
        trackController(flakes.add(params, "fallSpeed", 0.001, 10.5, 0.001).name("Fall speed"));
        trackController(flakes.add(params, "fallJitter", 0.0, 0.9, 0.01).name("Fall jitter"));
        trackController(flakes.add(params, "flakeSize", 0.01, 10.0, 0.01).name("Flake size"));
        trackController(
          flakes.add(params, "flakeSizeJitter", 0.0, 0.9, 0.01).name("Size jitter")
          );

        //flakes.open();

        const drifts = gui.addFolder("Drifts");

        trackController(drifts.add(params, "driftGrid", 32, 4096, 1).name("Grid"), {
          rebuild: true,
          instant: false
        });
        trackController(
          drifts.add(params, "driftMaxHeight", 0.5, 8.0, 0.1).name("Max height")
          );
        trackController(drifts.add(params, "coverBase", 0.0, 0.30, 0.005).name("Base cover"));
        trackController(
          drifts.add(params, "coverMacroAmp", 0.0, 0.30, 0.005).name("Macro amp")
          );
        trackController(
          drifts.add(params, "coverMacroFreq", 0.5, 6.0, 0.1).name("Macro freq")
          );
        trackController(
          drifts.add(params, "coverMicroAmp", 0.0, 0.20, 0.005).name("Micro amp")
          );
        trackController(
          drifts.add(params, "coverMicroFreq", 2.0, 16.0, 0.1).name("Micro freq")
          );
        trackController(
          drifts.add(params, "depositUnit", 0.00005, 0.0015, 0.00001).name("Deposit unit")
          );
        trackController(
          drifts.add(params, "driftDiffusion", 0.0, 0.25, 0.001).name("Diffusion")
          );
        trackController(
          drifts.add(params, "driftAdvection", 0.0, 0.30, 0.001).name("Advection")
          );
        trackController(
          drifts.add(params, "obstacleShapeInterval", 1, 60, 1).name("Obstacle shape N")
          );
        trackController(
          drifts.add(params, "driftWriteInterval", 1, 60, 1).name("Write mesh N")
          );
        trackController(
          drifts.add(params, "normalUpdateInterval", 4, 180, 1).name("Normals N")
          );
      //drifts.open();




        const terrain = gui.addFolder("Terrain");

        const terrainSanitize = () => {
          params.terrainColorLow = normalizeHexColor(params.terrainColorLow, DEFAULTS.terrainColorLow || "#ffffff");
          params.terrainColorHigh = normalizeHexColor(params.terrainColorHigh, DEFAULTS.terrainColorHigh || "#ffffff");
          params.terrainOctaves = clamp(params.terrainOctaves | 0, 1, 10);
          params.terrainLacunarity = Math.max(1.0, params.terrainLacunarity);
          params.terrainGain = clamp(params.terrainGain, 0.0, 1.0);
          params.terrainEdgeNoiseAmp = clamp(params.terrainEdgeNoiseAmp, 0.0, 0.9);
          params.terrainColorStrength = clamp(params.terrainColorStrength, 0.0, 1.0);
        };

        const terrainCtrls = [
          terrain.add(params, "terrainEnabled").name("Enabled").listen(),
          terrain.add(params, "terrainAmp", 0.0, 25.0, 0.05).name("Height amp").listen(),
          terrain.add(params, "terrainFreq", 0.001, 0.12, 0.001).name("Frequency").listen(),
          terrain.add(params, "terrainOctaves", 1, 10, 1).name("Octaves").listen(),
          terrain.add(params, "terrainLacunarity", 1.0, 3.5, 0.05).name("Lacunarity").listen(),
          terrain.add(params, "terrainGain", 0.0, 0.95, 0.01).name("Gain").listen(),
          terrain.add(params, "terrainWarpAmp", 0.0, 40.0, 0.25).name("Warp amp").listen(),
          terrain.add(params, "terrainWarpFreq", 0.001, 0.06, 0.001).name("Warp freq").listen(),
          terrain.add(params, "terrainRidge").name("Ridged").listen(),
          terrain.add(params, "terrainExponent", 0.5, 3.0, 0.05).name("Shape").listen(),

          terrain.add(params, "terrainRadius", 0.0, 200.0, 0.5).name("Radius").listen(),
          terrain.add(params, "terrainInnerRadius", 0.0, 200.0, 0.5).name("Inner radius").listen(),
          terrain.add(params, "terrainEdgeFade", 0.0, 40.0, 0.5).name("Edge fade").listen(),
          terrain.add(params, "terrainEdgeNoiseAmp", 0.0, 0.9, 0.01).name("Border noise").listen(),
          terrain.add(params, "terrainEdgeNoiseFreq", 0.001, 0.10, 0.001).name("Border freq").listen(),

          terrain.add(params, "terrainSeed", 0, 9999, 1).name("Seed").listen(),
          terrain.addColor(params, "terrainColorLow").name("Color low").listen(),
          terrain.addColor(params, "terrainColorHigh").name("Color high").listen(),
          terrain.add(params, "terrainColorStrength", 0.0, 1.0, 0.01).name("Color mix").listen()
        ];

        terrainCtrls.forEach((ctrl) => {
          trackController(ctrl, { rebuild: false, instant: true });
          if (typeof ctrl.onFinishChange === "function") {
            ctrl.onFinishChange(() => {
              terrainSanitize();
              applySettings(params, { rebuild: false, updateGui: false });
              rebuildTerrainBase();
              saveLastDebounced(params);
            });
          } else if (typeof ctrl.onChange === "function") {
            ctrl.onChange(() => {
              terrainSanitize();
              applySettings(params, { rebuild: false, updateGui: false });
              rebuildTerrainBase();
              saveLastDebounced(params);
            });
          }
        });

        terrain
        .add(
        {
          rebuildTerrain: () => {
            terrainSanitize();
            applySettings(params, { rebuild: false, updateGui: false });
            rebuildTerrainBase();
            saveLastDebounced(params);
          }
        },
        "rebuildTerrain"
        )
        .name("Rebuild terrain");
        terrain.close();



        const sticking = gui.addFolder("Sticking");



        trackController(
          sticking.add(params, "settlerCount", 1000, 300000, 500).name("Settlers"),
          { rebuild: true, instant: false }
          );
        trackController(
          sticking.add(params, "groundDepositBudget", 20, 10200, 10).name("Deposit budget")
          );
        trackController(
          sticking.add(params, "objectTestsPerFrame", 0, 50000, 50).name("Ray tests/frame")
          );
        trackController(
          sticking.add(params, "objectDeposit", 0.0, 1, 0.0005).name("Object deposit")
          );
        trackController(
          sticking.add(params, "stuckMax", 1000, 600000, 500).name("Max decals"),
          { rebuild: true, instant: false }
          );
        trackController(
          sticking.add(params, "decalSize", 0.06, 0.50, 0.01).name("Decal size"),
          { rebuild: true, instant: false }
          );
      //ticking.open();

        const deformation = gui.addFolder("Deformation");

        const deformActions = {
          clear: () => {
            if (driftDeform && driftDeform.length) {
              driftDeform.fill(0);
              requestDriftWrite();
            }
          }
        };

        const deformControllers = [];

        deformControllers.push(
          deformation.add(snowDeformConfig, "enabled").name("Enabled").listen()
          );
        deformation.add(deformActions, "clear").name("Clear");

        const deformAvatar = deformation.addFolder("Avatar");
        deformControllers.push(
          deformAvatar.add(snowDeformConfig, "avatarFootRadius", 0.08, 0.80, 0.01).name("Foot radius").listen()
          );
        deformControllers.push(
          deformAvatar.add(snowDeformConfig, "avatarStepDistance", 0.15, 1.50, 0.01).name("Step distance").listen()
          );
        deformControllers.push(
          deformAvatar.add(snowDeformConfig, "avatarDepthWalk", 0.001, 0.080, 0.001).name("Depth walk").listen()
          );
        deformControllers.push(
          deformAvatar.add(snowDeformConfig, "avatarDepthRun", 0.001, 0.120, 0.001).name("Depth run").listen()
          );

        const deformVehicle = deformation.addFolder("Vehicle");
        deformControllers.push(
          deformVehicle.add(snowDeformConfig, "vehicleTrackDepth", 0.001, 1, 0.001).name("Track depth").listen()
          );
        deformControllers.push(
          deformVehicle.add(snowDeformConfig, "vehicleHalfWidthFallback", 0.10, 2.50, 0.01).name("Half width").listen()
          );
        deformControllers.push(
          deformVehicle.add(snowDeformConfig, "vehicleTrackSpacing", 0.10, 3.00, 0.01).name("Track spacing").listen()
          );

        const deformCarve = deformation.addFolder("Carve");
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveDepthMin", 0.000, 0.120, 0.001).name("Depth min").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveDepthMax", 0.001, 0.300, 0.001).name("Depth max").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveRadiusBase", 0.00, 2.50, 0.01).name("Radius base").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveRadiusFromDepth", 0.00, 40.0, 0.1).name("Radius / depth").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveRadiusMin", 0.00, 4.00, 0.01).name("Radius min").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveRadiusMax", 0.05, 8.00, 0.01).name("Radius max").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveMinCellFrac", 0.00, 2.00, 0.01).name("Min cell frac").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveMaxCells", 1, 48, 1).name("Max cells").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveSigmaFrac", 0.10, 1.50, 0.01).name("Sigma frac").listen()
          );
        deformControllers.push(
          deformCarve.add(snowDeformConfig, "carveMaxCarve", 0.005, 0.50, 0.005).name("Max carve").listen()
          );


        const wet = deformation.addFolder("Wet marks");

        wet.add(wetTrailConfig, "enabled").name("Enabled").listen();
        wet.add(wetTrailConfig, "maxMarks", 0, 1200, 10).name("Max marks").listen().onFinishChange(() => {
          setupWetTrailSystem();
          rebuildWetTrailPool();
        });
        wet.add(wetTrailConfig, "life", 0.5, 12.0, 0.1).name("Life").listen();
        wet.add(wetTrailConfig, "opacity", 0.01, 1.0, 0.01).name("Opacity").listen();
        wet.add(wetTrailConfig, "lift", 0.0, 0.20, 0.001).name("Lift").listen();

        wet.add(wetTrailConfig, "avatarSize", 0.05, 2.0, 0.01).name("Avatar size").listen();
        wet.add(wetTrailConfig, "vehicleWidth", 0.05, 3.0, 0.01).name("Vehicle width").listen();
        wet.add(wetTrailConfig, "vehicleLength", 0.05, 4.0, 0.01).name("Vehicle length").listen();

        wet.addColor(wetTrailConfig, "avatarColor").name("Avatar color").listen();
        wet.addColor(wetTrailConfig, "vehicleColor").name("Vehicle color").listen();

        wet.add(wetTrailConfig, "avatarUseFootprint").name("Avatar footprint").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });

        wet.add(wetTrailConfig, "footToeScale", 0.10, 1.00, 0.01).name("Foot toe").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });
        wet.add(wetTrailConfig, "footHeelScale", 0.10, 1.00, 0.01).name("Foot heel").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });
        wet.add(wetTrailConfig, "footBridge", 0.00, 0.60, 0.01).name("Foot bridge").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });
        wet.add(wetTrailConfig, "footSoftness", 0.05, 0.95, 0.01).name("Foot softness").listen().onChange(() => {
          wetFootTex = null;
          wetFootSig = "";
        });

        wet.add({ clear: () => clearWetTrails() }, "clear").name("Clear");

        for (let i = 0; i < deformControllers.length; i++) {
          const c = deformControllers[i];
          if (c && c.onFinishChange) c.onFinishChange(() => requestDriftWrite());
        }

        deformation.close()

        const misc = {
          resetDefaults() {
            applySettings(DEFAULTS, { rebuild: true, updateGui: true, persist: true });
          }
        };


        gui.add(misc, "resetDefaults").name("Reset to defaults");

        const presets = gui.addFolder("Presets");
        presets.add(presetState, "presetName").name("Save as").listen();

        presetSelectCtrl = presets
        .add(presetState, "selected", ["<none>"])
        .name("Saved presets");

      // auto-load preset (file or DB) when selection changes
        presetSelectCtrl.onChange(async (value) => {
          const name = sanitizePresetName(value);
          presetState.selected = name || "<none>";
          if (name && name !== "<none>") {
            await loadPreset();
          }
        });

        presets.add({ savePreset }, "savePreset").name("Save");
      // no Load button â€“ selection loads instantly
        presets.add({ deletePreset }, "deletePreset").name("Delete");
        presets.add({ exportJson: exportSettings }, "exportJson").name("Export JSON");
        presets.add({ importJson: importSettings }, "importJson").name("Import JSON");
      //presets.open();
      //presets.open();


        const worldModels = gui.addFolder("World Models");
        worldModels.add(worldModelsIoState, "source").name("Config source").listen();
        worldModels.add(worldModelsIoState, "openWorlds").name("Worlds...");
        worldModels.add(worldModelsIoState, "exportWorldModelsJson").name("Export World");
        worldModels.add(worldModelsIoState, "exportDefaultModelJson").name("Export Models");
        worldModels.add(worldModelsIoState, "importWorldModelsJson").name("Import world");
        worldModels.close();



        const snowmanFolder = gui.addFolder("Snowman");        


        trackController(
          snowmanFolder.add(params, "snowmanMoveEnabled").name("Moving")
          );

        trackController(
          snowmanFolder
          .add(params, "snowmanSpeed", 0.002, 0.15, 0.001)
          .name("Path speed")
          );

        trackController(
          snowmanFolder
          .add(params, "snowmanPathRadius", 1.0, 8.0, 0.1)
          .name("Path radius")
          );

        // start folded to not spam the UI
        // snowmanFolder.open(); // enable if you prefer it open by default




        const vehiclesFolder = gui.addFolder("Vehicles");
        setupVehicleTuningGui(vehiclesFolder);
        vehiclesFolder.close();

        const equipmentFolder = gui.addFolder("Equipment");
        setupEquipmentTuningGui(equipmentFolder);
        equipmentFolder.close();

        const avatarFolder = gui.addFolder("Avatar");
        setupAvatarStepGui(avatarFolder);
        avatarFolder.close();

        const objectFolder = gui.addFolder("Object");
        setupWorldEditObjectGui(objectFolder);
        objectFolder.close();






        sim.close();
        wind.close();
        fogFolder.close();
        gustFolder.close();
        flakes.close();
        drifts.close();
        sticking.close();
        presets.close();
        snowmanFolder.close();
        forest.close();

        gui.close()

      }









    // -------------------------------------------------------------------------
    // Events / main loop
    // -------------------------------------------------------------------------

      function handleResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);

        layoutMinimapCanvases();
        drawMinimapFrame(true);
      }


      const clock = new THREE.Clock();
      let frame = 0;
      let simTime = 0;









      function animate() {
        const rawDt = clamp(
          clock.getDelta(),
          0.0,
          Math.max(0.001, params.dtMax)
          );

        const timeScale = clamp(params.timeScale, 0.05, 5.0);

        const dtSim = params.paused ? 0.0 : rawDt * timeScale;
        const dtAvatar = params.paused ? 0.0 : rawDt;

        if (!params.paused) simTime += dtSim;
        const t = simTime;

        const wA =
        Math.sin(t * params.windSpeed) * 0.48 +
        Math.sin(t * (params.windSpeed * 2.4)) * 0.16;
        const wB =
        Math.cos(t * (params.windSpeed * 0.92)) * 0.44 +
        Math.sin(t * (params.windSpeed * 2.1)) * 0.14;
        const baseWindX = wA * params.windStrength;
        const baseWindZ = wB * params.windStrength;

        if (!params.paused) {
          spawnGusts(dtSim);
          for (let i = 0; i < gusts.length; i++) {
            gusts[i].step(dtSim);
          }
        }

        for (let i = 0; i < GUST_MAX; i++) {
          const g = gusts[i];
          const fade = g.active ? g.fade : 0.0;

          gustPosRad[i * 3 + 0] = g.x;
          gustPosRad[i * 3 + 1] = g.z;
          gustPosRad[i * 3 + 2] = g.radius;

          gustParams[i * 3 + 0] = g.strength * fade;
          gustParams[i * 3 + 1] = g.swirl * fade;
          gustParams[i * 3 + 2] = g.updraft * fade;
        }

        if (params.snowEnabled && snowMat) {
          snowMat.uniforms.uTime.value = t;
          snowMat.uniforms.uWind.value.set(baseWindX, baseWindZ);
          snowMat.uniforms.uFallSpeed.value = params.fallSpeed;
          snowMat.uniforms.uFallJitter.value = params.fallJitter;
          snowMat.uniforms.uFlakeSize.value = params.flakeSize;
          snowMat.uniforms.uFlakeSizeJitter.value = params.flakeSizeJitter;
        }

        if (!params.paused) {
          if (driftHeights) {
            const flyingPlane = !!(vehicleDriveState && vehicleDriveState.enabled && vehicleDriveState.planeAirborne);
            const jetpackEquipped =
            !!(equipmentState && equipmentState.enabled && equipmentState.item && equipmentState.item.meta &&
             typeof equipmentState.item.meta.action === "string" &&
             equipmentState.item.meta.action.trim().toLowerCase() === "jetpack");
            const flyingJetpack = jetpackEquipped && !!(avatarJumpState && avatarJumpState.active);

            const freezeDrifts = flyingPlane || flyingJetpack;

            if (!freezeDrifts) {
              applyGustScour(baseWindX, baseWindZ);

              if (frame % clamp(params.obstacleShapeInterval | 0, 1, 600) === 0) {
                shapeDriftsAroundObstacles(baseWindX, baseWindZ);
              }
              evolveDrifts(baseWindX, baseWindZ);

              const writeEvery = clamp(params.driftWriteInterval | 0, 1, 120);
              const normalEvery = clamp(params.normalUpdateInterval | 0, 1, 240);

              const shouldWrite = forceDriftWrite || (frame % writeEvery === 0);
              if (shouldWrite) {
                applyHeightsToGeometry();
                forceDriftWrite = false;
              }

              if (driftGeo && (forceDriftNormals || (frame % normalEvery === 0))) {
                driftGeo.computeVertexNormals();
                driftGeo.attributes.normal.needsUpdate = true;
                forceDriftNormals = false;

                updateWetTrails(dtAvatar);
              }
            } else {
              forceDriftWrite = false;
              forceDriftNormals = false;
            }
          }

          updateSettlers(dtSim, baseWindX, baseWindZ);
          updateSnowman(dtSim);
          updateClouds(dtSim);
          tickEnvSound(dtSim);

          updateDust(dtSim);
          updateRain(dtSim);
          updateGrass(dtSim, baseWindX, baseWindZ);
        }

        tickAvatar(dtAvatar);

        updateHudTile((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());

        updateNowPlayingUi((typeof performance !== "undefined" && performance.now) ? performance.now() : Date.now());




        const fogFocus = getMinimapFocus();
        updateEdgeFadeFog(fogFocus.x, fogFocus.z);

        const inXR = renderer.xr.isPresenting;

        if (!inXR && controls) {
          if (avatarState.enabled) {
            controls.autoRotate = false;
            controls.autoRotateSpeed = AUTO_ROTATE_SPEED;

            if (vehicleDriveState.enabled && vehicleChaseCamState.enabled) {
              updateVehicleChaseCamera(dtAvatar);
            } else if (!vehicleDriveState.enabled && avatarChaseCamState.enabled && avatarState.viewMode === "third") {
              updateAvatarChaseCamera(dtAvatar);
            } else {
              if (!joystickState.active) {
                controls.update();
              }

              updateAvatarCamera(dtAvatar);
            }
          } else {
            const nowSeconds = performance.now() * 0.001;
            const idleSeconds = nowSeconds - lastInteractionTime;

            const shouldAutoRotate =
            autoRotateEnabled &&
            idleSeconds >= AUTO_ROTATE_IDLE_SECONDS;

            controls.autoRotate = shouldAutoRotate;
            controls.autoRotateSpeed = AUTO_ROTATE_SPEED;

            controls.update();
          }
        }

        applyShadowSettingsFromParams(false);
        renderer.render(scene, camera);

        drawMinimapFrame(false);

        frame++;
      }





// -------------------------------------------------------------------------
// Keyboard: fullscreen (F) and UI toggle (ESC)
// -------------------------------------------------------------------------

      let uiHidden = false;

/**
 * Toggle visibility of GUI and HUD without destroying state.
 */
      function setUIHidden(hidden) {
        uiHidden = hidden;

        if (gui && gui.domElement) {
          gui.domElement.style.display = hidden ? "none" : "";
        }

        const hud = document.querySelector(".hud");
        if (hud) {
          hud.style.display = hidden ? "none" : "";
        }

        const avatarUi = document.querySelector(".avatar-ui");
        if (avatarUi) {
          avatarUi.style.display = hidden ? "none" : "";
        }

        const joystickEl = document.getElementById("joystick");
        if (joystickEl) {
          joystickEl.style.display = hidden ? "none" : "";
        }

        const joystickRightEl = document.getElementById("joystickRight");
        if (joystickRightEl) {
          joystickRightEl.style.display = hidden ? "none" : "";
        }

        const vehiclePanel = document.getElementById("vehiclePrompt");
        if (vehiclePanel) {
          if (hidden) {
            vehiclePanel.style.display = "none";
            vehiclePanel.setAttribute("aria-hidden", "true");
          } else {
            const show = !!(vehiclePromptState.open && vehiclePromptState.nearby);
            vehiclePanel.style.display = show ? "block" : "none";
            vehiclePanel.setAttribute("aria-hidden", show ? "false" : "true");
          }
        }

        if (hidden) {
          updateVehicleOutlineFor(null);
        } else {
          if (vehiclePromptState.open && vehiclePromptState.nearby) {
            updateVehicleOutlineFor(vehiclePromptState.nearby);
          }
        }

        updateVehicleQuickActionButton();
      }








/**
 * Cross-browser fullscreen state check.
 */
      function isFullscreen() {
        return (
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement
          );
      }

/**
 * Toggle fullscreen on the document root.
 */
      function toggleFullscreen() {
        const el = document.documentElement;

        if (!isFullscreen()) {
          if (el.requestFullscreen) el.requestFullscreen();
          else if (el.webkitRequestFullscreen) el.webkitRequestFullscreen();
          else if (el.mozRequestFullScreen) el.mozRequestFullScreen();
          else if (el.msRequestFullscreen) el.msRequestFullscreen();
        } else {
          if (document.exitFullscreen) document.exitFullscreen();
          else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
          else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
          else if (document.msExitFullscreen) document.msExitFullscreen();
        }
      }



      const keyboardHelpState = { open: false };
      let keyboardHelpEl = null;
      let keyboardHelpCloseBtn = null;

      const playerProfileState = { open: false, wired: false };
      let playerProfileEl = null;
      let playerProfileCloseBtn = null;
      let playerProfileSaveBtn = null;
      let playerProfileResetBtn = null;
      let playerProfileIdEl = null;
      let playerNameInputEl = null;
      let playerColorInputEl = null;
      let playerBioInputEl = null;

      let avatarPrevBtnEl = null;
      let avatarNextBtnEl = null;
      let avatarSelectBtnEl = null;
      let avatarPreviewImgEl = null;
      let avatarPreviewNameEl = null;
      let avatarPreviewDescEl = null;
      let avatarPreviewCounterEl = null;

      const profileAvatarPicker = { index: 0, selectedId: DEFAULT_AVATAR_ID };



      const INVENTORY_STORAGE_KEY = "snow:playerInventory:v1";
      const inventoryPickerState = { open: false, wired: false, slots: 16 };

      let inventoryPickerEl = null;
      let inventoryPickerCloseBtn = null;
      let inventoryPickerListEl = null;

      const worldObjectPickerState = { open: false, wired: false };

      let worldObjectPickerEl = null;
      let worldObjectPickerCloseBtn = null;
      let worldObjectPickerListEl = null;


      const DEFAULT_ITEM_THUMB = 'data:image/svg+xml;utf8,' + encodeURIComponent(
        '<svg xmlns="http://www.w3.org/2000/svg" width="256" height="256" viewBox="0 0 256 256">' +
        '<defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1">' +
        '<stop offset="0" stop-color="rgba(255,255,255,0.10)"/>' +
        '<stop offset="1" stop-color="rgba(255,255,255,0.02)"/>' +
        '</linearGradient></defs>' +
        '<rect x="16" y="16" width="224" height="224" rx="28" fill="url(#g)" stroke="rgba(255,255,255,0.18)" stroke-width="6"/>' +
        '<path d="M78 164l34-44 28 34 18-22 42 54H78z" fill="rgba(255,255,255,0.20)"/>' +
        '<circle cx="104" cy="92" r="16" fill="rgba(255,255,255,0.20)"/>' +
        '</svg>'
        );

      /* Escapes text for safe HTML rendering inside the inventory cards. */
      function escapeInventoryText(value) {
        return String(value ?? "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
      }

      /* Provides a starter inventory payload for a new client (mock items). */
      function getDefaultPlayerInventory() {
        return {
          slots: inventoryPickerState.slots,
          items: [
            {
              id: "matches",
              name: "Matches",
              desc: "Light campfires and torches.",
              thumb: DEFAULT_ITEM_THUMB
            },
            {
              id: "compass",
              name: "Compass",
              desc: "Simple navigation aid.",
              thumb: DEFAULT_ITEM_THUMB
            },
            {
              id: "medkit",
              name: "Medkit",
              desc: "Restores health (mock).",
              thumb: DEFAULT_ITEM_THUMB
            }
          ]
        };
      }

      /* Loads inventory from localStorage and normalizes it to a safe schema. */
      function loadPlayerInventory() {
        try {
          const raw = localStorage.getItem(INVENTORY_STORAGE_KEY);
          if (!raw) return getDefaultPlayerInventory();
          const parsed = JSON.parse(raw);
          return normalizePlayerInventory(parsed);
        } catch (_) {
          return getDefaultPlayerInventory();
        }
      }

      /* Persists inventory to localStorage (single-writer; used by future pickup/use flows). */
      function savePlayerInventory(inv) {
        const normalized = normalizePlayerInventory(inv);
        localStorage.setItem(INVENTORY_STORAGE_KEY, JSON.stringify(normalized));
      }

      /* Ensures inventory payload stays valid and forward-compatible. */
      function normalizePlayerInventory(inv) {
        const out = { slots: inventoryPickerState.slots, items: [] };

        if (inv && Number.isFinite(inv.slots)) {
          out.slots = Math.max(1, Math.min(64, Math.floor(inv.slots)));
        }

        if (inv && Array.isArray(inv.items)) {
          for (const it of inv.items) {
            if (!it || typeof it !== "object") continue;
            const id = typeof it.id === "string" ? it.id.trim() : "";
            const name = typeof it.name === "string" ? it.name.trim() : "";
            if (!id || !name) continue;

            out.items.push({
              id,
              name,
              desc: typeof it.desc === "string" ? it.desc : "",
              thumb: typeof it.thumb === "string" && it.thumb ? it.thumb : DEFAULT_ITEM_THUMB,
              slot: Number.isFinite(it.slot) ? Math.floor(it.slot) : undefined
            });
          }
        }

        return out;
      }



      /* Adds a world pickup to inventory and removes it from the scene in a reversible-friendly way. */
      function pickupTake(near) {
        if (!near || !near.object) return;

        const meta = (near.meta && typeof near.meta === "object") ? near.meta : {};
        const requiresBackpack = !!meta.requiresBackpack || meta.size === "bulky";

        const hasBackpack =
        !!(equipmentState && equipmentState.enabled && equipmentState.item && equipmentState.item.meta) &&
        String(equipmentState.item.meta.type || "").toLowerCase().includes("backpack");

        if (requiresBackpack && !hasBackpack) {
          if (typeof showActionToast === "function") showActionToast("Requires backpack");
          console.warn("[pickup] requires backpack:", near.id || "(no-id)");
          return;
        }

        const entry = {
          id: near.id || "",
          kind: String(meta.kind || "pickup"),
          name: String(meta.name || meta.title || near.id || "Item"),
          desc: String(meta.description || ""),
          caloriesKcal: Number.isFinite(meta.caloriesKcal) ? meta.caloriesKcal : 0,
          weightKg: Number.isFinite(meta.weightKg) ? meta.weightKg : 0,
          ts: Date.now()
        };

        if (typeof loadPlayerInventory === "function" && typeof savePlayerInventory === "function") {
          const inv = loadPlayerInventory();
          if (inv && Array.isArray(inv.items)) {
            inv.items.push(entry);
            savePlayerInventory(inv);
          }
        }

        if (typeof showActionToast === "function") showActionToast(`TAKEN â€¢ ${entry.name}`);

        if (near.object.parent) near.object.parent.remove(near.object);

        for (let i = equipmentInteractables.length - 1; i >= 0; i--) {
          const e = equipmentInteractables[i];
          if (e && e.object === near.object) equipmentInteractables.splice(i, 1);
        }

        if (vehiclePromptState && vehiclePromptState.open) setVehiclePrompt(false, null);

        if (inventoryPickerState && inventoryPickerState.open) {
          if (typeof renderInventoryPickerList === "function") renderInventoryPickerList();
        }
      }






    /* Consumes a food pickup in-world and applies calories into player stamina/health pipeline. */
      function pickupConsume(near) {
        if (!near || !near.object) return;

        const meta = (near.meta && typeof near.meta === "object") ? near.meta : {};
        const kcal = Number.isFinite(meta.caloriesKcal) ? Math.max(0, meta.caloriesKcal) : 0;

        if (typeof window.__sessionEnergyIntakeKcal !== "number") window.__sessionEnergyIntakeKcal = 0;
        window.__sessionEnergyIntakeKcal += kcal;

        if (typeof playerVitals !== "undefined" && playerVitals) {
          const curEnergy = Number.isFinite(playerVitals.energyKcal) ? playerVitals.energyKcal : 0;
          const curStamina = Number.isFinite(playerVitals.stamina) ? playerVitals.stamina : 1;

          playerVitals.energyKcal = Math.max(0, curEnergy + kcal);
          playerVitals.stamina = Math.min(1, curStamina + (kcal / 1200));

          if (typeof savePlayerVitals === "function") savePlayerVitals();
        }

        const nm = String(meta.name || meta.title || near.id || "Food");
        if (typeof showActionToast === "function") showActionToast(`CONSUMED â€¢ ${nm} +${(kcal | 0)}kcal`);

        if (near.object.parent) near.object.parent.remove(near.object);

        for (let i = equipmentInteractables.length - 1; i >= 0; i--) {
          const e = equipmentInteractables[i];
          if (e && e.object === near.object) equipmentInteractables.splice(i, 1);
        }

        if (vehiclePromptState && vehiclePromptState.open) setVehiclePrompt(false, null);
        if (typeof updateHudTile === "function") updateHudTile();
      }






      /* Wires the inventory overlay UI once and keeps open/close state consistent. */
      function ensureInventoryPickerOverlayWired() {
        if (inventoryPickerState.wired) return;

        inventoryPickerEl = document.getElementById("inventoryPicker");
        inventoryPickerCloseBtn = document.getElementById("inventoryPickerClose");
        inventoryPickerListEl = document.getElementById("inventoryPickerList");

        if (!inventoryPickerEl || !inventoryPickerListEl) {
          inventoryPickerState.wired = true;
          return;
        }

        if (inventoryPickerCloseBtn) {
          inventoryPickerCloseBtn.addEventListener("click", (event) => {
            event.preventDefault();
            setInventoryPickerOpen(false);
          });
        }

        inventoryPickerEl.addEventListener("click", (event) => {
          if (event.target === inventoryPickerEl) setInventoryPickerOpen(false);
        });

        setInventoryPickerOpen(inventoryPickerState.open);
        inventoryPickerState.wired = true;
      }

      /* Opens/closes inventory overlay and triggers a render when shown. */
      function setInventoryPickerOpen(open) {
        inventoryPickerState.open = !!open;

        if (!inventoryPickerEl) return;

        inventoryPickerEl.classList.toggle("is-open", inventoryPickerState.open);
        inventoryPickerEl.setAttribute("aria-hidden", inventoryPickerState.open ? "false" : "true");

        if (inventoryPickerState.open) renderInventoryPickerList();
      }

      /* Opens inventory overlay and closes other overlays that compete for input focus. */
      function openInventoryPickerOverlay() {
        ensureInventoryPickerOverlayWired();
        if (typeof setWorldPickerOpen === "function") setWorldPickerOpen(false);
        if (typeof setPlayerProfileOpen === "function") setPlayerProfileOpen(false);
        if (typeof setKeyboardHelpOpen === "function") setKeyboardHelpOpen(false);
        setInventoryPickerOpen(true);
      }

      /* Renders inventory slots (filled + empty placeholders). */
      function renderInventoryPickerList() {
        if (!inventoryPickerListEl) return;

        const inv = loadPlayerInventory();
        const slots = new Array(inv.slots).fill(null);

        for (const it of inv.items) {
          const desired = Number.isFinite(it.slot) ? it.slot : -1;
          if (desired >= 0 && desired < slots.length && !slots[desired]) {
            slots[desired] = it;
            continue;
          }

          const firstEmpty = slots.findIndex((v) => !v);
          if (firstEmpty >= 0) slots[firstEmpty] = it;
        }

        inventoryPickerListEl.innerHTML = slots
        .map((it) => {
          if (!it) {
            return (
              '<div class="inv-slot inv-slot--empty">' +
              '<div class="inv-slot__empty">Empty</div>' +
              "</div>"
              );
          }

          const name = escapeInventoryText(it.name);
          const desc = escapeInventoryText(it.desc);
          const thumb = escapeInventoryText(it.thumb || DEFAULT_ITEM_THUMB);

          return (
            '<div class="inv-slot inv-slot--filled" data-item-id="' + escapeInventoryText(it.id) + '">' +
            '<img class="inv-item__thumb" alt="" loading="lazy" decoding="async" src="' + thumb + '"/>' +
            '<div class="inv-item__body">' +
            '<div class="inv-item__name">' + name + "</div>" +
            '<div class="inv-item__desc">' + (desc || "&nbsp;") + "</div>" +
            "</div>" +
            "</div>"
            );
        })
        .join("");
      }




      /* Builds the catalog shown in the edit-only object picker (uses currently available templates). */
      /* Builds the catalog shown in the edit-only object picker (uses currently available templates). */
      function getWorldObjectCatalog() {
        const base = worldModelsConfig || MODEL_CONFIG;
        const out = [];

        const findModelUrlByName = (name) => {
          const n = String(name || "");
          if (!n) return "";

          const fromBase = (Array.isArray(base) ? base : []).find((e) => e && String(e.name) === n) || null;
          const u0 = fromBase && typeof fromBase.url === "string" ? fromBase.url.trim() : "";
          if (u0) return u0;

          const fromDefaults = (Array.isArray(MODEL_CONFIG) ? MODEL_CONFIG : []).find((e) => e && String(e.name) === n) || null;
          const u1 = fromDefaults && typeof fromDefaults.url === "string" ? fromDefaults.url.trim() : "";
          return u1 || "";
        };

        const modelUrlToThumb = (url) => {
          const raw = String(url || "").trim();
          if (!raw) return DEFAULT_ITEM_THUMB;

          const clean = raw.split("#")[0].split("?")[0];
          const png = clean.replace(/\.(glb|gltf)$/i, ".png");
          return png && png !== clean ? png : DEFAULT_ITEM_THUMB;
        };

        for (const entry of base) {
          if (!entry || !entry.name) continue;

          const name = String(entry.name);
          const template = modelTemplates[name] || null;
          if (!template) continue;

          const url = findModelUrlByName(name);
          const thumb = modelUrlToThumb(url);

          out.push({
            name,
            desc: "Add to scene",
            thumb
          });
        }

        return out;
      }


      /* Wires the world-object picker overlay once and keeps open/close state consistent. */
      function ensureWorldObjectPickerOverlayWired() {
        if (worldObjectPickerState.wired) return;

        worldObjectPickerEl = document.getElementById("worldObjectPicker");
        worldObjectPickerCloseBtn = document.getElementById("worldObjectPickerClose");
        worldObjectPickerListEl = document.getElementById("worldObjectPickerList");

        if (!worldObjectPickerEl || !worldObjectPickerListEl) {
          worldObjectPickerState.wired = true;
          return;
        }

        if (worldObjectPickerCloseBtn) {
          worldObjectPickerCloseBtn.addEventListener("click", (event) => {
            event.preventDefault();
            setWorldObjectPickerOpen(false);
          });
        }

        worldObjectPickerEl.addEventListener("click", (event) => {
          if (event.target === worldObjectPickerEl) setWorldObjectPickerOpen(false);
        });

        worldObjectPickerListEl.addEventListener("click", (event) => {
          const btn = event.target && event.target.closest ? event.target.closest("[data-world-object]") : null;
          if (!btn) return;

          event.preventDefault();

          const modelName = btn.getAttribute("data-world-object") || "";
          if (!modelName) return;

          addWorldObjectToScene(modelName);
          setWorldObjectPickerOpen(false);
        });

        setWorldObjectPickerOpen(worldObjectPickerState.open);
        worldObjectPickerState.wired = true;
      }

      /* Opens/closes object picker overlay and triggers a render when shown. */
      function setWorldObjectPickerOpen(open) {
        worldObjectPickerState.open = !!open;

        if (!worldObjectPickerEl) return;

        worldObjectPickerEl.classList.toggle("is-open", worldObjectPickerState.open);
        worldObjectPickerEl.setAttribute("aria-hidden", worldObjectPickerState.open ? "false" : "true");

        if (worldObjectPickerState.open) renderWorldObjectPickerList();
      }

      /* Opens object picker overlay (Edit World only) and closes other overlays that compete for input focus. */
      function openWorldObjectPickerOverlay() {
        if (!worldEditState.enabled) return;

        ensureWorldObjectPickerOverlayWired();

        if (typeof setWorldPickerOpen === "function") setWorldPickerOpen(false);
        if (typeof setPlayerProfileOpen === "function") setPlayerProfileOpen(false);
        if (typeof setKeyboardHelpOpen === "function") setKeyboardHelpOpen(false);
        if (typeof setInventoryPickerOpen === "function") setInventoryPickerOpen(false);

        setWorldObjectPickerOpen(true);
      }

      /* Renders the catalog cards for adding objects back into the scene. */
      function renderWorldObjectPickerList() {
        if (!worldObjectPickerListEl) return;

        const items = getWorldObjectCatalog();

        worldObjectPickerListEl.innerHTML = items
        .map((it) => {
          const name = escapeInventoryText(it.name);
          const desc = escapeInventoryText(it.desc || "");
          const thumb = escapeInventoryText(it.thumb || DEFAULT_ITEM_THUMB);

          return (
            '<button class="inv-slot inv-slot--filled inv-slot--pick" type="button" data-world-object="' + name + '">' +
            '<img class="inv-item__thumb" alt="" loading="lazy" decoding="async" src="' + thumb + '"/>' +
            '<div class="inv-item__body">' +
            '<div class="inv-item__name">' + name + '</div>' +
            '<div class="inv-item__desc">' + (desc || "&nbsp;") + '</div>' +
            '</div>' +
            '</button>'
            );
        })
        .join("");
      }

      /* Computes a drop position in front of the avatar (or camera fallback) and snaps it to the traversable surface. */
      function computeDropPoseInFront(outPos, outYaw) {
        const forward = avatarTmpDir;
        const origin = avatarTmpVec;

        if (avatar) {
          avatar.getWorldPosition(origin);
          forward.set(0, 0, 1).applyQuaternion(avatar.quaternion);
        } else {
          origin.copy(camera.position);
          camera.getWorldDirection(forward);
        }

        forward.y = 0;
        if (forward.lengthSq() < 1e-10) forward.set(0, 0, 1);
        forward.normalize();

        outYaw.value = Math.atan2(forward.x, forward.z);

        outPos.copy(origin).addScaledVector(forward, 2.2);
        outPos.y = getWorldSurfaceY(outPos.x, outPos.z);
      }

      /* Adds a new instance of a catalog object to the editable world config and spawns it into the scene. */
      function addWorldObjectToScene(modelName) {
        if (!worldEditState.enabled) return;

        const name = String(modelName || "").trim();
        if (!name) return;

        const template = modelTemplates[name] || null;
        if (!template) return;

        ensureEditableWorldModelsConfig();
        pushWorldEditUndoSnapshot();

        let entry = null;
        for (const e of worldModelsConfig) {
          if (e && String(e.name) === name) {
            entry = e;
            break;
          }
        }

        if (!entry) {
          const src = (Array.isArray(MODEL_CONFIG) ? MODEL_CONFIG : []).find((e) => e && String(e.name) === name) || null;
          entry = {
            name,
            url: src && src.url ? src.url : "",
            instances: []
          };
          worldModelsConfig.push(entry);
        }

        if (!Array.isArray(entry.instances)) entry.instances = [];

        const srcEntry = (Array.isArray(MODEL_CONFIG) ? MODEL_CONFIG : []).find((e) => e && String(e.name) === name) || null;

        const pickBaseInstance = (fromCfg) => {
          if (!fromCfg || !Array.isArray(fromCfg.instances) || !fromCfg.instances.length) return null;

          for (let i = 0; i < fromCfg.instances.length; i++) {
            const it = fromCfg.instances[i];
            if (!it || typeof it !== "object") continue;
            if (it.vehicle || it.equipment) return it;
          }

          for (let i = 0; i < fromCfg.instances.length; i++) {
            const it = fromCfg.instances[i];
            if (!it || typeof it !== "object") continue;
            if (it.collide || it.stick || it.ground) return it;
          }

          return fromCfg.instances[0] || null;
        };

        const baseFromModelDefaults = pickBaseInstance(srcEntry);
        const baseFromWorld = baseFromModelDefaults ? null : pickBaseInstance(entry);
        const baseInst = baseFromModelDefaults || baseFromWorld;

        const instCfg = baseInst
        ? JSON.parse(JSON.stringify(baseInst))
        : {
          id: "",
          position: [0, 0, 0],
          rotation: [0, 0, 0],
          scale: 1.0,
          stick: false,
          collide: false
        };

        instCfg.id = makeUniqueWorldModelId(name);

        if (!Array.isArray(instCfg.position)) instCfg.position = [0, 0, 0];
        if (instCfg.position.length < 3) instCfg.position = [instCfg.position[0] || 0, instCfg.position[1] || 0, instCfg.position[2] || 0];

        if (!Array.isArray(instCfg.rotation)) instCfg.rotation = [0, 0, 0];
        if (instCfg.rotation.length < 3) instCfg.rotation = [instCfg.rotation[0] || 0, instCfg.rotation[1] || 0, instCfg.rotation[2] || 0];

        const dropPos = avatarTmpVec;
        const yawRef = { value: 0 };
        computeDropPoseInFront(dropPos, yawRef);

        instCfg.position[0] = dropPos.x;
        instCfg.position[1] = dropPos.y;
        instCfg.position[2] = dropPos.z;

        instCfg.rotation[1] = yawRef.value;

        entry.instances.push(instCfg);

        const inst = template.clone(true);
        applyInstCfgTransformToInstance(inst, instCfg);

        Object.defineProperty(instCfg, "runtimeObject", {
          value: inst,
          enumerable: false,
          configurable: true
        });

        scene.add(inst);
        modelInstances[instCfg.id] = inst;

        rebuildWorldModelsRuntimeCaches();
        selectWorldEditRoot(inst);
        updateAvatarButtons();
        showActionToast("Added");
      }





      /* Keeps the Profile avatar carousel synced with current params/player profile selection. */
      function syncProfileAvatarPickerFromCurrent() {
        const current = sanitizeAvatarId(
          (params && typeof params.avatarId === "string") ? params.avatarId : playerProfile.avatarId,
          DEFAULTS.avatarId
          );

        profileAvatarPicker.selectedId = current;

        let idx = 0;
        for (let i = 0; i < AVATAR_CATALOG.length; i++) {
          if (AVATAR_CATALOG[i].id === current) {
            idx = i;
            break;
          }
        }
        profileAvatarPicker.index = idx;

        renderProfileAvatarPicker();
      }

      /* Renders the visible card for the current carousel index. */
      function renderProfileAvatarPicker() {
        if (!avatarPreviewImgEl || !avatarPreviewNameEl || !avatarPreviewDescEl || !avatarPreviewCounterEl) return;
        if (!AVATAR_CATALOG.length) return;

        const idx = ((profileAvatarPicker.index % AVATAR_CATALOG.length) + AVATAR_CATALOG.length) % AVATAR_CATALOG.length;
        profileAvatarPicker.index = idx;

        const entry = AVATAR_CATALOG[idx];

        avatarPreviewImgEl.src = entry.thumb;
        avatarPreviewImgEl.onerror = () => {
          avatarPreviewImgEl.onerror = null;
          avatarPreviewImgEl.src = DEFAULT_ITEM_THUMB;
        };

        avatarPreviewNameEl.textContent = entry.name || entry.id;
        avatarPreviewDescEl.textContent = entry.desc || "";
        avatarPreviewCounterEl.textContent = `${idx + 1}/${AVATAR_CATALOG.length}`;

        const isSelected = profileAvatarPicker.selectedId === entry.id;
        if (avatarSelectBtnEl) {
          avatarSelectBtnEl.disabled = isSelected;
          avatarSelectBtnEl.textContent = isSelected ? "Selected" : "Select";
        }
      }

      /* Advances the carousel index by delta and refreshes preview only. */
      function stepProfileAvatarPicker(delta) {
        if (!AVATAR_CATALOG.length) return;
        profileAvatarPicker.index = (profileAvatarPicker.index + (delta | 0)) % AVATAR_CATALOG.length;
        if (profileAvatarPicker.index < 0) profileAvatarPicker.index += AVATAR_CATALOG.length;
        renderProfileAvatarPicker();
      }

      /* Commits the currently previewed avatar as selected and applies it to world/settings. */
      function commitProfileAvatarSelection() {
        if (!AVATAR_CATALOG.length) return;
        const entry = AVATAR_CATALOG[profileAvatarPicker.index];
        if (!entry) return;

        const id = sanitizeAvatarId(entry.id, DEFAULTS.avatarId);
        if (profileAvatarPicker.selectedId === id) return;

        profileAvatarPicker.selectedId = id;

        applySettings({ avatarId: id }, { rebuild: false, updateGui: false, persist: true });

        renderProfileAvatarPicker();
        showActionToast("Avatar selected");
      }



    /**
     * Shows or hides the player profile overlay and keeps ARIA state in sync.
     */
      function setPlayerProfileOpen(open) {
        playerProfileState.open = !!open;

        if (!playerProfileEl) return;

        playerProfileEl.classList.toggle("is-open", playerProfileState.open);
        playerProfileEl.setAttribute("aria-hidden", playerProfileState.open ? "false" : "true");

        if (playerProfileState.open) {
          if (playerProfileIdEl) playerProfileIdEl.textContent = playerProfile.id;
          if (playerNameInputEl) playerNameInputEl.value = playerProfile.name;
          if (playerColorInputEl) playerColorInputEl.value = playerProfile.color;
          if (playerBioInputEl) playerBioInputEl.value = String(playerProfile?.meta?.about ?? "");

          syncProfileAvatarPickerFromCurrent();

          if (playerNameInputEl) playerNameInputEl.focus({ preventScroll: true });
        }
      }


/**
 * Wires the profile overlay UI once and binds it to the persisted profile state.
 */
      function ensurePlayerProfileOverlayWired() {
        if (playerProfileState.wired) return;

        playerProfileEl = document.getElementById("playerProfile");
        playerProfileCloseBtn = document.getElementById("playerProfileClose");
        playerProfileSaveBtn = document.getElementById("playerProfileSave");
        playerProfileResetBtn = document.getElementById("playerProfileReset");
        playerProfileIdEl = document.getElementById("playerProfileId");
        playerNameInputEl = document.getElementById("playerNameInput");
        playerColorInputEl = document.getElementById("playerColorInput");
        playerBioInputEl = document.getElementById("playerBioInput");

        avatarPrevBtnEl = document.getElementById("avatarPrevBtn");
        avatarNextBtnEl = document.getElementById("avatarNextBtn");
        avatarSelectBtnEl = document.getElementById("avatarSelectBtn");
        avatarPreviewImgEl = document.getElementById("avatarPreviewImg");
        avatarPreviewNameEl = document.getElementById("avatarPreviewName");
        avatarPreviewDescEl = document.getElementById("avatarPreviewDesc");
        avatarPreviewCounterEl = document.getElementById("avatarPreviewCounter");

        if (playerProfileCloseBtn) {
          playerProfileCloseBtn.addEventListener("click", (event) => {
            event.preventDefault();
            setPlayerProfileOpen(false);
          });
        }

        if (playerProfileEl) {
          playerProfileEl.addEventListener("pointerdown", (event) => {
            if (event.target === playerProfileEl) setPlayerProfileOpen(false);
          });
        }

        if (avatarPrevBtnEl) {
          avatarPrevBtnEl.addEventListener("click", (event) => {
            event.preventDefault();
            stepProfileAvatarPicker(-1);
          });
        }

        if (avatarNextBtnEl) {
          avatarNextBtnEl.addEventListener("click", (event) => {
            event.preventDefault();
            stepProfileAvatarPicker(1);
          });
        }

        if (avatarSelectBtnEl) {
          avatarSelectBtnEl.addEventListener("click", (event) => {
            event.preventDefault();
            commitProfileAvatarSelection();
          });
        }

        if (avatarPreviewImgEl) {
          avatarPreviewImgEl.addEventListener("click", (event) => {
            event.preventDefault();
            commitProfileAvatarSelection();
          });
        }

        if (playerProfileSaveBtn) {
          playerProfileSaveBtn.addEventListener("click", (event) => {
            event.preventDefault();

            const next = {
              id: playerProfile.id,
              name: sanitizePlayerName(playerNameInputEl ? playerNameInputEl.value : playerProfile.name),
              color: playerColorInputEl ? String(playerColorInputEl.value) : playerProfile.color,
              avatarId: sanitizeAvatarId(profileAvatarPicker.selectedId, DEFAULTS.avatarId),
              meta: { about: playerBioInputEl ? String(playerBioInputEl.value ?? "").slice(0, 256) : "" }
            };

            setPlayerProfile(next, { persist: true });

            applySettings({ avatarId: next.avatarId }, { rebuild: false, updateGui: false, persist: true });

            setPlayerProfileOpen(false);
          });
        }

        if (playerProfileResetBtn) {
          playerProfileResetBtn.addEventListener("click", (event) => {
            event.preventDefault();

            const resetAvatarId = sanitizeAvatarId(DEFAULTS.avatarId, DEFAULTS.avatarId);

            setPlayerProfile(
            {
              id: playerProfile.id,
              name: "Anonymous",
              color: "#22c55e",
              avatarId: resetAvatarId,
              meta: { about: "" }
            },
            { persist: true }
            );

            applySettings({ avatarId: resetAvatarId }, { rebuild: false, updateGui: false, persist: true });

            setPlayerProfileOpen(true);
          });
        }

        playerProfileState.wired = true;
      }




      const actionToastState = { timer: 0 };
      let actionToastEl = null;

      /**
       * Displays a short-lived, centered status toast for editor actions (undo/redo/clone/delete).
       */
      function showActionToast(message) {
        if (!message) return;

        if (!actionToastEl) actionToastEl = document.getElementById("actionToast");
        if (!actionToastEl) return;

        actionToastEl.textContent = String(message);
        actionToastEl.classList.add("is-open");
        actionToastEl.setAttribute("aria-hidden", "false");

        if (actionToastState.timer) {
          clearTimeout(actionToastState.timer);
          actionToastState.timer = 0;
        }

        actionToastState.timer = setTimeout(() => {
          actionToastEl.classList.remove("is-open");
          actionToastEl.setAttribute("aria-hidden", "true");
          actionToastState.timer = 0;
        }, 900);
      }


      /**
       * Shows or hides the keyboard help overlay and keeps ARIA state in sync.
       */
      function setKeyboardHelpOpen(open) {
        keyboardHelpState.open = !!open;

        if (!keyboardHelpEl) return;

        keyboardHelpEl.classList.toggle("is-open", keyboardHelpState.open);
        keyboardHelpEl.setAttribute("aria-hidden", keyboardHelpState.open ? "false" : "true");

        if (keyboardHelpState.open && keyboardHelpCloseBtn) {
          keyboardHelpCloseBtn.focus({ preventScroll: true });
        }
      }






/**
 * Unified key handler.
 */
      function onKeyDown(event) {
        const tag = event.target && event.target.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA") return;

        const isHelpToggle = event.code === "Slash" && (event.metaKey || event.ctrlKey);
        if (isHelpToggle) {
          event.preventDefault();
          setKeyboardHelpOpen(!keyboardHelpState.open);
          return;
        }

        if (keyboardHelpState.open) {
          if (event.code === "Escape") {
            event.preventDefault();
            setKeyboardHelpOpen(false);
          }
          return;
        }

        if (event.code === "F8") {
          event.preventDefault();
          event.stopPropagation();
          if (!event.repeat) {
            const next = !isAvatarCollisionDebugEnabled();
            setAvatarCollisionDebugEnabled(next);
            if (typeof showActionToast === "function") showActionToast(next ? "Collision debug ON" : "Collision debug OFF");
            console.log("[snow][collision] debug", next ? "ON" : "OFF");
          }
          return;
        }


        if (typeof snapshotsOverlayState !== "undefined" && snapshotsOverlayState && snapshotsOverlayState.open) {
          if (event.code === "Escape") {
            event.preventDefault();
            setSnapshotsOverlayOpen(false);
            return;
          }

          if (event.code === "F7") {
            event.preventDefault();
            event.stopPropagation();
            if (!event.repeat) toggleSnapshotsOverlay();
            return;
          }

          if (event.code === "F5") {
            event.preventDefault();
            event.stopPropagation();
            if (!event.repeat) quickSave();
            return;
          }

          if (event.code === "F6") {
            event.preventDefault();
            event.stopPropagation();
            if (!event.repeat) quickReload();
            return;
          }

          return;
        }

        if (event.code === "F7") {
          event.preventDefault();
          event.stopPropagation();
          if (!event.repeat) toggleSnapshotsOverlay();
          return;
        }

        if (event.code === "F5") {
          event.preventDefault();
          event.stopPropagation();
          if (!event.repeat) quickSave();
          return;
        }

        if (event.code === "F6") {
          event.preventDefault();
          event.stopPropagation();
          if (!event.repeat) quickReload();
          return;
        }

        const isWorldSave = event.code === "KeyS" && (event.metaKey || event.ctrlKey);
        if (isWorldSave) {
          event.preventDefault();
          if (!event.repeat) saveActiveWorld();
          return;
        }

        if (event.code === "KeyE" && (event.metaKey || event.ctrlKey)) {
          if (event.repeat) return;
          event.preventDefault();
          setWorldEditEnabled(!worldEditState.enabled);
          return;
        }

        if (worldEditState.enabled) {
          const mod = event.metaKey || event.ctrlKey;

          if (mod) {
            if (event.code === "KeyZ") {
              event.preventDefault();
              if (event.shiftKey) worldEditRedo();
              else worldEditUndo();
              return;
            }

            if (event.code === "KeyY") {
              event.preventDefault();
              worldEditRedo();
              return;
            }
          }

          if (event.shiftKey && event.code === "KeyD") {
            event.preventDefault();
            if (!event.repeat) duplicateSelectedWorldModel();
            return;
          }

          if (event.code === "KeyX") {
            event.preventDefault();
            if (!event.repeat) deleteSelectedWorldModel();
            return;
          }

          if (worldEditState.selected && transformControls) {
            switch (event.code) {
            case "KeyW":
              event.preventDefault();
              transformControls.setMode("translate");
              return;

            case "KeyT":
              event.preventDefault();
              transformControls.setMode("rotate");
              return;

            case "KeyR":
              event.preventDefault();
              transformControls.setMode("scale");
              return;

            case "KeyQ":
              event.preventDefault();
              transformControls.setSpace(transformControls.space === "local" ? "world" : "local");
              return;

            default:
              break;
            }
          }
        }

        if (event.code === "KeyP") {
          if (event.repeat) return;
          event.preventDefault();
          params.paused = !params.paused;
          return;
        }

        if (event.code === "KeyB") {
          if (event.repeat) return;
          event.preventDefault();

          if (vehicleDriveState.enabled) {
            setVehicleChaseCameraEnabled(!vehicleChaseCamState.enabled);
            return;
          }

          if (avatarState.enabled && !vehicleDriveState.enabled) {
            if (avatarState.viewMode !== "third") {
              setAvatarViewMode("third", true);
              updateAvatarButtons();
            }

            setAvatarChaseCameraEnabled(!avatarChaseCamState.enabled);
            return;
          }

          return;
        }

        if (event.code === "KeyF") {
          event.preventDefault();
          toggleFullscreen();
          return;
        }

        if (event.code === "Escape") {
          if (isFullscreen()) {
            if (document.exitFullscreen) document.exitFullscreen();
            else if (document.webkitExitFullscreen) document.webkitExitFullscreen();
            else if (document.mozCancelFullScreen) document.mozCancelFullScreen();
            else if (document.msExitFullscreen) document.msExitFullscreen();
          }

          setUIHidden(!uiHidden);
          return;
        }

        if (event.code === "KeyE" && !event.metaKey && !event.ctrlKey) {
          if (event.repeat) return;
          event.preventDefault();

          if (!avatarState.enabled) return;

          if (vehicleDriveState.enabled) {
            exitVehicle();
            return;
          }

          if (equipmentState.enabled) {
            unequipItem();
            return;
          }

          const near = vehiclePromptState.nearby;
          if (!near) return;

          if (near.kind === "equipment") {
            equipItem(near);
            return;
          }

          enterVehicle(near);
          return;
        }

        if (event.code === "KeyO") {
          event.preventDefault();

          if (equipmentState.enabled) {
            unequipItem();
            return;
          }

          if (vehicleDriveState.enabled) {
            exitVehicle();
          }
          return;
        }

        if (event.code === "KeyA" && !vehicleDriveState.enabled && !avatarState.enabled && avatar) {
          event.preventDefault();
          enableAvatarControl(avatarState.viewMode);
          return;
        }

        switch (event.code) {
        case "ShiftLeft":
        case "ShiftRight":
          avatarKeys.run = true;
          break;

        case "KeyW":
        case "ArrowUp":
          avatarKeys.forward = true;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyS":
        case "ArrowDown":
          avatarKeys.back = true;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyA":
        case "ArrowLeft":
          avatarKeys.left = true;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyD":
        case "ArrowRight":
          avatarKeys.right = true;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyQ":
          if (avatarState.enabled && !vehicleDriveState.enabled) {
            event.preventDefault();
            avatarKeys.jetDown = true;
          }
          break;

        case "Space":
          event.preventDefault();
          avatarKeys.jump = true;
          if (!event.repeat) requestAvatarJump();
          break;

        case "KeyV":
          event.preventDefault();
          if (avatarState.enabled) {
            disableAvatarControl();
          } else {
            enableAvatarControl(avatarState.viewMode);
          }
          updateAvatarButtons();
          break;

        case "KeyC":
          event.preventDefault();
          if (avatarState.enabled) {
            const next = avatarState.viewMode === "third" ? "first" : "third";
            setAvatarViewMode(next, true);
            updateAvatarButtons();
          } else {
            avatarState.viewMode = avatarState.viewMode === "third" ? "first" : "third";
            updateAvatarButtons();
          }
          break;

        default:
          break;
        }
      }





      function onKeyUp(event) {
        const tag = event.target && event.target.tagName;
        if (tag === "INPUT" || tag === "TEXTAREA") return;

        switch (event.code) {
        case "ShiftLeft":
        case "ShiftRight":
          avatarKeys.run = false;
          break;

        case "KeyW":
        case "ArrowUp":
          avatarKeys.forward = false;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyS":
        case "ArrowDown":
          avatarKeys.back = false;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyA":
        case "ArrowLeft":
          avatarKeys.left = false;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyD":
        case "ArrowRight":
          avatarKeys.right = false;
          recomputeAvatarMoveFromKeys();
          break;

        case "KeyQ":
          avatarKeys.jetDown = false;
          break;

        case "Space":
          avatarKeys.jump = false;
          break;

        default:
          break;
        }
      }








    // -------------------------------------------------------------------------
    // Boot
    // -------------------------------------------------------------------------


/* Loads optional sound preset file and merges into params.sfxPresets. */
  // async function loadSoundPresetsJson() {
  //   try {
  //     const res = await fetch("./audio/sounds_presets.json", { cache: "no-store" });
  //     if (!res.ok) return;
  //     const obj = await res.json();
  //     if (!obj || typeof obj !== "object") return;

  //     if (!params.sfxPresets || typeof params.sfxPresets !== "object") params.sfxPresets = {};
  //     for (const k of Object.keys(obj)) params.sfxPresets[k] = obj[k];

  //       saveLastDebounced(params);
  //   } catch (e) {}
  // }


/* Loads SFX presets from a JSON file and merges into params.sfxPresets. */
      async function loadSfxPresetsFromFile(url) {
        const sfxUrl = typeof url === "string" && url.trim() ? url.trim() : "./audio/sounds_presets.json";

        try {
          const res = await fetch(sfxUrl, { cache: "no-store" });
          if (!res.ok) return;

          const json = await res.json();
          if (!json || typeof json !== "object") return;

          if (!params.sfxPresets || typeof params.sfxPresets !== "object") params.sfxPresets = {};

          for (const k in json) {
            if (!Object.prototype.hasOwnProperty.call(json, k)) continue;
            params.sfxPresets[k] = json[k];
          }
        } catch (e) {}
      }


// Loads a default preset JSON file and applies it on top of DEFAULTS.
// This is used for bootstrapping a consistent â€œDefaultâ€ scene state without persisting it.

      async function loadDefaultPresetFromFile(url) {
        const presetUrl = typeof url === "string" && url.trim() ? url.trim() : "presets/preset-default.json";

        try {
          const response = await fetch(presetUrl, { cache: "no-store" });

          if (!response.ok) {
            console.warn(
              "[snow] default preset fetch failed:",
              presetUrl,
              response.status,
              response.statusText
              );
            return;
          }

          const json = await response.json();

    // Accept both formats:
    // 1) { "v": 1, "settings": { ... } }
    // 2) { ...paramsDirectly }
          const srcSettings =
          json &&
          typeof json === "object" &&
          json.settings &&
          typeof json.settings === "object"
          ? json.settings
          : json;

          if (!srcSettings || typeof srcSettings !== "object") {
            console.warn("[snow] default preset JSON has no settings object");
            return;
          }

    // Merge onto DEFAULTS so missing keys get sane values
          const merged = Object.assign({}, DEFAULTS, srcSettings);

    // Apply with rebuild so procedural systems (including rocks) regenerate from preset values.
    // Do not persist boot defaults over user storage.
          applySettings(merged, {
            rebuild: true,
            updateGui: true,
            persist: false
          });
        } catch (e) {
          console.warn("[snow] default preset load failed", e);
        }
      }




      async function init() {
        loadLastSettings(params);
        await loadSfxPresetsFromFile("./audio/sounds_presets.json");


        const bootActiveWorldId = getActiveWorldId();
        let bootWorldSettings = null;

        if (bootActiveWorldId) {
          try {
            const rec = await idbGetWorld(bootActiveWorldId);
            if (rec && rec.settings && typeof rec.settings === "object") {
              bootWorldSettings = Object.assign({}, DEFAULTS, rec.settings);
            }
          } catch (e) {
            bootWorldSettings = null;
          }
        }

        setupScene();

        snowTex = makeRadialTexture(96);

        if (bootWorldSettings) {
          applySettings(bootWorldSettings, { rebuild: true, updateGui: false, persist: false });
          updateFogFromParams();
        } else {
          rebuildWorld();
        }

        setupGui();
        refreshGuiDisplays();
        refreshPresetList();
    //loadSoundPresetsJson();

        handleResize();
        window.addEventListener("resize", handleResize, { passive: true });


        /* Prevents browser scrolling/selection when interacting with the on-screen joysticks. */

        document.addEventListener("contextmenu", (e) => e.preventDefault());

        document.addEventListener(
          "touchmove",
          (e) => {
            if (joystickState.active || (typeof joystickRightState !== "undefined" && joystickRightState.active)) {
              e.preventDefault();
            }
          },
          { passive: false }
          );



        window.addEventListener("keydown", onKeyDown);
        window.addEventListener("keyup", onKeyUp);

        addEventListener("pagehide", () => saveLastNow(params), { capture: true });
        addEventListener("beforeunload", () => saveLastNow(params), { capture: true });
        addEventListener(
          "visibilitychange",
          () => {
            if (document.visibilityState === "hidden") saveLastNow(params);
          },
          { capture: true }
          );

        loadAllModels(() => {
          console.log("model ready");
        });

        loadAvatar();
        setupAvatarUI();
        setupMinimapUI();        

        bootWorldPickerOverlay();

        if (!bootActiveWorldId) {
          try {
            await loadDefaultPresetFromFile("presets/preset-default.json");
            updateFogFromParams();
          } catch (e) {
            console.warn("[snow] default preset load failed", e);
          }
        }

        renderer.setAnimationLoop(animate);
      }






      init();





    </script>
  </body>
  </html>
