<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>WebGL2 Radial Rays Effect</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
      object-fit: contain;
      background: #000;
    }
    #uploader {
      position: absolute;
      z-index: 10;
      top: 10px;
      left: 10px;
    }
  </style>
</head>
<body>
  <input id="uploader" type="file" accept="image/png, image/jpeg"/>
  <canvas id="c"></canvas>
  <script type="module">
    // ====== UTILITY ======
    function createShader(gl, source, type) {
      const s = gl.createShader(type);
      gl.shaderSource(s, source);
      gl.compileShader(s);
      if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
        throw new Error(gl.getShaderInfoLog(s));
      }
      return s;
    }
    function createProgram(gl, vs, fs) {
      const p = gl.createProgram();
      gl.attachShader(p, vs);
      gl.attachShader(p, fs);
      gl.linkProgram(p);
      if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
        throw new Error(gl.getProgramInfoLog(p));
      }
      return p;
    }

    // ====== SHADERS ======
    const vertexShaderSource = `#version 300 es
    in vec2 position;
    out vec2 vUv;
    void main() {
      vUv = position * 0.5 + 0.5;
      gl_Position = vec4(position, 0.0, 1.0);
    }
    `;
    const fragmentShaderSource = `#version 300 es
    precision highp float;
    uniform sampler2D uTex;
    uniform vec2 uRes;
    uniform float uTime;
    in vec2 vUv;
    out vec4 outColor;

    // Center in UV coordinates
    vec2 center = vec2(0.5, 0.5);

    void main() {
      vec4 base = texture(uTex, vUv);
      float alpha = base.a;

      // Only apply rays for non-transparent pixels
      float ray = 0.0;
      const int samples = 40;
      float strength = 0.32; // Increase for more streak
      for (int i = 0; i < samples; ++i) {
        float t = float(i) / float(samples-1);
        // Animate the blur center over time a bit
        vec2 dir = normalize(vUv - center);
        // Radial out-smearing (motion-blur-like)
        vec2 uv = mix(center, vUv, t + strength * (1.0-t));
        vec4 col = texture(uTex, uv);
        ray += col.a * col.r * (1.0-t);
      }
      ray /= float(samples);

      // Add radial rays as white for visible pixels, fade for transparent
      float rays = ray * 1.5 * smoothstep(0.2, 0.8, alpha);
      outColor = vec4(mix(base.rgb, vec3(1.0), rays), base.a);

      // Premultiplied output to keep the edge clean
      outColor.rgb *= outColor.a;
    }
    `;

    // ====== SETUP ======
    const canvas = document.getElementById('c');
    const gl = canvas.getContext('webgl2', { alpha: false });

    if (!gl) {
      alert('WebGL2 not supported');
      throw new Error('WebGL2 not supported');
    }

    // Resize canvas to fit window
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    }
    window.addEventListener('resize', resize);

    // Quad for fullscreen
    const positions = new Float32Array([
      -1, -1, 1, -1, -1, 1,
      -1, 1, 1, -1, 1, 1
    ]);
    const positionBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);

    // Compile shaders
    const vs = createShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
    const fs = createShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
    const program = createProgram(gl, vs, fs);

    // Look up attrib/uniform locations
    const posLoc = gl.getAttribLocation(program, 'position');
    const uTexLoc = gl.getUniformLocation(program, 'uTex');
    const uResLoc = gl.getUniformLocation(program, 'uRes');
    const uTimeLoc = gl.getUniformLocation(program, 'uTime');

    // Setup VAO
    const vao = gl.createVertexArray();
    gl.bindVertexArray(vao);
    gl.enableVertexAttribArray(posLoc);
    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
    gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

    // Texture setup
    let imgTex = gl.createTexture();
    let imgLoaded = false;

    function updateTexture(img) {
      gl.bindTexture(gl.TEXTURE_2D, imgTex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
      imgLoaded = true;
    }

    // ====== IMAGE UPLOAD ======
    const uploader = document.getElementById('uploader');
    uploader.addEventListener('change', function(e) {
      const file = e.target.files[0];
      if (!file) return;
      const img = new window.Image();
      img.onload = () => {
        updateTexture(img);
        resize();
      };
      img.src = URL.createObjectURL(file);
    });

    // ====== RENDER LOOP ======
    let startTime = performance.now();
    function render(now) {
      resize();
      gl.clear(gl.COLOR_BUFFER_BIT);

      if (imgLoaded) {
        gl.useProgram(program);
        gl.bindVertexArray(vao);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, imgTex);
        gl.uniform1i(uTexLoc, 0);
        gl.uniform2f(uResLoc, canvas.width, canvas.height);
        gl.uniform1f(uTimeLoc, (now-startTime)*0.001);
        gl.drawArrays(gl.TRIANGLES, 0, 6);
      }

      requestAnimationFrame(render);
    }

    render();
  </script>
</body>
</html>
